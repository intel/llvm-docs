<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: sycl::_V1::handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsycl_1_1__V1_1_1handler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsycl_1_1__V1_1_1handler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sycl::_V1::handler Class Reference<div class="ingroups"><a class="el" href="group__sycl__api.html">DPC++ User API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Command group handler class.  
 <a href="classsycl_1_1__V1_1_1handler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="handler_8hpp_source.html">sycl/handler.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac77ed0edb63b83f37997d89f1fc283d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac77ed0edb63b83f37997d89f1fc283d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">remove_cv_ref_t</a> = typename std::remove_cv_t&lt; std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:ac77ed0edb63b83f37997d89f1fc283d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03898341396b04fbae98f4a14affc39"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:aa03898341396b04fbae98f4a14affc39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa03898341396b04fbae98f4a14affc39">is_same_type</a> = std::is_same&lt; <a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">remove_cv_ref_t</a>&lt; U &gt;, <a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">remove_cv_ref_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:aa03898341396b04fbae98f4a14affc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac5d07cef306dee1ac97412b03570e0d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac5d07cef306dee1ac97412b03570e0d3">handler</a> (const <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;)=delete</td></tr>
<tr class="separator:ac5d07cef306dee1ac97412b03570e0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ace90d01dba531ad246689c5f3ad694"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5ace90d01dba531ad246689c5f3ad694">handler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a5ace90d01dba531ad246689c5f3ad694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a60111d2824787509379e7164a7ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a75a60111d2824787509379e7164a7ef3">operator=</a> (const <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;)=delete</td></tr>
<tr class="separator:a75a60111d2824787509379e7164a7ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e34bd24c6cc4b2b8261a9891c30ec34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a4e34bd24c6cc4b2b8261a9891c30ec34">operator=</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a4e34bd24c6cc4b2b8261a9891c30ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5f302db2045b8633e4ef909f5ce7c"><td class="memTemplParams" colspan="2">template&lt;auto &amp; SpecName&gt; </td></tr>
<tr class="memitem:ae0f5f302db2045b8633e4ef909f5ce7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ae0f5f302db2045b8633e4ef909f5ce7c">set_specialization_constant</a> (typename std::remove_reference_t&lt; decltype(SpecName)&gt;::<a class="el" href="namespacesycl_1_1__V1.html#aee985f1358b4b8acf5702c5cd2801b12">value_type</a> Value)</td></tr>
<tr class="separator:ae0f5f302db2045b8633e4ef909f5ce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5e10ddbc9b74b4f41b0532c7457c46"><td class="memTemplParams" colspan="2">template&lt;auto &amp; SpecName&gt; </td></tr>
<tr class="memitem:afe5e10ddbc9b74b4f41b0532c7457c46"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference_t&lt; decltype(SpecName)&gt;::<a class="el" href="namespacesycl_1_1__V1.html#aee985f1358b4b8acf5702c5cd2801b12">value_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#afe5e10ddbc9b74b4f41b0532c7457c46">get_specialization_constant</a> () const</td></tr>
<tr class="separator:afe5e10ddbc9b74b4f41b0532c7457c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaab4b3b9dc530e1dfdd6960fc26b0a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#adaab4b3b9dc530e1dfdd6960fc26b0a8">use_kernel_bundle</a> (const <a class="el" href="classsycl_1_1__V1_1_1kernel__bundle.html">kernel_bundle</a>&lt; <a class="el" href="namespacesycl_1_1__V1.html#a438914bf15d92a26476187e46dc7be94aee7004c7949d83f130592f15d98ca343">bundle_state::executable</a> &gt; &amp;ExecBundle)</td></tr>
<tr class="separator:adaab4b3b9dc530e1dfdd6960fc26b0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5daa8b33c2ec01e39cc988d04aa79"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:a83d5daa8b33c2ec01e39cc988d04aa79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a83d5daa8b33c2ec01e39cc988d04aa79">require</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa258614cdabc5e934cba911b756e5ada">isPlaceholder</a> &gt; Acc)</td></tr>
<tr class="memdesc:a83d5daa8b33c2ec01e39cc988d04aa79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires access to the memory object associated with the placeholder accessor.  <a href="classsycl_1_1__V1_1_1handler.html#a83d5daa8b33c2ec01e39cc988d04aa79">More...</a><br /></td></tr>
<tr class="separator:a83d5daa8b33c2ec01e39cc988d04aa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa885b250cfa370086480c3f569e2ff06"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:aa885b250cfa370086480c3f569e2ff06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa885b250cfa370086480c3f569e2ff06">require</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1dynamic__parameter.html">ext::oneapi::experimental::dynamic_parameter</a>&lt; <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa258614cdabc5e934cba911b756e5ada">isPlaceholder</a> &gt;&gt; dynamicParamAcc)</td></tr>
<tr class="memdesc:aa885b250cfa370086480c3f569e2ff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires access to the memory object associated with the placeholder accessor contained in a dynamic_parameter object.  <a href="classsycl_1_1__V1_1_1handler.html#aa885b250cfa370086480c3f569e2ff06">More...</a><br /></td></tr>
<tr class="separator:aa885b250cfa370086480c3f569e2ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06951d010166cb95ea660b0f0dcf9d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a06951d010166cb95ea660b0f0dcf9d4a">depends_on</a> (<a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> Event)</td></tr>
<tr class="memdesc:a06951d010166cb95ea660b0f0dcf9d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers event dependencies on this command group.  <a href="classsycl_1_1__V1_1_1handler.html#a06951d010166cb95ea660b0f0dcf9d4a">More...</a><br /></td></tr>
<tr class="separator:a06951d010166cb95ea660b0f0dcf9d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d52b50bfad4f2049f39e67c68f6dfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5d52b50bfad4f2049f39e67c68f6dfce">depends_on</a> (const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;Events)</td></tr>
<tr class="memdesc:a5d52b50bfad4f2049f39e67c68f6dfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers event dependencies on this command group.  <a href="classsycl_1_1__V1_1_1handler.html#a5d52b50bfad4f2049f39e67c68f6dfce">More...</a><br /></td></tr>
<tr class="separator:a5d52b50bfad4f2049f39e67c68f6dfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ea698d2c513b14b465457a5e162dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1ea698d2c513b14b465457a5e162dca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a>&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa1ea698d2c513b14b465457a5e162dca">set_arg</a> (int ArgIndex, T &amp;&amp;Arg)</td></tr>
<tr class="memdesc:aa1ea698d2c513b14b465457a5e162dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets argument for OpenCL interoperability kernels.  <a href="classsycl_1_1__V1_1_1handler.html#aa1ea698d2c513b14b465457a5e162dca">More...</a><br /></td></tr>
<tr class="separator:aa1ea698d2c513b14b465457a5e162dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc48af6df6fdc8dc93b074f144c7965b"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:afc48af6df6fdc8dc93b074f144c7965b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#afc48af6df6fdc8dc93b074f144c7965b">set_arg</a> (int ArgIndex, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Arg)</td></tr>
<tr class="separator:afc48af6df6fdc8dc93b074f144c7965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3e0778f3deb955d50b3177e97b30c3"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims&gt; </td></tr>
<tr class="memitem:aff3e0778f3deb955d50b3177e97b30c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aff3e0778f3deb955d50b3177e97b30c3">set_arg</a> (int ArgIndex, <a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a>&lt; DataT, Dims &gt; Arg)</td></tr>
<tr class="separator:aff3e0778f3deb955d50b3177e97b30c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d05b908d0a23804b70f81a4dd7e75f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d05b908d0a23804b70f81a4dd7e75f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a8d05b908d0a23804b70f81a4dd7e75f6">set_arg</a> (int argIndex, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1dynamic__parameter.html">ext::oneapi::experimental::dynamic_parameter</a>&lt; T &gt; &amp;dynamicParam)</td></tr>
<tr class="separator:a8d05b908d0a23804b70f81a4dd7e75f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2956904f5d8c3fb880524cb75a48cbd"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae2956904f5d8c3fb880524cb75a48cbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ae2956904f5d8c3fb880524cb75a48cbd">set_args</a> (Ts &amp;&amp;...Args)</td></tr>
<tr class="memdesc:ae2956904f5d8c3fb880524cb75a48cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arguments for OpenCL interoperability kernels.  <a href="classsycl_1_1__V1_1_1handler.html#ae2956904f5d8c3fb880524cb75a48cbd">More...</a><br /></td></tr>
<tr class="separator:ae2956904f5d8c3fb880524cb75a48cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2013e654d1c4b0b15a5c7f75ba4b13c6"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a2013e654d1c4b0b15a5c7f75ba4b13c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a2013e654d1c4b0b15a5c7f75ba4b13c6">single_task</a> (<a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a2013e654d1c4b0b15a5c7f75ba4b13c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function as a function object type.  <a href="classsycl_1_1__V1_1_1handler.html#a2013e654d1c4b0b15a5c7f75ba4b13c6">More...</a><br /></td></tr>
<tr class="separator:a2013e654d1c4b0b15a5c7f75ba4b13c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e25b928d17fcbbba9b0bcd5d1a4ca34"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a2e25b928d17fcbbba9b0bcd5d1a4ca34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a2e25b928d17fcbbba9b0bcd5d1a4ca34">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:a2e25b928d17fcbbba9b0bcd5d1a4ca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31dcff307283829783369b6fcddea6c"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:af31dcff307283829783369b6fcddea6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#af31dcff307283829783369b6fcddea6c">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:af31dcff307283829783369b6fcddea6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c705bb2b40e02cfc3987470e60ab241"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a4c705bb2b40e02cfc3987470e60ab241"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a4c705bb2b40e02cfc3987470e60ab241">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:a4c705bb2b40e02cfc3987470e60ab241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cb027dd014c064700858008b5f5207"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ad7cb027dd014c064700858008b5f5207"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt; std::remove_reference_t&lt; FuncT &gt;, void()&gt;::value||<a class="el" href="structsycl_1_1__V1_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt; std::remove_reference_t&lt; FuncT &gt;, void(<a class="el" href="classsycl_1_1__V1_1_1interop__handle.html">interop_handle</a>)&gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad7cb027dd014c064700858008b5f5207">host_task</a> (FuncT &amp;&amp;Func)</td></tr>
<tr class="memdesc:ad7cb027dd014c064700858008b5f5207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to the SYCL runtime to invoke <code>Func</code> once.  <a href="classsycl_1_1__V1_1_1handler.html#ad7cb027dd014c064700858008b5f5207">More...</a><br /></td></tr>
<tr class="separator:ad7cb027dd014c064700858008b5f5207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbb48ab11a91186d000973e9bac154c"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a1bbb48ab11a91186d000973e9bac154c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a1bbb48ab11a91186d000973e9bac154c">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a1bbb48ab11a91186d000973e9bac154c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offset.  <a href="classsycl_1_1__V1_1_1handler.html#a1bbb48ab11a91186d000973e9bac154c">More...</a><br /></td></tr>
<tr class="separator:a1bbb48ab11a91186d000973e9bac154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646ae5aec3971a5d7b72d64e2966abe"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:ad646ae5aec3971a5d7b72d64e2966abe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad646ae5aec3971a5d7b72d64e2966abe">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:ad646ae5aec3971a5d7b72d64e2966abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch.  <a href="classsycl_1_1__V1_1_1handler.html#ad646ae5aec3971a5d7b72d64e2966abe">More...</a><br /></td></tr>
<tr class="separator:ad646ae5aec3971a5d7b72d64e2966abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bd2ac840e5e346aed86b33660e14e6"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a60bd2ac840e5e346aed86b33660e14e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a60bd2ac840e5e346aed86b33660e14e6">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; WorkGroupSize, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a60bd2ac840e5e346aed86b33660e14e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch.  <a href="classsycl_1_1__V1_1_1handler.html#a60bd2ac840e5e346aed86b33660e14e6">More...</a><br /></td></tr>
<tr class="separator:a60bd2ac840e5e346aed86b33660e14e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf69064450ba00c2e17ab037961de159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aaf69064450ba00c2e17ab037961de159">single_task</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:aaf69064450ba00c2e17ab037961de159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a SYCL kernel.  <a href="classsycl_1_1__V1_1_1handler.html#aaf69064450ba00c2e17ab037961de159">More...</a><br /></td></tr>
<tr class="separator:aaf69064450ba00c2e17ab037961de159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f87f4438acd798cd247c08aaf27590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a71f87f4438acd798cd247c08aaf27590">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a71f87f4438acd798cd247c08aaf27590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c52e5d265f904612b1e157b633adde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a07c52e5d265f904612b1e157b633adde">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a07c52e5d265f904612b1e157b633adde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfc6f9c8d140435e0c6281edd4d0118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a6dfc6f9c8d140435e0c6281edd4d0118">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a6dfc6f9c8d140435e0c6281edd4d0118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad891bdc78dec0baebceea8df3198815b"><td class="memTemplParams" colspan="2">template&lt;int Dims&gt; </td></tr>
<tr class="memitem:ad891bdc78dec0baebceea8df3198815b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad891bdc78dec0baebceea8df3198815b">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:ad891bdc78dec0baebceea8df3198815b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classsycl_1_1__V1_1_1handler.html#ad891bdc78dec0baebceea8df3198815b">More...</a><br /></td></tr>
<tr class="separator:ad891bdc78dec0baebceea8df3198815b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8d41f988c4f4ceaec8c0df4b2fed33"><td class="memTemplParams" colspan="2">template&lt;int Dims&gt; </td></tr>
<tr class="memitem:a2c8d41f988c4f4ceaec8c0df4b2fed33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a2c8d41f988c4f4ceaec8c0df4b2fed33">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; NDRange, <a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:a2c8d41f988c4f4ceaec8c0df4b2fed33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classsycl_1_1__V1_1_1handler.html#a2c8d41f988c4f4ceaec8c0df4b2fed33">More...</a><br /></td></tr>
<tr class="separator:a2c8d41f988c4f4ceaec8c0df4b2fed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330133a41ea5e2c7c91ae89e850e359"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a7330133a41ea5e2c7c91ae89e850e359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7330133a41ea5e2c7c91ae89e850e359">single_task</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a7330133a41ea5e2c7c91ae89e850e359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function.  <a href="classsycl_1_1__V1_1_1handler.html#a7330133a41ea5e2c7c91ae89e850e359">More...</a><br /></td></tr>
<tr class="separator:a7330133a41ea5e2c7c91ae89e850e359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c2a3e3afc092ce318c9ac20cf216c5"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a09c2a3e3afc092ce318c9ac20cf216c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a09c2a3e3afc092ce318c9ac20cf216c5">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a09c2a3e3afc092ce318c9ac20cf216c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range.  <a href="classsycl_1_1__V1_1_1handler.html#a09c2a3e3afc092ce318c9ac20cf216c5">More...</a><br /></td></tr>
<tr class="separator:a09c2a3e3afc092ce318c9ac20cf216c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e29c5e7d0a6691cee2055eeb7c9ff0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a52e29c5e7d0a6691cee2055eeb7c9ff0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a52e29c5e7d0a6691cee2055eeb7c9ff0">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a52e29c5e7d0a6691cee2055eeb7c9ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classsycl_1_1__V1_1_1handler.html#a52e29c5e7d0a6691cee2055eeb7c9ff0">More...</a><br /></td></tr>
<tr class="separator:a52e29c5e7d0a6691cee2055eeb7c9ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7714823a677ccf62b3ec6b601dc8a359"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a7714823a677ccf62b3ec6b601dc8a359"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7714823a677ccf62b3ec6b601dc8a359">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; NDRange, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a7714823a677ccf62b3ec6b601dc8a359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classsycl_1_1__V1_1_1handler.html#a7714823a677ccf62b3ec6b601dc8a359">More...</a><br /></td></tr>
<tr class="separator:a7714823a677ccf62b3ec6b601dc8a359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb40f3cfc6f9be84f81a24825d95ef86"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:acb40f3cfc6f9be84f81a24825d95ef86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#acb40f3cfc6f9be84f81a24825d95ef86">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:acb40f3cfc6f9be84f81a24825d95ef86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel.  <a href="classsycl_1_1__V1_1_1handler.html#acb40f3cfc6f9be84f81a24825d95ef86">More...</a><br /></td></tr>
<tr class="separator:acb40f3cfc6f9be84f81a24825d95ef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fa74bcb8087e759115cb32937784cf"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a77fa74bcb8087e759115cb32937784cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a77fa74bcb8087e759115cb32937784cf">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; WorkGroupSize, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a77fa74bcb8087e759115cb32937784cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel.  <a href="classsycl_1_1__V1_1_1handler.html#a77fa74bcb8087e759115cb32937784cf">More...</a><br /></td></tr>
<tr class="separator:a77fa74bcb8087e759115cb32937784cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeca0e3ae2a508453c26025bd6b1599"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:aaeeca0e3ae2a508453c26025bd6b1599"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aaeeca0e3ae2a508453c26025bd6b1599">single_task</a> (PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:aaeeca0e3ae2a508453c26025bd6b1599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08088c19834b2da630b81d58ca34ca0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:ad08088c19834b2da630b81d58ca34ca0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad08088c19834b2da630b81d58ca34ca0">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:ad08088c19834b2da630b81d58ca34ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f19a2c377c10955323705b8345fdbbf"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:a9f19a2c377c10955323705b8345fdbbf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a9f19a2c377c10955323705b8345fdbbf">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:a9f19a2c377c10955323705b8345fdbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf25d3ecdce9453e02c0c2e14ea19ea6"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:abf25d3ecdce9453e02c0c2e14ea19ea6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#abf25d3ecdce9453e02c0c2e14ea19ea6">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:abf25d3ecdce9453e02c0c2e14ea19ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98363ae7e8790241949a4ceed54a03b"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT , int Dims&gt; </td></tr>
<tr class="memitem:ac98363ae7e8790241949a4ceed54a03b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac98363ae7e8790241949a4ceed54a03b">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, PropertiesT Properties, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:ac98363ae7e8790241949a4ceed54a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cdb542aa2a076f6714e683ee827d4e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad7cdb542aa2a076f6714e683ee827d4e">detail::queue_impl</a></td></tr>
<tr class="separator:ad7cdb542aa2a076f6714e683ee827d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe93ea8d613a9b7224780404781c279"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder, typename PropertyListT &gt; </td></tr>
<tr class="memitem:a4fe93ea8d613a9b7224780404781c279"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a4fe93ea8d613a9b7224780404781c279">accessor</a></td></tr>
<tr class="separator:a4fe93ea8d613a9b7224780404781c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb498cc698f57626f0746b3365a880e"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dimensions, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:adbb498cc698f57626f0746b3365a880e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#adbb498cc698f57626f0746b3365a880e">detail::image_accessor</a></td></tr>
<tr class="separator:adbb498cc698f57626f0746b3365a880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cdd83c821525ef93cdeb8332fd7de8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad6cdd83c821525ef93cdeb8332fd7de8">stream</a></td></tr>
<tr class="separator:ad6cdd83c821525ef93cdeb8332fd7de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca0ca308f0eac9343990d58cd54374"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5fca0ca308f0eac9343990d58cd54374">detail::stream_impl</a></td></tr>
<tr class="separator:a5fca0ca308f0eac9343990d58cd54374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077360329290ac82231a6ec498924b87"><td class="memTemplParams" colspan="2">template&lt;typename T , class BinaryOperation , int Dims, size_t Extent, bool ExplicitIdentity, typename RedOutVar &gt; </td></tr>
<tr class="memitem:a077360329290ac82231a6ec498924b87"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a077360329290ac82231a6ec498924b87">detail::reduction_impl_algo</a></td></tr>
<tr class="separator:a077360329290ac82231a6ec498924b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb994ca2bdbf38e10d7742a7e97f8f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aaabb994ca2bdbf38e10d7742a7e97f8f">::MockHandler</a></td></tr>
<tr class="separator:aaabb994ca2bdbf38e10d7742a7e97f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e0c51c04940031f8373b79944608b"><td class="memTemplParams" colspan="2">template&lt;class _name , class _dataT , int32_t _min_capacity, class _propertiesT , class &gt; </td></tr>
<tr class="memitem:a973e0c51c04940031f8373b79944608b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a973e0c51c04940031f8373b79944608b">ext::intel::experimental::pipe</a></td></tr>
<tr class="separator:a973e0c51c04940031f8373b79944608b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f61e7c6ba0bbe4d2c989b0a4e3d9e2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a52f61e7c6ba0bbe4d2c989b0a4e3d9e2">ext::oneapi::experimental::detail::graph_impl</a></td></tr>
<tr class="separator:a52f61e7c6ba0bbe4d2c989b0a4e3d9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d8e6fc224a900f33b837baf691041"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ae69d8e6fc224a900f33b837baf691041">ext::oneapi::experimental::detail::dynamic_parameter_impl</a></td></tr>
<tr class="separator:ae69d8e6fc224a900f33b837baf691041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46bc683d37b6005434a0bceb5389f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1device.html">device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa46bc683d37b6005434a0bceb5389f8c">detail::getDeviceFromHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;)</td></tr>
<tr class="separator:aa46bc683d37b6005434a0bceb5389f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac571a4beb419189001771e5db93f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a50ac571a4beb419189001771e5db93f0">detail::reduction::finalizeHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;CGH)</td></tr>
<tr class="separator:a50ac571a4beb419189001771e5db93f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb84c03068ae1eede7642423947a886"><td class="memTemplParams" colspan="2">template&lt;class FunctorTy &gt; </td></tr>
<tr class="memitem:adbb84c03068ae1eede7642423947a886"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#adbb84c03068ae1eede7642423947a886">detail::reduction::withAuxHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;CGH, FunctorTy Func)</td></tr>
<tr class="separator:adbb84c03068ae1eede7642423947a886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a678ed81a4f652853d4b55bad94f2af"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , detail::reduction::strategy Strategy, int Dims, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:a7a678ed81a4f652853d4b55bad94f2af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7a678ed81a4f652853d4b55bad94f2af">detail::reduction_parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;CGH, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NDRange, PropertiesT Properties, RestT... Rest)</td></tr>
<tr class="separator:a7a678ed81a4f652853d4b55bad94f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108ff1146239643004a7a1e913533d0d"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , detail::reduction::strategy Strategy, int Dims, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:a108ff1146239643004a7a1e913533d0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a108ff1146239643004a7a1e913533d0d">detail::reduction_parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;CGH, <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; NDRange, PropertiesT Properties, RestT... Rest)</td></tr>
<tr class="separator:a108ff1146239643004a7a1e913533d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548b3b019349fdb34b6be5d88d2165a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ae548b3b019349fdb34b6be5d88d2165a">detail::associateWithHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;, <a class="el" href="classsycl_1_1__V1_1_1detail_1_1AccessorBaseHost.html">detail::AccessorBaseHost</a> *, <a class="el" href="namespacesycl_1_1__V1_1_1access.html#a29a79e5735cefc35f6e4e5c5e8e782f3">access::target</a>)</td></tr>
<tr class="separator:ae548b3b019349fdb34b6be5d88d2165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de9871350057ac6128ab96ce8d85455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a1de9871350057ac6128ab96ce8d85455">detail::associateWithHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;, <a class="el" href="classsycl_1_1__V1_1_1detail_1_1UnsampledImageAccessorBaseHost.html">detail::UnsampledImageAccessorBaseHost</a> *, <a class="el" href="namespacesycl_1_1__V1.html#a45411492bdd7d4f2c1a02a77ec6aded7">image_target</a>)</td></tr>
<tr class="separator:a1de9871350057ac6128ab96ce8d85455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11778d67018d847c133db3a2b83be005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a11778d67018d847c133db3a2b83be005">detail::associateWithHandler</a> (<a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;, <a class="el" href="classsycl_1_1__V1_1_1detail_1_1SampledImageAccessorBaseHost.html">detail::SampledImageAccessorBaseHost</a> *, <a class="el" href="namespacesycl_1_1__V1.html#a45411492bdd7d4f2c1a02a77ec6aded7">image_target</a>)</td></tr>
<tr class="separator:a11778d67018d847c133db3a2b83be005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaa1af8114685a60c25b2856ec9e641"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:afdaa1af8114685a60c25b2856ec9e641"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(sizeof...(RestT) &gt; 1) &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#afdaa1af8114685a60c25b2856ec9e641">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; Range, PropertiesT Properties, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:afdaa1af8114685a60c25b2856ec9e641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reductions.  <a href="classsycl_1_1__V1_1_1handler.html#afdaa1af8114685a60c25b2856ec9e641">More...</a><br /></td></tr>
<tr class="separator:afdaa1af8114685a60c25b2856ec9e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3086b0c5a2780702fa7a4af697fa7dd2"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:a3086b0c5a2780702fa7a4af697fa7dd2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(sizeof...(RestT) &gt; 1) &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a3086b0c5a2780702fa7a4af697fa7dd2">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; Range, PropertiesT Properties, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:a3086b0c5a2780702fa7a4af697fa7dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ef58787b63943048b771fdb6dcc827"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:a52ef58787b63943048b771fdb6dcc827"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(sizeof...(RestT) &gt; 1) &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a52ef58787b63943048b771fdb6dcc827">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; Range, PropertiesT Properties, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:a52ef58787b63943048b771fdb6dcc827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e90b1ec9ee4c12e19fd9eea474fae6"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:ac9e90b1ec9ee4c12e19fd9eea474fae6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac9e90b1ec9ee4c12e19fd9eea474fae6">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:ac9e90b1ec9ee4c12e19fd9eea474fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca091463c4aabb2d4ba4d9df0fef8c15"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:aca091463c4aabb2d4ba4d9df0fef8c15"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aca091463c4aabb2d4ba4d9df0fef8c15">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:aca091463c4aabb2d4ba4d9df0fef8c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb203c9c052738e8681e54bf8e6de4bb"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:acb203c9c052738e8681e54bf8e6de4bb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#acb203c9c052738e8681e54bf8e6de4bb">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:acb203c9c052738e8681e54bf8e6de4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462ed02186a460601fa64123dc897958"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:a462ed02186a460601fa64123dc897958"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(sizeof...(RestT) &gt; 1) &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a462ed02186a460601fa64123dc897958">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, PropertiesT Properties, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:a462ed02186a460601fa64123dc897958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bc563630fac6935a28a0b55c90df09"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </td></tr>
<tr class="memitem:ab9bc563630fac6935a28a0b55c90df09"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ab9bc563630fac6935a28a0b55c90df09">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="separator:ab9bc563630fac6935a28a0b55c90df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b795cc26dc2a6b738644f7397d5d96"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename PropertiesT &gt; </td></tr>
<tr class="memitem:aa7b795cc26dc2a6b738644f7397d5d96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa7b795cc26dc2a6b738644f7397d5d96">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:aa7b795cc26dc2a6b738644f7397d5d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">}@  <a href="classsycl_1_1__V1_1_1handler.html#aa7b795cc26dc2a6b738644f7397d5d96">More...</a><br /></td></tr>
<tr class="separator:aa7b795cc26dc2a6b738644f7397d5d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e838c260c0adb15fd21e554f4a739ca"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename PropertiesT &gt; </td></tr>
<tr class="memitem:a2e838c260c0adb15fd21e554f4a739ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a2e838c260c0adb15fd21e554f4a739ca">parallel_for_work_group</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; WorkGroupSize, PropertiesT Props, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="separator:a2e838c260c0adb15fd21e554f4a739ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3887b6c5dad88cedf729ef7838837ba7"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a3887b6c5dad88cedf729ef7838837ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a3887b6c5dad88cedf729ef7838837ba7">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Src, std::shared_ptr&lt; T_Dst &gt; Dst)</td></tr>
<tr class="memdesc:a3887b6c5dad88cedf729ef7838837ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src into the memory pointed by Dst.  <a href="classsycl_1_1__V1_1_1handler.html#a3887b6c5dad88cedf729ef7838837ba7">More...</a><br /></td></tr>
<tr class="separator:a3887b6c5dad88cedf729ef7838837ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a9ff9e7899608b3e7a4b81161038a5"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:ac4a9ff9e7899608b3e7a4b81161038a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac4a9ff9e7899608b3e7a4b81161038a5">copy</a> (std::shared_ptr&lt; T_Src &gt; Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Dst)</td></tr>
<tr class="memdesc:ac4a9ff9e7899608b3e7a4b81161038a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory pointed by Src into the memory object accessed by Dst.  <a href="classsycl_1_1__V1_1_1handler.html#ac4a9ff9e7899608b3e7a4b81161038a5">More...</a><br /></td></tr>
<tr class="separator:ac4a9ff9e7899608b3e7a4b81161038a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d19f85a5623c3bacc574410dfb6de0"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:ac6d19f85a5623c3bacc574410dfb6de0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ac6d19f85a5623c3bacc574410dfb6de0">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Src, T_Dst *Dst)</td></tr>
<tr class="memdesc:ac6d19f85a5623c3bacc574410dfb6de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src into the memory pointed by Dst.  <a href="classsycl_1_1__V1_1_1handler.html#ac6d19f85a5623c3bacc574410dfb6de0">More...</a><br /></td></tr>
<tr class="separator:ac6d19f85a5623c3bacc574410dfb6de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdac89ce25c22a6c7033e0d96a42dfb1"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:abdac89ce25c22a6c7033e0d96a42dfb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#abdac89ce25c22a6c7033e0d96a42dfb1">copy</a> (const T_Src *Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Dst)</td></tr>
<tr class="memdesc:abdac89ce25c22a6c7033e0d96a42dfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory pointed by Src into the memory object accessed by Dst.  <a href="classsycl_1_1__V1_1_1handler.html#abdac89ce25c22a6c7033e0d96a42dfb1">More...</a><br /></td></tr>
<tr class="separator:abdac89ce25c22a6c7033e0d96a42dfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc58ba130cecbc06cc0782898016b0"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , int Dims_Src, access::mode AccessMode_Src, access::target AccessTarget_Src, typename T_Dst , int Dims_Dst, access::mode AccessMode_Dst, access::target AccessTarget_Dst, access::placeholder IsPlaceholder_Src = access::placeholder::false_t, access::placeholder IsPlaceholder_Dst = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a5cdc58ba130cecbc06cc0782898016b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5cdc58ba130cecbc06cc0782898016b0">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims_Src, AccessMode_Src, AccessTarget_Src, IsPlaceholder_Src &gt; Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims_Dst, AccessMode_Dst, AccessTarget_Dst, IsPlaceholder_Dst &gt; Dst)</td></tr>
<tr class="memdesc:a5cdc58ba130cecbc06cc0782898016b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src to the memory object accessed by Dst.  <a href="classsycl_1_1__V1_1_1handler.html#a5cdc58ba130cecbc06cc0782898016b0">More...</a><br /></td></tr>
<tr class="separator:a5cdc58ba130cecbc06cc0782898016b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b5c54bd2ffbf9da36c872ad7325967"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a89b5c54bd2ffbf9da36c872ad7325967"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a89b5c54bd2ffbf9da36c872ad7325967">update_host</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Acc)</td></tr>
<tr class="memdesc:a89b5c54bd2ffbf9da36c872ad7325967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides guarantees that the memory object accessed via Acc is updated on the host after command group object execution is complete.  <a href="classsycl_1_1__V1_1_1handler.html#a89b5c54bd2ffbf9da36c872ad7325967">More...</a><br /></td></tr>
<tr class="separator:a89b5c54bd2ffbf9da36c872ad7325967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888063c52f9fbf1f78145668ebb36816"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t, typename PropertyListT  = property_list&gt; </td></tr>
<tr class="memitem:a888063c52f9fbf1f78145668ebb36816"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a888063c52f9fbf1f78145668ebb36816">fill</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a>, PropertyListT &gt; Dst, const T &amp;Pattern)</td></tr>
<tr class="memdesc:a888063c52f9fbf1f78145668ebb36816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills memory pointed by accessor with the pattern given.  <a href="classsycl_1_1__V1_1_1handler.html#a888063c52f9fbf1f78145668ebb36816">More...</a><br /></td></tr>
<tr class="separator:a888063c52f9fbf1f78145668ebb36816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029daf97657e7e9da954341157382606"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a029daf97657e7e9da954341157382606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a029daf97657e7e9da954341157382606">fill</a> (void *Ptr, const T &amp;Pattern, size_t Count)</td></tr>
<tr class="memdesc:a029daf97657e7e9da954341157382606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classsycl_1_1__V1_1_1handler.html#a029daf97657e7e9da954341157382606">More...</a><br /></td></tr>
<tr class="separator:a029daf97657e7e9da954341157382606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb88f8ae65cf14301d59a04cc4576e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#acb88f8ae65cf14301d59a04cc4576e50">ext_oneapi_barrier</a> ()</td></tr>
<tr class="memdesc:acb88f8ae65cf14301d59a04cc4576e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classsycl_1_1__V1_1_1handler.html#acb88f8ae65cf14301d59a04cc4576e50">More...</a><br /></td></tr>
<tr class="separator:acb88f8ae65cf14301d59a04cc4576e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfc64310553bc5ce5971f65cd165dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5bfc64310553bc5ce5971f65cd165dc4">ext_oneapi_barrier</a> (const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;WaitList)</td></tr>
<tr class="memdesc:a5bfc64310553bc5ce5971f65cd165dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classsycl_1_1__V1_1_1handler.html#a5bfc64310553bc5ce5971f65cd165dc4">More...</a><br /></td></tr>
<tr class="separator:a5bfc64310553bc5ce5971f65cd165dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b330a7b45c669c391b5be2f389aeea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a56b330a7b45c669c391b5be2f389aeea">memcpy</a> (void *Dest, const void *Src, size_t Count)</td></tr>
<tr class="memdesc:a56b330a7b45c669c391b5be2f389aeea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on this handler's device.  <a href="classsycl_1_1__V1_1_1handler.html#a56b330a7b45c669c391b5be2f389aeea">More...</a><br /></td></tr>
<tr class="separator:a56b330a7b45c669c391b5be2f389aeea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df043377e1ca26c7ee7a4f372fe679c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5df043377e1ca26c7ee7a4f372fe679c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a5df043377e1ca26c7ee7a4f372fe679c">copy</a> (const T *Src, T *Dest, size_t Count)</td></tr>
<tr class="memdesc:a5df043377e1ca26c7ee7a4f372fe679c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on this handler's device.  <a href="classsycl_1_1__V1_1_1handler.html#a5df043377e1ca26c7ee7a4f372fe679c">More...</a><br /></td></tr>
<tr class="separator:a5df043377e1ca26c7ee7a4f372fe679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd29b753aaaa3f6398b80c43693dfd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#abfd29b753aaaa3f6398b80c43693dfd6">memset</a> (void *Dest, int Value, size_t Count)</td></tr>
<tr class="memdesc:abfd29b753aaaa3f6398b80c43693dfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1handler.html#abfd29b753aaaa3f6398b80c43693dfd6">More...</a><br /></td></tr>
<tr class="separator:abfd29b753aaaa3f6398b80c43693dfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f080b9f894eafc6c7d7c94c99e329e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ab4f080b9f894eafc6c7d7c94c99e329e">prefetch</a> (const void *Ptr, size_t Count)</td></tr>
<tr class="memdesc:ab4f080b9f894eafc6c7d7c94c99e329e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classsycl_1_1__V1_1_1handler.html#ab4f080b9f894eafc6c7d7c94c99e329e">More...</a><br /></td></tr>
<tr class="separator:ab4f080b9f894eafc6c7d7c94c99e329e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db164da9d50c11a939ea9f900df7a5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7db164da9d50c11a939ea9f900df7a5d">mem_advise</a> (const void *Ptr, size_t Length, int Advice)</td></tr>
<tr class="memdesc:a7db164da9d50c11a939ea9f900df7a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classsycl_1_1__V1_1_1handler.html#a7db164da9d50c11a939ea9f900df7a5d">More...</a><br /></td></tr>
<tr class="separator:a7db164da9d50c11a939ea9f900df7a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f3f3ef31c750b85ecd0869828b7ddd"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:aa1f3f3ef31c750b85ecd0869828b7ddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#aa1f3f3ef31c750b85ecd0869828b7ddd">ext_oneapi_memcpy2d</a> (void *Dest, size_t DestPitch, const void *Src, size_t SrcPitch, size_t Width, size_t Height)</td></tr>
<tr class="memdesc:aa1f3f3ef31c750b85ecd0869828b7ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1handler.html#aa1f3f3ef31c750b85ecd0869828b7ddd">More...</a><br /></td></tr>
<tr class="separator:aa1f3f3ef31c750b85ecd0869828b7ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904fc8faafd48f19f65f74551e9fc709"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904fc8faafd48f19f65f74551e9fc709"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a904fc8faafd48f19f65f74551e9fc709">ext_oneapi_copy2d</a> (const T *Src, size_t SrcPitch, T *Dest, size_t DestPitch, size_t Width, size_t Height)</td></tr>
<tr class="memdesc:a904fc8faafd48f19f65f74551e9fc709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1handler.html#a904fc8faafd48f19f65f74551e9fc709">More...</a><br /></td></tr>
<tr class="separator:a904fc8faafd48f19f65f74551e9fc709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a5ca19b48ea9a2e376b8408f1762cb"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:a47a5ca19b48ea9a2e376b8408f1762cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a47a5ca19b48ea9a2e376b8408f1762cb">ext_oneapi_memset2d</a> (void *Dest, size_t DestPitch, int Value, size_t Width, size_t Height)</td></tr>
<tr class="memdesc:a47a5ca19b48ea9a2e376b8408f1762cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1handler.html#a47a5ca19b48ea9a2e376b8408f1762cb">More...</a><br /></td></tr>
<tr class="separator:a47a5ca19b48ea9a2e376b8408f1762cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01da1e6f527f848939a7dd36c12ffd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b01da1e6f527f848939a7dd36c12ffd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a6b01da1e6f527f848939a7dd36c12ffd">ext_oneapi_fill2d</a> (void *Dest, size_t DestPitch, const T &amp;Pattern, size_t Width, size_t Height)</td></tr>
<tr class="memdesc:a6b01da1e6f527f848939a7dd36c12ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1handler.html#a6b01da1e6f527f848939a7dd36c12ffd">More...</a><br /></td></tr>
<tr class="separator:a6b01da1e6f527f848939a7dd36c12ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24ea95eb888d76d0db2d3cfbe5a5938"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:af24ea95eb888d76d0db2d3cfbe5a5938"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#af24ea95eb888d76d0db2d3cfbe5a5938">memcpy</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, const void *Src, size_t NumBytes=sizeof(T), size_t DestOffset=0)</td></tr>
<tr class="memdesc:af24ea95eb888d76d0db2d3cfbe5a5938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1handler.html#af24ea95eb888d76d0db2d3cfbe5a5938">More...</a><br /></td></tr>
<tr class="separator:af24ea95eb888d76d0db2d3cfbe5a5938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad355aaeb36157a7f4a6caff59b6a2d47"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:ad355aaeb36157a7f4a6caff59b6a2d47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad355aaeb36157a7f4a6caff59b6a2d47">memcpy</a> (void *Dest, const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, size_t NumBytes=sizeof(T), size_t SrcOffset=0)</td></tr>
<tr class="memdesc:ad355aaeb36157a7f4a6caff59b6a2d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a device_global to USM memory.  <a href="classsycl_1_1__V1_1_1handler.html#ad355aaeb36157a7f4a6caff59b6a2d47">More...</a><br /></td></tr>
<tr class="separator:ad355aaeb36157a7f4a6caff59b6a2d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2720b81f407fb2ca5d2d3b87d0ca686a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a2720b81f407fb2ca5d2d3b87d0ca686a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a2720b81f407fb2ca5d2d3b87d0ca686a">copy</a> (const std::remove_all_extents_t&lt; T &gt; *Src, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, size_t Count=sizeof(T)/sizeof(std::remove_all_extents_t&lt; T &gt;), size_t StartIndex=0)</td></tr>
<tr class="memdesc:a2720b81f407fb2ca5d2d3b87d0ca686a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1handler.html#a2720b81f407fb2ca5d2d3b87d0ca686a">More...</a><br /></td></tr>
<tr class="separator:a2720b81f407fb2ca5d2d3b87d0ca686a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b027bb708294b164bb3ee03966b08e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a46b027bb708294b164bb3ee03966b08e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a46b027bb708294b164bb3ee03966b08e">copy</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, std::remove_all_extents_t&lt; T &gt; *Dest, size_t Count=sizeof(T)/sizeof(std::remove_all_extents_t&lt; T &gt;), size_t StartIndex=0)</td></tr>
<tr class="memdesc:a46b027bb708294b164bb3ee03966b08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region.  <a href="classsycl_1_1__V1_1_1handler.html#a46b027bb708294b164bb3ee03966b08e">More...</a><br /></td></tr>
<tr class="separator:a46b027bb708294b164bb3ee03966b08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbfb285648869b6588263a6ce8080f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a3cbfb285648869b6588263a6ce8080f4">ext_oneapi_graph</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt; Graph)</td></tr>
<tr class="memdesc:a3cbfb285648869b6588263a6ce8080f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a command_graph.  <a href="classsycl_1_1__V1_1_1handler.html#a3cbfb285648869b6588263a6ce8080f4">More...</a><br /></td></tr>
<tr class="separator:a3cbfb285648869b6588263a6ce8080f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c606668039c62a7e0faecaaeb2e8f12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7c606668039c62a7e0faecaaeb2e8f12">ext_oneapi_copy</a> (void *Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc)</td></tr>
<tr class="memdesc:a7c606668039c62a7e0faecaaeb2e8f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle.  <a href="classsycl_1_1__V1_1_1handler.html#a7c606668039c62a7e0faecaaeb2e8f12">More...</a><br /></td></tr>
<tr class="separator:a7c606668039c62a7e0faecaaeb2e8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1dfcb4fb469fcc75e18d6296964b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7f1dfcb4fb469fcc75e18d6296964b46">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcExtent, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent)</td></tr>
<tr class="memdesc:a7f1dfcb4fb469fcc75e18d6296964b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle.  <a href="classsycl_1_1__V1_1_1handler.html#a7f1dfcb4fb469fcc75e18d6296964b46">More...</a><br /></td></tr>
<tr class="separator:a7f1dfcb4fb469fcc75e18d6296964b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4642536ab952bbad730824be871f5492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a4642536ab952bbad730824be871f5492">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc)</td></tr>
<tr class="memdesc:a4642536ab952bbad730824be871f5492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1handler.html#a4642536ab952bbad730824be871f5492">More...</a><br /></td></tr>
<tr class="separator:a4642536ab952bbad730824be871f5492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef3e9f2261a0f207b2fd554cd081ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a1ef3e9f2261a0f207b2fd554cd081ecf">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent)</td></tr>
<tr class="memdesc:a1ef3e9f2261a0f207b2fd554cd081ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1handler.html#a1ef3e9f2261a0f207b2fd554cd081ecf">More...</a><br /></td></tr>
<tr class="separator:a1ef3e9f2261a0f207b2fd554cd081ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc3c834e49e004838f450e056116c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a7cc3c834e49e004838f450e056116c40">ext_oneapi_copy</a> (void *Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch)</td></tr>
<tr class="memdesc:a7cc3c834e49e004838f450e056116c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1handler.html#a7cc3c834e49e004838f450e056116c40">More...</a><br /></td></tr>
<tr class="separator:a7cc3c834e49e004838f450e056116c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a50c2fa813f7a86e3bfe834b9a252e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a4a50c2fa813f7a86e3bfe834b9a252e8">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;ImageDesc)</td></tr>
<tr class="memdesc:a4a50c2fa813f7a86e3bfe834b9a252e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles.  <a href="classsycl_1_1__V1_1_1handler.html#a4a50c2fa813f7a86e3bfe834b9a252e8">More...</a><br /></td></tr>
<tr class="separator:a4a50c2fa813f7a86e3bfe834b9a252e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3843a146ffb598d03e556ef917603669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a3843a146ffb598d03e556ef917603669">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; HostExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent)</td></tr>
<tr class="memdesc:a3843a146ffb598d03e556ef917603669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1handler.html#a3843a146ffb598d03e556ef917603669">More...</a><br /></td></tr>
<tr class="separator:a3843a146ffb598d03e556ef917603669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319cf30e39a8293e66f655d806716fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#a319cf30e39a8293e66f655d806716fbc">ext_oneapi_wait_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle)</td></tr>
<tr class="memdesc:a319cf30e39a8293e66f655d806716fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue with a non-blocking wait on an external semaphore.  <a href="classsycl_1_1__V1_1_1handler.html#a319cf30e39a8293e66f655d806716fbc">More...</a><br /></td></tr>
<tr class="separator:a319cf30e39a8293e66f655d806716fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81192a96f660408a6d9ac5c5b6d9f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1handler.html#ad81192a96f660408a6d9ac5c5b6d9f11">ext_oneapi_signal_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle)</td></tr>
<tr class="memdesc:ad81192a96f660408a6d9ac5c5b6d9f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue to signal the external semaphore once all previous commands have completed execution.  <a href="classsycl_1_1__V1_1_1handler.html#ad81192a96f660408a6d9ac5c5b6d9f11">More...</a><br /></td></tr>
<tr class="separator:ad81192a96f660408a6d9ac5c5b6d9f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Command group handler class. </p>
<p>Objects of the handler class collect information about command group, such as kernel, requirements to the memory, arguments for the kernel.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#aa586b39a217e773b5802fb51a5217a99">sycl::queue::submit</a>([](handler &amp;CGH){</div>
<div class="line">  CGH.require(Accessor1);   <span class="comment">// Adds a requirement to the memory object.</span></div>
<div class="line">  CGH.setArg(0, Accessor2); <span class="comment">// Registers accessor given as an argument to</span></div>
<div class="line">                            <span class="comment">// the kernel + adds a requirement to the memory</span></div>
<div class="line">                            <span class="comment">// object.</span></div>
<div class="line">  CGH.setArg(1, N);         <span class="comment">// Registers value given as an argument to the</span></div>
<div class="line">                            <span class="comment">// kernel.</span></div>
<div class="line">  <span class="comment">// The following registers KernelFunctor to be a kernel that will be</span></div>
<div class="line">  <span class="comment">// executed in case of queue is bound to the host device, Kernel - for</span></div>
<div class="line">  <span class="comment">// an OpenCL device. This function clearly indicates that command group</span></div>
<div class="line">  <span class="comment">// represents kernel execution.</span></div>
<div class="line">  CGH.parallel_for(KernelFunctor, Kernel);</div>
<div class="line"> });</div>
<div class="ttc" id="anamespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_html_aa586b39a217e773b5802fb51a5217a99"><div class="ttname"><a href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#aa586b39a217e773b5802fb51a5217a99">sycl::_V1::ext::oneapi::experimental::submit</a></div><div class="ttdeci">void submit(queue Q, CommandGroupFunc &amp;&amp;CGF)</div><div class="ttdef"><b>Definition:</b> <a href="enqueue__functions_8hpp_source.html#l00077">enqueue_functions.hpp:77</a></div></div>
</div><!-- fragment --><p>The command group can represent absolutely different operations. Depending on the operation we need to store different data. But, in most cases, it's impossible to say what kind of operation we need to perform until the very end. So, handler class contains all fields simultaneously, then during "finalization" it constructs CG object, that represents specific operation, passing fields that are required only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsycl_1_1__V1_1_1queue.html" title="Encapsulates a single SYCL queue which schedules kernels on a SYCL device.">queue</a> </dd>
<dd>
program </dd>
<dd>
<a class="el" href="classsycl_1_1__V1_1_1kernel.html" title="Provides an abstraction of a SYCL kernel.">kernel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l00461">461</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa03898341396b04fbae98f4a14affc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03898341396b04fbae98f4a14affc39">&#9670;&nbsp;</a></span>is_same_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsycl_1_1__V1_1_1handler.html#aa03898341396b04fbae98f4a14affc39">sycl::_V1::handler::is_same_type</a> =  std::is_same&lt;<a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">remove_cv_ref_t</a>&lt;U&gt;, <a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">remove_cv_ref_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01948">1948</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ac77ed0edb63b83f37997d89f1fc283d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77ed0edb63b83f37997d89f1fc283d8">&#9670;&nbsp;</a></span>remove_cv_ref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classsycl_1_1__V1_1_1handler.html#ac77ed0edb63b83f37997d89f1fc283d8">sycl::_V1::handler::remove_cv_ref_t</a> =  typename std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01945">1945</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac5d07cef306dee1ac97412b03570e0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d07cef306dee1ac97412b03570e0d3">&#9670;&nbsp;</a></span>handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::handler::handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ace90d01dba531ad246689c5f3ad694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ace90d01dba531ad246689c5f3ad694">&#9670;&nbsp;</a></span>handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::handler::handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3887b6c5dad88cedf729ef7838837ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3887b6c5dad88cedf729ef7838837ba7">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T_Dst &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src into the memory pointed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a smart pointer to destination memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02597">2597</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor__image_8hpp_source.html#l00577">sycl::_V1::AccessMode</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l02393">sycl::_V1::queue::copy()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00269">sycl::_V1::ext::oneapi::experimental::copy()</a>, and <a class="el" href="reduction_8hpp_source.html#l00973">sycl::_V1::detail::reduction_impl_algo&lt; T, BinaryOperation, Dims, Extent, ExplicitIdentity, RedOutVar &gt;::withInitializedMem()</a>.</p>

</div>
</div>
<a id="ac6d19f85a5623c3bacc574410dfb6de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d19f85a5623c3bacc574410dfb6de0">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Dst *&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src into the memory pointed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a pointer to destination memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02654">2654</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor__image_8hpp_source.html#l00577">sycl::_V1::AccessMode</a>, <a class="el" href="cg_8hpp_source.html#l00059">sycl::_V1::detail::CG::CopyAccToPtr</a>, and <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a5cdc58ba130cecbc06cc0782898016b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdc58ba130cecbc06cc0782898016b0">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , int Dims_Src, access::mode AccessMode_Src, access::target AccessTarget_Src, typename T_Dst , int Dims_Dst, access::mode AccessMode_Dst, access::target AccessTarget_Dst, access::placeholder IsPlaceholder_Src = access::placeholder::false_t, access::placeholder IsPlaceholder_Dst = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Src, Dims_Src, AccessMode_Src, AccessTarget_Src, IsPlaceholder_Src &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims_Dst, AccessMode_Dst, AccessTarget_Dst, IsPlaceholder_Dst &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src to the memory object accessed by Dst. </p>
<p>Dst must have at least as many bytes as the range accessed by Src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02742">2742</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00061">sycl::_V1::detail::CG::CopyAccToAcc</a>, and <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a46b027bb708294b164bb3ee03966b08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b027bb708294b164bb3ee03966b08e">&#9670;&nbsp;</a></span>copy() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em> = <code>sizeof(T)&#160;/&#160;sizeof(std::remove_all_extents_t&lt;T&gt;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range <code>Src</code>, as specified through <code>Count</code> and <code>StartIndex</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in <code>Src</code> to copy from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03117">3117</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a2720b81f407fb2ca5d2d3b87d0ca686a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2720b81f407fb2ca5d2d3b87d0ca686a">&#9670;&nbsp;</a></span>copy() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em> = <code>sizeof(T)&#160;/&#160;sizeof(std::remove_all_extents_t&lt;T&gt;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range <code>Dest</code>, as specified through <code>Count</code> and <code>StartIndex</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in <code>Dest</code> to copy to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03097">3097</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a5df043377e1ca26c7ee7a4f372fe679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df043377e1ca26c7ee7a4f372fe679c">&#9670;&nbsp;</a></span>copy() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on this handler's device. </p>
<p>No operations is done if <code>Count</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type T to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02916">2916</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="abdac89ce25c22a6c7033e0d96a42dfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdac89ce25c22a6c7033e0d96a42dfb1">&#9670;&nbsp;</a></span>copy() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const T_Src *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory pointed by Src into the memory object accessed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a pointer to source memory. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02696">2696</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor__image_8hpp_source.html#l00577">sycl::_V1::AccessMode</a>, <a class="el" href="cg_8hpp_source.html#l00060">sycl::_V1::detail::CG::CopyPtrToAcc</a>, and <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ac4a9ff9e7899608b3e7a4b81161038a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a9ff9e7899608b3e7a4b81161038a5">&#9670;&nbsp;</a></span>copy() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::copy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T_Src &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory pointed by Src into the memory object accessed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a smart pointer to source memory. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02625">2625</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor__image_8hpp_source.html#l00577">sycl::_V1::AccessMode</a>.</p>

</div>
</div>
<a id="a5d52b50bfad4f2049f39e67c68f6dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d52b50bfad4f2049f39e67c68f6dfce">&#9670;&nbsp;</a></span>depends_on() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers event dependencies on this command group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Events</td><td>is a vector of valid SYCL events to wait on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01461">1461</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">depends_on()</a>.</p>

</div>
</div>
<a id="a06951d010166cb95ea660b0f0dcf9d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06951d010166cb95ea660b0f0dcf9d4a">&#9670;&nbsp;</a></span>depends_on() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>Event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers event dependencies on this command group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Event</td><td>is a valid SYCL event to wait on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01439">1439</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, <a class="el" href="handler_8cpp_source.html#l01461">depends_on()</a>, <a class="el" href="bindless__images_8hpp_source.html#l01404">sycl::_V1::queue::ext_oneapi_copy()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00184">sycl::_V1::queue::ext_oneapi_copy2d()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00257">sycl::_V1::queue::ext_oneapi_fill2d()</a>, <a class="el" href="queue_8hpp_source.html#l02553">sycl::_V1::queue::ext_oneapi_graph()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00145">sycl::_V1::queue::ext_oneapi_memcpy2d()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00221">sycl::_V1::queue::ext_oneapi_memset2d()</a>, <a class="el" href="queue_8hpp_source.html#l01926">sycl::_V1::queue::ext_oneapi_signal_external_semaphore()</a>, <a class="el" href="queue_8hpp_source.html#l01869">sycl::_V1::queue::ext_oneapi_wait_external_semaphore()</a>, <a class="el" href="queue_8hpp_source.html#l00497">sycl::_V1::queue::fill()</a>, <a class="el" href="reduction_8hpp_source.html#l01062">sycl::_V1::detail::reduction_impl_algo&lt; T, BinaryOperation, Dims, Extent, ExplicitIdentity, RedOutVar &gt;::getGroupsCounterAccDiscrete()</a>, <a class="el" href="queue_8hpp_source.html#l01084">sycl::_V1::queue::memcpy()</a>, <a class="el" href="queue_8hpp_source.html#l02346">sycl::_V1::queue::parallel_for()</a>, <a class="el" href="queue_8hpp_source.html#l02258">sycl::_V1::queue::parallel_for_impl()</a>, <a class="el" href="queue_8hpp_source.html#l00756">sycl::_V1::queue::prefetch()</a>, <a class="el" href="queue_8hpp_source.html#l02011">sycl::_V1::queue::single_task()</a>, <a class="el" href="queue__impl_8cpp_source.html#l00334">sycl::_V1::detail::queue_impl::submitWithHandler()</a>, and <a class="el" href="reduction_8hpp_source.html#l01166">sycl::_V1::detail::reduction::withAuxHandler()</a>.</p>

</div>
</div>
<a id="acb88f8ae65cf14301d59a04cc4576e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb88f8ae65cf14301d59a04cc4576e50">&#9670;&nbsp;</a></span>ext_oneapi_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02881">2881</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00062">sycl::_V1::detail::CG::Barrier</a>.</p>

<p class="reference">Referenced by <a class="el" href="enqueue__functions_8hpp_source.html#l00311">sycl::_V1::ext::oneapi::experimental::barrier()</a>, <a class="el" href="queue_8cpp_source.html#l00242">sycl::_V1::queue::ext_oneapi_submit_barrier()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00317">sycl::_V1::ext::oneapi::experimental::partial_barrier()</a>.</p>

</div>
</div>
<a id="a5bfc64310553bc5ce5971f65cd165dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfc64310553bc5ce5971f65cd165dc4">&#9670;&nbsp;</a></span>ext_oneapi_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>WaitList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then the barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00923">923</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00063">sycl::_V1::detail::CG::BarrierWaitlist</a>.</p>

</div>
</div>
<a id="a4a50c2fa813f7a86e3bfe834b9a252e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a50c2fa813f7a86e3bfe834b9a252e8">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>ImageDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles. </p>
<p>An exception is thrown if either <code>Src</code> or <code>Dest</code> is incomplete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">ImageDesc</td><td>is the source image descriptor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01182">1182</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00695">PI_IMAGE_COPY_DEVICE_TO_DEVICE</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__mem__handle_8hpp_source.html#l00017">sycl::_V1::ext::oneapi::experimental::image_mem_handle::raw_handle</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a1ef3e9f2261a0f207b2fd554cd081ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef3e9f2261a0f207b2fd554cd081ecf">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>Extent</code> are used to determine the sub-region. Pixel size is determined by <code>SrcImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin of source measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DestExtent</td><td>is the extent of the dest memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01233">1233</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00694">PI_IMAGE_COPY_DEVICE_TO_HOST</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__mem__handle_8hpp_source.html#l00017">sycl::_V1::ext::oneapi::experimental::image_mem_handle::raw_handle</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a4642536ab952bbad730824be871f5492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4642536ab952bbad730824be871f5492">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>An exception is thrown if either <code>Src</code> is incomplete or <code>Dest</code> is nullptr. The behavior is undefined if <code>Desc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01131">1131</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00694">PI_IMAGE_COPY_DEVICE_TO_HOST</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__mem__handle_8hpp_source.html#l00017">sycl::_V1::ext::oneapi::experimental::image_mem_handle::raw_handle</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a7c606668039c62a7e0faecaaeb2e8f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c606668039c62a7e0faecaaeb2e8f12">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete. The behavior is undefined if <code>Desc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the image descriptor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01027">1027</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00693">PI_IMAGE_COPY_HOST_TO_DEVICE</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__mem__handle_8hpp_source.html#l00017">sycl::_V1::ext::oneapi::experimental::image_mem_handle::raw_handle</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

<p class="reference">Referenced by <a class="el" href="bindless__images_8hpp_source.html#l01380">sycl::_V1::queue::ext_oneapi_copy()</a>.</p>

</div>
</div>
<a id="a7f1dfcb4fb469fcc75e18d6296964b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1dfcb4fb469fcc75e18d6296964b46">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. Pixel size is determined by <code>DestImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">SrcExtent</td><td>is the extent of the source memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels as determined by <code>DestImgDesc</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01078">1078</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00693">PI_IMAGE_COPY_HOST_TO_DEVICE</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__mem__handle_8hpp_source.html#l00017">sycl::_V1::ext::oneapi::experimental::image_mem_handle::raw_handle</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a3843a146ffb598d03e556ef917603669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3843a146ffb598d03e556ef917603669">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>HostExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>Extent</code> are used to determine the sub-region. Pixel size is determined by <code>DestImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the device image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the row pitch on the device </td></tr>
    <tr><td class="paramname">HostExtent</td><td>is the extent of the dest memory to copy, measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01339">1339</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="handler_8cpp_source.html#l00048">sycl::_V1::detail::getPiImageCopyFlags()</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01189">_pi_image_desc::image_row_pitch</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a7cc3c834e49e004838f450e056116c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc3c834e49e004838f450e056116c40">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr, <code>Dest</code> is nullptr, or <code>Pitch</code> is inconsistent with hardware requirements. The behavior is undefined if <code>Desc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the image descriptor (format, order, dimensions). </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the pitch of the rows on the device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01286">1286</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00041">sycl::_V1::ext::oneapi::experimental::image_descriptor::array_size</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00037">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_order</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00038">sycl::_V1::ext::oneapi::experimental::image_descriptor::channel_type</a>, <a class="el" href="image__impl_8cpp_source.html#l00111">sycl::_V1::detail::convertChannelOrder()</a>, <a class="el" href="image__impl_8cpp_source.html#l00187">sycl::_V1::detail::convertChannelType()</a>, <a class="el" href="cg_8hpp_source.html#l00078">sycl::_V1::detail::CG::CopyImage</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00036">sycl::_V1::ext::oneapi::experimental::image_descriptor::depth</a>, <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="handler_8cpp_source.html#l00048">sycl::_V1::detail::getPiImageCopyFlags()</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00035">sycl::_V1::ext::oneapi::experimental::image_descriptor::height</a>, <a class="el" href="pi_8h_source.html#l01188">_pi_image_desc::image_array_size</a>, <a class="el" href="pi_8h_source.html#l01180">_pi_image_format::image_channel_data_type</a>, <a class="el" href="pi_8h_source.html#l01179">_pi_image_format::image_channel_order</a>, <a class="el" href="pi_8h_source.html#l01187">_pi_image_desc::image_depth</a>, <a class="el" href="pi_8h_source.html#l01186">_pi_image_desc::image_height</a>, <a class="el" href="pi_8h_source.html#l01189">_pi_image_desc::image_row_pitch</a>, <a class="el" href="pi_8h_source.html#l01184">_pi_image_desc::image_type</a>, <a class="el" href="pi_8h_source.html#l01185">_pi_image_desc::image_width</a>, <a class="el" href="pi_8h_source.html#l00609">PI_MEM_TYPE_IMAGE1D</a>, <a class="el" href="pi_8h_source.html#l00610">PI_MEM_TYPE_IMAGE1D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00606">PI_MEM_TYPE_IMAGE2D</a>, <a class="el" href="pi_8h_source.html#l00608">PI_MEM_TYPE_IMAGE2D_ARRAY</a>, <a class="el" href="pi_8h_source.html#l00607">PI_MEM_TYPE_IMAGE3D</a>, <a class="el" href="pi_8h_source.html#l00612">PI_MEM_TYPE_IMAGE_CUBEMAP</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00039">sycl::_V1::ext::oneapi::experimental::image_descriptor::type</a>, <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00103">sycl::_V1::ext::oneapi::experimental::image_descriptor::verify()</a>, and <a class="el" href="bindless__images__descriptor_8hpp_source.html#l00034">sycl::_V1::ext::oneapi::experimental::image_descriptor::width</a>.</p>

</div>
</div>
<a id="a904fc8faafd48f19f65f74551e9fc709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904fc8faafd48f19f65f74551e9fc709">&#9670;&nbsp;</a></span>ext_oneapi_copy2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_copy2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if <code>Width</code> or <code>Height</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr or if <code>Width</code> is strictly greater than either <code>DestPitch</code> or <code>SrcPitch</code>. The behavior is undefined if any of the pointer parameters is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in <code>Src</code>. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in <code>Dest</code>. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00060">60</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177a67b3dba8bc6778101892eb77249db32e">sycl::_V1::usm::host</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177aad921d60486366258809553a3db49a4a">sycl::_V1::usm::unknown</a>.</p>

<p class="reference">Referenced by <a class="el" href="memcpy2d_8hpp_source.html#l00173">sycl::_V1::queue::ext_oneapi_copy2d()</a>.</p>

</div>
</div>
<a id="a6b01da1e6f527f848939a7dd36c12ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b01da1e6f527f848939a7dd36c12ffd">&#9670;&nbsp;</a></span>ext_oneapi_fill2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_fill2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if <code>Width</code> or <code>Height</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr or if <code>Width</code> is strictly greater than <code>DestPitch</code>. The behavior is undefined if any of the pointer parameters is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in <code>Dest</code>. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be device copyable. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00121">121</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177a67b3dba8bc6778101892eb77249db32e">sycl::_V1::usm::host</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177aad921d60486366258809553a3db49a4a">sycl::_V1::usm::unknown</a>.</p>

<p class="reference">Referenced by <a class="el" href="memcpy2d_8hpp_source.html#l00246">sycl::_V1::queue::ext_oneapi_fill2d()</a>.</p>

</div>
</div>
<a id="a3cbfb285648869b6588263a6ce8080f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbfb285648869b6588263a6ce8080f4">&#9670;&nbsp;</a></span>ext_oneapi_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt;&#160;</td>
          <td class="paramname"><em>Graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a command_graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>Executable command_graph to run </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01616">1616</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00077">sycl::_V1::detail::CG::ExecCommandBuffer</a>, and <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l02539">sycl::_V1::queue::ext_oneapi_graph()</a>.</p>

</div>
</div>
<a id="aa1f3f3ef31c750b85ecd0869828b7ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f3f3ef31c750b85ecd0869828b7ddd">&#9670;&nbsp;</a></span>ext_oneapi_memcpy2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_memcpy2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if <code>Width</code> or <code>Height</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr or if <code>Width</code> is strictly greater than either <code>DestPitch</code> or <code>SrcPitch</code>. The behavior is undefined if any of the pointer parameters is invalid.</p>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in <code>Dest</code>. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in <code>Src</code>. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in bytes of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of row of the 2D region to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00018">18</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177a67b3dba8bc6778101892eb77249db32e">sycl::_V1::usm::host</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177aad921d60486366258809553a3db49a4a">sycl::_V1::usm::unknown</a>.</p>

<p class="reference">Referenced by <a class="el" href="memcpy2d_8hpp_source.html#l00145">sycl::_V1::queue::ext_oneapi_memcpy2d()</a>.</p>

</div>
</div>
<a id="a47a5ca19b48ea9a2e376b8408f1762cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a5ca19b48ea9a2e376b8408f1762cb">&#9670;&nbsp;</a></span>ext_oneapi_memset2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_memset2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if <code>Width</code> or <code>Height</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr or if <code>Width</code> is strictly greater than <code>DestPitch</code>. The behavior is undefined if any of the pointer parameters is invalid.</p>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in <code>Dest</code>. </td></tr>
    <tr><td class="paramname">Value</td><td>is the value to fill into the region in <code>Dest</code>. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00098">98</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="usm__impl_8cpp_source.html#l00575">sycl::_V1::get_pointer_type()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177a67b3dba8bc6778101892eb77249db32e">sycl::_V1::usm::host</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1usm.html#adec943cf2b0ce1e251d50a73c10c3177aad921d60486366258809553a3db49a4a">sycl::_V1::usm::unknown</a>.</p>

<p class="reference">Referenced by <a class="el" href="memcpy2d_8hpp_source.html#l00210">sycl::_V1::queue::ext_oneapi_memset2d()</a>.</p>

</div>
</div>
<a id="ad81192a96f660408a6d9ac5c5b6d9f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81192a96f660408a6d9ac5c5b6d9f11">&#9670;&nbsp;</a></span>ext_oneapi_signal_external_semaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_signal_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct the queue to signal the external semaphore once all previous commands have completed execution. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01405">1405</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__interop_8hpp_source.html#l00028">sycl::_V1::ext::oneapi::experimental::interop_semaphore_handle::raw_handle</a>, and <a class="el" href="cg_8hpp_source.html#l00080">sycl::_V1::detail::CG::SemaphoreSignal</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l01908">sycl::_V1::queue::ext_oneapi_signal_external_semaphore()</a>.</p>

</div>
</div>
<a id="a319cf30e39a8293e66f655d806716fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319cf30e39a8293e66f655d806716fbc">&#9670;&nbsp;</a></span>ext_oneapi_wait_external_semaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::ext_oneapi_wait_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instruct the queue with a non-blocking wait on an external semaphore. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01395">1395</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="bindless__images__interop_8hpp_source.html#l00028">sycl::_V1::ext::oneapi::experimental::interop_semaphore_handle::raw_handle</a>, and <a class="el" href="cg_8hpp_source.html#l00079">sycl::_V1::detail::CG::SemaphoreWait</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l01852">sycl::_V1::queue::ext_oneapi_wait_external_semaphore()</a>.</p>

</div>
</div>
<a id="a888063c52f9fbf1f78145668ebb36816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888063c52f9fbf1f78145668ebb36816">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t, typename PropertyListT  = property_list&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a>, PropertyListT &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills memory pointed by accessor with the pattern given. </p>
<p>If the operation is submitted to queue associated with OpenCL device and accessor points to one dimensional memory object then use special type for filling. Otherwise fill using regular kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is a value to be used to fill the memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02826">2826</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor_8cpp_source.html#l00077">sycl::_V1::detail::AccessorBaseHost::getAccessRange()</a>, <a class="el" href="accessor_8cpp_source.html#l00078">sycl::_V1::detail::AccessorBaseHost::getMemoryRange()</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#af5c736ab0e1e67bdae429dba968a40a4a3298114541e4eb91b6f019ed67894fce">sycl::_V1::ext::oneapi::experimental::memfill</a>.</p>

<p class="reference">Referenced by <a class="el" href="enqueue__functions_8hpp_source.html#l00286">sycl::_V1::ext::oneapi::experimental::fill()</a>, and <a class="el" href="queue_8hpp_source.html#l00480">sycl::_V1::queue::fill()</a>.</p>

</div>
</div>
<a id="a029daf97657e7e9da954341157382606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029daf97657e7e9da954341157382606">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be device copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02872">2872</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="afe5e10ddbc9b74b4f41b0532c7457c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5e10ddbc9b74b4f41b0532c7457c46">&#9670;&nbsp;</a></span>get_specialization_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp; SpecName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference_t&lt;decltype(SpecName)&gt;::<a class="el" href="namespacesycl_1_1__V1.html#aee985f1358b4b8acf5702c5cd2801b12">value_type</a> sycl::_V1::handler::get_specialization_constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01880">1880</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<a id="ad7cb027dd014c064700858008b5f5207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cb027dd014c064700858008b5f5207">&#9670;&nbsp;</a></span>host_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt;std::remove_reference_t&lt;FuncT&gt;, void()&gt;::value || <a class="el" href="structsycl_1_1__V1_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt;std::remove_reference_t&lt;FuncT&gt;, void(<a class="el" href="classsycl_1_1__V1_1_1interop__handle.html">interop_handle</a>)&gt;::value&gt; sycl::_V1::handler::host_task </td>
          <td>(</td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>Func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a command to the SYCL runtime to invoke <code>Func</code> once. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02043">2043</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>.</p>

</div>
</div>
<a id="a7db164da9d50c11a939ea9f900df7a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db164da9d50c11a939ea9f900df7a5d">&#9670;&nbsp;</a></span>mem_advise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00971">971</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00070">sycl::_V1::detail::CG::AdviseUSM</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue__impl_8cpp_source.html#l00219">sycl::_V1::detail::queue_impl::mem_advise()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00303">sycl::_V1::ext::oneapi::experimental::mem_advise()</a>.</p>

</div>
</div>
<a id="af24ea95eb888d76d0db2d3cfbe5a5938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24ea95eb888d76d0db2d3cfbe5a5938">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em> = <code>sizeof(T)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range <code>Dest</code>, as specified through <code>NumBytes</code> and <code>DestOffset</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is the offset into <code>Dest</code> to copy to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03028">3028</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="annotated__arg_8hpp_source.html#l00191">sycl::_V1::ext::oneapi::experimental::has_property()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="handler_8cpp_source.html#l00040">sycl::_V1::detail::isDeviceGlobalUsedInKernel()</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<a id="ad355aaeb36157a7f4a6caff59b6a2d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad355aaeb36157a7f4a6caff59b6a2d47">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em> = <code>sizeof(T)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a device_global to USM memory. </p>
<p>Throws an exception if the copy operation intends to read outside the memory range <code>Src</code>, as specified through <code>NumBytes</code> and <code>SrcOffset</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is the offset into <code>Src</code> to copy from. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03062">3062</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="annotated__arg_8hpp_source.html#l00191">sycl::_V1::ext::oneapi::experimental::has_property()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="handler_8cpp_source.html#l00040">sycl::_V1::detail::isDeviceGlobalUsedInKernel()</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<a id="a56b330a7b45c669c391b5be2f389aeea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b330a7b45c669c391b5be2f389aeea">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on this handler's device. </p>
<p>No operations is done if <code>Count</code> is zero. An exception is thrown if either <code>Dest</code> or <code>Src</code> is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00947">947</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00066">sycl::_V1::detail::CG::CopyUSM</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue__impl_8cpp_source.html#l00180">sycl::_V1::detail::queue_impl::memcpy()</a>, <a class="el" href="queue_8hpp_source.html#l01084">sycl::_V1::queue::memcpy()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00260">sycl::_V1::ext::oneapi::experimental::memcpy()</a>.</p>

</div>
</div>
<a id="abfd29b753aaaa3f6398b80c43693dfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd29b753aaaa3f6398b80c43693dfd6">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if <code>Count</code> is zero. An exception is thrown if <code>Dest</code> is nullptr. The behavior is undefined if <code>Dest</code> is invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00955">955</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00067">sycl::_V1::detail::CG::FillUSM</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#af5c736ab0e1e67bdae429dba968a40a4a716af30655f8f3d9b32750dca746ddfb">sycl::_V1::ext::oneapi::experimental::memset</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue__impl_8cpp_source.html#l00133">sycl::_V1::detail::queue_impl::memset()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00277">sycl::_V1::ext::oneapi::experimental::memset()</a>.</p>

</div>
</div>
<a id="a75a60111d2824787509379e7164a7ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a60111d2824787509379e7164a7ef3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a>&amp; sycl::_V1::handler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e34bd24c6cc4b2b8261a9891c30ec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e34bd24c6cc4b2b8261a9891c30ec34">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a>&amp; sycl::_V1::handler::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7714823a677ccf62b3ec6b601dc8a359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7714823a677ccf62b3ec6b601dc8a359">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NDRange</td><td>is a ND-range defining global and local sizes as well as offset. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02318">2318</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="a09c2a3e3afc092ce318c9ac20cf216c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c2a3e3afc092ce318c9ac20cf216c5">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02240">2240</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="a52e29c5e7d0a6691cee2055eeb7c9ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e29c5e7d0a6691cee2055eeb7c9ff0">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02279">2279</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="a2c8d41f988c4f4ceaec8c0df4b2fed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8d41f988c4f4ceaec8c0df4b2fed33">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<p>The SYCL kernel function is defined as SYCL kernel object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NDRange</td><td>is a ND-range defining global and local sizes as well as offset. </td></tr>
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02188">2188</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="ac98363ae7e8790241949a4ceed54a03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98363ae7e8790241949a4ceed54a03b">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02469">2469</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a462ed02186a460601fa64123dc897958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462ed02186a460601fa64123dc897958">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (sizeof...(RestT) &gt; 1) &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02545">2545</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ab9bc563630fac6935a28a0b55c90df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bc563630fac6935a28a0b55c90df09">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02555">2555</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a2e25b928d17fcbbba9b0bcd5d1a4ca34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e25b928d17fcbbba9b0bcd5d1a4ca34">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02017">2017</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="launch_8hpp_source.html#l00071">syclcompat::detail::launch()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00188">sycl::_V1::ext::oneapi::experimental::nd_launch()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00113">sycl::_V1::ext::oneapi::experimental::parallel_for()</a>, <a class="el" href="reduction_8hpp_source.html#l02498">sycl::_V1::detail::reduAuxCGFunc()</a>, <a class="el" href="reduction_8hpp_source.html#l02298">sycl::_V1::detail::reduCGFuncMulti()</a>, <a class="el" href="reduction_8hpp_source.html#l01228">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::local_atomic_and_atomic_cross_wg &gt;::run()</a>, <a class="el" href="reduction_8hpp_source.html#l01279">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::group_reduce_and_last_wg_detection &gt;::run()</a>, <a class="el" href="reduction_8hpp_source.html#l01478">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::range_basic &gt;::run()</a>, <a class="el" href="reduction_8hpp_source.html#l01589">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::group_reduce_and_atomic_cross_wg &gt;::run()</a>, <a class="el" href="reduction_8hpp_source.html#l01625">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::local_mem_tree_and_atomic_cross_wg &gt;::run()</a>, <a class="el" href="reduction_8hpp_source.html#l01686">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::group_reduce_and_multiple_kernels &gt;::run()</a>, and <a class="el" href="reduction_8hpp_source.html#l01824">sycl::_V1::detail::NDRangeReduction&lt; reduction::strategy::basic &gt;::run()</a>.</p>

</div>
</div>
<a id="a71f87f4438acd798cd247c08aaf27590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f87f4438acd798cd247c08aaf27590">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02146">2146</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad08088c19834b2da630b81d58ca34ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08088c19834b2da630b81d58ca34ca0">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02439">2439</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="afdaa1af8114685a60c25b2856ec9e641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaa1af8114685a60c25b2856ec9e641">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (sizeof...(RestT) &gt; 1) &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reductions. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02482">2482</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ac9e90b1ec9ee4c12e19fd9eea474fae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e90b1ec9ee4c12e19fd9eea474fae6">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02517">2517</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="af31dcff307283829783369b6fcddea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31dcff307283829783369b6fcddea6c">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02024">2024</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a07c52e5d265f904612b1e157b633adde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c52e5d265f904612b1e157b633adde">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02150">2150</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a9f19a2c377c10955323705b8345fdbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f19a2c377c10955323705b8345fdbbf">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02449">2449</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a3086b0c5a2780702fa7a4af697fa7dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3086b0c5a2780702fa7a4af697fa7dd2">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (sizeof...(RestT) &gt; 1) &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02495">2495</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aca091463c4aabb2d4ba4d9df0fef8c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca091463c4aabb2d4ba4d9df0fef8c15">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02525">2525</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a4c705bb2b40e02cfc3987470e60ab241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c705bb2b40e02cfc3987470e60ab241">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02031">2031</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a6dfc6f9c8d140435e0c6281edd4d0118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc6f9c8d140435e0c6281edd4d0118">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02154">2154</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="abf25d3ecdce9453e02c0c2e14ea19ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf25d3ecdce9453e02c0c2e14ea19ea6">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02459">2459</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a52ef58787b63943048b771fdb6dcc827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ef58787b63943048b771fdb6dcc827">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (sizeof...(RestT) &gt; 1) &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02508">2508</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="acb203c9c052738e8681e54bf8e6de4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb203c9c052738e8681e54bf8e6de4bb">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value&gt; sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02533">2533</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a1bbb48ab11a91186d000973e9bac154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbb48ab11a91186d000973e9bac154c">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offset. </p>
<p>The SYCL kernel function is defined as a lambda function or a named function object type and given an id or item for indexing in the indexing space defined by range. If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02063">2063</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="ad891bdc78dec0baebceea8df3198815b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad891bdc78dec0baebceea8df3198815b">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<p>The SYCL kernel function is defined as SYCL kernel object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02168">2168</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="acb40f3cfc6f9be84f81a24825d95ef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb40f3cfc6f9be84f81a24825d95ef86">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel. </p>
<p>This version of <code>parallel_for_work_group</code> takes two parameters representing the same kernel. The first one - <code>Kernel</code> - is a compiled form of the second one - <code>kernelFunc</code>, which is the source form of the kernel. The same source kernel can be compiled multiple times yielding multiple kernel class objects accessible via the <code>program</code> class interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a compiled SYCL kernel. </td></tr>
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02361">2361</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="a77fa74bcb8087e759115cb32937784cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fa74bcb8087e759115cb32937784cf">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkGroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel. </p>
<p>This version of <code>parallel_for_work_group</code> takes two parameters representing the same kernel. The first one - <code>Kernel</code> - is a compiled form of the second one - <code>kernelFunc</code>, which is the source form of the kernel. The same source kernel can be compiled multiple times yielding multiple kernel class objects accessible via the <code>program</code> class interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a compiled SYCL kernel. </td></tr>
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">WorkGroupSize</td><td>is a range describing the size of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02400">2400</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>, and <a class="el" href="property_8hpp_source.html#l00147">sycl::_V1::ext::oneapi::experimental::detail::WorkGroupSize</a>.</p>

</div>
</div>
<a id="ad646ae5aec3971a5d7b72d64e2966abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad646ae5aec3971a5d7b72d64e2966abe">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch. </p>
<p>Lambda may contain multiple calls to parallel_for_work_item(...) methods representing the execution on each work-item. Launches NumWorkGroups work-groups of runtime-defined size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02098">2098</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aa7b795cc26dc2a6b738644f7397d5d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b795cc26dc2a6b738644f7397d5d96">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>}@ </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02565">2565</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a60bd2ac840e5e346aed86b33660e14e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bd2ac840e5e346aed86b33660e14e6">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkGroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch. </p>
<p>Lambda may contain multiple calls to parallel_for_work_item(...) methods representing the execution on each work-item. Launches NumWorkGroups work-groups of WorkGroupSize size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">WorkGroupSize</td><td>is a range describing the size of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02119">2119</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="property_8hpp_source.html#l00147">sycl::_V1::ext::oneapi::experimental::detail::WorkGroupSize</a>.</p>

</div>
</div>
<a id="a2e838c260c0adb15fd21e554f4a739ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e838c260c0adb15fd21e554f4a739ca">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkGroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02574">2574</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="property_8hpp_source.html#l00147">sycl::_V1::ext::oneapi::experimental::detail::WorkGroupSize</a>.</p>

</div>
</div>
<a id="ab4f080b9f894eafc6c7d7c94c99e329e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f080b9f894eafc6c7d7c94c99e329e">&#9670;&nbsp;</a></span>prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00964">964</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00068">sycl::_V1::detail::CG::PrefetchUSM</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l00741">sycl::_V1::queue::prefetch()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00295">sycl::_V1::ext::oneapi::experimental::prefetch()</a>.</p>

</div>
</div>
<a id="a83d5daa8b33c2ec01e39cc988d04aa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d5daa8b33c2ec01e39cc988d04aa79">&#9670;&nbsp;</a></span>require() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa258614cdabc5e934cba911b756e5ada">isPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requires access to the memory object associated with the placeholder accessor. </p>
<p>Calling this function with a non-placeholder accessor has no effect.</p>
<p>The command group has a requirement to gain access to the given memory object before executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Acc</td><td>is a SYCL accessor describing required memory region. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01908">1908</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler__proxy_8cpp_source.html#l00017">sycl::_V1::detail::associateWithHandler()</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l02393">sycl::_V1::queue::copy()</a>, <a class="el" href="queue_8hpp_source.html#l02513">sycl::_V1::queue::fill()</a>, and <a class="el" href="queue_8hpp_source.html#l02494">sycl::_V1::queue::update_host()</a>.</p>

</div>
</div>
<a id="aa885b250cfa370086480c3f569e2ff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa885b250cfa370086480c3f569e2ff06">&#9670;&nbsp;</a></span>require() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1dynamic__parameter.html">ext::oneapi::experimental::dynamic_parameter</a>&lt; <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa258614cdabc5e934cba911b756e5ada">isPlaceholder</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>dynamicParamAcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requires access to the memory object associated with the placeholder accessor contained in a dynamic_parameter object. </p>
<p>Calling this function with a non-placeholder accessor has no effect.</p>
<p>The command group has a requirement to gain access to the given memory object before executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamicParamAcc</td><td>is dynamic_parameter containing a SYCL accessor describing required memory region. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01924">1924</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler__proxy_8cpp_source.html#l00017">sycl::_V1::detail::associateWithHandler()</a>, and <a class="el" href="handler_8cpp_source.html#l00075">sycl::_V1::detail::getValueFromDynamicParameter()</a>.</p>

</div>
</div>
<a id="afc48af6df6fdc8dc93b074f144c7965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc48af6df6fdc8dc93b074f144c7965b">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DataT, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01977">1977</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a8d05b908d0a23804b70f81a4dd7e75f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d05b908d0a23804b70f81a4dd7e75f6">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1dynamic__parameter.html">ext::oneapi::experimental::dynamic_parameter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dynamicParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01989">1989</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aff3e0778f3deb955d50b3177e97b30c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3e0778f3deb955d50b3177e97b30c3">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a>&lt; DataT, Dims &gt;&#160;</td>
          <td class="paramname"><em>Arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01983">1983</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aa1ea698d2c513b14b465457a5e162dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ea698d2c513b14b465457a5e162dca">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a>&lt;T&gt;::value, void&gt; sycl::_V1::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>Arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets argument for OpenCL interoperability kernels. </p>
<p>Registers Arg passed as argument # ArgIndex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArgIndex</td><td>is a positional number of argument to be set. </td></tr>
    <tr><td class="paramname">Arg</td><td>is an argument value to be set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01970">1970</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae2956904f5d8c3fb880524cb75a48cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2956904f5d8c3fb880524cb75a48cbd">&#9670;&nbsp;</a></span>set_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::set_args </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets arguments for OpenCL interoperability kernels. </p>
<p>Registers pack of arguments(Args) with indexes starting from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Args</td><td>are argument values to be set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01999">1999</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="enqueue__functions_8hpp_source.html#l00227">sycl::_V1::ext::oneapi::experimental::nd_launch()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00153">sycl::_V1::ext::oneapi::experimental::parallel_for()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00098">sycl::_V1::ext::oneapi::experimental::single_task()</a>.</p>

</div>
</div>
<a id="ae0f5f302db2045b8633e4ef909f5ce7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f5f302db2045b8633e4ef909f5ce7c">&#9670;&nbsp;</a></span>set_specialization_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto &amp; SpecName&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::set_specialization_constant </td>
          <td>(</td>
          <td class="paramtype">typename std::remove_reference_t&lt; decltype(SpecName)&gt;::<a class="el" href="namespacesycl_1_1__V1.html#aee985f1358b4b8acf5702c5cd2801b12">value_type</a>&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01865">1865</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a2013e654d1c4b0b15a5c7f75ba4b13c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2013e654d1c4b0b15a5c7f75ba4b13c6">&#9670;&nbsp;</a></span>single_task() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function as a function object type. </p>
<p>If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KernelFunc</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02011">2011</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="reduction_8hpp_source.html#l01183">sycl::_V1::detail::reduSaveFinalResultToUserMem()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00088">sycl::_V1::ext::oneapi::experimental::single_task()</a>, and <a class="el" href="reduction_8hpp_source.html#l00973">sycl::_V1::detail::reduction_impl_algo&lt; T, BinaryOperation, Dims, Extent, ExplicitIdentity, RedOutVar &gt;::withInitializedMem()</a>.</p>

</div>
</div>
<a id="aaf69064450ba00c2e17ab037961de159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf69064450ba00c2e17ab037961de159">&#9670;&nbsp;</a></span>single_task() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a SYCL kernel. </p>
<p>Executes exactly once. The kernel invocation method has no functors and cannot be called on host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02133">2133</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="a7330133a41ea5e2c7c91ae89e850e359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7330133a41ea5e2c7c91ae89e850e359">&#9670;&nbsp;</a></span>single_task() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02206">2206</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00058">sycl::_V1::detail::CG::Kernel</a>.</p>

</div>
</div>
<a id="aaeeca0e3ae2a508453c26025bd6b1599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeca0e3ae2a508453c26025bd6b1599">&#9670;&nbsp;</a></span>single_task() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value&gt; sycl::_V1::handler::single_task </td>
          <td>(</td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02430">2430</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a89b5c54bd2ffbf9da36c872ad7325967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b5c54bd2ffbf9da36c872ad7325967">&#9670;&nbsp;</a></span>update_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::update_host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#ad6058940d697f1968a03eef1e147e634">AccessMode</a>, AccessTarget, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides guarantees that the memory object accessed via Acc is updated on the host after command group object execution is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Acc</td><td>is a SYCL accessor that needs to be updated on host. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02795">2795</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="cg_8hpp_source.html#l00065">sycl::_V1::detail::CG::UpdateHost</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l02494">sycl::_V1::queue::update_host()</a>.</p>

</div>
</div>
<a id="adaab4b3b9dc530e1dfdd6960fc26b0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaab4b3b9dc530e1dfdd6960fc26b0a8">&#9670;&nbsp;</a></span>use_kernel_bundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::handler::use_kernel_bundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1kernel__bundle.html">kernel_bundle</a>&lt; <a class="el" href="namespacesycl_1_1__V1.html#a438914bf15d92a26476187e46dc7be94aee7004c7949d83f130592f15d98ca343">bundle_state::executable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ExecBundle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l01415">1415</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="kernel__bundle_8hpp_source.html#l00244">sycl::_V1::kernel_bundle&lt; State &gt;::get_context()</a>, <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaabb994ca2bdbf38e10d7742a7e97f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabb994ca2bdbf38e10d7742a7e97f8f">&#9670;&nbsp;</a></span>::MockHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::MockHandler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03390">3390</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a4fe93ea8d613a9b7224780404781c279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe93ea8d613a9b7224780404781c279">&#9670;&nbsp;</a></span>accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder, typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03349">3349</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae548b3b019349fdb34b6be5d88d2165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae548b3b019349fdb34b6be5d88d2165a">&#9670;&nbsp;</a></span>detail::associateWithHandler <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#ac8e61ac78ec80f82fe6ea96ed91f7907">detail::associateWithHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1AccessorBaseHost.html">detail::AccessorBaseHost</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1access.html#a29a79e5735cefc35f6e4e5c5e8e782f3">access::target</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11778d67018d847c133db3a2b83be005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11778d67018d847c133db3a2b83be005">&#9670;&nbsp;</a></span>detail::associateWithHandler <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#ac8e61ac78ec80f82fe6ea96ed91f7907">detail::associateWithHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1SampledImageAccessorBaseHost.html">detail::SampledImageAccessorBaseHost</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#a45411492bdd7d4f2c1a02a77ec6aded7">image_target</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de9871350057ac6128ab96ce8d85455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de9871350057ac6128ab96ce8d85455">&#9670;&nbsp;</a></span>detail::associateWithHandler <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#ac8e61ac78ec80f82fe6ea96ed91f7907">detail::associateWithHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1UnsampledImageAccessorBaseHost.html">detail::UnsampledImageAccessorBaseHost</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#a45411492bdd7d4f2c1a02a77ec6aded7">image_target</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa46bc683d37b6005434a0bceb5389f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46bc683d37b6005434a0bceb5389f8c">&#9670;&nbsp;</a></span>detail::getDeviceFromHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#a2eacb8a61f00c27e7a977be5156e3474">detail::getDeviceFromHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb498cc698f57626f0746b3365a880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb498cc698f57626f0746b3365a880e">&#9670;&nbsp;</a></span>detail::image_accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dimensions, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1detail_1_1image__accessor.html">detail::image_accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03354">3354</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad7cdb542aa2a076f6714e683ee827d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cdb542aa2a076f6714e683ee827d4e">&#9670;&nbsp;</a></span>detail::queue_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1queue__impl.html">detail::queue_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03344">3344</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a50ac571a4beb419189001771e5db93f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac571a4beb419189001771e5db93f0">&#9670;&nbsp;</a></span>detail::reduction::finalizeHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail_1_1reduction.html#aeb8199daebf71eaf27ee27bed4040b47">detail::reduction::finalizeHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>CGH</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb84c03068ae1eede7642423947a886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb84c03068ae1eede7642423947a886">&#9670;&nbsp;</a></span>detail::reduction::withAuxHandler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FunctorTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail_1_1reduction.html#acb67a85e63a780d47b9619d767f5792a">detail::reduction::withAuxHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>CGH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctorTy&#160;</td>
          <td class="paramname"><em>Func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a077360329290ac82231a6ec498924b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077360329290ac82231a6ec498924b87">&#9670;&nbsp;</a></span>detail::reduction_impl_algo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class BinaryOperation , int Dims, size_t Extent, bool ExplicitIdentity, typename RedOutVar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1detail_1_1reduction__impl__algo.html">detail::reduction_impl_algo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03362">3362</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a108ff1146239643004a7a1e913533d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108ff1146239643004a7a1e913533d0d">&#9670;&nbsp;</a></span>detail::reduction_parallel_for <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , detail::reduction::strategy Strategy, int Dims, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#ad0600b49147a3f65459c2d1100a22de8">detail::reduction_parallel_for</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>CGH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a678ed81a4f652853d4b55bad94f2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a678ed81a4f652853d4b55bad94f2af">&#9670;&nbsp;</a></span>detail::reduction_parallel_for <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , detail::reduction::strategy Strategy, int Dims, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#ad0600b49147a3f65459c2d1100a22de8">detail::reduction_parallel_for</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>CGH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fca0ca308f0eac9343990d58cd54374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fca0ca308f0eac9343990d58cd54374">&#9670;&nbsp;</a></span>detail::stream_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1detail_1_1stream__impl.html">detail::stream_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03357">3357</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a973e0c51c04940031f8373b79944608b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973e0c51c04940031f8373b79944608b">&#9670;&nbsp;</a></span>ext::intel::experimental::pipe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class _name , class _dataT , int32_t _min_capacity, class _propertiesT , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1pipe.html">ext::intel::experimental::pipe</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03397">3397</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae69d8e6fc224a900f33b837baf691041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d8e6fc224a900f33b837baf691041">&#9670;&nbsp;</a></span>ext::oneapi::experimental::detail::dynamic_parameter_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1detail_1_1dynamic__parameter__impl.html">ext::oneapi::experimental::detail::dynamic_parameter_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03425">3425</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a52f61e7c6ba0bbe4d2c989b0a4e3d9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f61e7c6ba0bbe4d2c989b0a4e3d9e2">&#9670;&nbsp;</a></span>ext::oneapi::experimental::detail::graph_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1detail_1_1graph__impl.html">ext::oneapi::experimental::detail::graph_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03424">3424</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad6cdd83c821525ef93cdeb8332fd7de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cdd83c821525ef93cdeb8332fd7de8">&#9670;&nbsp;</a></span>stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l03356">3356</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/sycl/<a class="el" href="handler_8hpp_source.html">handler.hpp</a></li>
<li>include/sycl/ext/oneapi/<a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a></li>
<li>source/<a class="el" href="handler_8cpp_source.html">handler.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesycl.html">sycl</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1.html">_V1</a></li><li class="navelem"><a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
