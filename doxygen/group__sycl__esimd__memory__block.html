<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: Block load/prefetch/store functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory__block.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Block load/prefetch/store functions.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a> &raquo; <a class="el" href="group__sycl__esimd__memory.html">Memory access API.</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Block load/prefetch/store functions.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory__block.png" border="0" usemap="#agroup____sycl____esimd____memory____block" alt=""/></div>
<map name="agroup____sycl____esimd____memory____block" id="agroup____sycl____esimd____memory____block">
<area shape="rect" title=" " alt="" coords="207,5,355,45"/>
<area shape="rect" href="group__sycl__esimd__memory.html" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="5,13,159,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7894851ec14747893eac472ad8add7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!).  <a href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">More...</a><br /></td></tr>
<tr class="separator:ga7894851ec14747893eac472ad8add7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga480ebe06c1d5d2050d8e2603d62de995"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, props={}); // (usm-bl-2) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">More...</a><br /></td></tr>
<tr class="separator:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-3) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">More...</a><br /></td></tr>
<tr class="separator:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:gad65df008f55259009a111386082da30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-4) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">More...</a><br /></td></tr>
<tr class="separator:gad65df008f55259009a111386082da30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa9252b08b7c4467a792391d854dd559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-5) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">More...</a><br /></td></tr>
<tr class="separator:gaa9252b08b7c4467a792391d854dd559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-6) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">More...</a><br /></td></tr>
<tr class="separator:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">sycl::_V1::ext::intel::esimd::block_load</a> (const Tx *addr, Flags)</td></tr>
<tr class="memdesc:gaf853809d4b13a456607b0e10525e0e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given memory address <code>addr</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">More...</a><br /></td></tr>
<tr class="separator:gaf853809d4b13a456607b0e10525e0e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;              is_simd_flag_type_v&lt;Flags&gt; &amp;&amp;              detail::is_device_accessor_with_v&lt;                  AccessorTy, detail::accessor_mode_cap::can_read&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, Flags flags)</td></tr>
<tr class="memdesc:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given accessor <code>acc</code> and <code>byte_offset</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">More...</a><br /></td></tr>
<tr class="separator:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">More...</a><br /></td></tr>
<tr class="separator:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, PropertyListT={})</td></tr>
<tr class="memdesc:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, props = {}); // (acc-bl-2) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">More...</a><br /></td></tr>
<tr class="separator:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:ga25fa0c8cc614de20602c6b59cae470a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-3) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">More...</a><br /></td></tr>
<tr class="separator:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-4) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">More...</a><br /></td></tr>
<tr class="separator:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:gad8ad8f44d928b312fe483062bd87c21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-5) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">More...</a><br /></td></tr>
<tr class="separator:gad8ad8f44d928b312fe483062bd87c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga32d25f4fe10f0c79bbed061293813da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-6) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">More...</a><br /></td></tr>
<tr class="separator:ga32d25f4fe10f0c79bbed061293813da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT={})</td></tr>
<tr class="memdesc:ga67a5b4228984629dd3215235c3bc3829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block store functions stores a contiguous memory block to the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!) with data specified by 'vals'.  <a href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">More...</a><br /></td></tr>
<tr class="separator:ga67a5b4228984629dd3215235c3bc3829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa81d900f8d9b9954362c8420182619a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-2) simd&lt;T, N&gt; vals, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">More...</a><br /></td></tr>
<tr class="separator:gaa81d900f8d9b9954362c8420182619a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, simd&lt;T, N&gt; vals, // (usm-bs-3) simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">More...</a><br /></td></tr>
<tr class="separator:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5128f1ec8f70e26fe4258bbb49123133"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-4) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">More...</a><br /></td></tr>
<tr class="separator:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0fd624e96124663a6ae4c920706007f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block_store functions stores the vector 'vals' to a contiguous memory block at the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">More...</a><br /></td></tr>
<tr class="separator:ga0fd624e96124663a6ae4c920706007f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeaa6f746325b1be167c897ff9a554e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, props = {}); // (acc-bs-2) This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">More...</a><br /></td></tr>
<tr class="separator:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga59adec9467f16b6031eba98db1d38c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> and <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">More...</a><br /></td></tr>
<tr class="separator:ga59adec9467f16b6031eba98db1d38c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga30be02856481196cc276e77cf721d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, // (acc-bs-4) simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">More...</a><br /></td></tr>
<tr class="separator:ga30be02856481196cc276e77cf721d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga49ae87e4075911a7e92549fb1e25fdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49ae87e4075911a7e92549fb1e25fdb8">&#9670;&nbsp;</a></span>block_load() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following block load functions loads a contiguous memory block from the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate. </p>
<p>If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP. The parameter 'pass_thru' specifies the values being copied to the returned result if 'pred' is set to 0. The parameter 'props' specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a969cb03e77d7d772c2fabc901f407532">esimd::cache_hint_L3</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, props = {}); // (acc-bl-1) simd&lt;T, N&gt; block_load(AccessorT acc, props = {}); // (acc-bl-2) simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-3) simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-4) simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-5) simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-6) simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, props = {}); // (acc-bl-1) This function loads a contiguous memory block referenced by accessor <code>acc</code> and <code>byte_offset</code>.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the <code>byte_offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. The alignment requirement may be less strict if stateless memory mode is ON, see block_load(usm_ptr, props) (aka usm-bl-01) for details/requirements.</p>
<p>Restrictions: there may be some extra restrictions depending on a) stateless memory mode enforcement is ON, b) cache hints are used, c) number of bytes loaded is either 16,32,64, or 128. If (b) || !(c), then the target device must be DG2 or PVC (not Gen12). If (a) &amp;&amp; !(b), then there is no restriction on the number of elements to be loaded and <code>byte_offset</code> must be only element-aligned.</p>
<p>Gen12 requirements: !(b) &amp;&amp; (c). It can load 16-, 32-, 64-, or 128-bytes only. DG2/PVC requirements: It can load such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01748">1748</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3972b27da87b098bd3a5a4210e5cf58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3972b27da87b098bd3a5a4210e5cf58e">&#9670;&nbsp;</a></span>block_load() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-4) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the returned value is undefined.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the <code>offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements.</p>
<p>Restrictions - cache hint and predicate imposed - temporary: R1: <code>byte_offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01914">1914</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga25fa0c8cc614de20602c6b59cae470a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fa0c8cc614de20602c6b59cae470a0">&#9670;&nbsp;</a></span>block_load() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-3) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the <code>pass_thru</code> value is returned.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the <code>byte_offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements.</p>
<p>Restrictions - cache hint and predicate imposed - temporary: R1: <code>byte_offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01863">1863</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1cef3de9f1cac6acf5d11fcf3a07ab43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cef3de9f1cac6acf5d11fcf3a07ab43">&#9670;&nbsp;</a></span>block_load() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(AccessorT acc, props = {}); // (acc-bl-2) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0. </p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>. Other properties are ignored. If <code>props</code> specifies the alignment property, then it is ignored because this variant implies zero offset, which means the most favourable 16-byte alignment is used.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Restrictions: there may be some extra restrictions depending on a) stateless memory mode enforcement is ON, b) cache hints are used, c) number of bytes loaded is either 16,32,64, or 128. If (b) || !(c), then the target device must be DG2 or PVC (not Gen12). If (a) &amp;&amp; !(b), then there is no restriction on the number of elements to be loaded and <code>byte_offset</code> must be only element-aligned.</p>
<p>Gen12 requirements: !(b) &amp;&amp; (c). It can load 16-, 32-, 64-, or 128-bytes only. DG2/PVC requirements: It can load such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128; for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256; for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01816">1816</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga32d25f4fe10f0c79bbed061293813da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d25f4fe10f0c79bbed061293813da6">&#9670;&nbsp;</a></span>block_load() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-6) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and some undefined value is returned.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>. Other properties are ignored. If <code>props</code> specifies the alignment property, then it is ignored because this variant implies zero offset, which means the most favourable 16-byte alignment is used.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Restrictions - cache hint and predicate imposed - temporary: R1: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R2: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01998">1998</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad8ad8f44d928b312fe483062bd87c21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ad8f44d928b312fe483062bd87c21b">&#9670;&nbsp;</a></span>block_load() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-5) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the <code>pass_thru</code> value is returned.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>. Other properties are ignored. If <code>props</code> specifies the alignment property, then it is ignored because this variant implies zero offset, which means the most favourable 16-byte alignment is used.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Restrictions - cache hint and predicate imposed - temporary: R1: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R2: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01955">1955</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf6ce51fcd9012aac82528d731cb21b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ce51fcd9012aac82528d731cb21b5c">&#9670;&nbsp;</a></span>block_load() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;              is_simd_flag_type_v&lt;Flags&gt; &amp;&amp;              detail::is_device_accessor_with_v&lt;                  AccessorTy, detail::accessor_mode_cap::can_read&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of memory from the given accessor <code>acc</code> and <code>byte_offset</code> and returns the loaded data as a vector. </p>
<p>Actual code generated depends on the alignment parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load, <code>N * sizeof(Tx)</code> must be 1, 2, 4 or 8 owords long. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Accessor type (auto-deduced). </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. Auto-deduced from the <code>Flags</code> parameter. If it is less than <code>16</code>, then slower unaligned access is generated, otherwise the access is aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The offset to load from in bytes. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01646">1646</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory__properties_8hpp_source.html#l00098">sycl::_V1::ext::intel::esimd::alignment</a>, and <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00096">sycl::_V1::ext::intel::esimd::detail::isPowerOf2()</a>.</p>

</div>
</div>
<a id="ga7894851ec14747893eac472ad8add7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7894851ec14747893eac472ad8add7b0">&#9670;&nbsp;</a></span>block_load() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following block load functions loads a contiguous memory block from the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!). </p>
<p>The parameter 'pred' is the one element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP. The parameter 'pass_thru' specifies the values being copied to the returned result if 'pred' is set to 0. The parameter 'props' specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a969cb03e77d7d772c2fabc901f407532">esimd::cache_hint_L3</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. simd&lt;T, N&gt; block_load(const T* ptr, props={}); // (usm-bl-1) simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, props={}); // (usm-bl-2) simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-3) simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-4) simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-5) simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-6) simd&lt;T, N&gt; block_load(const T* ptr, props={}); // (usm-bl-1) This function loads a contiguous memory block from USM pointer <code>ptr</code>.</p>
<p>There may be temporary restrictions depending on L1, L2 cache hints, See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is 4-bytes for 4-byte or smaller elements and 8-bytes for 8-byte elements. The address may be element-size aligned even for byte- and word-elements, but in such case the smaller alignment property must explicitly passed to this function. Extra restrictions may be in place - see Restrictions/R1 below.</p>
<p>Restrictions - cache hint imposed - temporary: If L1 or L2 cache hint is passed, then: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01356">1356</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8615bdbbe10f01eed1890d41b3c10bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8615bdbbe10f01eed1890d41b3c10bbf">&#9670;&nbsp;</a></span>block_load() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-3) This function loads a contiguous memory block from USM pointer <code>ptr</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the returned value is undefined.</p>
<p>This function has temporary restrictions. See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is the minimally required element-size alignment. Note that additional/temporary restrictions are applied (see Restrictions below).</p>
<p>Restrictions - cache hint and mask imposed - temporary: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01454">1454</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa9252b08b7c4467a792391d854dd559a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9252b08b7c4467a792391d854dd559a">&#9670;&nbsp;</a></span>block_load() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-5) This function loads a contiguous memory block from USM pointer <code>ptr</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the vector <code>pass_thru</code> is returned.</p>
<p>This function has temporary restrictions. See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is the minimally required element-size alignment. Note that additional/temporary restrictions are applied (see Restrictions below).</p>
<p>Restrictions - cache hint and mask imposed - temporary: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01544">1544</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga480ebe06c1d5d2050d8e2603d62de995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480ebe06c1d5d2050d8e2603d62de995">&#9670;&nbsp;</a></span>block_load() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, props={}); // (usm-bl-2) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>. </p>
<p>There may be temporary restrictions depending on L1, L2 cache hints, See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is 4-bytes for 4-byte or smaller elements and 8-bytes for 8-byte elements. The address may be element-size aligned even for byte- and word-elements, but in such case the smaller alignment property must explicitly passed to this function. Extra restrictions may be in place - see Restrictions/R1 below.</p>
<p>Restrictions - cache hint imposed - temporary: If L1 or L2 cache hint is passed, then: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01411">1411</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad65df008f55259009a111386082da30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65df008f55259009a111386082da30f">&#9670;&nbsp;</a></span>block_load() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-4) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the returned value is undefined.</p>
<p>This function has temporary restrictions. See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is the minimally required element-size alignment. Note that additional/temporary restrictions are applied (see Restrictions below).</p>
<p>Restrictions - cache hint and mask imposed - temporary: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01500">1500</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga277bed1c03435c7fc557a3ceb86ab2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga277bed1c03435c7fc557a3ceb86ab2c5">&#9670;&nbsp;</a></span>block_load() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-6) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the load is omitted and the vector <code>pass_thru</code> is returned.</p>
<p>This function has temporary restrictions. See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is the minimally required element-size alignment. Note that additional/temporary restrictions are applied (see Restrictions below).</p>
<p>Restrictions - cache hint and mask imposed - temporary: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01591">1591</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf853809d4b13a456607b0e10525e0e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf853809d4b13a456607b0e10525e0e17">&#9670;&nbsp;</a></span>block_load() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of memory from the given memory address <code>addr</code> and returns the loaded data as a vector. </p>
<p>The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient gather is generated. If the loaded vector is too long for 1 flat-load GPU instruction, then a series of flat-loads and/or gathers may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load. </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to load from. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01616">1616</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga0fd624e96124663a6ae4c920706007f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd624e96124663a6ae4c920706007f4">&#9670;&nbsp;</a></span>block_store() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following block_store functions stores the vector 'vals' to a contiguous memory block at the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate. </p>
<p>If it is set to 1, then all 'N' elements are stored. Otherwise, the block store operation is a NO-OP. The parameter 'props' specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a969cb03e77d7d772c2fabc901f407532">esimd::cache_hint_L3</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-1) simd&lt;T, N&gt; vals, props = {}); void block_store(AccessorT acc, simd&lt;T, N&gt; vals, props = {}); // (acc-bs-2) void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props = {}); void block_store(AccessorT acc, simd&lt;T, N&gt; vals, // (acc-bs-4) simd_mask&lt;1&gt; pred, props = {}); void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-1) simd&lt;T, N&gt; vals, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> and <code>byte_offset</code> with data specified by <code>vals</code>.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the <code>byte_offset</code> must be at least 16-byte aligned if (!(b) &amp;&amp; (c)) from the below restrictions, and must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements otherwise. If the 'alignment' property is specified as less than 16 bytes, then the target device must be DG2 or PVC (not Gen12). The alignment requirement may be less strict if stateless memory mode is ON, see block_store(usm_ptr, props) (aka usm-bs-01) for details/requirements.</p>
<p>Restrictions: there may be some extra restrictions depending on a) stateless memory mode enforcement is ON, b) cache hints are used, c) number of bytes stored is either 16,32,64, or 128. d) the 'alignment' property is specified as less than 16 bytes.</p>
<p>If (b) || !(c) || (d), then the target device must be DG2 or PVC (not Gen12). If (a) &amp;&amp; !(b), then there is no restriction on the number of elements to be stored and <code>byte_offset</code> must be only element-aligned.</p>
<p>Gen12 requirements: !(b) &amp;&amp; (c) &amp;&amp; !(d). It can store 16-, 32-, 64-, or 128-bytes only. DG2/PVC requirements: It can store such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02288">2288</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga59adec9467f16b6031eba98db1d38c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59adec9467f16b6031eba98db1d38c04">&#9670;&nbsp;</a></span>block_store() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> and <code>byte_offset</code> with data specified by <code>vals</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the store is omitted.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the <code>byte_offset</code> must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. The alignment requirement may be less strict if stateless memory mode is ON, see block_store(usm_ptr, props) (aka usm-bs-01) for details/requirements.</p>
<p>Restrictions: R1: The target device must be DG2 or PVC (not Gen12).</p>
<p>R2: It can store such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02403">2403</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaeaa6f746325b1be167c897ff9a554e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa6f746325b1be167c897ff9a554e1b">&#9670;&nbsp;</a></span>block_store() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(AccessorT acc, simd&lt;T, N&gt; vals, props = {}); // (acc-bs-2) This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0. </p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>. Other properties are ignored. If <code>props</code> specifies the alignment property, then it is ignored because this variant implies zero offset, which means the most favourable 16-byte alignment is used.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Restrictions: there may be some extra restrictions depending on a) stateless memory mode enforcement is ON, b) cache hints are used, c) number of bytes stored is either 16,32,64, or 128. If (b) || !(c), then the target device must be DG2 or PVC (not Gen12). If (a) &amp;&amp; !(b), then there is no restriction on the number of elements to be stored.</p>
<p>Gen12 requirements: !(b) &amp;&amp; (c). It can store 16-, 32-, 64-, or 128-bytes only. DG2/PVC requirements: It can store such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128; for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256; for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02357">2357</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga30be02856481196cc276e77cf721d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30be02856481196cc276e77cf721d74e">&#9670;&nbsp;</a></span>block_store() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(AccessorT acc, simd&lt;T, N&gt; vals, // (acc-bs-4) simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0. </p>
<p>If the predicate <code>pred</code> is set to 0, then the store is omitted.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>. Other properties are ignored. If <code>props</code> specifies the alignment property, then it is ignored because this variant implies zero offset, which means the most favourable 16-byte alignment is used.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Restrictions: R1: The target device must be DG2 or PVC (not Gen12).</p>
<p>R2: It can store such number of elements depending on the type 'T': for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128; for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256; for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02443">2443</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga67a5b4228984629dd3215235c3bc3829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67a5b4228984629dd3215235c3bc3829">&#9670;&nbsp;</a></span>block_store() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following block store functions stores a contiguous memory block to the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!) with data specified by 'vals'. </p>
<p>The parameter 'pred' is the one element predicate. If it is set to 1, then all 'N' elements are stored. Otherwise, the block store operation is a NO-OP. The parameter 'props' specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a969cb03e77d7d772c2fabc901f407532">esimd::cache_hint_L3</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>.</p>
<p>void block_store(T* ptr, simd&lt;T, N&gt; vals, props={}); // (usm-bs-1) void block_store(T* ptr, size_t byte_offset, // (usm-bs-2) simd&lt;T, N&gt; vals, props={}); void block_store(T* ptr, simd&lt;T, N&gt; vals, // (usm-bs-3) simd_mask&lt;1&gt; pred, props={}); void block_store(T* ptr, size_t byte_offset, // (usm-bs-4) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={});</p>
<p>void block_store(T* ptr, simd&lt;T, N&gt; vals, props={}); // (usm-bs-1) This function stores a contiguous memory block to USM pointer <code>ptr</code> with data specified by <code>vals</code>.</p>
<p>There may be temporary restrictions depending on L1, L2 cache hints, See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is 16 bytes if <code>props</code> does not specify any L1 or L2 cache hints, and the minimally required element-size alignment otherwise. Note that additional/temporary restrictions may apply (see Restrictions below).</p>
<p>Restrictions - cache hint imposed - temporary: If L1 or L2 cache hint is passed, then: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02064">2064</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga9c3e5935f0c9edd7a6e35d49e5c088ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c3e5935f0c9edd7a6e35d49e5c088ba">&#9670;&nbsp;</a></span>block_store() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(T* ptr, simd&lt;T, N&gt; vals, // (usm-bs-3) simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> with data specified by <code>vals</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the store is omitted.</p>
<p>There are temporary restrictions. See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is the minimally required element-size alignment. Note that additional/temporary restrictions apply (see Restrictions below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The pointer must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02163">2163</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa81d900f8d9b9954362c8420182619a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa81d900f8d9b9954362c8420182619a6">&#9670;&nbsp;</a></span>block_store() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(T* ptr, size_t byte_offset, // (usm-bs-2) simd&lt;T, N&gt; vals, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>. </p>
<p>There may be temporary restrictions depending on L1, L2 cache hints, See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is 16 bytes if <code>props</code> does not specify any L1 or L2 cache hints, and the minimally required element-size alignment otherwise. Note that additional/temporary restrictions may apply (see Restrictions below).</p>
<p>Restrictions - cache hint imposed - temporary: If L1 or L2 cache hint is passed, then: R1: The pointer plus byte offset must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02120">2120</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5128f1ec8f70e26fe4258bbb49123133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5128f1ec8f70e26fe4258bbb49123133">&#9670;&nbsp;</a></span>block_store() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(T* ptr, size_t byte_offset, // (usm-bs-4) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>. </p>
<p>If the predicate <code>pred</code> is set to 0, then the store is omitted.</p>
<p>There may be temporary restrictions depending on L1, L2 cache hints, See details in the 'Restrictions' section below. The restrictions will be relaxed in the future.</p>
<p>The parameter <code>props</code> specifies the optional compile-time properties of the type <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">esimd::properties</a> and may include <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">esimd::cache_hint_L1</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">esimd::cache_hint_L2</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a>. Other properties are ignored.</p>
<p>Cache hints: If <code>props</code> does not specify any L1 or L2 cache hints, then the <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> value is assumed by default.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default assumed alignment is 16 bytes if <code>props</code> does not specify any L1 or L2 cache hints and <code>pred</code> is set to 1, and Note that additional/temporary restrictions may apply (see Restrictions below).</p>
<p>Restrictions - cache hint or predicate imposed - temporary: If a predicate, L1 or L2 cache hint is passed, then: R1: The pointer plus byte offset must be at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements for 8-byte data: 1, 2, 3, 4, 8, 16, 32, 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64, or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128, or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256, or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l02212">2212</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
