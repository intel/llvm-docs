<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: include/syclcompat/math.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ompat_2math_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">math.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="sycl_2sycl_8hpp_source.html">sycl/sycl.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="complex_8hpp_source.html">sycl/ext/oneapi/experimental/complex/complex.hpp</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for math.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="ompat_2math_8hpp__incl.png" border="0" usemap="#ainclude_2syclcompat_2math_8hpp" alt=""/></div>
<map name="ainclude_2syclcompat_2math_8hpp" id="ainclude_2syclcompat_2math_8hpp">
<area shape="rect" title=" " alt="" coords="2617,5,2765,47"/>
<area shape="rect" href="sycl_2sycl_8hpp.html" title=" " alt="" coords="2545,102,2652,129"/>
<area shape="rect" href="complex_8hpp.html" title=" " alt="" coords="2677,95,2889,136"/>
<area shape="rect" href="core_8hpp.html" title=" " alt="" coords="5,191,155,218"/>
<area shape="rect" href="accessor__image_8hpp.html" title=" " alt="" coords="1095,191,1281,218"/>
<area shape="rect" href="image_8hpp.html" title=" " alt="" coords="1127,273,1249,300"/>
<area shape="rect" href="context_8hpp.html" title=" " alt="" coords="777,527,906,553"/>
<area shape="rect" href="platform_8hpp.html" title=" " alt="" coords="423,601,559,628"/>
<area shape="rect" href="aspects_8hpp.html" title=" " alt="" coords="425,676,556,703"/>
<area shape="rect" href="device__selector_8hpp.html" title=" " alt="" coords="1201,676,1383,703"/>
<area shape="rect" href="event_8hpp.html" title=" " alt="" coords="1233,355,1351,382"/>
<area shape="rect" href="exception_8hpp.html" title=" " alt="" coords="2357,676,2501,703"/>
<area shape="rect" href="range_8hpp.html" title=" " alt="" coords="3609,676,3727,703"/>
<area shape="rect" href="sampler_8hpp.html" title=" " alt="" coords="1375,355,1507,382"/>
<area shape="rect" href="types_8hpp.html" title=" " alt="" coords="4374,527,4490,553"/>
<area shape="rect" href="marray_8hpp.html" title=" " alt="" coords="4369,601,4495,628"/>
<area shape="rect" href="multi__ptr_8hpp.html" title=" " alt="" coords="4540,601,4679,628"/>
<area shape="rect" href="sycl_2atomic_8hpp.html" title=" " alt="" coords="4287,273,4412,300"/>
<area shape="rect" href="atomic__fence_8hpp.html" title=" " alt="" coords="4985,191,5153,218"/>
<area shape="rect" href="atomic__ref_8hpp.html" title=" " alt="" coords="3345,273,3495,300"/>
<area shape="rect" href="backend_8hpp.html" title=" " alt="" coords="871,191,1006,218"/>
<area shape="rect" href="sycl_2device_8hpp.html" title=" " alt="" coords="1231,527,1353,553"/>
<area shape="rect" title=" " alt="" coords="543,273,702,300"/>
<area shape="rect" href="handler_8hpp.html" title=" " alt="" coords="2307,273,2435,300"/>
<area shape="rect" href="group_8hpp.html" title=" " alt="" coords="3959,445,4076,471"/>
<area shape="rect" href="id_8hpp.html" title=" " alt="" coords="3385,601,3477,628"/>
<area shape="rect" href="item_8hpp.html" title=" " alt="" coords="3469,527,3579,553"/>
<area shape="rect" href="pointers_8hpp.html" title=" " alt="" coords="4060,527,4193,553"/>
<area shape="rect" href="sycl_2kernel_8hpp.html" title=" " alt="" coords="964,445,1084,471"/>
<area shape="rect" href="kernel__bundle_8hpp.html" title=" " alt="" coords="684,355,855,382"/>
<area shape="rect" href="kernel__handler_8hpp.html" title=" " alt="" coords="2141,355,2315,382"/>
<area shape="rect" href="nd__item_8hpp.html" title=" " alt="" coords="3695,355,3828,382"/>
<area shape="rect" href="nd__range_8hpp.html" title=" " alt="" coords="3385,445,3525,471"/>
<area shape="rect" href="sub__group_8hpp.html" title=" " alt="" coords="4359,445,4505,471"/>
<area shape="rect" href="builtins_8hpp.html" title=" " alt="" coords="3049,355,3177,382"/>
<area shape="rect" href="define__vendors_8hpp.html" title=" " alt="" coords="5177,191,5356,218"/>
<area shape="rect" href="device__aspect__traits_8hpp.html" title=" " alt="" coords="230,437,375,479"/>
<area shape="rect" href="group__sort_8hpp.html" title=" " alt="" coords="1734,437,1946,479"/>
<area shape="rect" href="functional_8hpp.html" title=" " alt="" coords="4258,355,4403,382"/>
<area shape="rect" href="group__algorithm_8hpp.html" title=" " alt="" coords="3975,273,4161,300"/>
<area shape="rect" href="group__barrier_8hpp.html" title=" " alt="" coords="1829,601,1995,628"/>
<area shape="rect" href="pipes_8hpp.html" title=" " alt="" coords="5380,191,5495,218"/>
<area shape="rect" href="all__properties_8hpp.html" title=" " alt="" coords="5519,184,5657,225"/>
<area shape="rect" href="reduction_8hpp.html" title=" " alt="" coords="2933,191,3075,218"/>
<area shape="rect" href="usm_8hpp.html" title=" " alt="" coords="2545,273,2653,300"/>
<area shape="rect" href="usm__pointer__info_8hpp.html" title=" " alt="" coords="3252,348,3417,389"/>
<area shape="rect" href="specialization__id_8hpp.html" title=" " alt="" coords="5682,184,5825,225"/>
<area shape="rect" href="stream_8hpp.html" title=" " alt="" coords="3823,191,3950,218"/>
<area shape="rect" href="usm__allocator_8hpp.html" title=" " alt="" coords="1559,273,1761,300"/>
<area shape="rect" title=" " alt="" coords="5849,191,5977,218"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ompat_2math_8hpp__dep__incl.png" border="0" usemap="#ainclude_2syclcompat_2math_8hppdep" alt=""/></div>
<map name="ainclude_2syclcompat_2math_8hppdep" id="ainclude_2syclcompat_2math_8hppdep">
<area shape="rect" title=" " alt="" coords="19,5,167,47"/>
<area shape="rect" href="syclcompat_2syclcompat_8hpp.html" title=" " alt="" coords="19,184,167,225"/>
<area shape="rect" href="ompat_2util_8hpp.html" title=" " alt="" coords="75,95,223,136"/>
<area shape="rect" href="syclcompat_8hpp.html" title=" " alt="" coords="5,273,181,300"/>
</map>
</div>
</div>
<p><a href="ompat_2math_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1detail_1_1vectorized__binary.html">syclcompat::detail::vectorized_binary&lt; VecT, BinaryOperation, class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1abs.html">syclcompat::abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::abs wrapper functors.  <a href="structsyclcompat_1_1abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1abs__diff.html">syclcompat::abs_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#aa9236143fabea8fadb52dd9c796b47a8">sycl::abs_diff</a> wrapper functors.  <a href="structsyclcompat_1_1abs__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1add__sat.html">syclcompat::add_sat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::add_sat wrapper functors.  <a href="structsyclcompat_1_1add__sat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1rhadd.html">syclcompat::rhadd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::rhadd wrapper functors.  <a href="structsyclcompat_1_1rhadd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1hadd.html">syclcompat::hadd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#a5575957639958adc1535884f2440fdc9">sycl::hadd</a> wrapper functors.  <a href="structsyclcompat_1_1hadd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1maximum.html">syclcompat::maximum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#ac1ccdc393a3b0aaeb3f37b6b41c691f8">sycl::max</a> wrapper functors.  <a href="structsyclcompat_1_1maximum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1minimum.html">syclcompat::minimum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#a4072af1569b9ea628fd1222a82ea624a">sycl::min</a> wrapper functors.  <a href="structsyclcompat_1_1minimum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1sub__sat.html">syclcompat::sub_sat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::sub_sat wrapper functors.  <a href="structsyclcompat_1_1sub__sat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesyclcompat"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html">syclcompat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html">syclcompat::detail</a></td></tr>
<tr class="memdesc:namespacesyclcompat_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic extension to implement standard APIs in std::atomic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6b48bded63fb2dfc065766b1ff13c436"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ompat_2math_8hpp.html#a6b48bded63fb2dfc065766b1ff13c436">SYCL_EXT_ONEAPI_COMPLEX</a></td></tr>
<tr class="separator:a6b48bded63fb2dfc065766b1ff13c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a446feed90819e64f91c981bb08e57506"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a446feed90819e64f91c981bb08e57506"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#a446feed90819e64f91c981bb08e57506">syclcompat::detail::complex_type</a> = detail::complex_namespace::complex&lt; ValueT &gt;</td></tr>
<tr class="separator:a446feed90819e64f91c981bb08e57506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0bb65a29d0747fdcf5cf818537e2a955"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a0bb65a29d0747fdcf5cf818537e2a955"><td class="memTemplItemLeft" align="right" valign="top">ValueT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#a0bb65a29d0747fdcf5cf818537e2a955">syclcompat::detail::clamp</a> (ValueT val, ValueT min_val, ValueT max_val)</td></tr>
<tr class="separator:a0bb65a29d0747fdcf5cf818537e2a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a96a428b600118ac3c3855164ae43f3"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a4a96a428b600118ac3c3855164ae43f3"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#a4a96a428b600118ac3c3855164ae43f3">syclcompat::detail::zero_or_signed_extent</a> (ValueT val, unsigned bit)</td></tr>
<tr class="memdesc:a4a96a428b600118ac3c3855164ae43f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend the 'val' to 'bit' size, zero extend for unsigned int and signed extend for signed int.  <a href="namespacesyclcompat_1_1detail.html#a4a96a428b600118ac3c3855164ae43f3">More...</a><br /></td></tr>
<tr class="separator:a4a96a428b600118ac3c3855164ae43f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6b24dfe407de9ce041544a8b6adfd5"><td class="memTemplParams" colspan="2">template&lt;typename RetT , bool needSat, typename AT , typename BT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:aaf6b24dfe407de9ce041544a8b6adfd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#aaf6b24dfe407de9ce041544a8b6adfd5">syclcompat::detail::extend_binary</a> (AT a, BT b, BinaryOperation binary_op)</td></tr>
<tr class="separator:aaf6b24dfe407de9ce041544a8b6adfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be66e35b3bf9b63961ba2e6a59274d4"><td class="memTemplParams" colspan="2">template&lt;typename RetT , bool needSat, typename AT , typename BT , typename CT , typename BinaryOperation1 , typename BinaryOperation2 &gt; </td></tr>
<tr class="memitem:a1be66e35b3bf9b63961ba2e6a59274d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#a1be66e35b3bf9b63961ba2e6a59274d4">syclcompat::detail::extend_binary</a> (AT a, BT b, CT c, BinaryOperation1 binary_op, BinaryOperation2 second_op)</td></tr>
<tr class="separator:a1be66e35b3bf9b63961ba2e6a59274d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a8169c1680a576d02f673d98d7e4c1"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a03a8169c1680a576d02f673d98d7e4c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html#a03a8169c1680a576d02f673d98d7e4c1">syclcompat::detail::isnan</a> (const ValueT a)</td></tr>
<tr class="separator:a03a8169c1680a576d02f673d98d7e4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3ae74a23f7ffa7b31650daee0412f2b8">syclcompat::fast_length</a> (const float *a, int len)</td></tr>
<tr class="memdesc:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute fast_length for variable-length array.  <a href="namespacesyclcompat.html#a3ae74a23f7ffa7b31650daee0412f2b8">More...</a><br /></td></tr>
<tr class="separator:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5204b4194f5c613a63ff91f28d31a44"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ac5204b4194f5c613a63ff91f28d31a44"><td class="memTemplItemLeft" align="right" valign="top">ValueT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac5204b4194f5c613a63ff91f28d31a44">syclcompat::length</a> (const ValueT *a, const int len)</td></tr>
<tr class="memdesc:ac5204b4194f5c613a63ff91f28d31a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the square root of the input array.  <a href="namespacesyclcompat.html#ac5204b4194f5c613a63ff91f28d31a44">More...</a><br /></td></tr>
<tr class="separator:ac5204b4194f5c613a63ff91f28d31a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a123aec0583990a7a4a44531e407e7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a33a123aec0583990a7a4a44531e407e7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; BinaryOperation, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a33a123aec0583990a7a4a44531e407e7">syclcompat::compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a33a123aec0583990a7a4a44531e407e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs comparison.  <a href="namespacesyclcompat.html#a33a123aec0583990a7a4a44531e407e7">More...</a><br /></td></tr>
<tr class="separator:a33a123aec0583990a7a4a44531e407e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a07bd08286d8161d4f99e34e89c01c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a40a07bd08286d8161d4f99e34e89c01c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; std::not_equal_to&lt;&gt;, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a40a07bd08286d8161d4f99e34e89c01c">syclcompat::compare</a> (const ValueT a, const ValueT b, const std::not_equal_to&lt;&gt; binary_op)</td></tr>
<tr class="separator:a40a07bd08286d8161d4f99e34e89c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df4167f117b91719debbcd1f8d954c4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a1df4167f117b91719debbcd1f8d954c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1df4167f117b91719debbcd1f8d954c4">syclcompat::compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a1df4167f117b91719debbcd1f8d954c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element comparison.  <a href="namespacesyclcompat.html#a1df4167f117b91719debbcd1f8d954c4">More...</a><br /></td></tr>
<tr class="separator:a1df4167f117b91719debbcd1f8d954c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded00838c044c56640295819e6509c29"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:aded00838c044c56640295819e6509c29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; BinaryOperation, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aded00838c044c56640295819e6509c29">syclcompat::unordered_compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:aded00838c044c56640295819e6509c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unordered comparison.  <a href="namespacesyclcompat.html#aded00838c044c56640295819e6509c29">More...</a><br /></td></tr>
<tr class="separator:aded00838c044c56640295819e6509c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a24a0dd3d4869a23e8acd0000eff243a2">syclcompat::unordered_compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a24a0dd3d4869a23e8acd0000eff243a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element unordered comparison.  <a href="namespacesyclcompat.html#a24a0dd3d4869a23e8acd0000eff243a2">More...</a><br /></td></tr>
<tr class="separator:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac829511f38fb4f876d37b587190d00b8"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac829511f38fb4f876d37b587190d00b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac829511f38fb4f876d37b587190d00b8">syclcompat::compare_both</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac829511f38fb4f876d37b587190d00b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element comparison and return true if both results are true.  <a href="namespacesyclcompat.html#ac829511f38fb4f876d37b587190d00b8">More...</a><br /></td></tr>
<tr class="separator:ac829511f38fb4f876d37b587190d00b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89163075cb3b34a386d4e020c51ef77a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a89163075cb3b34a386d4e020c51ef77a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a89163075cb3b34a386d4e020c51ef77a">syclcompat::unordered_compare_both</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a89163075cb3b34a386d4e020c51ef77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element unordered comparison and return true if both results are true.  <a href="namespacesyclcompat.html#a89163075cb3b34a386d4e020c51ef77a">More...</a><br /></td></tr>
<tr class="separator:a89163075cb3b34a386d4e020c51ef77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac29a2946cfc8b1e5053f1d11a3f81a55">syclcompat::compare_mask</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements.  <a href="namespacesyclcompat.html#ac29a2946cfc8b1e5053f1d11a3f81a55">More...</a><br /></td></tr>
<tr class="separator:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac54f0e6926d1e17b28d01849ba1969e2">syclcompat::unordered_compare_mask</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac54f0e6926d1e17b28d01849ba1969e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements unordered comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements.  <a href="namespacesyclcompat.html#ac54f0e6926d1e17b28d01849ba1969e2">More...</a><br /></td></tr>
<tr class="separator:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a31a2a3d5e07d4bb8b20f2309f2827105">syclcompat::vectorized_max</a> (T a, T b)</td></tr>
<tr class="memdesc:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized max for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#a31a2a3d5e07d4bb8b20f2309f2827105">More...</a><br /></td></tr>
<tr class="separator:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf81d995e76936eb645775f69ba31e"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a9cbf81d995e76936eb645775f69ba31e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9cbf81d995e76936eb645775f69ba31e">syclcompat::vectorized_min</a> (T a, T b)</td></tr>
<tr class="memdesc:a9cbf81d995e76936eb645775f69ba31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized min for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#a9cbf81d995e76936eb645775f69ba31e">More...</a><br /></td></tr>
<tr class="separator:a9cbf81d995e76936eb645775f69ba31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b88222d07913e646022d54682371d"><td class="memTemplParams" colspan="2">template&lt;typename VecT , class UnaryOperation &gt; </td></tr>
<tr class="memitem:ad16b88222d07913e646022d54682371d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad16b88222d07913e646022d54682371d">syclcompat::vectorized_unary</a> (unsigned a, const UnaryOperation unary_op)</td></tr>
<tr class="memdesc:ad16b88222d07913e646022d54682371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized unary operation for a value, with the value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ad16b88222d07913e646022d54682371d">More...</a><br /></td></tr>
<tr class="separator:ad16b88222d07913e646022d54682371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memTemplParams" colspan="2">template&lt;typename VecT &gt; </td></tr>
<tr class="memitem:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae5c6ea6f042442a0e6b83406d3be7f47">syclcompat::vectorized_sum_abs_diff</a> (unsigned a, unsigned b)</td></tr>
<tr class="memdesc:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized absolute difference for two values without modulo overflow, with each value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ae5c6ea6f042442a0e6b83406d3be7f47">More...</a><br /></td></tr>
<tr class="separator:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfca16dc6307a92959d4d7ef76337cc"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:aecfca16dc6307a92959d4d7ef76337cc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aecfca16dc6307a92959d4d7ef76337cc">syclcompat::vectorized_isgreater</a> (T a, T b)</td></tr>
<tr class="memdesc:aecfca16dc6307a92959d4d7ef76337cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized isgreater for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#aecfca16dc6307a92959d4d7ef76337cc">More...</a><br /></td></tr>
<tr class="separator:aecfca16dc6307a92959d4d7ef76337cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c669031ba0dc847fe933f8640fe81"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a801c669031ba0dc847fe933f8640fe81"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a801c669031ba0dc847fe933f8640fe81">syclcompat::vectorized_isgreater&lt; sycl::ushort2, unsigned &gt;</a> (unsigned a, unsigned b)</td></tr>
<tr class="memdesc:a801c669031ba0dc847fe933f8640fe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized isgreater for two unsigned int values, with each value treated as a vector of two unsigned short.  <a href="namespacesyclcompat.html#a801c669031ba0dc847fe933f8640fe81">More...</a><br /></td></tr>
<tr class="separator:a801c669031ba0dc847fe933f8640fe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memTemplItemLeft" align="right" valign="top">ValueT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab9be2b3ef2fed36c10d60ac4eb130f5c">syclcompat::clamp</a> (ValueT val, ValueT min_val, ValueT max_val)</td></tr>
<tr class="memdesc:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min(max(val, min_val), max_val)  <a href="namespacesyclcompat.html#ab9be2b3ef2fed36c10d60ac4eb130f5c">More...</a><br /></td></tr>
<tr class="separator:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad717ffed265f37aad2378786fd6d89f4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ad717ffed265f37aad2378786fd6d89f4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad717ffed265f37aad2378786fd6d89f4">syclcompat::isnan</a> (const ValueT a)</td></tr>
<tr class="memdesc:ad717ffed265f37aad2378786fd6d89f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether 2 element value is NaN.  <a href="namespacesyclcompat.html#ad717ffed265f37aad2378786fd6d89f4">More...</a><br /></td></tr>
<tr class="separator:ad717ffed265f37aad2378786fd6d89f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba95047e6b327a88374d0ad3a595b7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a8cba95047e6b327a88374d0ad3a595b7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8cba95047e6b327a88374d0ad3a595b7">syclcompat::cbrt</a> (ValueT val)</td></tr>
<tr class="memdesc:a8cba95047e6b327a88374d0ad3a595b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">cbrt function wrapper.  <a href="namespacesyclcompat.html#a8cba95047e6b327a88374d0ad3a595b7">More...</a><br /></td></tr>
<tr class="separator:a8cba95047e6b327a88374d0ad3a595b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; ValueT &gt; &amp;&amp;std::is_integral_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7ca23d990971b4698e3c3e5c6a7c6a6a">syclcompat::min</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fd37967c8d72eaea54a9305713b68b"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:aa3fd37967c8d72eaea54a9305713b68b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt; &amp;&amp;std::is_floating_point_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa3fd37967c8d72eaea54a9305713b68b">syclcompat::min</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:aa3fd37967c8d72eaea54a9305713b68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b268e654edb59f11023407d89dc1e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a22b268e654edb59f11023407d89dc1e2">syclcompat::min</a> (<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> a, <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> b)</td></tr>
<tr class="separator:a22b268e654edb59f11023407d89dc1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531bbe21767e8f4072bfcdff20f498f7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a531bbe21767e8f4072bfcdff20f498f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; ValueT &gt; &amp;&amp;std::is_integral_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a531bbe21767e8f4072bfcdff20f498f7">syclcompat::max</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a531bbe21767e8f4072bfcdff20f498f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a7811f8997faff9f040545e94eb578"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a85a7811f8997faff9f040545e94eb578"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt; &amp;&amp;std::is_floating_point_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a85a7811f8997faff9f040545e94eb578">syclcompat::max</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a85a7811f8997faff9f040545e94eb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49771fa421f438b08a8a9fd641cbc9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a49771fa421f438b08a8a9fd641cbc9fb">syclcompat::max</a> (<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> a, <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> b)</td></tr>
<tr class="separator:a49771fa421f438b08a8a9fd641cbc9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memTemplItemLeft" align="right" valign="top">std::common_type_t&lt; ValueT, ValueU &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a615ce353b7e9f28276758fe1eacf4aaf">syclcompat::fmax_nan</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="memdesc:a615ce353b7e9f28276758fe1eacf4aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison and returns the bigger one.  <a href="namespacesyclcompat.html#a615ce353b7e9f28276758fe1eacf4aaf">More...</a><br /></td></tr>
<tr class="separator:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56980b5d12a81c3e1316d788f7730a24"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a56980b5d12a81c3e1316d788f7730a24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; std::common_type_t&lt; ValueT, ValueU &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a56980b5d12a81c3e1316d788f7730a24">syclcompat::fmax_nan</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt; b)</td></tr>
<tr class="separator:a56980b5d12a81c3e1316d788f7730a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e292b332c72f1e012dfff1543122ad"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:aa6e292b332c72f1e012dfff1543122ad"><td class="memTemplItemLeft" align="right" valign="top">std::common_type_t&lt; ValueT, ValueU &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa6e292b332c72f1e012dfff1543122ad">syclcompat::fmin_nan</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="memdesc:aa6e292b332c72f1e012dfff1543122ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison and returns the smaller one.  <a href="namespacesyclcompat.html#aa6e292b332c72f1e012dfff1543122ad">More...</a><br /></td></tr>
<tr class="separator:aa6e292b332c72f1e012dfff1543122ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f095a3499a1a403aa3a5c523af0f445"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a6f095a3499a1a403aa3a5c523af0f445"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; std::common_type_t&lt; ValueT, ValueU &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6f095a3499a1a403aa3a5c523af0f445">syclcompat::fmin_nan</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt; b)</td></tr>
<tr class="separator:a6f095a3499a1a403aa3a5c523af0f445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018900fdf8d4f949fd973c9d96765320"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a018900fdf8d4f949fd973c9d96765320">syclcompat::pow</a> (const float a, const int b)</td></tr>
<tr class="separator:a018900fdf8d4f949fd973c9d96765320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783139834d0eb876b11b4f5af0358e6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a783139834d0eb876b11b4f5af0358e6b">syclcompat::pow</a> (const double a, const int b)</td></tr>
<tr class="separator:a783139834d0eb876b11b4f5af0358e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4389d66219fa53171d7a8779fd7cc2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:ace4389d66219fa53171d7a8779fd7cc2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ace4389d66219fa53171d7a8779fd7cc2">syclcompat::pow</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="separator:ace4389d66219fa53171d7a8779fd7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_floating_point_v&lt; ValueT &gt;, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae16d49807b1bd0c2ba162b8b041e6328">syclcompat::pow</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="separator:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b7f69405f6f7dc164912b6dd25866"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a883b7f69405f6f7dc164912b6dd25866"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a883b7f69405f6f7dc164912b6dd25866">syclcompat::relu</a> (const ValueT a)</td></tr>
<tr class="memdesc:a883b7f69405f6f7dc164912b6dd25866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs relu saturation.  <a href="namespacesyclcompat.html#a883b7f69405f6f7dc164912b6dd25866">More...</a><br /></td></tr>
<tr class="separator:a883b7f69405f6f7dc164912b6dd25866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cefc15668bad433ae4dd61991eed446"><td class="memTemplParams" colspan="2">template&lt;class ValueT &gt; </td></tr>
<tr class="memitem:a9cefc15668bad433ae4dd61991eed446"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9cefc15668bad433ae4dd61991eed446">syclcompat::relu</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a)</td></tr>
<tr class="separator:a9cefc15668bad433ae4dd61991eed446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memTemplParams" colspan="2">template&lt;class ValueT &gt; </td></tr>
<tr class="memitem:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae5ef6bf54a8af27e5a21365dd387ea6b">syclcompat::relu</a> (const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; a)</td></tr>
<tr class="separator:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedacf06b344702068bd0e09261dda844"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedacf06b344702068bd0e09261dda844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aedacf06b344702068bd0e09261dda844">syclcompat::cmul</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; y)</td></tr>
<tr class="memdesc:aedacf06b344702068bd0e09261dda844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multiplication of two complex numbers.  <a href="namespacesyclcompat.html#aedacf06b344702068bd0e09261dda844">More...</a><br /></td></tr>
<tr class="separator:aedacf06b344702068bd0e09261dda844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a98ca4eb5a166e3a49c085c9445fef3c3">syclcompat::cdiv</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; y)</td></tr>
<tr class="memdesc:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the division of two complex numbers.  <a href="namespacesyclcompat.html#a98ca4eb5a166e3a49c085c9445fef3c3">More...</a><br /></td></tr>
<tr class="separator:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3c10c27d44679e0ae2829cb48ab76d14">syclcompat::cabs</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x)</td></tr>
<tr class="memdesc:a3c10c27d44679e0ae2829cb48ab76d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the magnitude of a complex number.  <a href="namespacesyclcompat.html#a3c10c27d44679e0ae2829cb48ab76d14">More...</a><br /></td></tr>
<tr class="separator:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bdeb6e393e3bb3493787eafef19dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74bdeb6e393e3bb3493787eafef19dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a74bdeb6e393e3bb3493787eafef19dca">syclcompat::conj</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x)</td></tr>
<tr class="memdesc:a74bdeb6e393e3bb3493787eafef19dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complex conjugate of a complex number.  <a href="namespacesyclcompat.html#a74bdeb6e393e3bb3493787eafef19dca">More...</a><br /></td></tr>
<tr class="separator:a74bdeb6e393e3bb3493787eafef19dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11b7d2b288bb226ea5209062146ec63"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ab11b7d2b288bb226ea5209062146ec63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab11b7d2b288bb226ea5209062146ec63">syclcompat::cmul_add</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; c)</td></tr>
<tr class="memdesc:ab11b7d2b288bb226ea5209062146ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs complex number multiply addition.  <a href="namespacesyclcompat.html#ab11b7d2b288bb226ea5209062146ec63">More...</a><br /></td></tr>
<tr class="separator:ab11b7d2b288bb226ea5209062146ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4415353f91d200fc2fbea022e53e336e"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a4415353f91d200fc2fbea022e53e336e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4415353f91d200fc2fbea022e53e336e">syclcompat::cmul_add</a> (const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; b, const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; c)</td></tr>
<tr class="separator:a4415353f91d200fc2fbea022e53e336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f7af0ba11c7e398732af5088e033f1"><td class="memTemplParams" colspan="2">template&lt;typename VecT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ad2f7af0ba11c7e398732af5088e033f1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad2f7af0ba11c7e398732af5088e033f1">syclcompat::vectorized_binary</a> (unsigned a, unsigned b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ad2f7af0ba11c7e398732af5088e033f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized binary operation value for two values, with each value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ad2f7af0ba11c7e398732af5088e033f1">More...</a><br /></td></tr>
<tr class="separator:ad2f7af0ba11c7e398732af5088e033f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2322aed08cbe875a97da83f7dcc8a61f">syclcompat::extend_add</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a2322aed08cbe875a97da83f7dcc8a61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and add them.  <a href="namespacesyclcompat.html#a2322aed08cbe875a97da83f7dcc8a61f">More...</a><br /></td></tr>
<tr class="separator:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acebd1383b7ad2eeba4f7749eb99e0bc0">syclcompat::extend_add</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, add <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#acebd1383b7ad2eeba4f7749eb99e0bc0">More...</a><br /></td></tr>
<tr class="separator:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b249ad38d46680197b4252ba0a36a60"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a3b249ad38d46680197b4252ba0a36a60"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3b249ad38d46680197b4252ba0a36a60">syclcompat::extend_add_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a3b249ad38d46680197b4252ba0a36a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and add them with saturation.  <a href="namespacesyclcompat.html#a3b249ad38d46680197b4252ba0a36a60">More...</a><br /></td></tr>
<tr class="separator:a3b249ad38d46680197b4252ba0a36a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8160bb0989abca1627abc8848d3e5d45"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a8160bb0989abca1627abc8848d3e5d45"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8160bb0989abca1627abc8848d3e5d45">syclcompat::extend_add_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a8160bb0989abca1627abc8848d3e5d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, add <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a8160bb0989abca1627abc8848d3e5d45">More...</a><br /></td></tr>
<tr class="separator:a8160bb0989abca1627abc8848d3e5d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a282cecb3084c18e11203262ef7d0"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a340a282cecb3084c18e11203262ef7d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a340a282cecb3084c18e11203262ef7d0">syclcompat::extend_sub</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a340a282cecb3084c18e11203262ef7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and minus them.  <a href="namespacesyclcompat.html#a340a282cecb3084c18e11203262ef7d0">More...</a><br /></td></tr>
<tr class="separator:a340a282cecb3084c18e11203262ef7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24d3ca4111c0870bce355c7283b2588"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ad24d3ca4111c0870bce355c7283b2588"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad24d3ca4111c0870bce355c7283b2588">syclcompat::extend_sub</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:ad24d3ca4111c0870bce355c7283b2588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#ad24d3ca4111c0870bce355c7283b2588">More...</a><br /></td></tr>
<tr class="separator:ad24d3ca4111c0870bce355c7283b2588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab537af4548527320497820dbe606d5fa"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:ab537af4548527320497820dbe606d5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab537af4548527320497820dbe606d5fa">syclcompat::extend_sub_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:ab537af4548527320497820dbe606d5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and minus them with saturation.  <a href="namespacesyclcompat.html#ab537af4548527320497820dbe606d5fa">More...</a><br /></td></tr>
<tr class="separator:ab537af4548527320497820dbe606d5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095a7e145440a9bee06ed5f885bcee62"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a095a7e145440a9bee06ed5f885bcee62"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a095a7e145440a9bee06ed5f885bcee62">syclcompat::extend_sub_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a095a7e145440a9bee06ed5f885bcee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a095a7e145440a9bee06ed5f885bcee62">More...</a><br /></td></tr>
<tr class="separator:a095a7e145440a9bee06ed5f885bcee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67762a6b2faa454a541b765c35164af4"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a67762a6b2faa454a541b765c35164af4"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a67762a6b2faa454a541b765c35164af4">syclcompat::extend_absdiff</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a67762a6b2faa454a541b765c35164af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a>.  <a href="namespacesyclcompat.html#a67762a6b2faa454a541b765c35164af4">More...</a><br /></td></tr>
<tr class="separator:a67762a6b2faa454a541b765c35164af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340c344b03eef89ef8abc09cdafd03ea"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a340c344b03eef89ef8abc09cdafd03ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a340c344b03eef89ef8abc09cdafd03ea">syclcompat::extend_absdiff</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a340c344b03eef89ef8abc09cdafd03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a340c344b03eef89ef8abc09cdafd03ea">More...</a><br /></td></tr>
<tr class="separator:a340c344b03eef89ef8abc09cdafd03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10430015596393bf2dce1e007dfcca07"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a10430015596393bf2dce1e007dfcca07"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a10430015596393bf2dce1e007dfcca07">syclcompat::extend_absdiff_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a10430015596393bf2dce1e007dfcca07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> with saturation.  <a href="namespacesyclcompat.html#a10430015596393bf2dce1e007dfcca07">More...</a><br /></td></tr>
<tr class="separator:a10430015596393bf2dce1e007dfcca07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf831fb5b0e0779bb550851b73af89b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a3cf831fb5b0e0779bb550851b73af89b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3cf831fb5b0e0779bb550851b73af89b">syclcompat::extend_absdiff_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a3cf831fb5b0e0779bb550851b73af89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a3cf831fb5b0e0779bb550851b73af89b">More...</a><br /></td></tr>
<tr class="separator:a3cf831fb5b0e0779bb550851b73af89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513cddbc8845e942c38c04484ddb359b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a513cddbc8845e942c38c04484ddb359b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a513cddbc8845e942c38c04484ddb359b">syclcompat::extend_min</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a513cddbc8845e942c38c04484ddb359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one.  <a href="namespacesyclcompat.html#a513cddbc8845e942c38c04484ddb359b">More...</a><br /></td></tr>
<tr class="separator:a513cddbc8845e942c38c04484ddb359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a77de29a1c643284782b3c83fba3d69"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a4a77de29a1c643284782b3c83fba3d69"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4a77de29a1c643284782b3c83fba3d69">syclcompat::extend_min</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a4a77de29a1c643284782b3c83fba3d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a4a77de29a1c643284782b3c83fba3d69">More...</a><br /></td></tr>
<tr class="separator:a4a77de29a1c643284782b3c83fba3d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a696a528e5d9dbe5944898a5a5ed7bf6b">syclcompat::extend_min_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one with saturation.  <a href="namespacesyclcompat.html#a696a528e5d9dbe5944898a5a5ed7bf6b">More...</a><br /></td></tr>
<tr class="separator:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf721a651b4656ca9f024818537215"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:afcaf721a651b4656ca9f024818537215"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afcaf721a651b4656ca9f024818537215">syclcompat::extend_min_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:afcaf721a651b4656ca9f024818537215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#afcaf721a651b4656ca9f024818537215">More...</a><br /></td></tr>
<tr class="separator:afcaf721a651b4656ca9f024818537215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a533cffd30b30a7a51f6e51283f6ad0fc">syclcompat::extend_max</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one.  <a href="namespacesyclcompat.html#a533cffd30b30a7a51f6e51283f6ad0fc">More...</a><br /></td></tr>
<tr class="separator:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8ec078f14bae384ecab4c45801b117"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:aba8ec078f14bae384ecab4c45801b117"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aba8ec078f14bae384ecab4c45801b117">syclcompat::extend_max</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:aba8ec078f14bae384ecab4c45801b117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#aba8ec078f14bae384ecab4c45801b117">More...</a><br /></td></tr>
<tr class="separator:aba8ec078f14bae384ecab4c45801b117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d428f4281cef11e44e37b69d62876d"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a36d428f4281cef11e44e37b69d62876d"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a36d428f4281cef11e44e37b69d62876d">syclcompat::extend_max_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a36d428f4281cef11e44e37b69d62876d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one with saturation.  <a href="namespacesyclcompat.html#a36d428f4281cef11e44e37b69d62876d">More...</a><br /></td></tr>
<tr class="separator:a36d428f4281cef11e44e37b69d62876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b890c4272f2b5c60e2205f90b422f2"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a60b890c4272f2b5c60e2205f90b422f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a60b890c4272f2b5c60e2205f90b422f2">syclcompat::extend_max_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a60b890c4272f2b5c60e2205f90b422f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a60b890c4272f2b5c60e2205f90b422f2">More...</a><br /></td></tr>
<tr class="separator:a60b890c4272f2b5c60e2205f90b422f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6b48bded63fb2dfc065766b1ff13c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b48bded63fb2dfc065766b1ff13c436">&#9670;&nbsp;</a></span>SYCL_EXT_ONEAPI_COMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SYCL_EXT_ONEAPI_COMPLEX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00037">37</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b1584ef745fb26c2594bce2bebdea133.html">syclcompat</a></li><li class="navelem"><a class="el" href="ompat_2math_8hpp.html">math.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
