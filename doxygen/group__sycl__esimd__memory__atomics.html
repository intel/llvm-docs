<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: Atomic memory access.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory__atomics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Atomic memory access.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a> &raquo; <a class="el" href="group__sycl__esimd__memory.html">Memory access API.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory access functions which perform per-lane atomic update using given operation.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Atomic memory access.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory__atomics.png" border="0" usemap="#agroup____sycl____esimd____memory____atomics" alt=""/></div>
<map name="agroup____sycl____esimd____memory____atomics" id="agroup____sycl____esimd____memory____atomics">
<area shape="rect" title="Memory access functions which perform per&#45;lane atomic update using given operation." alt="" coords="207,5,385,31"/>
<area shape="rect" href="group__sycl__esimd__memory.html" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="5,5,159,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9ca317137669bb87b6b0741d434d5834"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">More...</a><br /></td></tr>
<tr class="separator:ga9ca317137669bb87b6b0741d434d5834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga61ed2c099e12fc7505d061e617c241fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (usm-au0-2)  <a href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">More...</a><br /></td></tr>
<tr class="separator:ga61ed2c099e12fc7505d061e617c241fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga60a6e250570f0318924f443351dcd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-3)  <a href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">More...</a><br /></td></tr>
<tr class="separator:ga60a6e250570f0318924f443351dcd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga299c6985b6669fe4d0965a13223452c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, props = {}); /// (usm-au0-4)  <a href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">More...</a><br /></td></tr>
<tr class="separator:ga299c6985b6669fe4d0965a13223452c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, Toffset byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">More...</a><br /></td></tr>
<tr class="separator:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6624b909565dd8a01cca82f94118658f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">More...</a><br /></td></tr>
<tr class="separator:ga6624b909565dd8a01cca82f94118658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d32dac41faa2752a3a100179c047164"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">More...</a><br /></td></tr>
<tr class="separator:ga5d32dac41faa2752a3a100179c047164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa8235f4973a7f07671e65884d6a4e407"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (usm-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">More...</a><br /></td></tr>
<tr class="separator:gaa8235f4973a7f07671e65884d6a4e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3163517455229f9359dc7befcdaf33ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">More...</a><br /></td></tr>
<tr class="separator:ga3163517455229f9359dc7befcdaf33ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">sycl::_V1::ext::intel::esimd::atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaa11a4e5e6db9766b05f53882c5969894"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">More...</a><br /></td></tr>
<tr class="separator:gaa11a4e5e6db9766b05f53882c5969894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7818fd03a76ec89e81453fc2eed03315"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update2"></a>Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">More...</a><br /></td></tr>
<tr class="separator:ga7818fd03a76ec89e81453fc2eed03315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b0e94818140af7667c53ed1900f8227"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (usm-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">More...</a><br /></td></tr>
<tr class="separator:ga8b0e94818140af7667c53ed1900f8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga50118f07f0d1ce05b1f3af664e61f377"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}) // (usm-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">More...</a><br /></td></tr>
<tr class="separator:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b969ac66b06344433b03d7a42c5adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}) // (usm-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">More...</a><br /></td></tr>
<tr class="separator:ga8b969ac66b06344433b03d7a42c5adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">sycl::_V1::ext::intel::esimd::atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gadfc93c8742970952cb25c39099e90017"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">More...</a><br /></td></tr>
<tr class="separator:gadfc93c8742970952cb25c39099e90017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7a0e01d45006dc95652b9576a8468333"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">More...</a><br /></td></tr>
<tr class="separator:ga7a0e01d45006dc95652b9576a8468333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece5430efdfa55ea8851a6a4baffc367"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (acc-au0-2) A variation of <code>atomic_update</code> API without mask operand  <a href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">More...</a><br /></td></tr>
<tr class="separator:gaece5430efdfa55ea8851a6a4baffc367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-3) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">More...</a><br /></td></tr>
<tr class="separator:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0b4df1e247b58fad96a6ac29fca17892"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, props = {}); /// (acc-au0-4) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.  <a href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">More...</a><br /></td></tr>
<tr class="separator:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga026c23b583bbddb6c43fa0db20c15267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">More...</a><br /></td></tr>
<tr class="separator:ga026c23b583bbddb6c43fa0db20c15267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gac6fcffa3281c801923e6ca78d7681553"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar using <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">More...</a><br /></td></tr>
<tr class="separator:gac6fcffa3281c801923e6ca78d7681553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga12af50e667b8379c85ba2fbd69c9642a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">More...</a><br /></td></tr>
<tr class="separator:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga911d8084626d7c07dc3d5a358e8d6118"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">More...</a><br /></td></tr>
<tr class="separator:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (acc-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">More...</a><br /></td></tr>
<tr class="separator:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gab12baf4188b777673f2293f506f5c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">More...</a><br /></td></tr>
<tr class="separator:gab12baf4188b777673f2293f506f5c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gace9371b37fcc89eee8dd82d7957c9aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">More...</a><br /></td></tr>
<tr class="separator:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object and uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">More...</a><br /></td></tr>
<tr class="separator:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab1cb38958ce5611fbb683250b6d37b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update2"></a> <a href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">More...</a><br /></td></tr>
<tr class="separator:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">More...</a><br /></td></tr>
<tr class="separator:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2453919e91d9887fde4bc32fb858212c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (acc-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">More...</a><br /></td></tr>
<tr class="separator:ga2453919e91d9887fde4bc32fb858212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT, byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">More...</a><br /></td></tr>
<tr class="separator:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaf02d6524019b24c7f1444aec1057ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">More...</a><br /></td></tr>
<tr class="separator:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga0164810c5dc8e6862f0188fb93b75640"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar and <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> is used.  <a href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">More...</a><br /></td></tr>
<tr class="separator:ga0164810c5dc8e6862f0188fb93b75640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Memory access functions which perform per-lane atomic update using given operation. </p>
<p>"Per-lane" means that the atomicity guarantees of a vector atomic operation are the same as of N independent scalar atomic operations per lane (N is number of lanes). </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0b4df1e247b58fad96a6ac29fca17892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4df1e247b58fad96a6ac29fca17892">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[1/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, props = {}); /// (acc-au0-4) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07318">7318</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab12baf4188b777673f2293f506f5c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12baf4188b777673f2293f506f5c58a">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[2/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-4) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07613">7613</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaedaa2fddfad01be856f0ac3e92dea8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedaa2fddfad01be856f0ac3e92dea8f4">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[3/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT, byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-4) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as a <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07881">7881</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2453919e91d9887fde4bc32fb858212c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2453919e91d9887fde4bc32fb858212c">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[4/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (acc-au2-3) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as a <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07844">7844</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8d12ab7b93126d3af6531bf1cbfc830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d12ab7b93126d3af6531bf1cbfc830b">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[5/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (acc-au1-3) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07568">7568</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5725ccf8dfc4ecb5cc114b85c7327d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5725ccf8dfc4ecb5cc114b85c7327d23">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[6/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-3) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07284">7284</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaece5430efdfa55ea8851a6a4baffc367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece5430efdfa55ea8851a6a4baffc367">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[7/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (acc-au0-2) A variation of <code>atomic_update</code> API without mask operand </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07244">7244</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga911d8084626d7c07dc3d5a358e8d6118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga911d8084626d7c07dc3d5a358e8d6118">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[8/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-2) </p>
<p>A variation of <code>atomic_update</code> API with no mask operand.</p>
<p>Atomically updates <code>N</code> memory locations represented by an accessor and a vector of offsets, and returns a vector of old values found at the memory locations before update. The update operation has 1 additional argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07520">7520</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf72b54d4c40c5b335642b721bbd3cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf72b54d4c40c5b335642b721bbd3cd0c">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[9/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-2) </p>
<p>A variation of <code>atomic_update</code> API with no mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07805">7805</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab1cb38958ce5611fbb683250b6d37b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1cb38958ce5611fbb683250b6d37b9f">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[10/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="accessor_atomic_update2"></a></p>
<p>Two-argument variant of the atomic update operation.</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-2) simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (acc-au2-3)</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT, byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-4) simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, Atomically updates <code>N</code> memory locations represented by an accessor and a vector of offsets and returns a vector of old values found at the memory locations before update. The update operation has 2 additional arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07742">7742</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga12af50e667b8379c85ba2fbd69c9642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12af50e667b8379c85ba2fbd69c9642a">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[11/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="accessor_atomic_update1"></a></p>
<p>Single-argument variant of the atomic update operation.</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {});//(acc-au1-1) simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-2)</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (acc-au1-3) simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-4) simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {});//(acc-au1-1)</p>
<p>Atomically updates <code>N</code> memory locations represented by an accessor and a vector of offsets, and returns a vector of old values found at the memory locations before update. The update operation has 1 additional argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07442">7442</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7a0e01d45006dc95652b9576a8468333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0e01d45006dc95652b9576a8468333">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[12/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="accessor_atomic_update0"></a></p>
<p>No-argument variant of the atomic update operation.</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-1) simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (acc-au0-2) simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-3) simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, props = {}); /// (acc-au0-4) Usage of cache hints or non-standard operation width N requires DG2 or PVC.</p>
<p>simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-1)</p>
<p>Atomically updates <code>N</code> memory locations represented by an accessor and a vector of offsets, and returns a vector of old values found at the memory locations before update. The update operation has no arguments in addition to the value at the memory location.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. 64-bit offsets are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07177">7177</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga026c23b583bbddb6c43fa0db20c15267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga026c23b583bbddb6c43fa0db20c15267">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[13/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The scalar 32-bit or 64-bit offset in bytes. 64-bit offset are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07348">7348</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gace9371b37fcc89eee8dd82d7957c9aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9371b37fcc89eee8dd82d7957c9aab">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[14/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt; &amp;&amp; ((Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp; Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>) || N == 1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code> <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>The scalar 32-bit or 64-bit offset in bytes. 64-bit offset are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07646">7646</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>.</p>

</div>
</div>
<a id="gaf02d6524019b24c7f1444aec1057ebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf02d6524019b24c7f1444aec1057ebbe">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[15/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename Tx , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>The scalar 32-bit or 64-bit offset in bytes. 64-bit offset are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07912">7912</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src1</a>.</p>

</div>
</div>
<a id="gac6fcffa3281c801923e6ca78d7681553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fcffa3281c801923e6ca78d7681553">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[16/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar using <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The scalar 32-bit or 64-bit offset in bytes. 64-bit offset are supported only when stateless memory accesses are enforced, i.e. accessor based accesses are automatically converted to stateless accesses. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07375">7375</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga0164810c5dc8e6862f0188fb93b75640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0164810c5dc8e6862f0188fb93b75640">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[17/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar and <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> is used. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>The scalar 32-bit offset in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07938">7938</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src1</a>.</p>

</div>
</div>
<a id="ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[18/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt; &amp;&amp; ((Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp; Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>) || N == 1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object and uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code> <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>type of the SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>The scalar 32-bit offset in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07675">7675</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>.</p>

</div>
</div>
<a id="ga299c6985b6669fe4d0965a13223452c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga299c6985b6669fe4d0965a13223452c0">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[19/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, props = {}); /// (usm-au0-4) </p>
<p>A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object without mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06620">6620</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8b969ac66b06344433b03d7a42c5adef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b969ac66b06344433b03d7a42c5adef">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[20/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}) // (usm-au2-4) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07092">7092</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga50118f07f0d1ce05b1f3af664e61f377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50118f07f0d1ce05b1f3af664e61f377">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[21/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}) // (usm-au2-3) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07060">7060</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3163517455229f9359dc7befcdaf33ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3163517455229f9359dc7befcdaf33ac">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[22/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-4) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06865">6865</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa8235f4973a7f07671e65884d6a4e407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8235f4973a7f07671e65884d6a4e407">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[23/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (usm-au1-3) </p>
<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06827">6827</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga60a6e250570f0318924f443351dcd01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60a6e250570f0318924f443351dcd01d">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[24/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-3) </p>
<p>A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06589">6589</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga61ed2c099e12fc7505d061e617c241fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ed2c099e12fc7505d061e617c241fb">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[25/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (usm-au0-2) </p>
<p>A variation of <code>atomic_update</code> API without mask operand.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes (zero-based). </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06556">6556</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5d32dac41faa2752a3a100179c047164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d32dac41faa2752a3a100179c047164">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[26/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-2) </p>
<p>A variation of <code>atomic_update</code> API without mask operand. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06786">6786</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8b0e94818140af7667c53ed1900f8227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b0e94818140af7667c53ed1900f8227">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[27/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (usm-au2-2) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07026">7026</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7818fd03a76ec89e81453fc2eed03315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7818fd03a76ec89e81453fc2eed03315">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[28/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="usm_atomic_update2"></a>Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update. </p>
<p>The update operation has 2 additional arguments.</p>
<p>simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (usm-au2-1) simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (usm-au2-2)</p>
<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}) // (usm-au2-3) simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}) // (usm-au2-4) simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (usm-au2-1)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06951">6951</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6624b909565dd8a01cca82f94118658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6624b909565dd8a01cca82f94118658f">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[29/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="usm_atomic_update1"></a></p>
<p>Single-argument variant of the atomic update operation.</p>
<p>simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {});//(usm-au1-1) simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-2)</p>
<p>simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (usm-au1-3) simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-4) simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {});//(usm-au1-1)</p>
<p>Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update. The update operation has 1 additional argument.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171" title="ACM/PVC: Addition (floating point): *addr = *addr + src0.">atomic_op::fadd</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd" title="ACM/PVC: Subtraction (floating point): *addr = *addr - src0.">atomic_op::fsub</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. Other properties are ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06700">6700</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga9ca317137669bb87b6b0741d434d5834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca317137669bb87b6b0741d434d5834">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[30/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="usm_atomic_update0"></a></p>
<p>No-argument variant of the atomic update operation.</p>
<p>simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-1) simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (usm-au0-2) simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-3) simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, props = {}); /// (usm-au0-4)</p>
<p>Usage of cache hints or non-standard operation width N requires DG2 or PVC.</p>
<p>simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-1) Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update. The update operation has no arguments in addition to the value at the memory location.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit or 64-bit offsets in bytes (zero-based). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
    <tr><td class="paramname">props</td><td>The parameter 'props' specifies the optional compile-time properties list. Only L1/L2 properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06480">6480</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga49c30960f901e1ac8ddd3f6db43a1327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c30960f901e1ac8ddd3f6db43a1327">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[31/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The scalar 32-bit or 64-bit offset in bytes. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06641">6641</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gadfc93c8742970952cb25c39099e90017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc93c8742970952cb25c39099e90017">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[32/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d" title="Compare and exchange. if (*addr == src0) *sddr = src1;">atomic_op::cmpxchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5" title="ACM/PVC: Compare and exchange (floating point).">atomic_op::fcmpxchg</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The scalar 32-bit or 64-bit offset in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The first additional argument (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>The second additional argument (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07117">7117</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src1</a>.</p>

</div>
</div>
<a id="gaa11a4e5e6db9766b05f53882c5969894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11a4e5e6db9766b05f53882c5969894">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[33/33]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt;Toffset&gt; &amp;&amp; ((Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp; Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>) || N == 1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be one of the following: <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332" title="Addition: *addr = *addr + src0.">atomic_op::add</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140" title="Subtraction: *addr = *addr - src0.">atomic_op::sub</a></code>, <code>atomic_op::min</code>, <code>atomic_op::max</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b" title="Exchange. *addr == src0;">atomic_op::xchg</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a" title="Bit and: *addr = *addr &amp; src0.">atomic_op::bit_and</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b" title="Bit or: *addr = *addr | src0.">atomic_op::bit_or</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739" title="Bit xor: *addr = *addr | src0.">atomic_op::bit_xor</a></code>, <code>atomic_op::minsint</code>, <code>atomic_op::maxsint</code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce" title="ACM/PVC: Minimum (floating point): *addr = min(*addr, src0).">atomic_op::fmax</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421" title="ACM/PVC: Maximum (floating point): *addr = max(*addr, src0).">atomic_op::fmin</a></code> <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a></code>. </td></tr>
    <tr><td class="paramname">Tx</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM pointer. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The scalar 32-bit or 64-bit offsets in bytes. </td></tr>
    <tr><td class="paramname">src0</td><td>The additional argument. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06894">6894</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
