<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: DPC++ Execution Graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI Data Parallel C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">DPC++ Execution Graph</div>  </div>
</div><!--header-->
<div class="contents">

<p>SYCL, unlike OpenCL, provides a programming model in which the user doesn't need to manage dependencies between kernels and memory explicitly. The DPC++ Runtime must ensure correct execution with respect to the order commands are submitted.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1detail_1_1Command.html">cl::sycl::detail::Command</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classcl_1_1sycl_1_1detail_1_1Command.html" title="The Command class represents some action that needs to be performed on one or more memory objects.">Command</a> class represents some action that needs to be performed on one or more memory objects.  <a href="classcl_1_1sycl_1_1detail_1_1Command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1MemObjRecord.html">cl::sycl::detail::MemObjRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory Object Record.  <a href="structcl_1_1sycl_1_1detail_1_1MemObjRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1detail_1_1Scheduler_1_1GraphBuilder.html">cl::sycl::detail::Scheduler::GraphBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph builder class.  <a href="classcl_1_1sycl_1_1detail_1_1Scheduler_1_1GraphBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1detail_1_1Scheduler_1_1GraphProcessor.html">cl::sycl::detail::Scheduler::GraphProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph Processor provides interfaces for enqueueing commands and their dependencies to the underlying runtime.  <a href="classcl_1_1sycl_1_1detail_1_1Scheduler_1_1GraphProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1detail_1_1Scheduler.html">cl::sycl::detail::Scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DPC++ graph scheduler class.  <a href="classcl_1_1sycl_1_1detail_1_1Scheduler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>SYCL, unlike OpenCL, provides a programming model in which the user doesn't need to manage dependencies between kernels and memory explicitly. The DPC++ Runtime must ensure correct execution with respect to the order commands are submitted. </p>
<p>This document describes the part of the DPC++ Runtime that is responsible for building and processing dependency graph.</p>
<h2>A couple of words about DPC++ and SYCL execution and memory model</h2>
<p>The SYCL framework defines command group (CG) as an entity that represents minimal execution block. The command group is submitted to SYCL queue and consists of a kernel or an explicit memory operation, and their requirements. The SYCL queue defines the device and context using which the kernel should be executed.</p>
<p>The commands that contain explicit memory operations include copy, fill, update_host and other operations. It's up to implementation how to define these operations.</p>
<p>The relative order of command groups submission defines the order in which kernels must be executed if their memory requirements intersect. For example, if a command group A writes to a buffer X, command group B reads from X, then the scheduled execution order of A and B will be the same as their dynamic submission order (matches program order if submitted from the same host thread).</p>
<p>Memory requirements are requests to SYCL memory objects, such as buffer and image. SYCL memory objects are not bound to any specific context or device, it's SYCL responsibility to allocate and/or copy memory to the target context to achieve correct execution.</p>
<p>Refer to SYCL Specification 1.2.1 sections 3.4 and 3.5 to find more information about SYCL execution and memory model.</p>
<h3>Example of DPC++ application</h3>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">// Creating SYCL CPU and GPU queues</span></div>
<div class="line">  <a class="code" href="classcl_1_1sycl_1_1queue.html">cl::sycl::queue</a> CPU_Queue = ...;</div>
<div class="line">  <a class="code" href="classcl_1_1sycl_1_1queue.html">cl::sycl::queue</a> GPU_Queue = ...;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Creating 3 SYCL buffers</span></div>
<div class="line">  <span class="keyword">auto</span> BufferA = ...; <span class="comment">// Buffer is initialized with host memory.</span></div>
<div class="line">  <span class="keyword">auto</span> BufferB = ...;</div>
<div class="line">  <span class="keyword">auto</span> BufferC = ...;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// &quot;Copy command group&quot; section</span></div>
<div class="line">  <span class="comment">// Request processing explicit copy operation on CPU</span></div>
<div class="line">  <span class="comment">// The copy operation reads from BufferA and writes to BufferB</span></div>
<div class="line"> </div>
<div class="line">  CPU_Queue.<a class="code" href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">submit</a>([&amp;](handler &amp;CGH) {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a7fc56270e7a70fa81a5935b72eacbe29">A</a> = BufferA.get_access&lt;<a class="code" href="namespacecl_1_1sycl_1_1access.html#a9ae8c23f772316322be407bbb6498b17aecae13117d6f0584c25a9da6c8f8415e">read</a>&gt;(CGH);</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a9d5ed678fe57bcca610140957afab571">B</a> = BufferB.get_access&lt;<a class="code" href="namespacecl_1_1sycl_1_1detail.html#a7f8034599550834b7f1d9c514f8a088a">write</a>&gt;(CGH);</div>
<div class="line">    CGH.copy(A, B);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// &quot;Multi command group&quot; section</span></div>
<div class="line">  <span class="comment">// Request processing multi kernel on GPU</span></div>
<div class="line">  <span class="comment">// The kernel reads from BufferB, multiplies by 4 and writes result to</span></div>
<div class="line">  <span class="comment">// BufferC</span></div>
<div class="line"> </div>
<div class="line">  GPU_Queue.<a class="code" href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">submit</a>([&amp;](handler &amp;CGH) {</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a9d5ed678fe57bcca610140957afab571">B</a> = BufferB.get_access&lt;<a class="code" href="namespacecl_1_1sycl_1_1access.html#a9ae8c23f772316322be407bbb6498b17aecae13117d6f0584c25a9da6c8f8415e">read</a>&gt;(CGH);</div>
<div class="line">    <span class="keyword">auto</span> C = BufferC.get_access&lt;<a class="code" href="namespacecl_1_1sycl_1_1detail.html#a7f8034599550834b7f1d9c514f8a088a">write</a>&gt;(CGH);</div>
<div class="line">    CGH.parallel_for&lt;<span class="keyword">class </span>multi&gt;(range&lt;1&gt;{N}, [=](id&lt;1&gt; Index) {</div>
<div class="line">      C[Index] = <a class="code" href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a9d5ed678fe57bcca610140957afab571">B</a>[Index] * 4;</div>
<div class="line">    });</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// &quot;Host accessor creation&quot; section</span></div>
<div class="line">  <span class="comment">// Request the latest data of BufferC for the moment</span></div>
<div class="line">  <span class="comment">// This is a synchronization point, which means that the DPC++ RT blocks</span></div>
<div class="line">  <span class="comment">// on creation of the accessor until requested data is available.</span></div>
<div class="line">  <span class="keyword">auto</span> C = BufferC.get_access&lt;<a class="code" href="namespacecl_1_1sycl_1_1access.html#a9ae8c23f772316322be407bbb6498b17aecae13117d6f0584c25a9da6c8f8415e">read</a>&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example above the DPC++ RT does the following:</p>
<ol type="1">
<li><b>Copy command group</b>. The DPC++ RT allocates memory for BufferA and BufferB on CPU then executes an explicit copy operation on CPU.</li>
<li><b>Multi command group</b> DPC++ RT allocates memory for BufferC and BufferB on GPU and copy content of BufferB from CPU to GPU, then execute "multi" kernel on GPU.</li>
<li><b>Host accessor creation</b> DPC++ RT allocates(it's possible to reuse already allocated memory) memory available for user for BufferC then copy content of BufferC from GPU to this memory.</li>
</ol>
<p>So, the example above will be converted to the following OpenCL pseudo code </p><div class="fragment"><div class="line"><span class="comment">// Initialization(not related to the Scheduler)</span></div>
<div class="line">Platform = clGetPlatforms(...);</div>
<div class="line">DeviceCPU = clGetDevices(CL_DEVICE_TYPE_CPU, ...);</div>
<div class="line">DeviceGPU = clGetDevices(CL_DEVICE_TYPE_GPU, ...);</div>
<div class="line">ContextCPU = clCreateContext(DeviceCPU, ...)</div>
<div class="line">ContextGPU = clCreateContext(DeviceGPU, ...)</div>
<div class="line">QueueCPU = clCreateCommandQueue(ContextCPU, DeviceCPU, ...);</div>
<div class="line">QueueGPU = clCreateCommandQueue(ContextGPU, DeviceGPU, ...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Copy command group:</span></div>
<div class="line">BufferACPU = clCreateBuffer(ContextCPU, CL_MEM_USE_HOST_PTR, ...);</div>
<div class="line">BufferBCPU = clCreateBuffer(ContextCPU, ...);</div>
<div class="line">CopyEvent = clEnqueueCopyBuffer(QueueCPU, BufferACPU, BufferBCPU, ...)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Multi command group:</span></div>
<div class="line">ReadBufferEvent =</div>
<div class="line">   clEnqueueReadBuffer(QueueCPU, BufferBCPU, HostPtr, CopyEvent, ...);</div>
<div class="line">BufferBGPU = clCreateBuffer(ContextGPU, ...);</div>
<div class="line"> </div>
<div class="line">UserEvent = clCreateUserEvent(ContextCPU);</div>
<div class="line">clSetEventCallback(ReadBufferEvent, event_completion_callback,</div>
<div class="line"><span class="comment">/*data=*/</span>UserEvent);</div>
<div class="line"> </div>
<div class="line">WriteBufferEvent = clEnqueueWriteBuffer(QueueGPU, BufferBGPU, HostPtr,</div>
<div class="line">UserEvent, ...); BufferCGPU = clCreateBuffer(ContextGPU, ...); ProgramGPU =</div>
<div class="line">clCreateProgramWithIL(ContextGPU, ...); clBuildProgram(ProgramGPU);</div>
<div class="line">MultiKernel = clCreateKernel(&quot;multi&quot;);</div>
<div class="line">clSetKernelArg(MultiKernel, BufferBGPU, ...);</div>
<div class="line">clSetKernelArg(MultiKernel, BufferCGPU, ...);</div>
<div class="line">MultiEvent =</div>
<div class="line">   clEnqueueNDRangeKernel(QueueGPU, MultiKernel, WriteBufferEvent, ...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Host accessor creation:</span></div>
<div class="line">clEnqueueMapBuffer(QueueGPU, BufferCGPU, BLOCKING_MAP, MultiEvent, ...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Releasing mem objects during SYCL buffers destruction.</span></div>
<div class="line">clReleaseBuffer(BufferACPU);</div>
<div class="line">clReleaseBuffer(BufferBCPU);</div>
<div class="line">clReleaseBuffer(BufferBGPU);</div>
<div class="line">clReleaseBuffer(BufferCGPU);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release(not related to the Scheduler)</span></div>
<div class="line">clReleaseKernel(MultiKernel);</div>
<div class="line">clReleaseProgram(ProgramGPU);</div>
<div class="line">clReleaseContext(ContextGPU);</div>
<div class="line">clReleaseContext(ContextCPU);</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacecl_1_1sycl_1_1access_html_a9ae8c23f772316322be407bbb6498b17aecae13117d6f0584c25a9da6c8f8415e"><div class="ttname"><a href="namespacecl_1_1sycl_1_1access.html#a9ae8c23f772316322be407bbb6498b17aecae13117d6f0584c25a9da6c8f8415e">cl::sycl::access::mode::read</a></div><div class="ttdeci">@ read</div></div>
<div class="ttc" id="aclasscl_1_1sycl_1_1queue_html"><div class="ttname"><a href="classcl_1_1sycl_1_1queue.html">cl::sycl::queue</a></div><div class="ttdoc">Encapsulates a single SYCL queue which schedules kernels on a SYCL device.</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00103">queue.hpp:103</a></div></div>
<div class="ttc" id="anamespacecl_1_1sycl_1_1detail_html_a7f8034599550834b7f1d9c514f8a088a"><div class="ttname"><a href="namespacecl_1_1sycl_1_1detail.html#a7f8034599550834b7f1d9c514f8a088a">cl::sycl::detail::write</a></div><div class="ttdeci">void write(GlobalBufAccessorT &amp;GlobalFlushBuf, size_t FlushBufferSize, unsigned WIOffset, const char *Str, unsigned Len, unsigned Padding=0)</div><div class="ttdef"><b>Definition:</b> <a href="stream_8hpp_source.html#l00110">stream.hpp:110</a></div></div>
<div class="ttc" id="agroup__sycl__esimd__core_html_gga80f907c01fb30c8981d58c5619d18c06a9d5ed678fe57bcca610140957afab571"><div class="ttname"><a href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a9d5ed678fe57bcca610140957afab571">cl::__ESIMD_NS::rgba_channel::B</a></div><div class="ttdeci">@ B</div></div>
<div class="ttc" id="agroup__sycl__esimd__core_html_gga80f907c01fb30c8981d58c5619d18c06a7fc56270e7a70fa81a5935b72eacbe29"><div class="ttname"><a href="group__sycl__esimd__core.html#gga80f907c01fb30c8981d58c5619d18c06a7fc56270e7a70fa81a5935b72eacbe29">cl::__ESIMD_NS::rgba_channel::A</a></div><div class="ttdeci">@ A</div></div>
<div class="ttc" id="aclasscl_1_1sycl_1_1queue_html_a74cfc07a129881fbb0782cfc8092c150"><div class="ttname"><a href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">cl::sycl::queue::submit</a></div><div class="ttdeci">event submit(T CGF _CODELOCPARAM(&amp;CodeLoc))</div><div class="ttdoc">Submits a command group function object to the queue, in order to be scheduled for execution on the d...</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00252">queue.hpp:252</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
