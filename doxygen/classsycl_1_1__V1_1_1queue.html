<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: sycl::_V1::queue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsycl_1_1__V1_1_1queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsycl_1_1__V1_1_1queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sycl::_V1::queue Class Reference<div class="ingroups"><a class="el" href="group__sycl__api.html">DPC++ User API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a single SYCL queue which schedules kernels on a SYCL device.  
 <a href="classsycl_1_1__V1_1_1queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="queue_8hpp_source.html">sycl/queue.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sycl::_V1::queue:</div>
<div class="dyncontent">
<div class="center"><img src="classsycl_1_1__V1_1_1queue__inherit__graph.png" border="0" usemap="#asycl_1_1__V1_1_1queue_inherit__map" alt="Inheritance graph"/></div>
<map name="asycl_1_1__V1_1_1queue_inherit__map" id="asycl_1_1__V1_1_1queue_inherit__map">
<area shape="rect" title="Encapsulates a single SYCL queue which schedules kernels on a SYCL device." alt="" coords="39,95,167,121"/>
<area shape="rect" href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html" title=" " alt="" coords="5,5,200,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for sycl::_V1::queue:</div>
<div class="dyncontent">
<div class="center"><img src="classsycl_1_1__V1_1_1queue__coll__graph.png" border="0" usemap="#asycl_1_1__V1_1_1queue_coll__map" alt="Collaboration graph"/></div>
<map name="asycl_1_1__V1_1_1queue_coll__map" id="asycl_1_1__V1_1_1queue_coll__map">
<area shape="rect" title="Encapsulates a single SYCL queue which schedules kernels on a SYCL device." alt="" coords="903,101,1031,127"/>
<area shape="rect" href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html" title=" " alt="" coords="557,5,752,47"/>
<area shape="rect" title=" " alt="" coords="566,71,743,98"/>
<area shape="rect" title=" " alt="" coords="568,123,741,164"/>
<area shape="rect" href="classsycl_1_1__V1_1_1property__list.html" title="Objects of the property_list class are containers for the SYCL properties." alt="" coords="569,189,740,215"/>
<area shape="rect" href="classsycl_1_1__V1_1_1detail_1_1PropertyListBase.html" title=" " alt="" coords="375,181,508,223"/>
<area shape="rect" title=" " alt="" coords="13,144,205,185"/>
<area shape="rect" title=" " alt="" coords="5,210,213,266"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18897f997ae94d60bb1f3b3b51dfd6d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:a18897f997ae94d60bb1f3b3b51dfd6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device returned by an instance of default_selector.  <a href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">More...</a><br /></td></tr>
<tr class="separator:a18897f997ae94d60bb1f3b3b51dfd6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6acd31be0101cd9d94fcd8292d2d1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8f6acd31be0101cd9d94fcd8292d2d1d">queue</a> (const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:a8f6acd31be0101cd9d94fcd8292d2d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler using the device returned by an instance of default_selector.  <a href="classsycl_1_1__V1_1_1queue.html#a8f6acd31be0101cd9d94fcd8292d2d1d">More...</a><br /></td></tr>
<tr class="separator:a8f6acd31be0101cd9d94fcd8292d2d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ffa2b9e123b2192fcbc78afc2ff1a8"><td class="memTemplParams" colspan="2">template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </td></tr>
<tr class="memitem:aa0ffa2b9e123b2192fcbc78afc2ff1a8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa0ffa2b9e123b2192fcbc78afc2ff1a8">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;deviceSelector, const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:aa0ffa2b9e123b2192fcbc78afc2ff1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device identified by the device selector provided.  <a href="classsycl_1_1__V1_1_1queue.html#aa0ffa2b9e123b2192fcbc78afc2ff1a8">More...</a><br /></td></tr>
<tr class="separator:aa0ffa2b9e123b2192fcbc78afc2ff1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82debe5bf907e27ec58db65867aa52a6"><td class="memTemplParams" colspan="2">template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </td></tr>
<tr class="memitem:a82debe5bf907e27ec58db65867aa52a6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a82debe5bf907e27ec58db65867aa52a6">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;deviceSelector, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:a82debe5bf907e27ec58db65867aa52a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device identified by the device selector provided.  <a href="classsycl_1_1__V1_1_1queue.html#a82debe5bf907e27ec58db65867aa52a6">More...</a><br /></td></tr>
<tr class="separator:a82debe5bf907e27ec58db65867aa52a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae031075a0ebb42bab98f2728d67901"><td class="memTemplParams" colspan="2">template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </td></tr>
<tr class="memitem:a5ae031075a0ebb42bab98f2728d67901"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5ae031075a0ebb42bab98f2728d67901">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;syclContext, const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;deviceSelector, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a5ae031075a0ebb42bab98f2728d67901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device identified by the device selector provided.  <a href="classsycl_1_1__V1_1_1queue.html#a5ae031075a0ebb42bab98f2728d67901">More...</a><br /></td></tr>
<tr class="separator:a5ae031075a0ebb42bab98f2728d67901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c036e6e630818b65129e2cdd248f1eb"><td class="memTemplParams" colspan="2">template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </td></tr>
<tr class="memitem:a3c036e6e630818b65129e2cdd248f1eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a3c036e6e630818b65129e2cdd248f1eb">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;syclContext, const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;deviceSelector, const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;propList={})</td></tr>
<tr class="memdesc:a3c036e6e630818b65129e2cdd248f1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device identified by the device selector provided.  <a href="classsycl_1_1__V1_1_1queue.html#a3c036e6e630818b65129e2cdd248f1eb">More...</a><br /></td></tr>
<tr class="separator:a3c036e6e630818b65129e2cdd248f1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561de199991e9fa5822ba75e54193726"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a561de199991e9fa5822ba75e54193726">__SYCL2020_DEPRECATED</a> (&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;) queue(const <a class="el" href="classdevice__selector.html">device_selector</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a></td></tr>
<tr class="memdesc:a561de199991e9fa5822ba75e54193726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device returned by the DeviceSelector provided.  <a href="classsycl_1_1__V1_1_1queue.html#a561de199991e9fa5822ba75e54193726">More...</a><br /></td></tr>
<tr class="separator:a561de199991e9fa5822ba75e54193726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa9182b8383d4b1c6eeff4ff70adb1461">__SYCL2020_DEPRECATED</a> (&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;) queue(const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;SyclContext</td></tr>
<tr class="memdesc:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance that is associated with the context provided, using the device returned by the device selector.  <a href="classsycl_1_1__V1_1_1queue.html#aa9182b8383d4b1c6eeff4ff70adb1461">More...</a><br /></td></tr>
<tr class="separator:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa9182b8383d4b1c6eeff4ff70adb1461">__SYCL2020_DEPRECATED</a> (&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;) queue(const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;SyclContext</td></tr>
<tr class="memdesc:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler that is associated with the context provided, using the device returned by the device selector.  <a href="classsycl_1_1__V1_1_1queue.html#aa9182b8383d4b1c6eeff4ff70adb1461">More...</a><br /></td></tr>
<tr class="separator:aa9182b8383d4b1c6eeff4ff70adb1461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ec8c3092ded56a7de635cfcb4ef2ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a81ec8c3092ded56a7de635cfcb4ef2ae">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:a81ec8c3092ded56a7de635cfcb4ef2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue associated with the given context, device and optional properties list.  <a href="classsycl_1_1__V1_1_1queue.html#a81ec8c3092ded56a7de635cfcb4ef2ae">More...</a><br /></td></tr>
<tr class="separator:a81ec8c3092ded56a7de635cfcb4ef2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73764bd452fd935b9be39b1c47dcd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aac73764bd452fd935b9be39b1c47dcd7">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;<a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>={})</td></tr>
<tr class="memdesc:aac73764bd452fd935b9be39b1c47dcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue associated with the given context, device, asynchronous exception handler and optional properties list.  <a href="classsycl_1_1__V1_1_1queue.html#aac73764bd452fd935b9be39b1c47dcd7">More...</a><br /></td></tr>
<tr class="separator:aac73764bd452fd935b9be39b1c47dcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75222e49912fa7a24f14237aa0b94ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab75222e49912fa7a24f14237aa0b94ae">queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;RHS)=default</td></tr>
<tr class="memdesc:ab75222e49912fa7a24f14237aa0b94ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue with an optional async_handler from an OpenCL cl_command_queue.  <a href="classsycl_1_1__V1_1_1queue.html#ab75222e49912fa7a24f14237aa0b94ae">More...</a><br /></td></tr>
<tr class="separator:ab75222e49912fa7a24f14237aa0b94ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541318823677b4ddb7892e06ef08a3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6541318823677b4ddb7892e06ef08a3e">queue</a> (<a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&amp;RHS)=default</td></tr>
<tr class="separator:a6541318823677b4ddb7892e06ef08a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231c5ccd03c9cc98aad14ce6aba579a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a231c5ccd03c9cc98aad14ce6aba579a9">operator=</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;RHS)=default</td></tr>
<tr class="separator:a231c5ccd03c9cc98aad14ce6aba579a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f01aad4b97f245499297c5dca95fc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9f01aad4b97f245499297c5dca95fc54">operator=</a> (<a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&amp;RHS)=default</td></tr>
<tr class="separator:a9f01aad4b97f245499297c5dca95fc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f8d57bb9a8cfb618bee5c41de86675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab5f8d57bb9a8cfb618bee5c41de86675">operator==</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;RHS) const</td></tr>
<tr class="separator:ab5f8d57bb9a8cfb618bee5c41de86675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec588401fb7ece240784b8ca75df65c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#afec588401fb7ece240784b8ca75df65c">operator!=</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;RHS) const</td></tr>
<tr class="separator:afec588401fb7ece240784b8ca75df65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dd483e6986fbf840bd532ac017445a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1context.html">context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab3dd483e6986fbf840bd532ac017445a">get_context</a> () const</td></tr>
<tr class="separator:ab3dd483e6986fbf840bd532ac017445a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786ac57f419cca2eba3a069990846188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1device.html">device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a786ac57f419cca2eba3a069990846188">get_device</a> () const</td></tr>
<tr class="separator:a786ac57f419cca2eba3a069990846188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e95b9bd7693e1031cd425dd71f8f9"><td class="memItemLeft" align="right" valign="top">ext::oneapi::experimental::queue_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aae0e95b9bd7693e1031cd425dd71f8f9">ext_oneapi_get_state</a> () const</td></tr>
<tr class="separator:aae0e95b9bd7693e1031cd425dd71f8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c81b32f261f867313a4890b91ff4ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512a8dce88101886d945bc56a5c0cd3a473f">ext::oneapi::experimental::graph_state::modifiable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ad1c81b32f261f867313a4890b91ff4ca">ext_oneapi_get_graph</a> () const</td></tr>
<tr class="separator:ad1c81b32f261f867313a4890b91ff4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847f1817fc43e1a40622d127837cbd4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a847f1817fc43e1a40622d127837cbd4d">__SYCL2020_DEPRECATED</a> (&quot;is_host() is deprecated as the host <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> is no longer supported.&quot;) bool is_host() const</td></tr>
<tr class="separator:a847f1817fc43e1a40622d127837cbd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb786d28feb3f1254823d57493cf7b39"><td class="memTemplParams" colspan="2">template&lt;typename Param &gt; </td></tr>
<tr class="memitem:abb786d28feb3f1254823d57493cf7b39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsycl_1_1__V1_1_1detail_1_1is__queue__info__desc.html">detail::is_queue_info_desc</a>&lt; Param &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#abb786d28feb3f1254823d57493cf7b39">get_info</a> () const</td></tr>
<tr class="memdesc:abb786d28feb3f1254823d57493cf7b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries SYCL queue for information.  <a href="classsycl_1_1__V1_1_1queue.html#abb786d28feb3f1254823d57493cf7b39">More...</a><br /></td></tr>
<tr class="separator:abb786d28feb3f1254823d57493cf7b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7cc50fcd82224e540bbfc531532f0a"><td class="memTemplParams" colspan="2">template&lt;typename Param &gt; </td></tr>
<tr class="memitem:abc7cc50fcd82224e540bbfc531532f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsycl_1_1__V1_1_1detail_1_1is__backend__info__desc.html">detail::is_backend_info_desc</a>&lt; Param &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#abc7cc50fcd82224e540bbfc531532f0a">get_backend_info</a> () const</td></tr>
<tr class="memdesc:abc7cc50fcd82224e540bbfc531532f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries SYCL queue for SYCL backend-specific information.  <a href="classsycl_1_1__V1_1_1queue.html#abc7cc50fcd82224e540bbfc531532f0a">More...</a><br /></td></tr>
<tr class="separator:abc7cc50fcd82224e540bbfc531532f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd6bd99dbc2249251e952a939ae97b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedd6bd99dbc2249251e952a939ae97b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_r_v&lt; void, T, <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp; &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aedd6bd99dbc2249251e952a939ae97b8">submit</a> (T CGF, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aedd6bd99dbc2249251e952a939ae97b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command group function object to the queue, in order to be scheduled for execution on the device.  <a href="classsycl_1_1__V1_1_1queue.html#aedd6bd99dbc2249251e952a939ae97b8">More...</a><br /></td></tr>
<tr class="separator:aedd6bd99dbc2249251e952a939ae97b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359a1d5501184282c29ab476326c051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af359a1d5501184282c29ab476326c051"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_r_v&lt; void, T, <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp; &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af359a1d5501184282c29ab476326c051">submit</a> (T CGF, <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;SecondaryQueue, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:af359a1d5501184282c29ab476326c051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command group function object to the queue, in order to be scheduled for execution on the device.  <a href="classsycl_1_1__V1_1_1queue.html#af359a1d5501184282c29ab476326c051">More...</a><br /></td></tr>
<tr class="separator:af359a1d5501184282c29ab476326c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac39c4798d74dfe144d0e15855136ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aac39c4798d74dfe144d0e15855136ebc">ext_oneapi_submit_barrier</a> (const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aac39c4798d74dfe144d0e15855136ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classsycl_1_1__V1_1_1queue.html#aac39c4798d74dfe144d0e15855136ebc">More...</a><br /></td></tr>
<tr class="separator:aac39c4798d74dfe144d0e15855136ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7a0dc5dd031073e00afd7b5e020761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9c7a0dc5dd031073e00afd7b5e020761">ext_oneapi_submit_barrier</a> (const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;WaitList, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a9c7a0dc5dd031073e00afd7b5e020761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classsycl_1_1__V1_1_1queue.html#a9c7a0dc5dd031073e00afd7b5e020761">More...</a><br /></td></tr>
<tr class="separator:a9c7a0dc5dd031073e00afd7b5e020761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad311b7ee1ea5b4938724c6a87acdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a0ad311b7ee1ea5b4938724c6a87acdb5">wait</a> (const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a0ad311b7ee1ea5b4938724c6a87acdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking wait for the completion of all enqueued tasks in the queue.  <a href="classsycl_1_1__V1_1_1queue.html#a0ad311b7ee1ea5b4938724c6a87acdb5">More...</a><br /></td></tr>
<tr class="separator:a0ad311b7ee1ea5b4938724c6a87acdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5c2435ff47951d394782fb8f23abf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#abf5c2435ff47951d394782fb8f23abf9">wait_and_throw</a> (const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:abf5c2435ff47951d394782fb8f23abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking wait for the completion of all enqueued tasks in the queue.  <a href="classsycl_1_1__V1_1_1queue.html#abf5c2435ff47951d394782fb8f23abf9">More...</a><br /></td></tr>
<tr class="separator:abf5c2435ff47951d394782fb8f23abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4adae7339424f51968212334daa4b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af4adae7339424f51968212334daa4b85">wait_proxy</a> (const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc)</td></tr>
<tr class="memdesc:af4adae7339424f51968212334daa4b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy method for wait to forward the code location information to the implementation.  <a href="classsycl_1_1__V1_1_1queue.html#af4adae7339424f51968212334daa4b85">More...</a><br /></td></tr>
<tr class="separator:af4adae7339424f51968212334daa4b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc81c99ac1e04008401a5cf8781a11b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8fc81c99ac1e04008401a5cf8781a11b">wait_and_throw_proxy</a> (const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc)</td></tr>
<tr class="memdesc:a8fc81c99ac1e04008401a5cf8781a11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy method for wait_and_throw to forward the code location information to the implementation.  <a href="classsycl_1_1__V1_1_1queue.html#a8fc81c99ac1e04008401a5cf8781a11b">More...</a><br /></td></tr>
<tr class="separator:a8fc81c99ac1e04008401a5cf8781a11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcde34e624f1c86d4d6f5e7a1506218e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#afcde34e624f1c86d4d6f5e7a1506218e">throw_asynchronous</a> ()</td></tr>
<tr class="memdesc:afcde34e624f1c86d4d6f5e7a1506218e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any asynchronous errors have been produced by the queue and if so reports them to the async_handler passed on the queue construction.  <a href="classsycl_1_1__V1_1_1queue.html#afcde34e624f1c86d4d6f5e7a1506218e">More...</a><br /></td></tr>
<tr class="separator:afcde34e624f1c86d4d6f5e7a1506218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab576e60a52714370580b37ca9d6b43f4"><td class="memTemplParams" colspan="2">template&lt;typename PropertyT &gt; </td></tr>
<tr class="memitem:ab576e60a52714370580b37ca9d6b43f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab576e60a52714370580b37ca9d6b43f4">has_property</a> () const <a class="el" href="std_2experimental_2simd_8hpp.html#a431625e0f1f8e5ea857a516afacf47e7">noexcept</a></td></tr>
<tr class="separator:ab576e60a52714370580b37ca9d6b43f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff9caedf4b49a994478ddcfec1e81e0"><td class="memTemplParams" colspan="2">template&lt;typename PropertyT &gt; </td></tr>
<tr class="memitem:aeff9caedf4b49a994478ddcfec1e81e0"><td class="memTemplItemLeft" align="right" valign="top">PropertyT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aeff9caedf4b49a994478ddcfec1e81e0">get_property</a> () const</td></tr>
<tr class="separator:aeff9caedf4b49a994478ddcfec1e81e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184c13a29e222fd9db55ddfa0757cf26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a184c13a29e222fd9db55ddfa0757cf26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a184c13a29e222fd9db55ddfa0757cf26">fill</a> (void *Ptr, const T &amp;Pattern, size_t Count, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a184c13a29e222fd9db55ddfa0757cf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classsycl_1_1__V1_1_1queue.html#a184c13a29e222fd9db55ddfa0757cf26">More...</a><br /></td></tr>
<tr class="separator:a184c13a29e222fd9db55ddfa0757cf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2277899aae7084c33b016eb53c6d19ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2277899aae7084c33b016eb53c6d19ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a2277899aae7084c33b016eb53c6d19ce">fill</a> (void *Ptr, const T &amp;Pattern, size_t Count, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a2277899aae7084c33b016eb53c6d19ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classsycl_1_1__V1_1_1queue.html#a2277899aae7084c33b016eb53c6d19ce">More...</a><br /></td></tr>
<tr class="separator:a2277899aae7084c33b016eb53c6d19ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1724ddf75285defdf8e9f15a8bb5b235"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1724ddf75285defdf8e9f15a8bb5b235"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a1724ddf75285defdf8e9f15a8bb5b235">fill</a> (void *Ptr, const T &amp;Pattern, size_t Count, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a1724ddf75285defdf8e9f15a8bb5b235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classsycl_1_1__V1_1_1queue.html#a1724ddf75285defdf8e9f15a8bb5b235">More...</a><br /></td></tr>
<tr class="separator:a1724ddf75285defdf8e9f15a8bb5b235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a466db5791c5059a46afc86ae9eaff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a33a466db5791c5059a46afc86ae9eaff">memset</a> (void *Ptr, int Value, size_t Count, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a33a466db5791c5059a46afc86ae9eaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#a33a466db5791c5059a46afc86ae9eaff">More...</a><br /></td></tr>
<tr class="separator:a33a466db5791c5059a46afc86ae9eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa950860f549487e12f91dacab74a61e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa950860f549487e12f91dacab74a61e0">memset</a> (void *Ptr, int Value, size_t Count, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aa950860f549487e12f91dacab74a61e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#aa950860f549487e12f91dacab74a61e0">More...</a><br /></td></tr>
<tr class="separator:aa950860f549487e12f91dacab74a61e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb0ea45a86c61e592d6e3500c8b2d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#adfb0ea45a86c61e592d6e3500c8b2d22">memset</a> (void *Ptr, int Value, size_t Count, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:adfb0ea45a86c61e592d6e3500c8b2d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#adfb0ea45a86c61e592d6e3500c8b2d22">More...</a><br /></td></tr>
<tr class="separator:adfb0ea45a86c61e592d6e3500c8b2d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123f9d1df9cbb040c4810d7a493bdcee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a123f9d1df9cbb040c4810d7a493bdcee">memcpy</a> (void *Dest, const void *Src, size_t Count, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a123f9d1df9cbb040c4810d7a493bdcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a123f9d1df9cbb040c4810d7a493bdcee">More...</a><br /></td></tr>
<tr class="separator:a123f9d1df9cbb040c4810d7a493bdcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd2d7facb527f42dca44e51c68bbd72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a4cd2d7facb527f42dca44e51c68bbd72">memcpy</a> (void *Dest, const void *Src, size_t Count, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a4cd2d7facb527f42dca44e51c68bbd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a4cd2d7facb527f42dca44e51c68bbd72">More...</a><br /></td></tr>
<tr class="separator:a4cd2d7facb527f42dca44e51c68bbd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeec538d8c73d1eb5f0173e21b76db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a0aeec538d8c73d1eb5f0173e21b76db6">memcpy</a> (void *Dest, const void *Src, size_t Count, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a0aeec538d8c73d1eb5f0173e21b76db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a0aeec538d8c73d1eb5f0173e21b76db6">More...</a><br /></td></tr>
<tr class="separator:a0aeec538d8c73d1eb5f0173e21b76db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcf0c525944e1561a82404dabf5daa9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fcf0c525944e1561a82404dabf5daa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5fcf0c525944e1561a82404dabf5daa9">copy</a> (const T *Src, T *Dest, size_t Count, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a5fcf0c525944e1561a82404dabf5daa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a5fcf0c525944e1561a82404dabf5daa9">More...</a><br /></td></tr>
<tr class="separator:a5fcf0c525944e1561a82404dabf5daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dba86a843c95fe2f3fc634a22c3bcfa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6dba86a843c95fe2f3fc634a22c3bcfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6dba86a843c95fe2f3fc634a22c3bcfa">copy</a> (const T *Src, T *Dest, size_t Count, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a6dba86a843c95fe2f3fc634a22c3bcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a6dba86a843c95fe2f3fc634a22c3bcfa">More...</a><br /></td></tr>
<tr class="separator:a6dba86a843c95fe2f3fc634a22c3bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395a1b7e7e6c4b43d24089304a2628b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a395a1b7e7e6c4b43d24089304a2628b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a395a1b7e7e6c4b43d24089304a2628b7">copy</a> (const T *Src, T *Dest, size_t Count, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a395a1b7e7e6c4b43d24089304a2628b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a395a1b7e7e6c4b43d24089304a2628b7">More...</a><br /></td></tr>
<tr class="separator:a395a1b7e7e6c4b43d24089304a2628b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc43813da13473a0c47e92c7d334dc5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#abc43813da13473a0c47e92c7d334dc5a">mem_advise</a> (const void *Ptr, size_t Length, <a class="el" href="pi_8h.html#a286bf19d79f0e65f8137d269f037798b">pi_mem_advice</a> Advice, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:abc43813da13473a0c47e92c7d334dc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classsycl_1_1__V1_1_1queue.html#abc43813da13473a0c47e92c7d334dc5a">More...</a><br /></td></tr>
<tr class="separator:abc43813da13473a0c47e92c7d334dc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f1da83fc43ae4f218317e81848422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d7f1da83fc43ae4f218317e81848422">mem_advise</a> (const void *Ptr, size_t Length, int Advice, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a6d7f1da83fc43ae4f218317e81848422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classsycl_1_1__V1_1_1queue.html#a6d7f1da83fc43ae4f218317e81848422">More...</a><br /></td></tr>
<tr class="separator:a6d7f1da83fc43ae4f218317e81848422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc69b914e25d8e47f87cbd7ff7c7d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aedc69b914e25d8e47f87cbd7ff7c7d30">mem_advise</a> (const void *Ptr, size_t Length, int Advice, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aedc69b914e25d8e47f87cbd7ff7c7d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classsycl_1_1__V1_1_1queue.html#aedc69b914e25d8e47f87cbd7ff7c7d30">More...</a><br /></td></tr>
<tr class="separator:aedc69b914e25d8e47f87cbd7ff7c7d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4860bb2cb60c2dcda5c849950d78b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ad4860bb2cb60c2dcda5c849950d78b89">mem_advise</a> (const void *Ptr, size_t Length, int Advice, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ad4860bb2cb60c2dcda5c849950d78b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classsycl_1_1__V1_1_1queue.html#ad4860bb2cb60c2dcda5c849950d78b89">More...</a><br /></td></tr>
<tr class="separator:ad4860bb2cb60c2dcda5c849950d78b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61f7ff23542bdca51cec9afcf60fa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ae61f7ff23542bdca51cec9afcf60fa5e">prefetch</a> (const void *Ptr, size_t Count, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ae61f7ff23542bdca51cec9afcf60fa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classsycl_1_1__V1_1_1queue.html#ae61f7ff23542bdca51cec9afcf60fa5e">More...</a><br /></td></tr>
<tr class="separator:ae61f7ff23542bdca51cec9afcf60fa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6361603ff952beefe8b1c52a6633e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7c6361603ff952beefe8b1c52a6633e4">prefetch</a> (const void *Ptr, size_t Count, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a7c6361603ff952beefe8b1c52a6633e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classsycl_1_1__V1_1_1queue.html#a7c6361603ff952beefe8b1c52a6633e4">More...</a><br /></td></tr>
<tr class="separator:a7c6361603ff952beefe8b1c52a6633e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c7953436cddfcd284af7d99a22ff7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a23c7953436cddfcd284af7d99a22ff7f">prefetch</a> (const void *Ptr, size_t Count, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a23c7953436cddfcd284af7d99a22ff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classsycl_1_1__V1_1_1queue.html#a23c7953436cddfcd284af7d99a22ff7f">More...</a><br /></td></tr>
<tr class="separator:a23c7953436cddfcd284af7d99a22ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a37e0203758f98a3255a98f67d2b40"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:a22a37e0203758f98a3255a98f67d2b40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a22a37e0203758f98a3255a98f67d2b40">ext_oneapi_memcpy2d</a> (void *Dest, size_t DestPitch, const void *Src, size_t SrcPitch, size_t Width, size_t Height, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a22a37e0203758f98a3255a98f67d2b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a22a37e0203758f98a3255a98f67d2b40">More...</a><br /></td></tr>
<tr class="separator:a22a37e0203758f98a3255a98f67d2b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe55a7497c4c6d7d613ced41ea83fab"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:aabe55a7497c4c6d7d613ced41ea83fab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aabe55a7497c4c6d7d613ced41ea83fab">ext_oneapi_memcpy2d</a> (void *Dest, size_t DestPitch, const void *Src, size_t SrcPitch, size_t Width, size_t Height, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aabe55a7497c4c6d7d613ced41ea83fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#aabe55a7497c4c6d7d613ced41ea83fab">More...</a><br /></td></tr>
<tr class="separator:aabe55a7497c4c6d7d613ced41ea83fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb6cbc9bcd00ad2b9427ea52bf91c3c"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:a3bb6cbc9bcd00ad2b9427ea52bf91c3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a3bb6cbc9bcd00ad2b9427ea52bf91c3c">ext_oneapi_memcpy2d</a> (void *Dest, size_t DestPitch, const void *Src, size_t SrcPitch, size_t Width, size_t Height, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a3bb6cbc9bcd00ad2b9427ea52bf91c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a3bb6cbc9bcd00ad2b9427ea52bf91c3c">More...</a><br /></td></tr>
<tr class="separator:a3bb6cbc9bcd00ad2b9427ea52bf91c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193a410e11512580f8dfee3e3a4f8dbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a193a410e11512580f8dfee3e3a4f8dbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a193a410e11512580f8dfee3e3a4f8dbe">ext_oneapi_copy2d</a> (const T *Src, size_t SrcPitch, T *Dest, size_t DestPitch, size_t Width, size_t Height, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a193a410e11512580f8dfee3e3a4f8dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a193a410e11512580f8dfee3e3a4f8dbe">More...</a><br /></td></tr>
<tr class="separator:a193a410e11512580f8dfee3e3a4f8dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5b0c3f4183efc17dcaedeb6a35bbfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f5b0c3f4183efc17dcaedeb6a35bbfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7f5b0c3f4183efc17dcaedeb6a35bbfb">ext_oneapi_copy2d</a> (const T *Src, size_t SrcPitch, T *Dest, size_t DestPitch, size_t Width, size_t Height, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a7f5b0c3f4183efc17dcaedeb6a35bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a7f5b0c3f4183efc17dcaedeb6a35bbfb">More...</a><br /></td></tr>
<tr class="separator:a7f5b0c3f4183efc17dcaedeb6a35bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb410b9ac38620b54be4c31ea81b76d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb410b9ac38620b54be4c31ea81b76d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#afb410b9ac38620b54be4c31ea81b76d0">ext_oneapi_copy2d</a> (const T *Src, size_t SrcPitch, T *Dest, size_t DestPitch, size_t Width, size_t Height, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:afb410b9ac38620b54be4c31ea81b76d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one 2D memory region to another, both pointed by USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#afb410b9ac38620b54be4c31ea81b76d0">More...</a><br /></td></tr>
<tr class="separator:afb410b9ac38620b54be4c31ea81b76d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1bc4a085d7fecfb83a86aa35874056"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1e1bc4a085d7fecfb83a86aa35874056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a1e1bc4a085d7fecfb83a86aa35874056">ext_oneapi_memset2d</a> (void *Dest, size_t DestPitch, int Value, size_t Width, size_t Height, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a1e1bc4a085d7fecfb83a86aa35874056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#a1e1bc4a085d7fecfb83a86aa35874056">More...</a><br /></td></tr>
<tr class="separator:a1e1bc4a085d7fecfb83a86aa35874056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ddac3b8e052534a1166d9511f25ca"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9f3ddac3b8e052534a1166d9511f25ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9f3ddac3b8e052534a1166d9511f25ca">ext_oneapi_memset2d</a> (void *Dest, size_t DestPitch, int Value, size_t Width, size_t Height, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a9f3ddac3b8e052534a1166d9511f25ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#a9f3ddac3b8e052534a1166d9511f25ca">More...</a><br /></td></tr>
<tr class="separator:a9f3ddac3b8e052534a1166d9511f25ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18c871b8cbd2a39f3432fe65120cae3"><td class="memTemplParams" colspan="2">template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac18c871b8cbd2a39f3432fe65120cae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ac18c871b8cbd2a39f3432fe65120cae3">ext_oneapi_memset2d</a> (void *Dest, size_t DestPitch, int Value, size_t Width, size_t Height, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ac18c871b8cbd2a39f3432fe65120cae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#ac18c871b8cbd2a39f3432fe65120cae3">More...</a><br /></td></tr>
<tr class="separator:ac18c871b8cbd2a39f3432fe65120cae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa731512bfb8c9dff8660964c45cd4ce5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa731512bfb8c9dff8660964c45cd4ce5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa731512bfb8c9dff8660964c45cd4ce5">ext_oneapi_fill2d</a> (void *Dest, size_t DestPitch, const T &amp;Pattern, size_t Width, size_t Height, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aa731512bfb8c9dff8660964c45cd4ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#aa731512bfb8c9dff8660964c45cd4ce5">More...</a><br /></td></tr>
<tr class="separator:aa731512bfb8c9dff8660964c45cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acf6b4dded170813edc6712eca0a7d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1acf6b4dded170813edc6712eca0a7d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a1acf6b4dded170813edc6712eca0a7d1">ext_oneapi_fill2d</a> (void *Dest, size_t DestPitch, const T &amp;Pattern, size_t Width, size_t Height, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a1acf6b4dded170813edc6712eca0a7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#a1acf6b4dded170813edc6712eca0a7d1">More...</a><br /></td></tr>
<tr class="separator:a1acf6b4dded170813edc6712eca0a7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec567ea0aa4f5f6c0080b7b03856d9ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec567ea0aa4f5f6c0080b7b03856d9ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aec567ea0aa4f5f6c0080b7b03856d9ad">ext_oneapi_fill2d</a> (void *Dest, size_t DestPitch, const T &amp;Pattern, size_t Width, size_t Height, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aec567ea0aa4f5f6c0080b7b03856d9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classsycl_1_1__V1_1_1queue.html#aec567ea0aa4f5f6c0080b7b03856d9ad">More...</a><br /></td></tr>
<tr class="separator:aec567ea0aa4f5f6c0080b7b03856d9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7290fedb5358b72af57905654d5034"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:acc7290fedb5358b72af57905654d5034"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#acc7290fedb5358b72af57905654d5034">memcpy</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, const void *Src, size_t NumBytes, size_t Offset, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:acc7290fedb5358b72af57905654d5034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#acc7290fedb5358b72af57905654d5034">More...</a><br /></td></tr>
<tr class="separator:acc7290fedb5358b72af57905654d5034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe131237b0b5f99cf8dfc03dec271c22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:abe131237b0b5f99cf8dfc03dec271c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#abe131237b0b5f99cf8dfc03dec271c22">memcpy</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, const void *Src, size_t NumBytes, size_t Offset, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:abe131237b0b5f99cf8dfc03dec271c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#abe131237b0b5f99cf8dfc03dec271c22">More...</a><br /></td></tr>
<tr class="separator:abe131237b0b5f99cf8dfc03dec271c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b045e5328f9e886b6a712daa5aae7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a58b045e5328f9e886b6a712daa5aae7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a58b045e5328f9e886b6a712daa5aae7e">memcpy</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, const void *Src, size_t NumBytes=sizeof(T), size_t Offset=0, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a58b045e5328f9e886b6a712daa5aae7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#a58b045e5328f9e886b6a712daa5aae7e">More...</a><br /></td></tr>
<tr class="separator:a58b045e5328f9e886b6a712daa5aae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e1a515e22fdf97b564c3692706a30"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:af90e1a515e22fdf97b564c3692706a30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af90e1a515e22fdf97b564c3692706a30">memcpy</a> (void *Dest, const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, size_t NumBytes, size_t Offset, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:af90e1a515e22fdf97b564c3692706a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a device_global to USM memory.  <a href="classsycl_1_1__V1_1_1queue.html#af90e1a515e22fdf97b564c3692706a30">More...</a><br /></td></tr>
<tr class="separator:af90e1a515e22fdf97b564c3692706a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98d18455f2818bd31ba5344e3ec4ccc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:ab98d18455f2818bd31ba5344e3ec4ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab98d18455f2818bd31ba5344e3ec4ccc">memcpy</a> (void *Dest, const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, size_t NumBytes, size_t Offset, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ab98d18455f2818bd31ba5344e3ec4ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a device_global to USM memory.  <a href="classsycl_1_1__V1_1_1queue.html#ab98d18455f2818bd31ba5344e3ec4ccc">More...</a><br /></td></tr>
<tr class="separator:ab98d18455f2818bd31ba5344e3ec4ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b05ef31f83050172245de0d3c8b2482"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a8b05ef31f83050172245de0d3c8b2482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8b05ef31f83050172245de0d3c8b2482">memcpy</a> (void *Dest, const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, size_t NumBytes=sizeof(T), size_t Offset=0, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a8b05ef31f83050172245de0d3c8b2482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a device_global to USM memory.  <a href="classsycl_1_1__V1_1_1queue.html#a8b05ef31f83050172245de0d3c8b2482">More...</a><br /></td></tr>
<tr class="separator:a8b05ef31f83050172245de0d3c8b2482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f5c94a96fb7999e66f1e976102bae6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a08f5c94a96fb7999e66f1e976102bae6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a08f5c94a96fb7999e66f1e976102bae6">copy</a> (const std::remove_all_extents_t&lt; T &gt; *Src, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, size_t Count, size_t StartIndex, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a08f5c94a96fb7999e66f1e976102bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#a08f5c94a96fb7999e66f1e976102bae6">More...</a><br /></td></tr>
<tr class="separator:a08f5c94a96fb7999e66f1e976102bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba2e0a16101c222dc5b9e6f4f2c0ae0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:adba2e0a16101c222dc5b9e6f4f2c0ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#adba2e0a16101c222dc5b9e6f4f2c0ae0">copy</a> (const std::remove_all_extents_t&lt; T &gt; *Src, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, size_t Count, size_t StartIndex, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:adba2e0a16101c222dc5b9e6f4f2c0ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#adba2e0a16101c222dc5b9e6f4f2c0ae0">More...</a><br /></td></tr>
<tr class="separator:adba2e0a16101c222dc5b9e6f4f2c0ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf6a9c6458bf01a3b6185d13021411a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:acbf6a9c6458bf01a3b6185d13021411a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#acbf6a9c6458bf01a3b6185d13021411a">copy</a> (const std::remove_all_extents_t&lt; T &gt; *Src, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Dest, size_t Count=sizeof(T)/sizeof(std::remove_all_extents_t&lt; T &gt;), size_t StartIndex=0, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:acbf6a9c6458bf01a3b6185d13021411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global.  <a href="classsycl_1_1__V1_1_1queue.html#acbf6a9c6458bf01a3b6185d13021411a">More...</a><br /></td></tr>
<tr class="separator:acbf6a9c6458bf01a3b6185d13021411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c88131dc7aa9560bfc098b4755ac470"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a8c88131dc7aa9560bfc098b4755ac470"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8c88131dc7aa9560bfc098b4755ac470">copy</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, std::remove_all_extents_t&lt; T &gt; *Dest, size_t Count, size_t StartIndex, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a8c88131dc7aa9560bfc098b4755ac470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region.  <a href="classsycl_1_1__V1_1_1queue.html#a8c88131dc7aa9560bfc098b4755ac470">More...</a><br /></td></tr>
<tr class="separator:a8c88131dc7aa9560bfc098b4755ac470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee79952847e991b5ed25a6446a3810d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:aee79952847e991b5ed25a6446a3810d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aee79952847e991b5ed25a6446a3810d8">copy</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, std::remove_all_extents_t&lt; T &gt; *Dest, size_t Count, size_t StartIndex, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aee79952847e991b5ed25a6446a3810d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region.  <a href="classsycl_1_1__V1_1_1queue.html#aee79952847e991b5ed25a6446a3810d8">More...</a><br /></td></tr>
<tr class="separator:aee79952847e991b5ed25a6446a3810d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5a4ee9b531cf1c4f88b2fe5580eb97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PropertyListT &gt; </td></tr>
<tr class="memitem:a7c5a4ee9b531cf1c4f88b2fe5580eb97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7c5a4ee9b531cf1c4f88b2fe5580eb97">copy</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;Src, std::remove_all_extents_t&lt; T &gt; *Dest, size_t Count=sizeof(T)/sizeof(std::remove_all_extents_t&lt; T &gt;), size_t StartIndex=0, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a7c5a4ee9b531cf1c4f88b2fe5580eb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region.  <a href="classsycl_1_1__V1_1_1queue.html#a7c5a4ee9b531cf1c4f88b2fe5580eb97">More...</a><br /></td></tr>
<tr class="separator:a7c5a4ee9b531cf1c4f88b2fe5580eb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac9dc5d39dcf9f2ac4064858854a3ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aaac9dc5d39dcf9f2ac4064858854a3ff">ext_oneapi_copy</a> (void *Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aaac9dc5d39dcf9f2ac4064858854a3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper.  <a href="classsycl_1_1__V1_1_1queue.html#aaac9dc5d39dcf9f2ac4064858854a3ff">More...</a><br /></td></tr>
<tr class="separator:aaac9dc5d39dcf9f2ac4064858854a3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c51afd6f7a4ef659fbfb77e2f2b8d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af5c51afd6f7a4ef659fbfb77e2f2b8d7">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcExtent, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:af5c51afd6f7a4ef659fbfb77e2f2b8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle.  <a href="classsycl_1_1__V1_1_1queue.html#af5c51afd6f7a4ef659fbfb77e2f2b8d7">More...</a><br /></td></tr>
<tr class="separator:af5c51afd6f7a4ef659fbfb77e2f2b8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfa24a598d4c7ac734e5b3230695cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a73cfa24a598d4c7ac734e5b3230695cd">ext_oneapi_copy</a> (void *Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a73cfa24a598d4c7ac734e5b3230695cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper.  <a href="classsycl_1_1__V1_1_1queue.html#a73cfa24a598d4c7ac734e5b3230695cd">More...</a><br /></td></tr>
<tr class="separator:a73cfa24a598d4c7ac734e5b3230695cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ba049b237364a53b5cfbd9da022497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a84ba049b237364a53b5cfbd9da022497">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcExtent, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a84ba049b237364a53b5cfbd9da022497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle.  <a href="classsycl_1_1__V1_1_1queue.html#a84ba049b237364a53b5cfbd9da022497">More...</a><br /></td></tr>
<tr class="separator:a84ba049b237364a53b5cfbd9da022497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c78eacb09dc1bad7a85d14727eef2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a62c78eacb09dc1bad7a85d14727eef2f">ext_oneapi_copy</a> (void *Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a62c78eacb09dc1bad7a85d14727eef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper.  <a href="classsycl_1_1__V1_1_1queue.html#a62c78eacb09dc1bad7a85d14727eef2f">More...</a><br /></td></tr>
<tr class="separator:a62c78eacb09dc1bad7a85d14727eef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9581b3cd995357eb313a846937cda6cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9581b3cd995357eb313a846937cda6cf">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcExtent, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DestImgDesc, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a9581b3cd995357eb313a846937cda6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle.  <a href="classsycl_1_1__V1_1_1queue.html#a9581b3cd995357eb313a846937cda6cf">More...</a><br /></td></tr>
<tr class="separator:a9581b3cd995357eb313a846937cda6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ebda1916bc1edb98489d648a388c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ae61ebda1916bc1edb98489d648a388c4">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ae61ebda1916bc1edb98489d648a388c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#ae61ebda1916bc1edb98489d648a388c4">More...</a><br /></td></tr>
<tr class="separator:ae61ebda1916bc1edb98489d648a388c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489955f80eaf194fa3ba52804b14cacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a489955f80eaf194fa3ba52804b14cacf">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a489955f80eaf194fa3ba52804b14cacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#a489955f80eaf194fa3ba52804b14cacf">More...</a><br /></td></tr>
<tr class="separator:a489955f80eaf194fa3ba52804b14cacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424a805a9553200af351c415c2f5d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a4424a805a9553200af351c415c2f5d07">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a4424a805a9553200af351c415c2f5d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#a4424a805a9553200af351c415c2f5d07">More...</a><br /></td></tr>
<tr class="separator:a4424a805a9553200af351c415c2f5d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1251b8141eef61e08bdb09d4cc78f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7d1251b8141eef61e08bdb09d4cc78f8">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a7d1251b8141eef61e08bdb09d4cc78f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#a7d1251b8141eef61e08bdb09d4cc78f8">More...</a><br /></td></tr>
<tr class="separator:a7d1251b8141eef61e08bdb09d4cc78f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dd98d45ebbb659b261083c49b53276"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a76dd98d45ebbb659b261083c49b53276">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a76dd98d45ebbb659b261083c49b53276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#a76dd98d45ebbb659b261083c49b53276">More...</a><br /></td></tr>
<tr class="separator:a76dd98d45ebbb659b261083c49b53276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7c247220175686a5b2165ee609146d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aec7c247220175686a5b2165ee609146d">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;SrcImgDesc, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aec7c247220175686a5b2165ee609146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer.  <a href="classsycl_1_1__V1_1_1queue.html#aec7c247220175686a5b2165ee609146d">More...</a><br /></td></tr>
<tr class="separator:aec7c247220175686a5b2165ee609146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c1fbfaf67abc18d6a6bafa4a6241b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ac92c1fbfaf67abc18d6a6bafa4a6241b">ext_oneapi_copy</a> (void *Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ac92c1fbfaf67abc18d6a6bafa4a6241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#ac92c1fbfaf67abc18d6a6bafa4a6241b">More...</a><br /></td></tr>
<tr class="separator:ac92c1fbfaf67abc18d6a6bafa4a6241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502aeda137af500af23ad8274558ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a1502aeda137af500af23ad8274558ddb">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; HostExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a1502aeda137af500af23ad8274558ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a1502aeda137af500af23ad8274558ddb">More...</a><br /></td></tr>
<tr class="separator:a1502aeda137af500af23ad8274558ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6dbc69138bba1eb8217f3c1897c217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aeb6dbc69138bba1eb8217f3c1897c217">ext_oneapi_copy</a> (void *Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aeb6dbc69138bba1eb8217f3c1897c217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#aeb6dbc69138bba1eb8217f3c1897c217">More...</a><br /></td></tr>
<tr class="separator:aeb6dbc69138bba1eb8217f3c1897c217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3468bfd43b9c47cbc8fdc18aa539cbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a3468bfd43b9c47cbc8fdc18aa539cbf3">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;ImageDesc, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a3468bfd43b9c47cbc8fdc18aa539cbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles.  <a href="classsycl_1_1__V1_1_1queue.html#a3468bfd43b9c47cbc8fdc18aa539cbf3">More...</a><br /></td></tr>
<tr class="separator:a3468bfd43b9c47cbc8fdc18aa539cbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97445c279690746d8cfebe84ae495ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab97445c279690746d8cfebe84ae495ce">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;ImageDesc, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ab97445c279690746d8cfebe84ae495ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles.  <a href="classsycl_1_1__V1_1_1queue.html#ab97445c279690746d8cfebe84ae495ce">More...</a><br /></td></tr>
<tr class="separator:ab97445c279690746d8cfebe84ae495ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ef6d531e1bebc3273414e692085d29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a36ef6d531e1bebc3273414e692085d29">ext_oneapi_copy</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Src, <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a> Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;ImageDesc, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a36ef6d531e1bebc3273414e692085d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles.  <a href="classsycl_1_1__V1_1_1queue.html#a36ef6d531e1bebc3273414e692085d29">More...</a><br /></td></tr>
<tr class="separator:a36ef6d531e1bebc3273414e692085d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19bf402dea588ef0373b60785aab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a53d19bf402dea588ef0373b60785aab8">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; HostExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a53d19bf402dea588ef0373b60785aab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a53d19bf402dea588ef0373b60785aab8">More...</a><br /></td></tr>
<tr class="separator:a53d19bf402dea588ef0373b60785aab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbe4cd60d7a24aea7817eacadd8f89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9fbe4cd60d7a24aea7817eacadd8f89c">ext_oneapi_copy</a> (void *Src, void *Dest, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a9fbe4cd60d7a24aea7817eacadd8f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a9fbe4cd60d7a24aea7817eacadd8f89c">More...</a><br /></td></tr>
<tr class="separator:a9fbe4cd60d7a24aea7817eacadd8f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc78e457a96e417730f4177222448d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6fc78e457a96e417730f4177222448d9">ext_oneapi_copy</a> (void *Src, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; SrcOffset, void *Dest, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; DestOffset, const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;DeviceImgDesc, size_t DeviceRowPitch, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; HostExtent, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; CopyExtent, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a6fc78e457a96e417730f4177222448d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers.  <a href="classsycl_1_1__V1_1_1queue.html#a6fc78e457a96e417730f4177222448d9">More...</a><br /></td></tr>
<tr class="separator:a6fc78e457a96e417730f4177222448d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc251067111f6708e6447997d0fcb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a65cc251067111f6708e6447997d0fcb8">ext_oneapi_wait_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a65cc251067111f6708e6447997d0fcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue with a non-blocking wait on an external semaphore.  <a href="classsycl_1_1__V1_1_1queue.html#a65cc251067111f6708e6447997d0fcb8">More...</a><br /></td></tr>
<tr class="separator:a65cc251067111f6708e6447997d0fcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7640f69f669cdb014cd22c91a9de2ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7640f69f669cdb014cd22c91a9de2ece">ext_oneapi_wait_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a7640f69f669cdb014cd22c91a9de2ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue with a non-blocking wait on an external semaphore.  <a href="classsycl_1_1__V1_1_1queue.html#a7640f69f669cdb014cd22c91a9de2ece">More...</a><br /></td></tr>
<tr class="separator:a7640f69f669cdb014cd22c91a9de2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bac1f3ba9912ec5da3fb44d81b9efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab2bac1f3ba9912ec5da3fb44d81b9efc">ext_oneapi_wait_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ab2bac1f3ba9912ec5da3fb44d81b9efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue with a non-blocking wait on an external semaphore.  <a href="classsycl_1_1__V1_1_1queue.html#ab2bac1f3ba9912ec5da3fb44d81b9efc">More...</a><br /></td></tr>
<tr class="separator:ab2bac1f3ba9912ec5da3fb44d81b9efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa774aab382e1630a4c24e69056f5940f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa774aab382e1630a4c24e69056f5940f">ext_oneapi_signal_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aa774aab382e1630a4c24e69056f5940f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue to signal the external semaphore once all previous commands have completed execution.  <a href="classsycl_1_1__V1_1_1queue.html#aa774aab382e1630a4c24e69056f5940f">More...</a><br /></td></tr>
<tr class="separator:aa774aab382e1630a4c24e69056f5940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da37618faa4d1184640b294df6dcf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5da37618faa4d1184640b294df6dcf46">ext_oneapi_signal_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a5da37618faa4d1184640b294df6dcf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue to signal the external semaphore once all previous commands have completed execution.  <a href="classsycl_1_1__V1_1_1queue.html#a5da37618faa4d1184640b294df6dcf46">More...</a><br /></td></tr>
<tr class="separator:a5da37618faa4d1184640b294df6dcf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ed14c5d7813385ea827b57f1fd3b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af1ed14c5d7813385ea827b57f1fd3b64">ext_oneapi_signal_external_semaphore</a> (<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a> SemaphoreHandle, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:af1ed14c5d7813385ea827b57f1fd3b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruct the queue to signal the external semaphore once all previous commands have completed execution.  <a href="classsycl_1_1__V1_1_1queue.html#af1ed14c5d7813385ea827b57f1fd3b64">More...</a><br /></td></tr>
<tr class="separator:af1ed14c5d7813385ea827b57f1fd3b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f61a923d009189ef6a47aeb22333fd1"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:a2f61a923d009189ef6a47aeb22333fd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a2f61a923d009189ef6a47aeb22333fd1">single_task</a> (PropertiesT Properties, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a2f61a923d009189ef6a47aeb22333fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#a2f61a923d009189ef6a47aeb22333fd1">More...</a><br /></td></tr>
<tr class="separator:a2f61a923d009189ef6a47aeb22333fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34cd87892dc0da20ad485ddbddc0f6d"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:ab34cd87892dc0da20ad485ddbddc0f6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab34cd87892dc0da20ad485ddbddc0f6d">single_task</a> (<a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ab34cd87892dc0da20ad485ddbddc0f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#ab34cd87892dc0da20ad485ddbddc0f6d">More...</a><br /></td></tr>
<tr class="separator:ab34cd87892dc0da20ad485ddbddc0f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d4c60daebb6910c571a33a1d05bbb4"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:ae9d4c60daebb6910c571a33a1d05bbb4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ae9d4c60daebb6910c571a33a1d05bbb4">single_task</a> (<a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, PropertiesT Properties, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ae9d4c60daebb6910c571a33a1d05bbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#ae9d4c60daebb6910c571a33a1d05bbb4">More...</a><br /></td></tr>
<tr class="separator:ae9d4c60daebb6910c571a33a1d05bbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc4877fccd5d18b1e3c3a98010b97da"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:aabc4877fccd5d18b1e3c3a98010b97da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aabc4877fccd5d18b1e3c3a98010b97da">single_task</a> (<a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aabc4877fccd5d18b1e3c3a98010b97da"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#aabc4877fccd5d18b1e3c3a98010b97da">More...</a><br /></td></tr>
<tr class="separator:aabc4877fccd5d18b1e3c3a98010b97da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbf1a2d03648b5078f889f4cd54e31e"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </td></tr>
<tr class="memitem:a4fbf1a2d03648b5078f889f4cd54e31e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a4fbf1a2d03648b5078f889f4cd54e31e">single_task</a> (const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, PropertiesT Properties, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a4fbf1a2d03648b5078f889f4cd54e31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#a4fbf1a2d03648b5078f889f4cd54e31e">More...</a><br /></td></tr>
<tr class="separator:a4fbf1a2d03648b5078f889f4cd54e31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60ed6cf74ff022c8e0bde7e4b449e5b"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:ac60ed6cf74ff022c8e0bde7e4b449e5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ac60ed6cf74ff022c8e0bde7e4b449e5b">single_task</a> (const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc), const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ac60ed6cf74ff022c8e0bde7e4b449e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classsycl_1_1__V1_1_1queue.html#ac60ed6cf74ff022c8e0bde7e4b449e5b">More...</a><br /></td></tr>
<tr class="separator:ac60ed6cf74ff022c8e0bde7e4b449e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527f98ae3748efad819156017b27a0ac"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a527f98ae3748efad819156017b27a0ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a527f98ae3748efad819156017b27a0ac">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a527f98ae3748efad819156017b27a0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a527f98ae3748efad819156017b27a0ac">More...</a><br /></td></tr>
<tr class="separator:a527f98ae3748efad819156017b27a0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9d2fe4cc216d6541e72e1b283ee400"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a8e9d2fe4cc216d6541e72e1b283ee400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8e9d2fe4cc216d6541e72e1b283ee400">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a8e9d2fe4cc216d6541e72e1b283ee400"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a8e9d2fe4cc216d6541e72e1b283ee400">More...</a><br /></td></tr>
<tr class="separator:a8e9d2fe4cc216d6541e72e1b283ee400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5fbbb1f5bf6cd37e509eb890089111"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a6a5fbbb1f5bf6cd37e509eb890089111"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6a5fbbb1f5bf6cd37e509eb890089111">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a6a5fbbb1f5bf6cd37e509eb890089111"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a6a5fbbb1f5bf6cd37e509eb890089111">More...</a><br /></td></tr>
<tr class="separator:a6a5fbbb1f5bf6cd37e509eb890089111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e21434831efda508a95a1bd733de59"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a60e21434831efda508a95a1bd733de59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a60e21434831efda508a95a1bd733de59">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a60e21434831efda508a95a1bd733de59"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a60e21434831efda508a95a1bd733de59">More...</a><br /></td></tr>
<tr class="separator:a60e21434831efda508a95a1bd733de59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1388baf7ec7886550bdfec5d7246d0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:aec1388baf7ec7886550bdfec5d7246d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aec1388baf7ec7886550bdfec5d7246d0">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:aec1388baf7ec7886550bdfec5d7246d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#aec1388baf7ec7886550bdfec5d7246d0">More...</a><br /></td></tr>
<tr class="separator:aec1388baf7ec7886550bdfec5d7246d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eee60d0adf4ff332a2fe79e2cf178a"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a68eee60d0adf4ff332a2fe79e2cf178a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a68eee60d0adf4ff332a2fe79e2cf178a">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a68eee60d0adf4ff332a2fe79e2cf178a"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a68eee60d0adf4ff332a2fe79e2cf178a">More...</a><br /></td></tr>
<tr class="separator:a68eee60d0adf4ff332a2fe79e2cf178a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5e1a4caaea58f07bffbe067f510867"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a3f5e1a4caaea58f07bffbe067f510867"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a3f5e1a4caaea58f07bffbe067f510867">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt; Range, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a3f5e1a4caaea58f07bffbe067f510867"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a3f5e1a4caaea58f07bffbe067f510867">More...</a><br /></td></tr>
<tr class="separator:a3f5e1a4caaea58f07bffbe067f510867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc006afebe0519d5986526b210dc07c"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:afbc006afebe0519d5986526b210dc07c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#afbc006afebe0519d5986526b210dc07c">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt; Range, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:afbc006afebe0519d5986526b210dc07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#afbc006afebe0519d5986526b210dc07c">More...</a><br /></td></tr>
<tr class="separator:afbc006afebe0519d5986526b210dc07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4216b8e73fef689ccd9a593921238d46"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </td></tr>
<tr class="memitem:a4216b8e73fef689ccd9a593921238d46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a4216b8e73fef689ccd9a593921238d46">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt; Range, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a4216b8e73fef689ccd9a593921238d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classsycl_1_1__V1_1_1queue.html#a4216b8e73fef689ccd9a593921238d46">More...</a><br /></td></tr>
<tr class="separator:a4216b8e73fef689ccd9a593921238d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bc0946b89b41305222e1981fd865dd"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dim&gt; </td></tr>
<tr class="memitem:a57bc0946b89b41305222e1981fd865dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a57bc0946b89b41305222e1981fd865dd">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dim &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dim &gt; WorkItemOffset, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a57bc0946b89b41305222e1981fd865dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classsycl_1_1__V1_1_1queue.html#a57bc0946b89b41305222e1981fd865dd">More...</a><br /></td></tr>
<tr class="separator:a57bc0946b89b41305222e1981fd865dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e06bb63d3816f2f65d7b57a8977d5e"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a05e06bb63d3816f2f65d7b57a8977d5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a05e06bb63d3816f2f65d7b57a8977d5e">parallel_for_impl</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a05e06bb63d3816f2f65d7b57a8977d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classsycl_1_1__V1_1_1queue.html#a05e06bb63d3816f2f65d7b57a8977d5e">More...</a><br /></td></tr>
<tr class="separator:a05e06bb63d3816f2f65d7b57a8977d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dbb4df6cab8c97859f5d129c3f8e03"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:aa6dbb4df6cab8c97859f5d129c3f8e03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa6dbb4df6cab8c97859f5d129c3f8e03">parallel_for_impl</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:aa6dbb4df6cab8c97859f5d129c3f8e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classsycl_1_1__V1_1_1queue.html#aa6dbb4df6cab8c97859f5d129c3f8e03">More...</a><br /></td></tr>
<tr class="separator:aa6dbb4df6cab8c97859f5d129c3f8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf45c68d167868f887019c4cff49357"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a6cf45c68d167868f887019c4cff49357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6cf45c68d167868f887019c4cff49357">parallel_for_impl</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc))</td></tr>
<tr class="memdesc:a6cf45c68d167868f887019c4cff49357"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classsycl_1_1__V1_1_1queue.html#a6cf45c68d167868f887019c4cff49357">More...</a><br /></td></tr>
<tr class="separator:a6cf45c68d167868f887019c4cff49357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07249217a4004ca226b4816243f012"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename PropertiesT , typename... RestT&gt; </td></tr>
<tr class="memitem:afd07249217a4004ca226b4816243f012"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value &amp;&amp;<a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt; PropertiesT &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#afd07249217a4004ca226b4816243f012">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, PropertiesT Properties, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:afd07249217a4004ca226b4816243f012"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classsycl_1_1__V1_1_1queue.html#afd07249217a4004ca226b4816243f012">More...</a><br /></td></tr>
<tr class="separator:afd07249217a4004ca226b4816243f012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b75add0622e612bfcec703c5351b3e"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </td></tr>
<tr class="memitem:ad7b75add0622e612bfcec703c5351b3e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ad7b75add0622e612bfcec703c5351b3e">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:ad7b75add0622e612bfcec703c5351b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classsycl_1_1__V1_1_1queue.html#ad7b75add0622e612bfcec703c5351b3e">More...</a><br /></td></tr>
<tr class="separator:ad7b75add0622e612bfcec703c5351b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c70f088df529c5a122977ca559f13c1"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </td></tr>
<tr class="memitem:a9c70f088df529c5a122977ca559f13c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9c70f088df529c5a122977ca559f13c1">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a9c70f088df529c5a122977ca559f13c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classsycl_1_1__V1_1_1queue.html#a9c70f088df529c5a122977ca559f13c1">More...</a><br /></td></tr>
<tr class="separator:a9c70f088df529c5a122977ca559f13c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a863f9a6ff8fcbeb49ca49245650d3"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </td></tr>
<tr class="memitem:a92a863f9a6ff8fcbeb49ca49245650d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a92a863f9a6ff8fcbeb49ca49245650d3">parallel_for</a> (<a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, RestT &amp;&amp;...Rest)</td></tr>
<tr class="memdesc:a92a863f9a6ff8fcbeb49ca49245650d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classsycl_1_1__V1_1_1queue.html#a92a863f9a6ff8fcbeb49ca49245650d3">More...</a><br /></td></tr>
<tr class="separator:a92a863f9a6ff8fcbeb49ca49245650d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a80dcf371f03d77f2a3ed83d1d062"><td class="memTemplParams" colspan="2">template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsPlaceholder, typename DestT &gt; </td></tr>
<tr class="memitem:ae57a80dcf371f03d77f2a3ed83d1d062"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ae57a80dcf371f03d77f2a3ed83d1d062">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Src, std::shared_ptr&lt; DestT &gt; Dest, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ae57a80dcf371f03d77f2a3ed83d1d062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory region pointed to by a placeholder accessor to another memory region pointed to by a shared_ptr.  <a href="classsycl_1_1__V1_1_1queue.html#ae57a80dcf371f03d77f2a3ed83d1d062">More...</a><br /></td></tr>
<tr class="separator:ae57a80dcf371f03d77f2a3ed83d1d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5976f5305fac8e20afe4a52f6cee601d"><td class="memTemplParams" colspan="2">template&lt;typename SrcT , typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:a5976f5305fac8e20afe4a52f6cee601d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5976f5305fac8e20afe4a52f6cee601d">copy</a> (std::shared_ptr&lt; SrcT &gt; Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Dest, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a5976f5305fac8e20afe4a52f6cee601d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory region pointed to by a shared_ptr to another memory region pointed to by a placeholder accessor.  <a href="classsycl_1_1__V1_1_1queue.html#a5976f5305fac8e20afe4a52f6cee601d">More...</a><br /></td></tr>
<tr class="separator:a5976f5305fac8e20afe4a52f6cee601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4ea48ef75850a846a2be4cbbd9f6e"><td class="memTemplParams" colspan="2">template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsPlaceholder, typename DestT &gt; </td></tr>
<tr class="memitem:a06e4ea48ef75850a846a2be4cbbd9f6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a06e4ea48ef75850a846a2be4cbbd9f6e">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Src, DestT *Dest, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a06e4ea48ef75850a846a2be4cbbd9f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory region pointed to by a placeholder accessor to another memory region pointed to by a raw pointer.  <a href="classsycl_1_1__V1_1_1queue.html#a06e4ea48ef75850a846a2be4cbbd9f6e">More...</a><br /></td></tr>
<tr class="separator:a06e4ea48ef75850a846a2be4cbbd9f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5a34799910469730cd7e7ac07c04df"><td class="memTemplParams" colspan="2">template&lt;typename SrcT , typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:ade5a34799910469730cd7e7ac07c04df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ade5a34799910469730cd7e7ac07c04df">copy</a> (const SrcT *Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Dest, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ade5a34799910469730cd7e7ac07c04df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a memory region pointed to by a raw pointer to another memory region pointed to by a placeholder accessor.  <a href="classsycl_1_1__V1_1_1queue.html#ade5a34799910469730cd7e7ac07c04df">More...</a><br /></td></tr>
<tr class="separator:ade5a34799910469730cd7e7ac07c04df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebfebd9117cb95d5e31310de832348b"><td class="memTemplParams" colspan="2">template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsSrcPlaceholder, typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsDestPlaceholder&gt; </td></tr>
<tr class="memitem:a5ebfebd9117cb95d5e31310de832348b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5ebfebd9117cb95d5e31310de832348b">copy</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder &gt; Src, <a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder &gt; Dest, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a5ebfebd9117cb95d5e31310de832348b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by placeholder accessors.  <a href="classsycl_1_1__V1_1_1queue.html#a5ebfebd9117cb95d5e31310de832348b">More...</a><br /></td></tr>
<tr class="separator:a5ebfebd9117cb95d5e31310de832348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7e65102366f103fcef293d7b2b4d35"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access_mode Mode, target Tgt, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:a6a7e65102366f103fcef293d7b2b4d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6a7e65102366f103fcef293d7b2b4d35">update_host</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#a4cf7da32ec662adec405ef862ce9d8d5">Mode</a>, Tgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Acc, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a6a7e65102366f103fcef293d7b2b4d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides guarantees that the memory object accessed via Acc is updated on the host after operation is complete.  <a href="classsycl_1_1__V1_1_1queue.html#a6a7e65102366f103fcef293d7b2b4d35">More...</a><br /></td></tr>
<tr class="separator:a6a7e65102366f103fcef293d7b2b4d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4413c993f995205d1be56c6d6c905a3"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access_mode Mode, target Tgt, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:ab4413c993f995205d1be56c6d6c905a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ab4413c993f995205d1be56c6d6c905a3">fill</a> (<a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#a4cf7da32ec662adec405ef862ce9d8d5">Mode</a>, Tgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt; Dest, const T &amp;Src, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ab4413c993f995205d1be56c6d6c905a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified data.  <a href="classsycl_1_1__V1_1_1queue.html#ab4413c993f995205d1be56c6d6c905a3">More...</a><br /></td></tr>
<tr class="separator:ab4413c993f995205d1be56c6d6c905a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa7909d598ab2ae40a762f896dd0710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8fa7909d598ab2ae40a762f896dd0710">ext_codeplay_supports_fusion</a> () const</td></tr>
<tr class="memdesc:a8fa7909d598ab2ae40a762f896dd0710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue was created with the <a class="el" href="classsycl_1_1__V1_1_1ext_1_1codeplay_1_1experimental_1_1property_1_1queue_1_1enable__fusion.html">ext::codeplay::experimental::property::queue::enable_fusion</a> property.  <a href="classsycl_1_1__V1_1_1queue.html#a8fa7909d598ab2ae40a762f896dd0710">More...</a><br /></td></tr>
<tr class="separator:a8fa7909d598ab2ae40a762f896dd0710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa287f01c727846e03b96074640309d78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#aa287f01c727846e03b96074640309d78">ext_oneapi_graph</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt; Graph, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:aa287f01c727846e03b96074640309d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for executing a graph of commands.  <a href="classsycl_1_1__V1_1_1queue.html#aa287f01c727846e03b96074640309d78">More...</a><br /></td></tr>
<tr class="separator:aa287f01c727846e03b96074640309d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a5ec9128350fa0d69f6c48a5be0f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ad0a5ec9128350fa0d69f6c48a5be0f2d">ext_oneapi_graph</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt; Graph, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> DepEvent, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:ad0a5ec9128350fa0d69f6c48a5be0f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for executing a graph of commands with a single dependency.  <a href="classsycl_1_1__V1_1_1queue.html#ad0a5ec9128350fa0d69f6c48a5be0f2d">More...</a><br /></td></tr>
<tr class="separator:ad0a5ec9128350fa0d69f6c48a5be0f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6280768301d890f25683211545eac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a5c6280768301d890f25683211545eac5">ext_oneapi_graph</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt; Graph, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;DepEvents, const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc=<a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>())</td></tr>
<tr class="memdesc:a5c6280768301d890f25683211545eac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for executing a graph of commands with multiple dependencies.  <a href="classsycl_1_1__V1_1_1queue.html#a5c6280768301d890f25683211545eac5">More...</a><br /></td></tr>
<tr class="separator:a5c6280768301d890f25683211545eac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5afa27a05f32208067379bc763759"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a1dc5afa27a05f32208067379bc763759">is_in_order</a> () const</td></tr>
<tr class="memdesc:a1dc5afa27a05f32208067379bc763759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the queue is in order or OoO.  <a href="classsycl_1_1__V1_1_1queue.html#a1dc5afa27a05f32208067379bc763759">More...</a><br /></td></tr>
<tr class="separator:a1dc5afa27a05f32208067379bc763759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c02085a395d1437d3c8a0877d7b88fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesycl_1_1__V1.html#a9b3eefbf42f0cc6ace1a979adfc94f0c">backend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a7c02085a395d1437d3c8a0877d7b88fb">get_backend</a> () const <a class="el" href="std_2experimental_2simd_8hpp.html#a431625e0f1f8e5ea857a516afacf47e7">noexcept</a></td></tr>
<tr class="memdesc:a7c02085a395d1437d3c8a0877d7b88fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the backend associated with this queue.  <a href="classsycl_1_1__V1_1_1queue.html#a7c02085a395d1437d3c8a0877d7b88fb">More...</a><br /></td></tr>
<tr class="separator:a7c02085a395d1437d3c8a0877d7b88fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073ee47fcff85ebbd880a15dc456bb4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a073ee47fcff85ebbd880a15dc456bb4f">ext_oneapi_empty</a> () const</td></tr>
<tr class="memdesc:a073ee47fcff85ebbd880a15dc456bb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to check status of the queue (completed vs noncompleted).  <a href="classsycl_1_1__V1_1_1queue.html#a073ee47fcff85ebbd880a15dc456bb4f">More...</a><br /></td></tr>
<tr class="separator:a073ee47fcff85ebbd880a15dc456bb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e5294b936033764ca1210c39363165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pi_8h.html#a11056869f4074c362c2347033e5d1b92">pi_native_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a66e5294b936033764ca1210c39363165">getNative</a> (int32_t &amp;NativeHandleDesc) const</td></tr>
<tr class="separator:a66e5294b936033764ca1210c39363165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae3341758042fea556238fb341653fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a9ae3341758042fea556238fb341653fc">ext_oneapi_get_last_event</a> () const</td></tr>
<tr class="separator:a9ae3341758042fea556238fb341653fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6469a57fbbdf2521eb6fe5cb003e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a8e6469a57fbbdf2521eb6fe5cb003e2f">ext_oneapi_set_external_event</a> (const <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &amp;external_event)</td></tr>
<tr class="separator:a8e6469a57fbbdf2521eb6fe5cb003e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html">sycl::_V1::detail::OwnerLessBase&lt; queue &gt;</a></td></tr>
<tr class="memitem:a2acdcd7da10cad6a09210de3f20578d6 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html#a2acdcd7da10cad6a09210de3f20578d6">ext_oneapi_owner_before</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1detail_1_1weak__object__base.html">ext::oneapi::detail::weak_object_base</a>&lt; <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &gt; &amp;Other) const <a class="el" href="std_2experimental_2simd_8hpp.html#a431625e0f1f8e5ea857a516afacf47e7">noexcept</a></td></tr>
<tr class="memdesc:a2acdcd7da10cad6a09210de3f20578d6 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the object against a weak object using an owner-based implementation-defined ordering.  <a href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html#a2acdcd7da10cad6a09210de3f20578d6">More...</a><br /></td></tr>
<tr class="separator:a2acdcd7da10cad6a09210de3f20578d6 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abb8b65b0f139968d7553e381739a69 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html#a7abb8b65b0f139968d7553e381739a69">ext_oneapi_owner_before</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;Other) const <a class="el" href="std_2experimental_2simd_8hpp.html#a431625e0f1f8e5ea857a516afacf47e7">noexcept</a></td></tr>
<tr class="memdesc:a7abb8b65b0f139968d7553e381739a69 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the object against another object using an owner-based implementation-defined ordering.  <a href="classsycl_1_1__V1_1_1detail_1_1OwnerLessBase.html#a7abb8b65b0f139968d7553e381739a69">More...</a><br /></td></tr>
<tr class="separator:a7abb8b65b0f139968d7553e381739a69 inherit pub_methods_classsycl_1_1__V1_1_1detail_1_1OwnerLessBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a103ac3f98e7947007f7693baf12ee8c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a></td></tr>
<tr class="separator:a103ac3f98e7947007f7693baf12ee8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50726d3009266f6f9caa725b2b83cc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdevice__selector.html">device_selector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a></td></tr>
<tr class="separator:ac50726d3009266f6f9caa725b2b83cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1655b3de5a26ac436d3b0e2e9ab004f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#af1655b3de5a26ac436d3b0e2e9ab004f">PropList</a> = {})</td></tr>
<tr class="separator:af1655b3de5a26ac436d3b0e2e9ab004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d33dacbc2f70eec8aedea4b1ca4607b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a></td></tr>
<tr class="separator:a6d33dacbc2f70eec8aedea4b1ca4607b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3f2aa46617a5baa0e0f20db0c1aed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#ae1a3f2aa46617a5baa0e0f20db0c1aed">PropList</a> = {})</td></tr>
<tr class="separator:ae1a3f2aa46617a5baa0e0f20db0c1aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a71492293d0386f542d120a1fc3dfbb55"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a71492293d0386f542d120a1fc3dfbb55"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a71492293d0386f542d120a1fc3dfbb55">detail::createSyclObjFromImpl</a> (decltype(T::impl) ImplObj)</td></tr>
<tr class="separator:a71492293d0386f542d120a1fc3dfbb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c48c53733505713cf25f65c2d69a20"><td class="memTemplParams" colspan="2">template&lt;backend BackendName, class SyclObjectT &gt; </td></tr>
<tr class="memitem:a93c48c53733505713cf25f65c2d69a20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1queue.html#a93c48c53733505713cf25f65c2d69a20">get_native</a> (const SyclObjectT &amp;Obj) -&gt; <a class="el" href="namespacesycl_1_1__V1.html#a9c96775f520573d94ebaea3872b69f6d">backend_return_t</a>&lt; BackendName, SyclObjectT &gt;</td></tr>
<tr class="separator:a93c48c53733505713cf25f65c2d69a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a single SYCL queue which schedules kernels on a SYCL device. </p>
<p>A SYCL queue can be used to submit command groups to be executed by the SYCL runtime.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classsycl_1_1__V1_1_1device.html" title="The SYCL device class encapsulates a single SYCL device on which kernels may be executed.">device</a> </dd>
<dd>
<a class="el" href="classsycl_1_1__V1_1_1handler.html" title="Command group handler class.">handler</a> </dd>
<dd>
<a class="el" href="classsycl_1_1__V1_1_1event.html" title="An event object can be used to synchronize memory transfers, enqueues of kernels and signaling barrie...">event</a> </dd>
<dd>
<a class="el" href="classsycl_1_1__V1_1_1kernel.html" title="Provides an abstraction of a SYCL kernel.">kernel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00105">105</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a18897f997ae94d60bb1f3b3b51dfd6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18897f997ae94d60bb1f3b3b51dfd6d5">&#9670;&nbsp;</a></span>queue() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device returned by an instance of default_selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00111">111</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a8f6acd31be0101cd9d94fcd8292d2d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6acd31be0101cd9d94fcd8292d2d1d">&#9670;&nbsp;</a></span>queue() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler using the device returned by an instance of default_selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00119">119</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="aa0ffa2b9e123b2192fcbc78afc2ff1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ffa2b9e123b2192fcbc78afc2ff1a8">&#9670;&nbsp;</a></span>queue() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device identified by the device selector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceSelector</td><td>is SYCL 2020 Device Selector, a simple callable that takes a device and returns an int </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00131">131</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a82debe5bf907e27ec58db65867aa52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82debe5bf907e27ec58db65867aa52a6">&#9670;&nbsp;</a></span>queue() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device identified by the device selector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceSelector</td><td>is SYCL 2020 Device Selector, a simple callable that takes a device and returns an int </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00144">144</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a5ae031075a0ebb42bab98f2728d67901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae031075a0ebb42bab98f2728d67901">&#9670;&nbsp;</a></span>queue() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>syclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device identified by the device selector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is SYCL 2020 Device Selector, a simple callable that takes a device and returns an int </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00158">158</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a3c036e6e630818b65129e2cdd248f1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c036e6e630818b65129e2cdd248f1eb">&#9670;&nbsp;</a></span>queue() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeviceSelector , typename  = detail::EnableIfSYCL2020DeviceSelectorInvocable&lt;DeviceSelector&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>syclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>propList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device identified by the device selector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is SYCL 2020 Device Selector, a simple callable that takes a device and returns an int </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00174">174</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a81ec8c3092ded56a7de635cfcb4ef2ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ec8c3092ded56a7de635cfcb4ef2ae">&#9670;&nbsp;</a></span>queue() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue associated with the given context, device and optional properties list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00058">58</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aac73764bd452fd935b9be39b1c47dcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac73764bd452fd935b9be39b1c47dcd7">&#9670;&nbsp;</a></span>queue() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue associated with the given context, device, asynchronous exception handler and optional properties list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00039">39</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00243">AsyncHandler</a>, <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, and <a class="el" href="queue_8hpp_source.html#l00189">PropList</a>.</p>

</div>
</div>
<a id="ab75222e49912fa7a24f14237aa0b94ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75222e49912fa7a24f14237aa0b94ae">&#9670;&nbsp;</a></span>queue() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue with an optional async_handler from an OpenCL cl_command_queue. </p>
<p>The instance of cl_command_queue is retained on construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ClQueue</td><td>is a valid instance of OpenCL queue. </td></tr>
    <tr><td class="paramname">SyclContext</td><td>is a valid SYCL context. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6541318823677b4ddb7892e06ef08a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541318823677b4ddb7892e06ef08a3e">&#9670;&nbsp;</a></span>queue() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a847f1817fc43e1a40622d127837cbd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847f1817fc43e1a40622d127837cbd4d">&#9670;&nbsp;</a></span>__SYCL2020_DEPRECATED() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::__SYCL2020_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;is_host() is deprecated as the host <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> is no longer supported.&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this queue is a SYCL host queue. </dd></dl>

</div>
</div>
<a id="aa9182b8383d4b1c6eeff4ff70adb1461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9182b8383d4b1c6eeff4ff70adb1461">&#9670;&nbsp;</a></span>__SYCL2020_DEPRECATED() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::__SYCL2020_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance that is associated with the context provided, using the device returned by the device selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9182b8383d4b1c6eeff4ff70adb1461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9182b8383d4b1c6eeff4ff70adb1461">&#9670;&nbsp;</a></span>__SYCL2020_DEPRECATED() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::__SYCL2020_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler that is associated with the context provided, using the device returned by the device selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a561de199991e9fa5822ba75e54193726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561de199991e9fa5822ba75e54193726">&#9670;&nbsp;</a></span>__SYCL2020_DEPRECATED() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sycl::_V1::queue::__SYCL2020_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;SYCL 1.2.1 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors are deprecated. Please &quot; &quot;use SYCL 2020 <a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> selectors instead.&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device returned by the DeviceSelector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of a SYCL 1.2.1 <a class="el" href="classdevice__selector.html">device_selector</a>. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06e4ea48ef75850a846a2be4cbbd9f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e4ea48ef75850a846a2be4cbbd9f6e">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsPlaceholder, typename DestT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestT *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a memory region pointed to by a placeholder accessor to another memory region pointed to by a raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a placeholder accessor to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a raw pointer to the destination memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02433">2433</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02597">sycl::_V1::handler::copy()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ae57a80dcf371f03d77f2a3ed83d1d062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57a80dcf371f03d77f2a3ed83d1d062">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsPlaceholder, typename DestT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; DestT &gt;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a memory region pointed to by a placeholder accessor to another memory region pointed to by a shared_ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a placeholder accessor to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a shared_ptr to the destination memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02393">2393</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02597">sycl::_V1::handler::copy()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a5ebfebd9117cb95d5e31310de832348b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebfebd9117cb95d5e31310de832348b">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcT , int SrcDims, access_mode SrcMode, target SrcTgt, access::placeholder IsSrcPlaceholder, typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsDestPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; SrcT, SrcDims, SrcMode, SrcTgt, IsSrcPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, IsDestPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by placeholder accessors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a placeholder accessor to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a placeholder accessor to the destination memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02474">2474</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02597">sycl::_V1::handler::copy()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a8c88131dc7aa9560bfc098b4755ac470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c88131dc7aa9560bfc098b4755ac470">&#9670;&nbsp;</a></span>copy() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Src to copy from. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the operation dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01320">1320</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="aee79952847e991b5ed25a6446a3810d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee79952847e991b5ed25a6446a3810d8">&#9670;&nbsp;</a></span>copy() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Src to copy from. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is a vector of event that specifies the operation dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01345">1345</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a7c5a4ee9b531cf1c4f88b2fe5580eb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5a4ee9b531cf1c4f88b2fe5580eb97">&#9670;&nbsp;</a></span>copy() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em> = <code>sizeof(T)&#160;/&#160;sizeof(std::remove_all_extents_t&lt;T&gt;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a device_global to a USM memory region. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Src to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01368">1368</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ade5a34799910469730cd7e7ac07c04df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5a34799910469730cd7e7ac07c04df">&#9670;&nbsp;</a></span>copy() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcT , typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const SrcT *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a memory region pointed to by a raw pointer to another memory region pointed to by a placeholder accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a raw pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a placeholder accessor to the destination memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02452">2452</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02597">sycl::_V1::handler::copy()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a08f5c94a96fb7999e66f1e976102bae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f5c94a96fb7999e66f1e976102bae6">&#9670;&nbsp;</a></span>copy() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Dest to copy to. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the operation dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01247">1247</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="adba2e0a16101c222dc5b9e6f4f2c0ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba2e0a16101c222dc5b9e6f4f2c0ae0">&#9670;&nbsp;</a></span>copy() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Dest to copy to. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is a vector of event that specifies the operation dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01272">1272</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="acbf6a9c6458bf01a3b6185d13021411a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf6a9c6458bf01a3b6185d13021411a">&#9670;&nbsp;</a></span>copy() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const std::remove_all_extents_t&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em> = <code>sizeof(T)&#160;/&#160;sizeof(std::remove_all_extents_t&lt;T&gt;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>StartIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies elements of type <code>std::remove_all_extents_t&lt;T&gt;</code> from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">Count</td><td>and </td></tr>
    <tr><td class="paramname">StartIndex.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements to copy. </td></tr>
    <tr><td class="paramname">StartIndex</td><td>is the index of the first element in Dest to copy to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01295">1295</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a5fcf0c525944e1561a82404dabf5daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcf0c525944e1561a82404dabf5daa9">&#9670;&nbsp;</a></span>copy() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type T to copy. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00636">636</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a395a1b7e7e6c4b43d24089304a2628b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a1b7e7e6c4b43d24089304a2628b7">&#9670;&nbsp;</a></span>copy() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type T to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00678">678</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a6dba86a843c95fe2f3fc634a22c3bcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dba86a843c95fe2f3fc634a22c3bcfa">&#9670;&nbsp;</a></span>copy() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type T to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00657">657</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a5976f5305fac8e20afe4a52f6cee601d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5976f5305fac8e20afe4a52f6cee601d">&#9670;&nbsp;</a></span>copy() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcT , typename DestT , int DestDims, access_mode DestMode, target DestTgt, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::copy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; SrcT &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; DestT, DestDims, DestMode, DestTgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a memory region pointed to by a shared_ptr to another memory region pointed to by a placeholder accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a shared_ptr to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a placeholder accessor to the destination memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02413">2413</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02597">sycl::_V1::handler::copy()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a8fa7909d598ab2ae40a762f896dd0710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa7909d598ab2ae40a762f896dd0710">&#9670;&nbsp;</a></span>ext_codeplay_supports_fusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::ext_codeplay_supports_fusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue was created with the <a class="el" href="classsycl_1_1__V1_1_1ext_1_1codeplay_1_1experimental_1_1property_1_1queue_1_1enable__fusion.html">ext::codeplay::experimental::property::queue::enable_fusion</a> property. </p>
<p>Equivalent to <code>has_property&lt;<a class="el" href="classsycl_1_1__V1_1_1ext_1_1codeplay_1_1experimental_1_1property_1_1queue_1_1enable__fusion.html">ext::codeplay::experimental::property::queue::enable_fusion</a>&gt;()</code>. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00353">353</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="fusion__wrapper_8cpp_source.html#l00018">sycl::_V1::ext::codeplay::experimental::fusion_wrapper::fusion_wrapper()</a>.</p>

</div>
</div>
<a id="a36ef6d531e1bebc3273414e692085d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ef6d531e1bebc3273414e692085d29">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>ImageDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles. </p>
<p>An exception is thrown if either <code>Src</code> or <code>Dest</code> is incomplete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">ImageDesc</td><td>is the source image descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01612">1612</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="ab97445c279690746d8cfebe84ae495ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97445c279690746d8cfebe84ae495ce">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>ImageDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles. </p>
<p>An exception is thrown if either <code>Src</code> or <code>Dest</code> is incomplete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">ImageDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01598">1598</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a3468bfd43b9c47cbc8fdc18aa539cbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3468bfd43b9c47cbc8fdc18aa539cbf3">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>ImageDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from device to device memory, where <code>Src</code> and <code>Dest</code> are opaque image memory handles. </p>
<p>An exception is thrown if either <code>Src</code> or <code>Dest</code> is incomplete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">ImageDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an events that specifies the kernel dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01584">1584</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a489955f80eaf194fa3ba52804b14cacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489955f80eaf194fa3ba52804b14cacf">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. Pixel size is determined by <code>SrcImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin of source measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DestExtent</td><td>is the extent of the dest memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01472">1472</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="aec7c247220175686a5b2165ee609146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7c247220175686a5b2165ee609146d">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. Pixel size is determined by <code>SrcImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin of source measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DestExtent</td><td>is the extent of the dest memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01528">1528</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a7d1251b8141eef61e08bdb09d4cc78f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1251b8141eef61e08bdb09d4cc78f8">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. Pixel size is determined by <code>SrcImgDesc</code> An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin of source measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DestExtent</td><td>is the extent of the dest memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>SrcImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01499">1499</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="ae61ebda1916bc1edb98489d648a388c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61ebda1916bc1edb98489d648a388c4">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>An exception is thrown if either <code>Src</code> is incomplete or <code>Dest</code> is nullptr. The behavior is undefined if <code>SrcImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the source image descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01462">1462</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a76dd98d45ebbb659b261083c49b53276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dd98d45ebbb659b261083c49b53276">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>An exception is thrown if either <code>Src</code> is incomplete or <code>Dest</code> is nullptr. The behavior is undefined if <code>SrcImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the image descriptor (format, order, dimensions). </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01515">1515</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a4424a805a9553200af351c415c2f5d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4424a805a9553200af351c415c2f5d07">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>SrcImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is an opaque image memory handle and <code>Dest</code> is a USM pointer. </p>
<p>An exception is thrown if either <code>Src</code> is incomplete or <code>Dest</code> is nullptr. The behavior is undefined if <code>SrcImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is an opaque image memory handle to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">SrcImgDesc</td><td>is the image descriptor (format, order, dimensions). </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01486">1486</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="aaac9dc5d39dcf9f2ac4064858854a3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac9dc5d39dcf9f2ac4064858854a3ff">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete. The behavior is undefined if <code>DestImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a wrapper for an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the image descriptor (format, order, dimensions). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01380">1380</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a62c78eacb09dc1bad7a85d14727eef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c78eacb09dc1bad7a85d14727eef2f">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete. The behavior is undefined if <code>DestImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a wrapper for an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01433">1433</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a73cfa24a598d4c7ac734e5b3230695cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cfa24a598d4c7ac734e5b3230695cd">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle wrapper. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete. The behavior is undefined if <code>DestImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a wrapper for an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01404">1404</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="af5c51afd6f7a4ef659fbfb77e2f2b8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c51afd6f7a4ef659fbfb77e2f2b8d7">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>CopyExtent</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">SrcExtent</td><td>is the extent of the source memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels as determined by <code>DestImgDesc</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01390">1390</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a9581b3cd995357eb313a846937cda6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9581b3cd995357eb313a846937cda6cf">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">SrcExtent</td><td>is the extent of the source memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels as determined by <code>DestImgDesc</code> </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01446">1446</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a84ba049b237364a53b5cfbd9da022497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ba049b237364a53b5cfbd9da022497">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__mem__handle.html">ext::oneapi::experimental::image_mem_handle</a>&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DestImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> is a USM pointer and <code>Dest</code> is an opaque image memory handle. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>CopyExtent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">SrcExtent</td><td>is the extent of the source memory to copy, measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">Dest</td><td>is an opaque image memory handle to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an offset from the destination origin measured in pixels (pixel size determined by <code>DestImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DestImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels as determined by <code>DestImgDesc</code> </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01417">1417</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a1502aeda137af500af23ad8274558ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1502aeda137af500af23ad8274558ddb">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>HostExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>Extent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the device image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the row pitch on the device </td></tr>
    <tr><td class="paramname">HostExtent</td><td>is the extent of the host memory to copy, measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01556">1556</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a6fc78e457a96e417730f4177222448d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc78e457a96e417730f4177222448d9">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>HostExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>Extent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the row pitch on the device </td></tr>
    <tr><td class="paramname">HostExtent</td><td>is the extent of the host memory to copy, measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01652">1652</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a53d19bf402dea588ef0373b60785aab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d19bf402dea588ef0373b60785aab8">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>SrcOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>DestOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>HostExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>CopyExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>Allows for a sub-region copy, where <code>SrcOffset</code> , <code>DestOffset</code> , and <code>Extent</code> are used to determine the sub-region. An exception is thrown if either <code>Src</code> is nullptr or <code>Dest</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestOffset</td><td>is an destination offset from the origin where the x, y, and z components are measured in bytes, rows, and slices respectively </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the destination image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the row pitch on the device </td></tr>
    <tr><td class="paramname">HostExtent</td><td>is the extent of the host memory to copy, measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">CopyExtent</td><td>is the width, height, and depth of the region to copy measured in pixels (pixel size determined by <code>DeviceImgDesc</code> ) </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01623">1623</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="ac92c1fbfaf67abc18d6a6bafa4a6241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92c1fbfaf67abc18d6a6bafa4a6241b">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr, <code>Dest</code> is nullptr, or <code>Pitch</code> is inconsistent with hardware requirements. The behavior is undefined if <code>DeviceImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the DeviceRowPitch of the rows on the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01544">1544</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a9fbe4cd60d7a24aea7817eacadd8f89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbe4cd60d7a24aea7817eacadd8f89c">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr, <code>Dest</code> is nullptr, or <code>Pitch</code> is inconsistent with hardware requirements. The behavior is undefined if <code>DeviceImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the pitch of the rows on the device. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01638">1638</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="aeb6dbc69138bba1eb8217f3c1897c217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6dbc69138bba1eb8217f3c1897c217">&#9670;&nbsp;</a></span>ext_oneapi_copy() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1image__descriptor.html">ext::oneapi::experimental::image_descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceImgDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DeviceRowPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, where <code>Src</code> and <code>Dest</code> are USM pointers. </p>
<p>An exception is thrown if either <code>Src</code> is nullptr, <code>Dest</code> is nullptr, or <code>Pitch</code> is inconsistent with hardware requirements. The behavior is undefined if <code>DeviceImgDesc</code> is inconsistent with the allocated memory region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DeviceImgDesc</td><td>is the image descriptor </td></tr>
    <tr><td class="paramname">DeviceRowPitch</td><td>is the pitch of the rows on the device. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bindless__images_8hpp_source.html#l01570">1570</a> of file <a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01027">sycl::_V1::handler::ext_oneapi_copy()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a193a410e11512580f8dfee3e3a4f8dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193a410e11512580f8dfee3e3a4f8dbe">&#9670;&nbsp;</a></span>ext_oneapi_copy2d() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00173">173</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="memcpy2d_8hpp_source.html#l00060">sycl::_V1::handler::ext_oneapi_copy2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="afb410b9ac38620b54be4c31ea81b76d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb410b9ac38620b54be4c31ea81b76d0">&#9670;&nbsp;</a></span>ext_oneapi_copy2d() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00197">197</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00060">sycl::_V1::handler::ext_oneapi_copy2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a7f5b0c3f4183efc17dcaedeb6a35bbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5b0c3f4183efc17dcaedeb6a35bbfb">&#9670;&nbsp;</a></span>ext_oneapi_copy2d() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_copy2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00184">184</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00060">sycl::_V1::handler::ext_oneapi_copy2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a073ee47fcff85ebbd880a15dc456bb4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073ee47fcff85ebbd880a15dc456bb4f">&#9670;&nbsp;</a></span>ext_oneapi_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::ext_oneapi_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to check status of the queue (completed vs noncompleted). </p>
<dl class="section return"><dt>Returns</dt><dd>returns true if all enqueued commands in the queue have been completed, otherwise returns false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00324">324</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aa731512bfb8c9dff8660964c45cd4ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa731512bfb8c9dff8660964c45cd4ce5">&#9670;&nbsp;</a></span>ext_oneapi_fill2d() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_fill2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00246">246</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="memcpy2d_8hpp_source.html#l00121">sycl::_V1::handler::ext_oneapi_fill2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="aec567ea0aa4f5f6c0080b7b03856d9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec567ea0aa4f5f6c0080b7b03856d9ad">&#9670;&nbsp;</a></span>ext_oneapi_fill2d() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_fill2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00269">269</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00121">sycl::_V1::handler::ext_oneapi_fill2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a1acf6b4dded170813edc6712eca0a7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acf6b4dded170813edc6712eca0a7d1">&#9670;&nbsp;</a></span>ext_oneapi_fill2d() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_fill2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00257">257</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00121">sycl::_V1::handler::ext_oneapi_fill2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="ad1c81b32f261f867313a4890b91ff4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c81b32f261f867313a4890b91ff4ca">&#9670;&nbsp;</a></span>ext_oneapi_get_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512a8dce88101886d945bc56a5c0cd3a473f">ext::oneapi::experimental::graph_state::modifiable</a> &gt; sycl::_V1::queue::ext_oneapi_get_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Graph when the queue is recording. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00086">86</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="impl__utils_8hpp_source.html#l00048">sycl::_V1::detail::createSyclObjFromImpl()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512a8dce88101886d945bc56a5c0cd3a473f">sycl::_V1::ext::oneapi::experimental::modifiable</a>.</p>

</div>
</div>
<a id="a9ae3341758042fea556238fb341653fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae3341758042fea556238fb341653fc">&#9670;&nbsp;</a></span>ext_oneapi_get_last_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_get_last_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00358">358</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="queue_8cpp_source.html#l00318">is_in_order()</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<a id="aae0e95b9bd7693e1031cd425dd71f8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0e95b9bd7693e1031cd425dd71f8f9">&#9670;&nbsp;</a></span>ext_oneapi_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ext::oneapi::experimental::queue_state sycl::_V1::queue::ext_oneapi_get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>State the queue is currently in. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00078">78</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aa287f01c727846e03b96074640309d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa287f01c727846e03b96074640309d78">&#9670;&nbsp;</a></span>ext_oneapi_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt;&#160;</td>
          <td class="paramname"><em>Graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut for executing a graph of commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>the graph of commands to execute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing graph execution operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02539">2539</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01616">sycl::_V1::handler::ext_oneapi_graph()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a5c6280768301d890f25683211545eac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6280768301d890f25683211545eac5">&#9670;&nbsp;</a></span>ext_oneapi_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt;&#160;</td>
          <td class="paramname"><em>Graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut for executing a graph of commands with multiple dependencies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>the graph of commands to execute </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the graph execution dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing graph execution operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02573">2573</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01616">sycl::_V1::handler::ext_oneapi_graph()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ad0a5ec9128350fa0d69f6c48a5be0f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a5ec9128350fa0d69f6c48a5be0f2d">&#9670;&nbsp;</a></span>ext_oneapi_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1command__graph.html">ext::oneapi::experimental::command_graph</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental.html#a14756d01a0d78ec9aa6666587761a512aee7004c7949d83f130592f15d98ca343">ext::oneapi::experimental::graph_state::executable</a> &gt;&#160;</td>
          <td class="paramname"><em>Graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut for executing a graph of commands with a single dependency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>the graph of commands to execute </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the graph execution dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing graph execution operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02553">2553</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01616">sycl::_V1::handler::ext_oneapi_graph()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a22a37e0203758f98a3255a98f67d2b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a37e0203758f98a3255a98f67d2b40">&#9670;&nbsp;</a></span>ext_oneapi_memcpy2d() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = unsigned char, typename  = std::enable_if_t&lt;std::is_same_v&lt;T, unsigned char&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memcpy2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in bytes of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00809">809</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="memcpy2d_8hpp_source.html#l00018">sycl::_V1::handler::ext_oneapi_memcpy2d()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a3bb6cbc9bcd00ad2b9427ea52bf91c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb6cbc9bcd00ad2b9427ea52bf91c3c">&#9670;&nbsp;</a></span>ext_oneapi_memcpy2d() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memcpy2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in bytes of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00159">159</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00018">sycl::_V1::handler::ext_oneapi_memcpy2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="aabe55a7497c4c6d7d613ced41ea83fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe55a7497c4c6d7d613ced41ea83fab">&#9670;&nbsp;</a></span>ext_oneapi_memcpy2d() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memcpy2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>SrcPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one 2D memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than either</td></tr>
    <tr><td class="paramname">DestPitch</td><td>or </td></tr>
    <tr><td class="paramname">SrcPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">SrcPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Src.</td><td></td></tr>
    <tr><td class="paramname">Width</td><td>is the width in bytes of the 2D region to copy. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00145">145</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00018">sycl::_V1::handler::ext_oneapi_memcpy2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a1e1bc4a085d7fecfb83a86aa35874056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1bc4a085d7fecfb83a86aa35874056">&#9670;&nbsp;</a></span>ext_oneapi_memset2d() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memset2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Value</td><td>is the value to fill into the region in</td></tr>
    <tr><td class="paramname">Dest.</td><td>Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00210">210</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="memcpy2d_8hpp_source.html#l00098">sycl::_V1::handler::ext_oneapi_memset2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="ac18c871b8cbd2a39f3432fe65120cae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18c871b8cbd2a39f3432fe65120cae3">&#9670;&nbsp;</a></span>ext_oneapi_memset2d() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memset2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Value</td><td>is the value to fill into the region in</td></tr>
    <tr><td class="paramname">Dest.</td><td>Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00233">233</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00098">sycl::_V1::handler::ext_oneapi_memset2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a9f3ddac3b8e052534a1166d9511f25ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3ddac3b8e052534a1166d9511f25ca">&#9670;&nbsp;</a></span>ext_oneapi_memset2d() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_memset2d </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>DestPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Width</td><td>or</td></tr>
    <tr><td class="paramname">Height</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr or if </td></tr>
    <tr><td class="paramname">Width</td><td>is strictly greater than</td></tr>
    <tr><td class="paramname">DestPitch.</td><td>The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Function is dependent to prevent the fallback kernels from materializing without the use of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">DestPitch</td><td>is the pitch of the rows in</td></tr>
    <tr><td class="paramname">Dest.</td><td></td></tr>
    <tr><td class="paramname">Value</td><td>is the value to fill into the region in</td></tr>
    <tr><td class="paramname">Dest.</td><td>Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Width</td><td>is the width in number of elements of the 2D region to fill. </td></tr>
    <tr><td class="paramname">Height</td><td>is the height in number of rows of the 2D region to fill. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="memcpy2d_8hpp_source.html#l00221">221</a> of file <a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00098">sycl::_V1::handler::ext_oneapi_memset2d()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a8e6469a57fbbdf2521eb6fe5cb003e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6469a57fbbdf2521eb6fe5cb003e2f">&#9670;&nbsp;</a></span>ext_oneapi_set_external_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::ext_oneapi_set_external_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &amp;&#160;</td>
          <td class="paramname"><em>external_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00371">371</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="queue_8cpp_source.html#l00318">is_in_order()</a>, and <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>.</p>

</div>
</div>
<a id="aa774aab382e1630a4c24e69056f5940f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa774aab382e1630a4c24e69056f5940f">&#9670;&nbsp;</a></span>ext_oneapi_signal_external_semaphore() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_signal_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue to signal the external semaphore once all previous commands have completed execution. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the signal operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01908">1908</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01405">sycl::_V1::handler::ext_oneapi_signal_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="af1ed14c5d7813385ea827b57f1fd3b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ed14c5d7813385ea827b57f1fd3b64">&#9670;&nbsp;</a></span>ext_oneapi_signal_external_semaphore() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_signal_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue to signal the external semaphore once all previous commands have completed execution. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the signal operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01947">1947</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01405">sycl::_V1::handler::ext_oneapi_signal_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a5da37618faa4d1184640b294df6dcf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da37618faa4d1184640b294df6dcf46">&#9670;&nbsp;</a></span>ext_oneapi_signal_external_semaphore() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_signal_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue to signal the external semaphore once all previous commands have completed execution. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the signal operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01926">1926</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01405">sycl::_V1::handler::ext_oneapi_signal_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="aac39c4798d74dfe144d0e15855136ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac39c4798d74dfe144d0e15855136ebc">&#9670;&nbsp;</a></span>ext_oneapi_submit_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_submit_barrier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00242">242</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02881">sycl::_V1::handler::ext_oneapi_barrier()</a>, <a class="el" href="queue_8cpp_source.html#l00209">sycl::_V1::getBarrierEventForInorderQueueHelper()</a>, <a class="el" href="queue_8cpp_source.html#l00318">is_in_order()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a9c7a0dc5dd031073e00afd7b5e020761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7a0dc5dd031073e00afd7b5e020761">&#9670;&nbsp;</a></span>ext_oneapi_submit_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_submit_barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>WaitList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then ext_oneapi_submit_barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00258">258</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="std_2experimental_2simd_8hpp.html#a14a5bbfa961877859b40336bdfcfd65a">all_of()</a>, <a class="el" href="handler_8hpp_source.html#l02881">sycl::_V1::handler::ext_oneapi_barrier()</a>, <a class="el" href="queue_8cpp_source.html#l00209">sycl::_V1::getBarrierEventForInorderQueueHelper()</a>, <a class="el" href="impl__utils_8hpp_source.html#l00030">sycl::_V1::detail::getSyclObjImpl()</a>, <a class="el" href="queue_8cpp_source.html#l00318">is_in_order()</a>, and <a class="el" href="queue_8hpp_source.html#l00340">submit()</a>.</p>

</div>
</div>
<a id="a65cc251067111f6708e6447997d0fcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cc251067111f6708e6447997d0fcb8">&#9670;&nbsp;</a></span>ext_oneapi_wait_external_semaphore() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_wait_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue with a non-blocking wait on an external semaphore. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the wait operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01852">1852</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01395">sycl::_V1::handler::ext_oneapi_wait_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ab2bac1f3ba9912ec5da3fb44d81b9efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bac1f3ba9912ec5da3fb44d81b9efc">&#9670;&nbsp;</a></span>ext_oneapi_wait_external_semaphore() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_wait_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue with a non-blocking wait on an external semaphore. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the wait operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01889">1889</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01395">sycl::_V1::handler::ext_oneapi_wait_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a7640f69f669cdb014cd22c91a9de2ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7640f69f669cdb014cd22c91a9de2ece">&#9670;&nbsp;</a></span>ext_oneapi_wait_external_semaphore() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::ext_oneapi_wait_external_semaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1interop__semaphore__handle.html">sycl::ext::oneapi::experimental::interop_semaphore_handle</a>&#160;</td>
          <td class="paramname"><em>SemaphoreHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instruct the queue with a non-blocking wait on an external semaphore. </p>
<p>An exception is thrown if <code>SemaphoreHandle</code> is incomplete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SemaphoreHandle</td><td>is an opaque external interop semaphore handle </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing the wait operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01869">1869</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l01395">sycl::_V1::handler::ext_oneapi_wait_external_semaphore()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ab4413c993f995205d1be56c6d6c905a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4413c993f995205d1be56c6d6c905a3">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access_mode Mode, target Tgt, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#a4cf7da32ec662adec405ef862ce9d8d5">Mode</a>, Tgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest</td><td>is the placeholder accessor to the memory to fill. </td></tr>
    <tr><td class="paramname">Src</td><td>is the data to fill the memory with. T should be trivially copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02513">2513</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02826">sycl::_V1::handler::fill()</a>, <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a184c13a29e222fd9db55ddfa0757cf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184c13a29e222fd9db55ddfa0757cf26">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00480">480</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02826">sycl::_V1::handler::fill()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00185">syclcompat::detail::fill()</a>.</p>

</div>
</div>
<a id="a1724ddf75285defdf8e9f15a8bb5b235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1724ddf75285defdf8e9f15a8bb5b235">&#9670;&nbsp;</a></span>fill() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00519">519</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8hpp_source.html#l02826">sycl::_V1::handler::fill()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a2277899aae7084c33b016eb53c6d19ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2277899aae7084c33b016eb53c6d19ce">&#9670;&nbsp;</a></span>fill() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. T should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00497">497</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8hpp_source.html#l02826">sycl::_V1::handler::fill()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a7c02085a395d1437d3c8a0877d7b88fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c02085a395d1437d3c8a0877d7b88fb">&#9670;&nbsp;</a></span>get_backend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesycl_1_1__V1.html#a9b3eefbf42f0cc6ace1a979adfc94f0c">backend</a> sycl::_V1::queue::get_backend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the backend associated with this queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the backend associated with this queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00322">322</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="backend__impl_8hpp_source.html#l00017">sycl::_V1::detail::getImplBackend()</a>.</p>

</div>
</div>
<a id="abc7cc50fcd82224e540bbfc531532f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7cc50fcd82224e540bbfc531532f0a">&#9670;&nbsp;</a></span>get_backend_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Param &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsycl_1_1__V1_1_1detail_1_1is__backend__info__desc.html">detail::is_backend_info_desc</a>&lt; Param &gt;::return_type sycl::_V1::queue::get_backend_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries SYCL queue for SYCL backend-specific information. </p>
<p>The return type depends on information being queried. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00287">287</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ab3dd483e6986fbf840bd532ac017445a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dd483e6986fbf840bd532ac017445a">&#9670;&nbsp;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1context.html">context</a> sycl::_V1::queue::get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a valid instance of OpenCL queue, which is retained before being returned.</dd>
<dd>
an associated SYCL context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00074">74</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="bindless__images_8cpp_source.html#l00184">sycl::_V1::ext::oneapi::experimental::alloc_image_mem()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00339">sycl::_V1::ext::oneapi::experimental::create_image()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00675">sycl::_V1::ext::oneapi::experimental::destroy_external_semaphore()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00128">sycl::_V1::ext::oneapi::experimental::destroy_image_handle()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00536">syclcompat::free()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00283">sycl::_V1::ext::oneapi::experimental::free_image_mem()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00734">sycl::_V1::ext::oneapi::experimental::get_image_channel_type()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00826">sycl::_V1::ext::oneapi::experimental::get_image_num_channels()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00706">sycl::_V1::ext::oneapi::experimental::get_image_range()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00247">sycl::_V1::ext::oneapi::experimental::get_mip_level_mem_handle()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00251">syclcompat::detail::get_pointer_attribute()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00491">sycl::_V1::ext::oneapi::experimental::import_external_memory&lt; resource_fd &gt;()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00624">sycl::_V1::ext::oneapi::experimental::import_external_semaphore()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l01165">syclcompat::pointer_attributes::init()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00150">syclcompat::detail::malloc()</a>, <a class="el" href="alloc__base_8hpp_source.html#l00244">sycl::_V1::ext::oneapi::experimental::malloc_annotated()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00554">sycl::_V1::ext::oneapi::experimental::map_external_image_memory()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00772">sycl::_V1::ext::oneapi::experimental::pitched_alloc_device()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00693">sycl::_V1::ext::oneapi::experimental::prepare_for_device_copy()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00595">sycl::_V1::ext::oneapi::experimental::release_external_memory()</a>, and <a class="el" href="usm__impl_8cpp_source.html#l00701">sycl::_V1::ext::oneapi::experimental::release_from_device_copy()</a>.</p>

</div>
</div>
<a id="a786ac57f419cca2eba3a069990846188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786ac57f419cca2eba3a069990846188">&#9670;&nbsp;</a></span>get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1device.html">device</a> sycl::_V1::queue::get_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>SYCL device this queue was constructed with. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00076">76</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="bindless__images_8cpp_source.html#l00184">sycl::_V1::ext::oneapi::experimental::alloc_image_mem()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00339">sycl::_V1::ext::oneapi::experimental::create_image()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00675">sycl::_V1::ext::oneapi::experimental::destroy_external_semaphore()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00128">sycl::_V1::ext::oneapi::experimental::destroy_image_handle()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00283">sycl::_V1::ext::oneapi::experimental::free_image_mem()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00734">sycl::_V1::ext::oneapi::experimental::get_image_channel_type()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00826">sycl::_V1::ext::oneapi::experimental::get_image_num_channels()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00706">sycl::_V1::ext::oneapi::experimental::get_image_range()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00247">sycl::_V1::ext::oneapi::experimental::get_mip_level_mem_handle()</a>, <a class="el" href="reduction_8hpp_source.html#l01062">sycl::_V1::detail::reduction_impl_algo&lt; T, BinaryOperation, Dims, Extent, ExplicitIdentity, RedOutVar &gt;::getGroupsCounterAccDiscrete()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00491">sycl::_V1::ext::oneapi::experimental::import_external_memory&lt; resource_fd &gt;()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00624">sycl::_V1::ext::oneapi::experimental::import_external_semaphore()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00150">syclcompat::detail::malloc()</a>, <a class="el" href="alloc__base_8hpp_source.html#l00244">sycl::_V1::ext::oneapi::experimental::malloc_annotated()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00554">sycl::_V1::ext::oneapi::experimental::map_external_image_memory()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00772">sycl::_V1::ext::oneapi::experimental::pitched_alloc_device()</a>, <a class="el" href="ext_2intel_2experimental_2pipes_8hpp_source.html#l00079">sycl::_V1::ext::intel::experimental::pipe&lt; _name, _dataT, _min_capacity, _propertiesT, class &gt;::read()</a>, <a class="el" href="bindless__images_8cpp_source.html#l00595">sycl::_V1::ext::oneapi::experimental::release_external_memory()</a>, and <a class="el" href="ext_2intel_2experimental_2pipes_8hpp_source.html#l00108">sycl::_V1::ext::intel::experimental::pipe&lt; _name, _dataT, _min_capacity, _propertiesT, class &gt;::write()</a>.</p>

</div>
</div>
<a id="abb786d28feb3f1254823d57493cf7b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb786d28feb3f1254823d57493cf7b39">&#9670;&nbsp;</a></span>get_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Param &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsycl_1_1__V1_1_1detail_1_1is__queue__info__desc.html">detail::is_queue_info_desc</a>&lt; Param &gt;::return_type sycl::_V1::queue::get_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries SYCL queue for information. </p>
<p>The return type depends on information being queried. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00274">274</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aeff9caedf4b49a994478ddcfec1e81e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff9caedf4b49a994478ddcfec1e81e0">&#9670;&nbsp;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertyT sycl::_V1::queue::get_property</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a copy of the property of type PropertyT that the queue was constructed with. If the queue was not constructed with the PropertyT property, an invalid_object_error SYCL exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00303">303</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a66e5294b936033764ca1210c39363165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e5294b936033764ca1210c39363165">&#9670;&nbsp;</a></span>getNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pi_8h.html#a11056869f4074c362c2347033e5d1b92">pi_native_handle</a> sycl::_V1::queue::getNative </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>NativeHandleDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00326">326</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ab576e60a52714370580b37ca9d6b43f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab576e60a52714370580b37ca9d6b43f4">&#9670;&nbsp;</a></span>has_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::has_property</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the queue was constructed with property specified by PropertyT. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00299">299</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a1dc5afa27a05f32208067379bc763759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5afa27a05f32208067379bc763759">&#9670;&nbsp;</a></span>is_in_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::is_in_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the queue is in order or OoO. </p>
<p>Equivalent to <a class="el" href="classsycl_1_1__V1_1_1queue.html#ab576e60a52714370580b37ca9d6b43f4">has_property&lt;property::queue::in_order&gt;()</a> </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00318">318</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8cpp_source.html#l00358">ext_oneapi_get_last_event()</a>, <a class="el" href="queue_8cpp_source.html#l00371">ext_oneapi_set_external_event()</a>, and <a class="el" href="queue_8cpp_source.html#l00242">ext_oneapi_submit_barrier()</a>.</p>

</div>
</div>
<a id="a6d7f1da83fc43ae4f218317e81848422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7f1da83fc43ae4f218317e81848422">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00150">150</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ad4860bb2cb60c2dcda5c849950d78b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4860bb2cb60c2dcda5c849950d78b89">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00162">162</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aedc69b914e25d8e47f87cbd7ff7c7d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc69b914e25d8e47f87cbd7ff7c7d30">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00156">156</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="abc43813da13473a0c47e92c7d334dc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc43813da13473a0c47e92c7d334dc5a">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pi_8h.html#a286bf19d79f0e65f8137d269f037798b">pi_mem_advice</a>&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00144">144</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="acc7290fedb5358b72af57905654d5034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7290fedb5358b72af57905654d5034">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Dest</td><td>to copy to. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the operation dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01084">1084</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="annotated__arg_8hpp_source.html#l00191">sycl::_V1::ext::oneapi::experimental::has_property()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="handler_8cpp_source.html#l00040">sycl::_V1::detail::isDeviceGlobalUsedInKernel()</a>, <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>, <a class="el" href="handler_8cpp_source.html#l00947">sycl::_V1::handler::memcpy()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="abe131237b0b5f99cf8dfc03dec271c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe131237b0b5f99cf8dfc03dec271c22">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Dest</td><td>to copy to. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is a vector of event that specifies the operation dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01124">1124</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a58b045e5328f9e886b6a712daa5aae7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b045e5328f9e886b6a712daa5aae7e">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em> = <code>sizeof(T)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a USM memory region to a device_global. </p>
<p>Throws an exception if the copy operation intends to write outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dest,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is the destination device_glboal. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Dest</td><td>to copy to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01144">1144</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="af90e1a515e22fdf97b564c3692706a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90e1a515e22fdf97b564c3692706a30">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a device_global to USM memory. </p>
<p>Throws an exception if the copy operation intends to read outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Src</td><td>to copy from. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the operation dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01165">1165</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="annotated__arg_8hpp_source.html#l00191">sycl::_V1::ext::oneapi::experimental::has_property()</a>, <a class="el" href="namespacesycl_1_1__V1.html#a4d1eae6704d24c4b9abcef220dddc66bafedb2d84cafe20862cb4399751a8a7e3">sycl::_V1::invalid</a>, <a class="el" href="handler_8cpp_source.html#l00040">sycl::_V1::detail::isDeviceGlobalUsedInKernel()</a>, <a class="el" href="exception_8cpp_source.html#l00093">sycl::_V1::make_error_code()</a>, <a class="el" href="handler_8cpp_source.html#l00947">sycl::_V1::handler::memcpy()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ab98d18455f2818bd31ba5344e3ec4ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98d18455f2818bd31ba5344e3ec4ccc">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a device_global to USM memory. </p>
<p>Throws an exception if the copy operation intends to read outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Src</td><td>to copy from. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is a vector of event that specifies the operation dependency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01203">1203</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a8b05ef31f83050172245de0d3c8b2482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b05ef31f83050172245de0d3c8b2482">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1device__global.html">ext::oneapi::experimental::device_global</a>&lt; T, PropertyListT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NumBytes</em> = <code>sizeof(T)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a device_global to USM memory. </p>
<p>Throws an exception if the copy operation intends to read outside the memory range</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src,as</td><td>specified through</td></tr>
    <tr><td class="paramname">NumBytes</td><td>and </td></tr>
    <tr><td class="paramname">Offset.</td><td></td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to copy to. </td></tr>
    <tr><td class="paramname">Src</td><td>is the source device_global. </td></tr>
    <tr><td class="paramname">NumBytes</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">Offset</td><td>is the offset into</td></tr>
    <tr><td class="paramname">Src</td><td>to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01224">1224</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a123f9d1df9cbb040c4810d7a493bdcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123f9d1df9cbb040c4810d7a493bdcee">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00125">125</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a0aeec538d8c73d1eb5f0173e21b76db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeec538d8c73d1eb5f0173e21b76db6">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00137">137</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a4cd2d7facb527f42dca44e51c68bbd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd2d7facb527f42dca44e51c68bbd72">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, each is either a host pointer or a pointer within USM allocation accessible on the device associated with this queue. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00131">131</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a33a466db5791c5059a46afc86ae9eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a466db5791c5059a46afc86ae9eaff">&#9670;&nbsp;</a></span>memset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00106">106</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="reduction_8hpp_source.html#l01062">sycl::_V1::detail::reduction_impl_algo&lt; T, BinaryOperation, Dims, Extent, ExplicitIdentity, RedOutVar &gt;::getGroupsCounterAccDiscrete()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00197">syclcompat::detail::memset()</a>.</p>

</div>
</div>
<a id="adfb0ea45a86c61e592d6e3500c8b2d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb0ea45a86c61e592d6e3500c8b2d22">&#9670;&nbsp;</a></span>memset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00118">118</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aa950860f549487e12f91dacab74a61e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa950860f549487e12f91dacab74a61e0">&#9670;&nbsp;</a></span>memset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00112">112</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="afec588401fb7ece240784b8ca75df65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec588401fb7ece240784b8ca75df65c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00287">287</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a231c5ccd03c9cc98aad14ce6aba579a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231c5ccd03c9cc98aad14ce6aba579a9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a>&amp; sycl::_V1::queue::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f01aad4b97f245499297c5dca95fc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f01aad4b97f245499297c5dca95fc54">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a>&amp; sycl::_V1::queue::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5f8d57bb9a8cfb618bee5c41de86675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f8d57bb9a8cfb618bee5c41de86675">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sycl::_V1::queue::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00285">285</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a92a863f9a6ff8fcbeb49ca49245650d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a863f9a6ff8fcbeb49ca49245650d3">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global and local work spaces of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02370">2370</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a9c70f088df529c5a122977ca559f13c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c70f088df529c5a122977ca559f13c1">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global and local work spaces of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02346">2346</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="afd07249217a4004ca226b4816243f012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd07249217a4004ca226b4816243f012">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename PropertiesT , typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value &amp;&amp; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global and local work spaces of the kernel </td></tr>
    <tr><td class="paramname">Properties</td><td>is the kernel properties. </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02310">2310</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ad7b75add0622e612bfcec703c5351b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b75add0622e612bfcec703c5351b3e">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structsycl_1_1__V1_1_1detail_1_1AreAllButLastReductions.html">detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classsycl_1_1__V1_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global and local work spaces of the kernel </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02332">2332</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a3f5e1a4caaea58f07bffbe067f510867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5e1a4caaea58f07bffbe067f510867">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02172">2172</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a60e21434831efda508a95a1bd733de59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e21434831efda508a95a1bd733de59">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02135">2135</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a527f98ae3748efad819156017b27a0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527f98ae3748efad819156017b27a0ac">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02101">2101</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="launch_8hpp_source.html#l00059">syclcompat::detail::launch()</a>.</p>

</div>
</div>
<a id="afbc006afebe0519d5986526b210dc07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc006afebe0519d5986526b210dc07c">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02186">2186</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="aec1388baf7ec7886550bdfec5d7246d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1388baf7ec7886550bdfec5d7246d0">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02147">2147</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a8e9d2fe4cc216d6541e72e1b283ee400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9d2fe4cc216d6541e72e1b283ee400">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02112">2112</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a4216b8e73fef689ccd9a593921238d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4216b8e73fef689ccd9a593921238d46">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02200">2200</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a68eee60d0adf4ff332a2fe79e2cf178a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68eee60d0adf4ff332a2fe79e2cf178a">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02159">2159</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a6a5fbbb1f5bf6cd37e509eb890089111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5fbbb1f5bf6cd37e509eb890089111">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">Rest</td><td>acts as-if: "ReductionTypes&amp;&amp;... Reductions,
const KernelType &amp;KernelFunc". </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02123">2123</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a57bc0946b89b41305222e1981fd865dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bc0946b89b41305222e1981fd865dd">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02217">2217</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a05e06bb63d3816f2f65d7b57a8977d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e06bb63d3816f2f65d7b57a8977d5e">&#9670;&nbsp;</a></span>parallel_for_impl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02235">2235</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a6cf45c68d167868f887019c4cff49357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf45c68d167868f887019c4cff49357">&#9670;&nbsp;</a></span>parallel_for_impl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02283">2283</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="aa6dbb4df6cab8c97859f5d129c3f8e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dbb4df6cab8c97859f5d129c3f8e03">&#9670;&nbsp;</a></span>parallel_for_impl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::parallel_for_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Range</td><td>specifies the global work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02258">2258</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ae61f7ff23542bdca51cec9afcf60fa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61f7ff23542bdca51cec9afcf60fa5e">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00741">741</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00964">sycl::_V1::handler::prefetch()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a23c7953436cddfcd284af7d99a22ff7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c7953436cddfcd284af7d99a22ff7f">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00777">777</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l00964">sycl::_V1::handler::prefetch()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a7c6361603ff952beefe8b1c52a6633e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6361603ff952beefe8b1c52a6633e4">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00756">756</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, <a class="el" href="handler_8cpp_source.html#l00964">sycl::_V1::handler::prefetch()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="ab34cd87892dc0da20ad485ddbddc0f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34cd87892dc0da20ad485ddbddc0f6d">&#9670;&nbsp;</a></span>single_task() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01994">1994</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ac60ed6cf74ff022c8e0bde7e4b449e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60ed6cf74ff022c8e0bde7e4b449e5b">&#9670;&nbsp;</a></span>single_task() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02086">2086</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a4fbf1a2d03648b5078f889f4cd54e31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbf1a2d03648b5078f889f4cd54e31e">&#9670;&nbsp;</a></span>single_task() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Properties</td><td>is the kernel properties. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02057">2057</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="aabc4877fccd5d18b1e3c3a98010b97da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc4877fccd5d18b1e3c3a98010b97da">&#9670;&nbsp;</a></span>single_task() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02038">2038</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ae9d4c60daebb6910c571a33a1d05bbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d4c60daebb6910c571a33a1d05bbb4">&#9670;&nbsp;</a></span>single_task() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">Properties</td><td>is the kernel properties. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02011">2011</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l01439">sycl::_V1::handler::depends_on()</a>, and <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="a2f61a923d009189ef6a47aeb22333fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f61a923d009189ef6a47aeb22333fd1">&#9670;&nbsp;</a></span>single_task() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , typename PropertiesT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1is__property__list.html">ext::oneapi::experimental::is_property_list</a>&lt;PropertiesT&gt;::value, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::single_task </td>
          <td>(</td>
          <td class="paramtype">PropertiesT&#160;</td>
          <td class="paramname"><em>Properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(KernelFunc)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Properties</td><td>is the kernel properties. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01969">1969</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>.</p>

</div>
</div>
<a id="aedd6bd99dbc2249251e952a939ae97b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd6bd99dbc2249251e952a939ae97b8">&#9670;&nbsp;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_r_v&lt;void, T, <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::submit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a command group function object to the queue, in order to be scheduled for execution on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CGF</td><td>is a function object containing command group. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object for the submitted command group. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00340">340</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="oneapi_2kernel__properties_2properties_8hpp_source.html#l00127">sycl::_V1::ext::oneapi::experimental::device_has</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, <a class="el" href="bindless__images_8hpp_source.html#l01380">ext_oneapi_copy()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00173">ext_oneapi_copy2d()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00246">ext_oneapi_fill2d()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00145">ext_oneapi_memcpy2d()</a>, <a class="el" href="memcpy2d_8hpp_source.html#l00210">ext_oneapi_memset2d()</a>, <a class="el" href="queue_8cpp_source.html#l00242">ext_oneapi_submit_barrier()</a>, <a class="el" href="launch_8hpp_source.html#l00071">syclcompat::detail::launch()</a>, <a class="el" href="ext_2intel_2experimental_2pipes_8hpp_source.html#l00079">sycl::_V1::ext::intel::experimental::pipe&lt; _name, _dataT, _min_capacity, _propertiesT, class &gt;::read()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00083">sycl::_V1::ext::oneapi::experimental::submit_with_event()</a>, and <a class="el" href="ext_2intel_2experimental_2pipes_8hpp_source.html#l00108">sycl::_V1::ext::intel::experimental::pipe&lt; _name, _dataT, _min_capacity, _propertiesT, class &gt;::write()</a>.</p>

</div>
</div>
<a id="af359a1d5501184282c29ab476326c051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359a1d5501184282c29ab476326c051">&#9670;&nbsp;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_r_v&lt;void, T, <a class="el" href="classsycl_1_1__V1_1_1handler.html">handler</a> &amp;&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">event</a>&gt; sycl::_V1::queue::submit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>SecondaryQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a command group function object to the queue, in order to be scheduled for execution on the device. </p>
<p>On a kernel error, this command group function object is then scheduled for execution on a secondary queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CGF</td><td>is a function object containing command group. </td></tr>
    <tr><td class="paramname">SecondaryQueue</td><td>is a fallback SYCL queue. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00375">375</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="oneapi_2kernel__properties_2properties_8hpp_source.html#l00127">sycl::_V1::ext::oneapi::experimental::device_has</a>.</p>

</div>
</div>
<a id="afcde34e624f1c86d4d6f5e7a1506218e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcde34e624f1c86d4d6f5e7a1506218e">&#9670;&nbsp;</a></span>throw_asynchronous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::throw_asynchronous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any asynchronous errors have been produced by the queue and if so reports them to the async_handler passed on the queue construction. </p>
<p>If no async_handler was provided then asynchronous exceptions will be lost. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00104">104</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a6a7e65102366f103fcef293d7b2b4d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7e65102366f103fcef293d7b2b4d35">&#9670;&nbsp;</a></span>update_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access_mode Mode, target Tgt, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">event</a> sycl::_V1::queue::update_host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1accessor.html">accessor</a>&lt; T, Dims, <a class="el" href="namespacesycl_1_1__V1.html#a4cf7da32ec662adec405ef862ce9d8d5">Mode</a>, Tgt, <a class="el" href="namespacesycl_1_1__V1.html#aa5c718414e73c4bfe2f1d8eac8fd682a">IsPlaceholder</a> &gt;&#160;</td>
          <td class="paramname"><em>Acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides guarantees that the memory object accessed via Acc is updated on the host after operation is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Acc</td><td>is a SYCL accessor that needs to be updated on host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing update_host operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l02494">2494</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l01908">sycl::_V1::handler::require()</a>, <a class="el" href="enqueue__functions_8hpp_source.html#l00077">sycl::_V1::ext::oneapi::experimental::submit()</a>, and <a class="el" href="handler_8hpp_source.html#l02795">sycl::_V1::handler::update_host()</a>.</p>

</div>
</div>
<a id="a0ad311b7ee1ea5b4938724c6a87acdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad311b7ee1ea5b4938724c6a87acdb5">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a blocking wait for the completion of all enqueued tasks in the queue. </p>
<p>Synchronous errors will be reported through SYCL exceptions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00429">429</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="abf5c2435ff47951d394782fb8f23abf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5c2435ff47951d394782fb8f23abf9">&#9670;&nbsp;</a></span>wait_and_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::wait_and_throw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em> = <code><a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html#a02f65879e268ddfaea96a0ffdc9d4fa2">detail::code_location::current</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a blocking wait for the completion of all enqueued tasks in the queue. </p>
<p>Synchronous errors will be reported through SYCL exceptions. Asynchronous errors will be passed to the async_handler passed to the queue on construction. If no async_handler was provided then asynchronous exceptions will be lost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00443">443</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a8fc81c99ac1e04008401a5cf8781a11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc81c99ac1e04008401a5cf8781a11b">&#9670;&nbsp;</a></span>wait_and_throw_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::wait_and_throw_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxy method for wait_and_throw to forward the code location information to the implementation. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00204">204</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="af4adae7339424f51968212334daa4b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4adae7339424f51968212334daa4b85">&#9670;&nbsp;</a></span>wait_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sycl::_V1::queue::wait_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsycl_1_1__V1_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxy method for wait to forward the code location information to the implementation. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00200">200</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a71492293d0386f542d120a1fc3dfbb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71492293d0386f542d120a1fc3dfbb55">&#9670;&nbsp;</a></span>detail::createSyclObjFromImpl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespacesycl_1_1__V1_1_1detail.html#a7e4c6cf99258f4e1fcf88439ff4808f8">detail::createSyclObjFromImpl</a> </td>
          <td>(</td>
          <td class="paramtype">decltype(T::impl)&#160;</td>
          <td class="paramname"><em>ImplObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93c48c53733505713cf25f65c2d69a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c48c53733505713cf25f65c2d69a20">&#9670;&nbsp;</a></span>get_native</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;backend BackendName, class SyclObjectT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto get_native </td>
          <td>(</td>
          <td class="paramtype">const SyclObjectT &amp;&#160;</td>
          <td class="paramname"><em>Obj</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="namespacesycl_1_1__V1.html#a9c96775f520573d94ebaea3872b69f6d">backend_return_t</a>&lt; BackendName, SyclObjectT &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="backend_8hpp_source.html#l00136">136</a> of file <a class="el" href="backend_8hpp_source.html">backend.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6d33dacbc2f70eec8aedea4b1ca4607b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d33dacbc2f70eec8aedea4b1ca4607b">&#9670;&nbsp;</a></span>AsyncHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a>&amp; sycl::_V1::queue::AsyncHandler</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00243">243</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8cpp_source.html#l00039">queue()</a>.</p>

</div>
</div>
<a id="ac50726d3009266f6f9caa725b2b83cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50726d3009266f6f9caa725b2b83cc9">&#9670;&nbsp;</a></span>DeviceSelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdevice__selector.html">device_selector</a> &amp; sycl::_V1::queue::DeviceSelector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00229">229</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a103ac3f98e7947007f7693baf12ee8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103ac3f98e7947007f7693baf12ee8c1">&#9670;&nbsp;</a></span>PropList <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a>&amp; sycl::_V1::queue::PropList</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {})</div>
<div class="line">      : <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(<a class="code" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a>.select_device(), <a class="code" href="namespacesycl_1_1__V1_1_1detail.html#a54fe182c49d3483640d9284ebe0391d7">detail::defaultAsyncHandler</a>,</div>
<div class="line">              <a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>) {}</div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">  <a class="code" href="classsycl_1_1__V1_1_1queue.html#a561de199991e9fa5822ba75e54193726">__SYCL2020_DEPRECATED</a>(<span class="stringliteral">&quot;SYCL 1.2.1 device selectors are deprecated. Please &quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;use SYCL 2020 device selectors instead.&quot;</span>)</div>
<div class="line">  <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(const <a class="code" href="classdevice__selector.html">device_selector</a> &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a>,</div>
<div class="line">        const <a class="code" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, const property_list &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a> = {})</div>
<div class="line">      : <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(<a class="code" href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">DeviceSelector</a>.select_device(), <a class="code" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>, <a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>) {}</div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(<span class="keyword">const</span> device &amp;SyclDevice, <span class="keyword">const</span> property_list &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a> = {})</div>
<div class="line">      : <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(SyclDevice, <a class="code" href="namespacesycl_1_1__V1_1_1detail.html#a54fe182c49d3483640d9284ebe0391d7">detail::defaultAsyncHandler</a>, <a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a>) {}</div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line">  <span class="keyword">explicit</span> <a class="code" href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">queue</a>(<span class="keyword">const</span> device &amp;SyclDevice, <span class="keyword">const</span> <a class="code" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">AsyncHandler</a>,</div>
<div class="line">                 <span class="keyword">const</span> property_list &amp;<a class="code" href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">PropList</a> = {})</div>
<div class="ttc" id="aclassdevice__selector_html"><div class="ttname"><a href="classdevice__selector.html">device_selector</a></div></div>
<div class="ttc" id="aclasssycl_1_1__V1_1_1queue_html_a103ac3f98e7947007f7693baf12ee8c1"><div class="ttname"><a href="classsycl_1_1__V1_1_1queue.html#a103ac3f98e7947007f7693baf12ee8c1">sycl::_V1::queue::PropList</a></div><div class="ttdeci">const property_list &amp; PropList</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00189">queue.hpp:189</a></div></div>
<div class="ttc" id="aclasssycl_1_1__V1_1_1queue_html_a18897f997ae94d60bb1f3b3b51dfd6d5"><div class="ttname"><a href="classsycl_1_1__V1_1_1queue.html#a18897f997ae94d60bb1f3b3b51dfd6d5">sycl::_V1::queue::queue</a></div><div class="ttdeci">queue(const property_list &amp;PropList={})</div><div class="ttdoc">Constructs a SYCL queue instance using the device returned by an instance of default_selector.</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00111">queue.hpp:111</a></div></div>
<div class="ttc" id="aclasssycl_1_1__V1_1_1queue_html_a561de199991e9fa5822ba75e54193726"><div class="ttname"><a href="classsycl_1_1__V1_1_1queue.html#a561de199991e9fa5822ba75e54193726">sycl::_V1::queue::__SYCL2020_DEPRECATED</a></div><div class="ttdeci">__SYCL2020_DEPRECATED(&quot;SYCL 1.2.1 device selectors are deprecated. Please &quot; &quot;use SYCL 2020 device selectors instead.&quot;) queue(const device_selector &amp;DeviceSelector</div><div class="ttdoc">Constructs a SYCL queue instance using the device returned by the DeviceSelector provided.</div></div>
<div class="ttc" id="aclasssycl_1_1__V1_1_1queue_html_a6d33dacbc2f70eec8aedea4b1ca4607b"><div class="ttname"><a href="classsycl_1_1__V1_1_1queue.html#a6d33dacbc2f70eec8aedea4b1ca4607b">sycl::_V1::queue::AsyncHandler</a></div><div class="ttdeci">const device_selector const async_handler &amp; AsyncHandler</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00243">queue.hpp:243</a></div></div>
<div class="ttc" id="aclasssycl_1_1__V1_1_1queue_html_ac50726d3009266f6f9caa725b2b83cc9"><div class="ttname"><a href="classsycl_1_1__V1_1_1queue.html#ac50726d3009266f6f9caa725b2b83cc9">sycl::_V1::queue::DeviceSelector</a></div><div class="ttdeci">const device_selector &amp; DeviceSelector</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00229">queue.hpp:229</a></div></div>
<div class="ttc" id="anamespacesycl_1_1__V1_1_1detail_html_a54fe182c49d3483640d9284ebe0391d7"><div class="ttname"><a href="namespacesycl_1_1__V1_1_1detail.html#a54fe182c49d3483640d9284ebe0391d7">sycl::_V1::detail::defaultAsyncHandler</a></div><div class="ttdeci">void defaultAsyncHandler(exception_list Exceptions)</div><div class="ttdef"><b>Definition:</b> <a href="exception__list_8hpp_source.html#l00058">exception_list.hpp:58</a></div></div>
<div class="ttc" id="anamespacesycl_1_1__V1_html_ace2fa55964ec5168ef5e80d83a9c02f3"><div class="ttname"><a href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">sycl::_V1::async_handler</a></div><div class="ttdeci">std::function&lt; void(sycl::exception_list)&gt; async_handler</div><div class="ttdef"><b>Definition:</b> <a href="async__handler_8hpp_source.html#l00019">async_handler.hpp:19</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00189">189</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8cpp_source.html#l00039">queue()</a>.</p>

</div>
</div>
<a id="af1655b3de5a26ac436d3b0e2e9ab004f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1655b3de5a26ac436d3b0e2e9ab004f">&#9670;&nbsp;</a></span>PropList <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a>&amp; sycl::_V1::queue::PropList = {})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00230">230</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ae1a3f2aa46617a5baa0e0f20db0c1aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3f2aa46617a5baa0e0f20db0c1aed">&#9670;&nbsp;</a></span>PropList <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdevice__selector.html">device_selector</a> const <a class="el" href="namespacesycl_1_1__V1.html#ace2fa55964ec5168ef5e80d83a9c02f3">async_handler</a> const <a class="el" href="classsycl_1_1__V1_1_1property__list.html">property_list</a>&amp; sycl::_V1::queue::PropList = {})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00243">243</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/sycl/<a class="el" href="queue_8hpp_source.html">queue.hpp</a></li>
<li>include/sycl/ext/oneapi/<a class="el" href="bindless__images_8hpp_source.html">bindless_images.hpp</a></li>
<li>include/sycl/ext/oneapi/<a class="el" href="memcpy2d_8hpp_source.html">memcpy2d.hpp</a></li>
<li>source/<a class="el" href="queue_8cpp_source.html">queue.cpp</a></li>
<li>source/<a class="el" href="queue__v3_8cpp_source.html">queue_v3.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesycl.html">sycl</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1.html">_V1</a></li><li class="navelem"><a class="el" href="classsycl_1_1__V1_1_1queue.html">queue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
