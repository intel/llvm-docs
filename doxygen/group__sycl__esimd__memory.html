<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: Memory access API.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory access API.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ESIMD APIs to access memory via accessors, USM pointers, perform per-element atomic operations.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Memory access API.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory.png" border="0" usemap="#agroup____sycl____esimd____memory" alt=""/></div>
<map name="agroup____sycl____esimd____memory" id="agroup____sycl____esimd____memory">
<area shape="rect" href="group__sycl__esimd.html" title="This is a low&#45;level API providing direct access to Intel GPU hardware features." alt="" coords="5,177,192,203"/>
<area shape="rect" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="240,177,393,203"/>
<area shape="rect" href="group__sycl__esimd__raw__send.html" title="Implements the send instruction to send messages to variaous components of the Intel(R) processor gra..." alt="" coords="470,5,591,31"/>
<area shape="rect" href="group__sycl__esimd__memory__lsc.html" title="This group combines types and functions specific to LSC, which is available in Intel GPUs starting fr..." alt="" coords="451,55,610,95"/>
<area shape="rect" href="group__sycl__esimd__memory__atomics.html" title="Memory access functions which perform per&#45;lane atomic update using given operation." alt="" coords="441,120,620,145"/>
<area shape="rect" href="group__sycl__esimd__memory__block.html" title=" " alt="" coords="457,170,605,210"/>
<area shape="rect" href="group__sycl__esimd__memory__nbarrier.html" title=" " alt="" coords="455,235,607,260"/>
<area shape="rect" href="group__sycl__esimd__hw__thread__queries.html" title=" " alt="" coords="481,284,580,309"/>
<area shape="rect" href="group__sycl__esimd__memory__slm.html" title=" " alt="" coords="450,334,611,374"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__sycl__esimd__memory__atomics"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html">Atomic memory access.</a></td></tr>
<tr class="memdesc:group__sycl__esimd__memory__atomics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access functions which perform per-lane atomic update using given operation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__slm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html">Shared local memory access functions.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__block"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html">Block load/prefetch/store functions.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__lsc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html">LSC-specific memory access APIs.</a></td></tr>
<tr class="memdesc:group__sycl__esimd__memory__lsc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This group combines types and functions specific to LSC, which is available in Intel GPUs starting from PVC and ACM. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__nbarrier"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__nbarrier.html">Named barrier APIs.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__hw__thread__queries"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__hw__thread__queries.html">HW thread .</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__raw__send"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html">Raw send APIs.</a></td></tr>
<tr class="memdesc:group__sycl__esimd__raw__send"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the <code>send</code> instruction to send messages to variaous components of the Intel(R) processor graphics, as defined in the documentation at <a href="https://www.intel.com/content/www/us/en/docs/graphics-for-linux/developer-reference/1-0/hardware-specs.html">https://www.intel.com/content/www/us/en/docs/graphics-for-linux/developer-reference/1-0/hardware-specs.html</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga906135fd4810a79321d334ff5a6f917f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">sycl::_V1::ext::intel::esimd::fence_mask</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa352e1a80b6a794d0635d97bce7be7a99">sycl::_V1::ext::intel::esimd::global_coherent_fence</a> = 0x1
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917faecbd2e70ac0a720e0637bef6d3436f64">sycl::_V1::ext::intel::esimd::l2_flush_instructions</a> = 0x2
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fadbfc05dab2e2f87874de2d77b1fbd87e">sycl::_V1::ext::intel::esimd::l2_flush_texture_data</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa366cc36ca4e0f2747a4e8b7c92a316f1">sycl::_V1::ext::intel::esimd::l2_flush_constant_data</a> = 0x8
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa94e99d3ee1634b6ae3e5d556ef8de693">sycl::_V1::ext::intel::esimd::l2_flush_rw_data</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa3fb710e2fb45d755fb367baaf61c4d58">sycl::_V1::ext::intel::esimd::local_barrier</a> = 0x20
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa7555392d8038cb3d5f52d9d8f3394cb8">sycl::_V1::ext::intel::esimd::l1_flush_ro_data</a> = 0x40
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga906135fd4810a79321d334ff5a6f917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represetns a bit mask to control behavior of esimd::fence.  <a href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">More...</a><br /></td></tr>
<tr class="separator:ga906135fd4810a79321d334ff5a6f917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplParams" colspan="2">template&lt;typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__core.html#ga5f7fa652eebf3bdf4266307fd9cb1ed2">SurfaceIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">sycl::_V1::ext::intel::esimd::get_surface_index</a> (AccessorTy acc)</td></tr>
<tr class="memdesc:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get surface index corresponding to a SYCL accessor.  <a href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">More...</a><br /></td></tr>
<tr class="separator:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-1) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3)  <a href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">More...</a><br /></td></tr>
<tr class="separator:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb545348460db14b403c4923f4532764"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">More...</a><br /></td></tr>
<tr class="separator:gacb545348460db14b403c4923f4532764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">More...</a><br /></td></tr>
<tr class="separator:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-4) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">More...</a><br /></td></tr>
<tr class="separator:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac4176f6b0d7fc589e443f73c4315a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (usm-ga-5) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">More...</a><br /></td></tr>
<tr class="separator:gac4176f6b0d7fc589e443f73c4315a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaaaea88e37c82e73114d497ed3cba6048"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-6) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">More...</a><br /></td></tr>
<tr class="separator:gaaaea88e37c82e73114d497ed3cba6048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9908f885e11383b3d9ae90d12aef54a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-7) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">More...</a><br /></td></tr>
<tr class="separator:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-8) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">More...</a><br /></td></tr>
<tr class="separator:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1ff4da96a8c706907eb6275cac6c374a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-ga-9) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">More...</a><br /></td></tr>
<tr class="separator:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">sycl::_V1::ext::intel::esimd::gather</a> (const Tx *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7434161e9dec4e48d95379efe31e8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">More...</a><br /></td></tr>
<tr class="separator:ga7434161e9dec4e48d95379efe31e8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6599de1385f2655db2a9a800d5f00fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-1)  <a href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">More...</a><br /></td></tr>
<tr class="separator:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga157294a3866261bb5653b95c21d20dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">More...</a><br /></td></tr>
<tr class="separator:ga157294a3866261bb5653b95c21d20dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">More...</a><br /></td></tr>
<tr class="separator:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga757b89941e01477057602ad88da9912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-4)  <a href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">More...</a><br /></td></tr>
<tr class="separator:ga757b89941e01477057602ad88da9912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">sycl::_V1::ext::intel::esimd::scatter</a> (Tx *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaf371739a39a0af6f5676082708aa2d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">More...</a><br /></td></tr>
<tr class="separator:gaf371739a39a0af6f5676082708aa2d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">sycl::_V1::ext::intel::esimd::block_store</a> (Tx *addr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga364d8c4536dc36d2132adbd21f7e953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of memory at the given address <code>addr</code>.  <a href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">More...</a><br /></td></tr>
<tr class="separator:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; byte_offsets, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gac409b1352b9c6e41558277de95fa9b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_gather"></a>Accessor-based gather.  <a href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">More...</a><br /></td></tr>
<tr class="separator:gac409b1352b9c6e41558277de95fa9b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset)</td></tr>
<tr class="memdesc:gaa32a70edd8b9e78619e8625877debfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and broadcasts the element located at <code>acc</code> and byte offset <code>glob_offset</code> to a vector and returns it as a <a class="el" href="classsimd.html">simd</a> object.  <a href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">More...</a><br /></td></tr>
<tr class="separator:gaa32a70edd8b9e78619e8625877debfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0e451ceb76100adc0313158b6f37e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3)  <a href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">More...</a><br /></td></tr>
<tr class="separator:ga0e451ceb76100adc0313158b6f37e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3690bd1701c99a14d84d30f41cdde08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">More...</a><br /></td></tr>
<tr class="separator:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">More...</a><br /></td></tr>
<tr class="separator:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga20645123e4dcd440cb2bd220ab746ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-4) This function is identical to (acc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">More...</a><br /></td></tr>
<tr class="separator:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae8d131ce16330c0f088929e97f8bab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (acc-ga-5) This function is identical to (acc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">More...</a><br /></td></tr>
<tr class="separator:gae8d131ce16330c0f088929e97f8bab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-6) This function is identical to (acc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">More...</a><br /></td></tr>
<tr class="separator:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d43b1baaab951d4142e49e50d875a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">More...</a><br /></td></tr>
<tr class="separator:ga5d43b1baaab951d4142e49e50d875a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga767b97791462434ce040062cfe9ff819"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">More...</a><br /></td></tr>
<tr class="separator:ga767b97791462434ce040062cfe9ff819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1b1e1eef8e77177e7433f558e4521f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">More...</a><br /></td></tr>
<tr class="separator:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_scatter"></a>Accessor-based scatter.  <a href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">More...</a><br /></td></tr>
<tr class="separator:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2cea67d78dd64774281e59176dc1f204"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-2)  <a href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">More...</a><br /></td></tr>
<tr class="separator:ga2cea67d78dd64774281e59176dc1f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaadd878ac42b167a591ef02609ebbd12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-3)  <a href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">More...</a><br /></td></tr>
<tr class="separator:gaadd878ac42b167a591ef02609ebbd12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-4)  <a href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">More...</a><br /></td></tr>
<tr class="separator:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga097b8aadcd461c076d70226f01925390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets.  <a href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">More...</a><br /></td></tr>
<tr class="separator:ga097b8aadcd461c076d70226f01925390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1d32f7dd4b7ccb79e581b5a568085855">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">sycl::_V1::ext::intel::esimd::scalar_load</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> offset)</td></tr>
<tr class="memdesc:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from an accessor.  <a href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">More...</a><br /></td></tr>
<tr class="separator:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">sycl::_V1::ext::intel::esimd::scalar_store</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> offset, T val)</td></tr>
<tr class="memdesc:ga70654519014529d4217fee666d2bce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into an accessor.  <a href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">More...</a><br /></td></tr>
<tr class="separator:ga70654519014529d4217fee666d2bce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_gather_rgba"></a>Gather and transpose pixels from given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">More...</a><br /></td></tr>
<tr class="separator:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, OffsetSimdViewT offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49a890423f6afbba762d935b13200831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">More...</a><br /></td></tr>
<tr class="separator:ga49a890423f6afbba762d935b13200831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">More...</a><br /></td></tr>
<tr class="separator:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_scatter_rgba"></a>Transpose and scatter pixels to given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">More...</a><br /></td></tr>
<tr class="separator:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">More...</a><br /></td></tr>
<tr class="separator:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">More...</a><br /></td></tr>
<tr class="separator:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4cc43d10a1ffceca5170c191c13117e4">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;((N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">sycl::_V1::ext::intel::esimd::gather_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather and transpose pixels from the given memory locations defined by the base specified by <code>acc</code>, the global offset <code>global_offset</code> and a vector of offsets <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">More...</a><br /></td></tr>
<tr class="separator:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28490b843690be3630d11e68998cf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector.  <a href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">More...</a><br /></td></tr>
<tr class="separator:ga28490b843690be3630d11e68998cf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplParams" colspan="2">template&lt;uint8_t cntl&gt; </td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">sycl::_V1::ext::intel::esimd::fence</a> ()</td></tr>
<tr class="memdesc:ga6894e650e3d2d8252726536d4055aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">esimd::fence</a> sets the memory read/write order.  <a href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">More...</a><br /></td></tr>
<tr class="separator:ga6894e650e3d2d8252726536d4055aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2eefea21b6197da16a58d10ecb1d7a38">sycl::_V1::ext::intel::esimd::fence</a> (<a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">fence_mask</a> cntl)</td></tr>
<tr class="separator:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplParams" colspan="2">template&lt;memory_kind Kind = memory_kind::global, fence_flush_op FenceOp = fence_flush_op::none, fence_scope Scope = fence_scope::group&gt; </td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">sycl::_V1::ext::intel::esimd::fence</a> ()</td></tr>
<tr class="memdesc:ga671467f8fc485a53380db7359bb9c193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory fence.  <a href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">More...</a><br /></td></tr>
<tr class="separator:ga671467f8fc485a53380db7359bb9c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">sycl::_V1::ext::intel::esimd::barrier</a> ()</td></tr>
<tr class="memdesc:gaf339323c524d7aad3ef8d592c197d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group barrier.  <a href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">More...</a><br /></td></tr>
<tr class="separator:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, m *N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">sycl::_V1::ext::intel::esimd::media_block_load</a> (AccessorTy acc, unsigned x, unsigned y)</td></tr>
<tr class="memdesc:gacb4ea356b65d551c454e43430a266a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block load.  <a href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">More...</a><br /></td></tr>
<tr class="separator:gacb4ea356b65d551c454e43430a266a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">sycl::_V1::ext::intel::esimd::media_block_store</a> (AccessorTy acc, unsigned x, unsigned y, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, m *N &gt; vals)</td></tr>
<tr class="memdesc:ga7228e366d106365df6b40f4f192004ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block store.  <a href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">More...</a><br /></td></tr>
<tr class="separator:ga7228e366d106365df6b40f4f192004ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy , typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorTy acc, uint32_t byte_offset, Flags flags)</td></tr>
<tr class="memdesc:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given local-accessor <code>acc</code> and <code>byte_offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">More...</a><br /></td></tr>
<tr class="separator:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename Flags &gt; </td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, Flags flags)</td></tr>
<tr class="memdesc:ga3770b4bddea00af67e996df884f1310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of block_store that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">More...</a><br /></td></tr>
<tr class="separator:ga3770b4bddea00af67e996df884f1310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga46229a4f362e8ffae317a1b69ff22046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3)  <a href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">More...</a><br /></td></tr>
<tr class="separator:ga46229a4f362e8ffae317a1b69ff22046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">More...</a><br /></td></tr>
<tr class="separator:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf0e84c0a304d1986dc243b965c157834"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">More...</a><br /></td></tr>
<tr class="separator:gaf0e84c0a304d1986dc243b965c157834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-4) This function is identical to (lacc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">More...</a><br /></td></tr>
<tr class="separator:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (lacc-ga-5) This function is identical to (lacc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">More...</a><br /></td></tr>
<tr class="separator:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-6) This function is identical to (lacc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">More...</a><br /></td></tr>
<tr class="separator:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">sycl::_V1::ext::intel::esimd::gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gae8edb9934390ed9f0485689d7e21a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">More...</a><br /></td></tr>
<tr class="separator:gae8edb9934390ed9f0485689d7e21a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab4754c6fc7ec658643ff5552bc5907f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter that uses local accessor as a parameter template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-1)  <a href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">More...</a><br /></td></tr>
<tr class="separator:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-2)  <a href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">More...</a><br /></td></tr>
<tr class="separator:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7d1e59064714e4494d2f44bd48788b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-3)  <a href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">More...</a><br /></td></tr>
<tr class="separator:ga7d1e59064714e4494d2f44bd48788b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa204bc7f7a825040148c900e0b4e0a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-4)  <a href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">More...</a><br /></td></tr>
<tr class="separator:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac74cbc4141970dfbd259060d2597e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-1) void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2)  <a href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">More...</a><br /></td></tr>
<tr class="separator:gac74cbc4141970dfbd259060d2597e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">More...</a><br /></td></tr>
<tr class="separator:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac194ba4693e7c9aee73f63c959947f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (usm-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">More...</a><br /></td></tr>
<tr class="separator:gac194ba4693e7c9aee73f63c959947f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">More...</a><br /></td></tr>
<tr class="separator:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">More...</a><br /></td></tr>
<tr class="separator:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga68cb007526441a43e5a72668a52fc3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">More...</a><br /></td></tr>
<tr class="separator:ga68cb007526441a43e5a72668a52fc3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7ffd04632e53c13cae50f95c8266428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">More...</a><br /></td></tr>
<tr class="separator:ga7ffd04632e53c13cae50f95c8266428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0eb8934c359d7b74a1979513576ba0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, PropertyListT props = {}); // (usm-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">More...</a><br /></td></tr>
<tr class="separator:ga0eb8934c359d7b74a1979513576ba0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(usm-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">More...</a><br /></td></tr>
<tr class="separator:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, PropertyListT props={})</td></tr>
<tr class="memdesc:ga78527de7e485b381788e4b031b29b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, PropertyListT props = {}); // (usm-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">More...</a><br /></td></tr>
<tr class="separator:ga78527de7e485b381788e4b031b29b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga76862c56e39d4464ee6015f0c69ac537"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-1) void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2)  <a href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">More...</a><br /></td></tr>
<tr class="separator:ga76862c56e39d4464ee6015f0c69ac537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">More...</a><br /></td></tr>
<tr class="separator:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1aa325722f031578760777bc849efe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (acc-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">More...</a><br /></td></tr>
<tr class="separator:ga1aa325722f031578760777bc849efe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab1304b5dbfe4f787c09221b4e427b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">More...</a><br /></td></tr>
<tr class="separator:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gadc4bd79c567f680523a2277b67ce5a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">More...</a><br /></td></tr>
<tr class="separator:gadc4bd79c567f680523a2277b67ce5a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3b61e9602ee8be170bcba87227501525"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">More...</a><br /></td></tr>
<tr class="separator:ga3b61e9602ee8be170bcba87227501525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae5b4ee36004127672acde85ce8b05d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">More...</a><br /></td></tr>
<tr class="separator:gae5b4ee36004127672acde85ce8b05d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5629d544041ea068f46b2d16edbf528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, PropertyListT props = {}); // (acc-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">More...</a><br /></td></tr>
<tr class="separator:ga5629d544041ea068f46b2d16edbf528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab36701169020a7a0ac58009a54ea935"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(acc-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">More...</a><br /></td></tr>
<tr class="separator:gaab36701169020a7a0ac58009a54ea935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8876c22da7059ca756e04cd16da42218"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, PropertyListT props = {}); // (acc-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">More...</a><br /></td></tr>
<tr class="separator:ga8876c22da7059ca756e04cd16da42218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">sycl::_V1::ext::intel::esimd::load_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; load_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block load.  <a href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">More...</a><br /></td></tr>
<tr class="separator:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">sycl::_V1::ext::intel::esimd::prefetch_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, false, false&gt;(), typename PropertyListT = empty_properties_t&gt; void prefetch_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block prefetch.  <a href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">More...</a><br /></td></tr>
<tr class="separator:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">sycl::_V1::ext::intel::esimd::store_2d</a> (T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; Vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block store.  <a href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">More...</a><br /></td></tr>
<tr class="separator:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852c850b4bce5bfa54af798a2007ca9d"><td class="memTemplParams" colspan="2">template&lt;split_barrier_action flag&gt; </td></tr>
<tr class="memitem:ga852c850b4bce5bfa54af798a2007ca9d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga852c850b4bce5bfa54af798a2007ca9d">sycl::_V1::ext::intel::experimental::esimd::split_barrier</a> ()</td></tr>
<tr class="memdesc:ga852c850b4bce5bfa54af798a2007ca9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group split barrier.  <a href="group__sycl__esimd__memory.html#ga852c850b4bce5bfa54af798a2007ca9d">More...</a><br /></td></tr>
<tr class="separator:ga852c850b4bce5bfa54af798a2007ca9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233d1933f5a0d5c6de69c1b8feecc93e"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga233d1933f5a0d5c6de69c1b8feecc93e">sycl::_V1::ext::intel::experimental::esimd::split_barrier</a> (<a class="el" href="group__sycl__esimd__core.html#gafa86c8afcf13781bdecb4c245b402ee5">split_barrier_action</a> flag)</td></tr>
<tr class="separator:ga233d1933f5a0d5c6de69c1b8feecc93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ESIMD APIs to access memory via accessors, USM pointers, perform per-element atomic operations. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga906135fd4810a79321d334ff5a6f917f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga906135fd4810a79321d334ff5a6f917f">&#9670;&nbsp;</a></span>fence_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">sycl::_V1::ext::intel::esimd::fence_mask</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represetns a bit mask to control behavior of <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">esimd::fence</a>. </p>
<p>Enum elements define semantics of the bits in the mask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fa352e1a80b6a794d0635d97bce7be7a99"></a>global_coherent_fence&#160;</td><td class="fielddoc"><p>“Commit enable” - wait for fence to complete before continuing. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917faecbd2e70ac0a720e0637bef6d3436f64"></a>l2_flush_instructions&#160;</td><td class="fielddoc"><p>Flush the instruction cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0"></a>__SYCL_DEPRECATED&#160;</td><td class="fielddoc"><p>Creates a software (compiler) barrier, which does not generate any instruction and only prevents instruction scheduler from reordering instructions across this barrier at compile time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fadbfc05dab2e2f87874de2d77b1fbd87e"></a>l2_flush_texture_data&#160;</td><td class="fielddoc"><p>Flush sampler (texture) cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0"></a>__SYCL_DEPRECATED&#160;</td><td class="fielddoc"><p>Creates a software (compiler) barrier, which does not generate any instruction and only prevents instruction scheduler from reordering instructions across this barrier at compile time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fa366cc36ca4e0f2747a4e8b7c92a316f1"></a>l2_flush_constant_data&#160;</td><td class="fielddoc"><p>Flush constant cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0"></a>__SYCL_DEPRECATED&#160;</td><td class="fielddoc"><p>Creates a software (compiler) barrier, which does not generate any instruction and only prevents instruction scheduler from reordering instructions across this barrier at compile time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fa94e99d3ee1634b6ae3e5d556ef8de693"></a>l2_flush_rw_data&#160;</td><td class="fielddoc"><p>Flush constant cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0"></a>__SYCL_DEPRECATED&#160;</td><td class="fielddoc"><p>Creates a software (compiler) barrier, which does not generate any instruction and only prevents instruction scheduler from reordering instructions across this barrier at compile time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fa3fb710e2fb45d755fb367baaf61c4d58"></a>local_barrier&#160;</td><td class="fielddoc"><p>Issue SLM memory barrier only. If not set, the memory barrier is global. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fa7555392d8038cb3d5f52d9d8f3394cb8"></a>l1_flush_ro_data&#160;</td><td class="fielddoc"><p>Flush L1 read - only data cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0"></a>__SYCL_DEPRECATED&#160;</td><td class="fielddoc"><p>Creates a software (compiler) barrier, which does not generate any instruction and only prevents instruction scheduler from reordering instructions across this barrier at compile time. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07951">7951</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf339323c524d7aad3ef8d592c197d7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf339323c524d7aad3ef8d592c197d7ae">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic work-group barrier. </p>
<p>Performs barrier synchronization for all threads within the same thread group. The barrier instruction causes the executing thread to wait until all threads in the same thread group have executed the barrier instruction. Memory ordering is also guaranteed by this instruction. The behavior is undefined if this instruction is executed in divergent control flow. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08016">8016</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07953">sycl::_V1::ext::intel::esimd::global_coherent_fence</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07971">sycl::_V1::ext::intel::esimd::local_barrier</a>.</p>

<p class="reference">Referenced by <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00393">sycl::_V1::ext::intel::experimental::esimd::named_barrier_signal()</a>.</p>

</div>
</div>
<a id="ga88f61c5e7a95c1d17f66b3dbf06f6106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f61c5e7a95c1d17f66b3dbf06f6106">&#9670;&nbsp;</a></span>block_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy , typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of SLM memory referenced by the given local-accessor <code>acc</code> and <code>byte_offset</code>, then returns the loaded data as a simd object. </p>
<p>The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient gather is generated. If the loaded vector is too long for 1 flat-load GPU instruction, then a series of flat-loads and/or gathers may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Accessor type (auto-deduced). </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The local accessor. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>The offset to load from in bytes. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08133">8133</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3770b4bddea00af67e996df884f1310c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3770b4bddea00af67e996df884f1310c">&#9670;&nbsp;</a></span>block_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename Flags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of block_store that uses local accessor as a parameter. </p>
<p>Stores elements of the vector <code>vals</code> to a contiguous block of SLM memory represented by the given local accessor and the byte-offset <code>offset</code>. The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient scatter is generated. If the stored vector is too long for 1 flat-store GPU instruction, then a series of flat-store and/or scatters may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to store. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>Accessor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The local accessor to store to. </td></tr>
    <tr><td class="paramname">offset</td><td>The byte-offset to store at. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to store. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08160">8160</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga364d8c4536dc36d2132adbd21f7e953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364d8c4536dc36d2132adbd21f7e953b">&#9670;&nbsp;</a></span>block_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores elements of the vector <code>vals</code> to a contiguous block of memory at the given address <code>addr</code>. </p>
<p>The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient scatter is generated. If the stored vector is too long for 1 flat-store GPU instruction, then a series of flat-store and/or scatters may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to store. </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The memory address to store at. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to store. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01281">1281</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>.</p>

</div>
</div>
<a id="ga6894e650e3d2d8252726536d4055aa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6894e650e3d2d8252726536d4055aa0e">&#9670;&nbsp;</a></span>fence() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint8_t cntl&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">esimd::fence</a> sets the memory read/write order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cntl</td><td>A bitmask composed from <code>fence_mask</code> bits. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07983">7983</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga671467f8fc485a53380db7359bb9c193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga671467f8fc485a53380db7359bb9c193">&#9670;&nbsp;</a></span>fence() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;memory_kind Kind = memory_kind::global, fence_flush_op FenceOp = fence_flush_op::none, fence_scope Scope = fence_scope::group&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::fence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory fence. </p>
<p>Supported platforms: DG2, PVC</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Kind</td><td>is the memory kind. </td></tr>
    <tr><td class="paramname">FenceOp</td><td>is the fence cache flush operation to apply after fence. </td></tr>
    <tr><td class="paramname">Scope</td><td>is the fence operation scope. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07997">7997</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eedadb0f6f37ebeb6ea09489124345af2a45">sycl::_V1::ext::intel::esimd::group</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796af5ddaf0ca7929578b408c909429f68f2">sycl::_V1::ext::intel::esimd::local</a>, and <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818a334c4a4c42fdb79d7ebc3e73b517e6f8">sycl::_V1::ext::intel::esimd::none</a>.</p>

</div>
</div>
<a id="ga2eefea21b6197da16a58d10ecb1d7a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eefea21b6197da16a58d10ecb1d7a38">&#9670;&nbsp;</a></span>fence() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::fence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">fence_mask</a>&#160;</td>
          <td class="paramname"><em>cntl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l07986">7986</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa32a70edd8b9e78619e8625877debfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32a70edd8b9e78619e8625877debfc9">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>glob_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and broadcasts the element located at <code>acc</code> and byte offset <code>glob_offset</code> to a vector and returns it as a <a class="el" href="classsimd.html">simd</a> object. </p>
<p>Supported platforms: DG2/PVC if sizeof(T) &gt; 4 or the number of elements to load is not equal to 1, 8, 16, 32. Otherwise, it is supported on ALL platforms.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to gather from. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03324">3324</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1b1e1eef8e77177e7433f558e4521f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1e1eef8e77177e7433f558e4521f92">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-ga-9) This function is identical to (acc-ga-3) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03667">3667</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga767b97791462434ce040062cfe9ff819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767b97791462434ce040062cfe9ff819">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-8) This function is identical to (acc-ga-2) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03645">3645</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5d43b1baaab951d4142e49e50d875a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d43b1baaab951d4142e49e50d875a92">&#9670;&nbsp;</a></span>gather() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-7) This function is identical to (acc-ga-1) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03622">3622</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac409b1352b9c6e41558277de95fa9b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac409b1352b9c6e41558277de95fa9b71">&#9670;&nbsp;</a></span>gather() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>glob_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="accessor_gather"></a>Accessor-based gather. </p>
<p>Collects elements from memory referenced by the accessor <code>acc</code>, byte offsets <code>byte_offsets</code> and common offset \glob_offset, then returns the loaded elements as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<p>Supported platforms: DG2/PVC if sizeof(T) &gt; 4 or the number of elements to load is not equal to 1, 8, 16, 32. Otherwise, it is supported on ALL platforms.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to gather from. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed, their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03286">3286</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9bd99917636b94d50409d390ed3d53dda6bad67b5e8990b5f40b54dddd984ea08">sycl::_V1::ext::intel::esimd::detail::default_size</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00133">sycl::_V1::ext::intel::esimd::detail::gather_impl()</a>, and <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00096">sycl::_V1::ext::intel::esimd::detail::isPowerOf2()</a>.</p>

</div>
</div>
<a id="gae8d131ce16330c0f088929e97f8bab5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d131ce16330c0f088929e97f8bab5d">&#9670;&nbsp;</a></span>gather() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; std::is_same_v&lt;MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt;N&gt;&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaskT&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (acc-ga-5) This function is identical to (acc-ga-2) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and let user omit the template arguments and call the function as 'gather(acc, byte_offsets, mask);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03580">3580</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga20645123e4dcd440cb2bd220ab746ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20645123e4dcd440cb2bd220ab746ec1">&#9670;&nbsp;</a></span>gather() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; std::is_same_v&lt;MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt;N&gt;&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaskT&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-4) This function is identical to (acc-ga-1) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and let user omit the template arguments and call the function as 'gather(acc, byte_offsets, mask, pass_thru);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03554">3554</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf12e8c9393d9c731bdaf73f8d408b17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf12e8c9393d9c731bdaf73f8d408b17d">&#9670;&nbsp;</a></span>gather() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-6) This function is identical to (acc-ga-3) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and let user omit the template arguments and call the function as 'gather(acc, byte_offsets);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03600">3600</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3f30620c5263fd5c2a79059d05b4e3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f30620c5263fd5c2a79059d05b4e3e2">&#9670;&nbsp;</a></span>gather() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3) Supported platforms: DG2, PVC in most cases. </p>
<p>DG2/PVC is not required if VS == 1 and no L1/L2 cache hints used and sizeof(T) &lt;= 4 and N = {1,8,16,32}</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03525">3525</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3690bd1701c99a14d84d30f41cdde08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3690bd1701c99a14d84d30f41cdde08d">&#9670;&nbsp;</a></span>gather() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) Supported platforms: DG2, PVC in most cases. </p>
<p>DG2/PVC is not required if VS == 1 and no L1/L2 cache hints used and sizeof(T) &lt;= 4 and N = {1,8,16,32}</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (acc + byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03471">3471</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga0e451ceb76100adc0313158b6f37e866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e451ceb76100adc0313158b6f37e866">&#9670;&nbsp;</a></span>gather() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3) </p>
<p>The next 3 functions are similar to (acc-ga-1,2,3), but they don't have the template parameter 'VS'. These functions are added for convenience and to make it possible for user to omit the template parameters T and N, e.g. 'auto res = gather(acc, byte_offsets); template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-4) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (acc-ga-5) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-6)</p>
<p>The next 3 functions are similar to (acc-ga-1,2,3), but accept the <code>byte_offsets</code> as a <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> argument: template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-7) simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-8) simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-ga-9) template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-1) Supported platforms: DG2, PVC only - Temporary restriction for the variant with pass_thru operand. The only exception: DG2/PVC is not required if stateless memory mode is enforced via -fsycl-esimd-force-stateless-mem and VS == 1 and no L1/L2 cache hints passed and the __ESIMD_GATHER_SCATTER_LLVM_IR macro is used.</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (acc + byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03422">3422</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga81d896e0dbfd1d31f3052fd5484ecd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d896e0dbfd1d31f3052fd5484ecd5f">&#9670;&nbsp;</a></span>gather() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; std::is_same_v&lt;MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt;N&gt;&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaskT&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (lacc-ga-5) This function is identical to (lacc-ga-2) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and let user omit the template arguments and call the function as 'gather(acc, byte_offsets, mask);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08382">8382</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4ceac1668c5a35e5da1a90e8e3200875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ceac1668c5a35e5da1a90e8e3200875">&#9670;&nbsp;</a></span>gather() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; std::is_same_v&lt;MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt;N&gt;&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaskT&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-4) This function is identical to (lacc-ga-1) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and lets the user omit the template arguments and call the function as 'gather(acc, byte_offsets, mask, pass_thru);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08355">8355</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga361bb93f02b78ef43b5c78f3b9a14484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361bb93f02b78ef43b5c78f3b9a14484">&#9670;&nbsp;</a></span>gather() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-6) This function is identical to (lacc-ga-3) except that vector size is fixed to 1. </p>
<p>This variant is added for convenience and let user omit the template arguments and call the function as 'gather(acc, byte_offsets);'. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08403">8403</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf0e84c0a304d1986dc243b965c157834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e84c0a304d1986dc243b965c157834">&#9670;&nbsp;</a></span>gather() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3) Supported platforms: DG2, PVC in most cases. </p>
<p>DG2/PVC is not required if VS == 1 and the __ESIMD_GATHER_SCATTER_LLVM_IR macro is used or sizeof(T) &lt;= 4 and N = {1,2,4,8,16,32}</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08327">8327</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2d2f59b6d09c35bfe9f285fc50bb2029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2f59b6d09c35bfe9f285fc50bb2029">&#9670;&nbsp;</a></span>gather() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) Supported platforms: DG2, PVC in most cases. </p>
<p>DG2/PVC is not required if VS == 1 and the __ESIMD_GATHER_SCATTER_LLVM_IR macro is used or sizeof(T) &lt;= 4 and N = {1,2,4,8,16,32}</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (acc + byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08289">8289</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga46229a4f362e8ffae317a1b69ff22046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46229a4f362e8ffae317a1b69ff22046">&#9670;&nbsp;</a></span>gather() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of gather that uses local accessor as a parameter template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3) </p>
<p>The next 3 functions are similar to (lacc-ga-1,2,3), but they don't have the template parameter 'VS'. These functions are added for convenience and to make it possible for the user to omit the template parameters T and N, e.g. 'auto res = gather(acc, byte_offsets); template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-4) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});//(lacc-ga-5) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-6)</p>
<p>The next 3 functions are similar to (lacc-ga-1,2,3), but accept the <code>byte_offsets</code> as a <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> argument: template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-7) simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-8) simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (lacc-ga-9) template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-1) Supported platforms: DG2, PVC only - Temporary restriction for the variant with pass_thru operand. The only exception: DG2/PVC is not required if the __ESIMD_GATHER_SCATTER_LLVM_IR macro is used.</p>
<p>Loads ("gathers") elements of the type 'T' from memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (acc + byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08244">8244</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae8edb9934390ed9f0485689d7e21a00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8edb9934390ed9f0485689d7e21a00e">&#9670;&nbsp;</a></span>gather() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>glob_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of gather that uses local accessor as a parameter. </p>
<p>Collects elements located at given offsets in an accessor and returns them as a single <a class="el" href="classsimd.html">simd</a> object. An element can be a 1, 2 or 4-byte value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type; can only be a 1,2,4-byte integer, <code><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a></code> or <code>float</code>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. Can be <code>1</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to gather from. </td></tr>
    <tr><td class="paramname">offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed, their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08498">8498</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1ff4da96a8c706907eb6275cac6c374a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ff4da96a8c706907eb6275cac6c374a">&#9670;&nbsp;</a></span>gather() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-ga-9) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00604">604</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae9bd8b51383a95837bc3c04ea702aa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9bd8b51383a95837bc3c04ea702aa1d">&#9670;&nbsp;</a></span>gather() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-8) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00575">575</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga9908f885e11383b3d9ae90d12aef54a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9908f885e11383b3d9ae90d12aef54a1">&#9670;&nbsp;</a></span>gather() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-7) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00540">540</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaaaea88e37c82e73114d497ed3cba6048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaea88e37c82e73114d497ed3cba6048">&#9670;&nbsp;</a></span>gather() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-6) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00500">500</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac4176f6b0d7fc589e443f73c4315a937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4176f6b0d7fc589e443f73c4315a937">&#9670;&nbsp;</a></span>gather() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (usm-ga-5) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00474">474</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad1e9ee8a7af1db1da3c397728c4aa413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e9ee8a7af1db1da3c397728c4aa413">&#9670;&nbsp;</a></span>gather() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-4) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00442">442</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa152d4063042d8ad059e5fbc7bd8c758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa152d4063042d8ad059e5fbc7bd8c758">&#9670;&nbsp;</a></span>gather() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00407">407</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gacb545348460db14b403c4923f4532764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb545348460db14b403c4923f4532764">&#9670;&nbsp;</a></span>gather() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00348">348</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gacb9f0f82354b45e8fb2203c96b6e0210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9f0f82354b45e8fb2203c96b6e0210">&#9670;&nbsp;</a></span>gather() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-1) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3) </p>
<p>The next 3 functions are similar to the above and were added for convenience. They assume the VS parameter is set to 1 and do not require specifying the template parameters &lt;T, N, VS&gt; at function calls. template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-4) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (usm-ga-5) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-6)</p>
<p>The next 3 functions are variations of the first 3 above (usm-ga-1,2,3) and were added only to support <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> instead of simd for byte_offsets and/or pass_thru operands. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-7) simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-8) simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-ga-9) template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-1) Supported platforms: DG2, PVC only - Temporary restriction for the variant with pass_thru operand. Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00289">289</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7434161e9dec4e48d95379efe31e8308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7434161e9dec4e48d95379efe31e8308">&#9670;&nbsp;</a></span>gather() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>gather</code> API with <code>offsets</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type, must be of size 4 or less. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read; can be <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">offset</td><td>the scalar 32-bit or 64-bit offset in bytes. ((byte*)p + offset) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00622">622</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga12445cfacbfd6f5758d3e0d3daa4b6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12445cfacbfd6f5758d3e0d3daa4b6f8">&#9670;&nbsp;</a></span>gather_rgba() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;((N == 8 || N == 16 || N == 32) &amp;&amp; sizeof(T) == 4 &amp;&amp; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt; sycl::_V1::ext::intel::esimd::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>global_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather and transpose pixels from the given memory locations defined by the base specified by <code>acc</code>, the global offset <code>global_offset</code> and a vector of offsets <code>offsets</code>. </p>
<p>Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>RGBAMask</code>. Each pixel's address must be 4-byte aligned. For usage examples, see <a class="el" href="group__sycl__esimd__memory.html#usm_gather_rgba">usm_gather_rgba</a> above, the only difference would be the usage of an accessor instead of a usm pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RGBAMask</td><td>A pixel's channel mask. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type for the memory to be loaded/gathered. The returned vector elements must match the accessor data type. The loaded elements must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor representing memory address of the access. </td></tr>
    <tr><td class="paramname">offsets</td><td>Byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">global_offset</td><td>Byte offset of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04165">4165</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
<a id="ga49a890423f6afbba762d935b13200831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a890423f6afbba762d935b13200831">&#9670;&nbsp;</a></span>gather_rgba() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt; sycl::_V1::ext::intel::esimd::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">Mask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">offsets</td><td><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04003">4003</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga11a0bcf038027eb73c63a9e2a2b84dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a0bcf038027eb73c63a9e2a2b84dce">&#9670;&nbsp;</a></span>gather_rgba() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; sycl::_V1::ext::intel::esimd::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="usm_gather_rgba"></a>Gather and transpose pixels from given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>. </p>
<p>Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>Mask</code> template parameter. Each pixel's address must be 4 byte aligned. As an example, let's assume we want to read <code>n</code> pixels at address <code>addr</code>, skipping <code>G</code> and <code>B</code> channels. Each channel is a 32-bit float and the pixel data at given address in memory is: </p><div class="fragment"><div class="line">R1 G1 B1 A1 R2 G2 B2 A2 ... Rn Gn Bn An</div>
</div><!-- fragment --><p> Then this can be achieved by using </p><div class="fragment"><div class="line"><a class="code" href="classsimd.html">simd&lt;uint32_t, n&gt;</a> byte_offsets(0, 4*4 <span class="comment">/* byte size of a single pixel */</span>);</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="namespacesycl_1_1__V1.html#aeb98a006d1d0b7d9447fd33bea7afd4b">x</a> = gather_rgba&lt;float, n, rgba_channel_mask::AR&gt;(addr, byte_offsets);</div>
<div class="ttc" id="aclasssimd_html"><div class="ttname"><a href="classsimd.html">simd</a></div><div class="ttdef"><b>Definition:</b> <a href="std_2experimental_2simd_8hpp_source.html#l01387">simd.hpp:1387</a></div></div>
<div class="ttc" id="anamespacesycl_1_1__V1_html_aeb98a006d1d0b7d9447fd33bea7afd4b"><div class="ttname"><a href="namespacesycl_1_1__V1.html#aeb98a006d1d0b7d9447fd33bea7afd4b">sycl::_V1::x</a></div><div class="ttdeci">autodecltype(x) x</div><div class="ttdef"><b>Definition:</b> <a href="common__functions_8cpp_source.html#l00033">common_functions.cpp:33</a></div></div>
</div><!-- fragment --><p> Returned <code>x</code> will contain <code>2*n</code> <code>float</code> elements: </p><div class="fragment"><div class="line">R1 R2 ... Rn A1 A2 ... An</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">Mask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">offsets</td><td>vector of byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03973">3973</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, and <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>.</p>

</div>
</div>
<a id="gab48301f49cffd0e72ea23c49e6c4ed87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab48301f49cffd0e72ea23c49e6c4ed87">&#9670;&nbsp;</a></span>gather_rgba() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt; sycl::_V1::ext::intel::esimd::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">Mask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">offset</td><td>scalar byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04026">4026</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac1cffe68c0ac49b088dcadff58a6a2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1cffe68c0ac49b088dcadff58a6a2da">&#9670;&nbsp;</a></span>get_surface_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="group__sycl__esimd__core.html#ga5f7fa652eebf3bdf4266307fd9cb1ed2">SurfaceIndex</a> sycl::_V1::ext::intel::esimd::get_surface_index </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get surface index corresponding to a SYCL accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>a SYCL buffer or image accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the corresponding surface (aka "binding table index"). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">53</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00115">sycl::_V1::ext::intel::esimd::detail::SLM_BTI</a>.</p>

<p class="reference">Referenced by <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06287">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00981">sycl::_V1::ext::intel::esimd::detail::block_load_impl()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01199">sycl::_V1::ext::intel::esimd::detail::block_store_impl()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04165">sycl::_V1::ext::intel::esimd::gather_rgba()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08038">sycl::_V1::ext::intel::esimd::media_block_load()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08079">sycl::_V1::ext::intel::esimd::media_block_store()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04219">sycl::_V1::ext::intel::esimd::scatter_rgba()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05929">sycl::_V1::ext::intel::esimd::slm_atomic_update()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04943">sycl::_V1::ext::intel::esimd::slm_gather_rgba()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04961">sycl::_V1::ext::intel::esimd::slm_scatter_rgba()</a>.</p>

</div>
</div>
<a id="gaa4bb3bbc96f311cf8d34ac6879de5e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4bb3bbc96f311cf8d34ac6879de5e17">&#9670;&nbsp;</a></span>load_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::load_2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; load_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block load. </p>
<p>Supported platforms: PVC VISA instruction: lsc_load_block2d.ugm</p>
<p>Collects elements located at specified address and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">NBlocks</td><td>is the number of blocks. </td></tr>
    <tr><td class="paramname">Transposed</td><td>is the transposed version or not. </td></tr>
    <tr><td class="paramname">Transformed</td><td>is apply VNNI transform or not. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N, where N is BlockWidth * BlockHeight * NBlocks, if not transformed; otherwise, N = roundUpNextMultiple(BlockHeight, 4 / sizeof(T)) * getNextPowerOf2(BlockWidth) * NBlocks </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09457">9457</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gacb4ea356b65d551c454e43430a266a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb4ea356b65d551c454e43430a266a20">&#9670;&nbsp;</a></span>media_block_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, m * N&gt; sycl::_V1::ext::intel::esimd::media_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Media block load. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the element data type. </td></tr>
    <tr><td class="paramname">m</td><td>is the height of the 2D block. </td></tr>
    <tr><td class="paramname">N</td><td>is the width of the 2D block. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is type of the SYCL accessor. </td></tr>
    <tr><td class="paramname">plane</td><td>is planar surface index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">x</td><td>is X-coordinate of the left upper rectangle corner in BYTES. </td></tr>
    <tr><td class="paramname">y</td><td>is Y-coordinate of the left upper rectangle corner in ROWS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linearized 2D block data read from surface. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08038">8038</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
<a id="ga7228e366d106365df6b40f4f192004ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7228e366d106365df6b40f4f192004ba">&#9670;&nbsp;</a></span>media_block_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::media_block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, m *N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Media block store. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the element data type. </td></tr>
    <tr><td class="paramname">m</td><td>is the height of the 2D block. </td></tr>
    <tr><td class="paramname">N</td><td>is the width of the 2D block. </td></tr>
    <tr><td class="paramname">is</td><td>AccessorTy type of the SYCL accessor. </td></tr>
    <tr><td class="paramname">plane</td><td>is planar surface index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">x</td><td>is X-coordinate of the left upper rectangle corner in BYTES. </td></tr>
    <tr><td class="paramname">y</td><td>is Y-coordinate of the left upper rectangle corner in ROWS. </td></tr>
    <tr><td class="paramname">vals</td><td>is the linearized 2D block data to be written to surface. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08079">8079</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
<a id="ga3b61e9602ee8be170bcba87227501525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b61e9602ee8be170bcba87227501525">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[1/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-pf-6) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code> to the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09283">9283</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gadc4bd79c567f680523a2277b67ce5a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc4bd79c567f680523a2277b67ce5a77">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[2/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-5) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code> to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (acc + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09251">9251</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5629d544041ea068f46b2d16edbf528d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5629d544041ea068f46b2d16edbf528d">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[3/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt;OffsetT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, PropertyListT props = {}); // (acc-pf-8) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the accessor <code>acc</code>, and offset <code>byte_offset</code> and the length <code>VS</code> elements into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>offset from the base address </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09354">9354</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae5b4ee36004127672acde85ce8b05d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b4ee36004127672acde85ce8b05d7b">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[4/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt;OffsetT&gt; &amp;&amp; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-7) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the accessor <code>acc</code>, and offset <code>byte_offset</code> and the length <code>VS</code> elements into the cache. The maximum size of prefetched block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>VS</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>VS</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>VS</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>VS</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>offset from the base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. If it is set to 0, then the prefetch is omitted. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09321">9321</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8876c22da7059ca756e04cd16da42218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8876c22da7059ca756e04cd16da42218">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[5/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, PropertyListT props = {}); // (acc-pf-10) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the accessor <code>acc</code> and the length <code>VS</code> into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09405">9405</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02197">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch_2d()</a>.</p>

</div>
</div>
<a id="gaab1304b5dbfe4f787c09221b4e427b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab1304b5dbfe4f787c09221b4e427b87">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[6/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-4) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09215">9215</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1aa325722f031578760777bc849efe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa325722f031578760777bc849efe36">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[7/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (acc-pf-3) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the prefetch from (acc + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09187">9187</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[8/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09154">9154</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga76862c56e39d4464ee6015f0c69ac537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76862c56e39d4464ee6015f0c69ac537">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[9/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-1) void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2) </p>
<p>The next 2 functions are similar to the above and were added for convenience. They assume the VS parameter is set to 1 and do not require specifying the template parameters &lt;T, N, VS&gt; at function calls. template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (acc-pf-3) void prefetch(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-4) The next 2 functions are variations of the first 2 above (acc-pf-1,2) and were added only to support <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> instead of simd for byte_offsets operand. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {});//(acc-pf-5) void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); //(acc-pf-6)</p>
<p>The next functions perform transposed 1-channel prefetch. template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-7) void prefetch(AccessorT acc, OffsetT byte_offset, PropertyListT props = {}); // (acc-pf-8) template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-9) void prefetch(AccessorT acc, PropertyListT props = {}); // (acc-pf-10) template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-1) Supported platforms: DG2, PVC only. Prefetches elements of the type 'T' from memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>, to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the prefetch from (acc + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of offsets in bytes. If force stateless memory is used the offsets can be up to 64 bit size, otherwise up to 32 bit size. For each i, (acc + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09118">9118</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaab36701169020a7a0ac58009a54ea935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab36701169020a7a0ac58009a54ea935">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[10/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(acc-pf-9) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the accessor <code>acc</code> and the length <code>VS</code> elements into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to load. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. If it is set to 0, then the prefetch is omitted. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09382">9382</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga68cb007526441a43e5a72668a52fc3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68cb007526441a43e5a72668a52fc3d4">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[11/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-pf-6) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code> to the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08932">8932</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga23c5e7c8323cdcf85d018fbf4299b698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23c5e7c8323cdcf85d018fbf4299b698">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[12/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-5) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code> to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (p + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08904">8904</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga0eb8934c359d7b74a1979513576ba0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb8934c359d7b74a1979513576ba0be">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[13/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt;OffsetT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, PropertyListT props = {}); // (usm-pf-8) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the base pointer <code>p</code>, and offset <code>byte_offset</code> and the length <code>VS</code> elements into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>offset from the base address </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08995">8995</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7ffd04632e53c13cae50f95c8266428e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ffd04632e53c13cae50f95c8266428e">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[14/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt;OffsetT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-7) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the base pointer <code>p</code>, and offset <code>byte_offset</code> and the length <code>VS</code> elements into the cache. The maximum size of a prefetched block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) is equal to 8 the address must be 8-byte aligned. Also, 8-byte alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>VS</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>VS</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>VS</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>VS</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offset</td><td>offset from the base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. If it is set to 0, then the prefetch is omitted. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08968">8968</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga78527de7e485b381788e4b031b29b39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78527de7e485b381788e4b031b29b39c">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[15/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, PropertyListT props = {}); // (usm-pf-10) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the base pointer <code>p</code> and the length <code>VS</code> into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09042">9042</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2c0b6e34163d6dabbab61d2681c07c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c0b6e34163d6dabbab61d2681c07c93">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[16/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-4) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08873">8873</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac194ba4693e7c9aee73f63c959947f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac194ba4693e7c9aee73f63c959947f76">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[17/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (usm-pf-3) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the prefetch from (p + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08848">8848</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac311042ed7d2a3446ad9ab78b9f7d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac311042ed7d2a3446ad9ab78b9f7d505">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[18/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08818">8818</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac74cbc4141970dfbd259060d2597e08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac74cbc4141970dfbd259060d2597e08e">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[19/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-1) void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2) </p>
<p>The next 2 functions are similar to the above and were added for convenience. They assume the VS parameter is set to 1 and do not require specifying the template parameters &lt;T, N, VS&gt; at function calls. template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (usm-pf-3) void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-4) The next 2 functions are variations of the first 2 above (usm-pf-1,2) and were added only to support <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> instead of simd for byte_offsets operand. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-5) void prefetch(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-pf-6)</p>
<p>The next functions perform transposed 1-channel prefetch. template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-7) void prefetch(const T *p, OffsetT byte_offset, PropertyListT props = {}); // (usm-pf-8) template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-9) void prefetch(const T *p, PropertyListT props = {}); //(usm-pf-10) template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-1) Supported platforms: DG2, PVC only. Prefetches elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, to the cache. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the prefetch from (p + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08790">8790</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf2d595c9381e5a0414aeb53b548f2c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d595c9381e5a0414aeb53b548f2c83">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[20/20]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(usm-pf-9) Supported platforms: DG2, PVC only. </p>
<p>Prefetches elements of the type 'T' from continuous memory location addressed by the base pointer <code>p</code> and the length <code>VS</code> elements into the cache. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It specifies the number of consequent elements to prefetch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. If it is set to 0, then the prefetch is omitted. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09021">9021</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6283ab7040a03799e7b3aee0f1be6afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6283ab7040a03799e7b3aee0f1be6afc">&#9670;&nbsp;</a></span>prefetch_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::prefetch_2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, false, false&gt;(), typename PropertyListT = empty_properties_t&gt; void prefetch_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block prefetch. </p>
<p>Supported platforms: PVC VISA instruction: lsc_load_block2d.ugm</p>
<p>Prefetches elements located at specified address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">NBlocks</td><td>is the number of blocks. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
    <tr><td class="paramname">props</td><td>The compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09500">9500</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2f837b1a07e95b6f9a73947d71d36c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f837b1a07e95b6f9a73947d71d36c6e">&#9670;&nbsp;</a></span>scalar_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API T sycl::_V1::ext::intel::esimd::scalar_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a scalar value from an accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Type of the accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to load from. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03916">3916</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga70654519014529d4217fee666d2bce0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70654519014529d4217fee666d2bce0d">&#9670;&nbsp;</a></span>scalar_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::scalar_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a scalar value into an accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Type of the accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to store to. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes. </td></tr>
    <tr><td class="paramname">val</td><td>The stored value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03931">3931</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa204bc7f7a825040148c900e0b4e0a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa204bc7f7a825040148c900e0b4e0a21">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-4) </p>
<p>Writes ("scatters") elements of the input vector to memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08688">8688</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7d1e59064714e4494d2f44bd48788b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d1e59064714e4494d2f44bd48788b36">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-3) </p>
<p>Writes ("scatters") elements of the input vector to memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. Access to any element's memory location can be disabled via the input mask. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08650">8650</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gacb2c6a4ee8b73ab52f75a66877fa5a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb2c6a4ee8b73ab52f75a66877fa5a46">&#9670;&nbsp;</a></span>scatter() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-2) </p>
<p>Writes ("scatters") elements of the input vector to memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08608">8608</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab4754c6fc7ec658643ff5552bc5907f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4754c6fc7ec658643ff5552bc5907f7">&#9670;&nbsp;</a></span>scatter() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of scatter that uses local accessor as a parameter template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-1) </p>
<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-2) The next two functions are similar to lacc-sc-{1,2} with the 'byte_offsets' parameter represerented as '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>'. template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-3) template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-4) template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-1)</p>
<p>Writes ("scatters") elements of the input vector to memory locations addressed by the local accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. Access to any element's memory location can be disabled via the input mask. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08573">8573</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1d32f7dd4b7ccb79e581b5a568085855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d32f7dd4b7ccb79e581b5a568085855">&#9670;&nbsp;</a></span>scatter() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>glob_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03889">3889</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac5378beb33dbb1ada7aa21df6a2edcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5378beb33dbb1ada7aa21df6a2edcbd">&#9670;&nbsp;</a></span>scatter() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorTy, detail::accessor_mode_cap::can_write&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-4) </p>
<p>Stores ("scatters") elements of the type 'T' to memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to store. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, (acc + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03850">3850</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaadd878ac42b167a591ef02609ebbd12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd878ac42b167a591ef02609ebbd12b">&#9670;&nbsp;</a></span>scatter() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorTy, detail::accessor_mode_cap::can_write&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-3) </p>
<p>Stores ("scatters") elements of the type 'T' to memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the store to (acc + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to store. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, (acc + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03816">3816</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga097b8aadcd461c076d70226f01925390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097b8aadcd461c076d70226f01925390">&#9670;&nbsp;</a></span>scatter() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>glob_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets. </p>
<p>An element can be a 1, 2 or 4-byte value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type; can only be a 1,2,4-byte integer, <code><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a></code> or <code>float</code>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. Can be <code>1</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>Values to write. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03877">3877</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2cea67d78dd64774281e59176dc1f204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cea67d78dd64774281e59176dc1f204">&#9670;&nbsp;</a></span>scatter() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorTy, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-2) </p>
<p>Stores ("scatters") elements of the type 'T' to memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to store. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, (acc + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03776">3776</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6dca741e4dcb7ee702fe8b19684c445e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dca741e4dcb7ee702fe8b19684c445e">&#9670;&nbsp;</a></span>scatter() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt;AccessorTy, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="accessor_scatter"></a>Accessor-based scatter. </p>
<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-1)</p>
<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-2) The following two functions are similar to acc-sc-{1,2} with the 'byte_offsets' parameter represented as '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>'. template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {});// (acc-sc-3)</p>
<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-4)</p>
<p>template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-1)</p>
<p>Stores ("scatters") elements of the type 'T' to memory locations addressed by the accessor <code>acc</code> and byte offsets <code>byte_offsets</code>. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the store to (acc + byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor referencing the data to store. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, (acc + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l03729">3729</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga757b89941e01477057602ad88da9912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga757b89941e01477057602ad88da9912f">&#9670;&nbsp;</a></span>scatter() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-4) </p>
<p>Writes ("scatters") elements of the input vector to different memory locations. Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00823">823</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga06f2b46b3a704cdf02dc7f44b7a7ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06f2b46b3a704cdf02dc7f44b7a7ae80">&#9670;&nbsp;</a></span>scatter() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes ("scatters") elements of the input vector to different memory locations. </p>
<p>Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. Access to any element's memory location can be disabled via the input mask. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes represented as a '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>' object. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00790">790</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga157294a3866261bb5653b95c21d20dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga157294a3866261bb5653b95c21d20dd2">&#9670;&nbsp;</a></span>scatter() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes ("scatters") elements of the input vector to different memory locations. </p>
<p>Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00754">754</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6599de1385f2655db2a9a800d5f00fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6599de1385f2655db2a9a800d5f00fc6">&#9670;&nbsp;</a></span>scatter() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-1) </p>
<p>template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-2) The next two functions are similar to usm-sc-{1,2} with the 'byte_offsets' parameter represented as '<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a>'. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-3) template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-4) template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-1)</p>
<p>Writes ("scatters") elements of the input vector to different memory locations. Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. Access to any element's memory location can be disabled via the input mask. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit or 64-bit offsets in bytes. For each i, ((byte*)p + byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' and cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00677">677</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf371739a39a0af6f5676082708aa2d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf371739a39a0af6f5676082708aa2d56">&#9670;&nbsp;</a></span>scatter() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; N == 1&gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>scatter</code> API with <code>offsets</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type, must be of size 4 or less. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write; can be <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">offset</td><td>the scalar 32-bit or 64-bit offset in bytes. ((byte*)p + offset) must be element size aligned. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00842">842</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga28490b843690be3630d11e68998cf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28490b843690be3630d11e68998cf1ee">&#9670;&nbsp;</a></span>scatter_rgba() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; sizeof(T) == 4 &amp;&amp; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>&#160;</td>
          <td class="paramname"><em>global_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector. </p>
<p>See <a class="el" href="group__sycl__esimd__memory.html#usm_gather_rgba">usm_gather_rgba</a> for information about the operation semantics and parameter restrictions/interdependencies. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RGBAMask</td><td>Pixel's channel mask. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type for the memory to be stored/scattered. The returned vector elements must match the accessor data type. The loaded elements must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>Byte offsets of each element. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">global_offset</td><td>Byte offset of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask. All-1 by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04219">4219</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
<a id="ga66b12c692e0ca18d800cee6a69e0feb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b12c692e0ca18d800cee6a69e0feb3">&#9670;&nbsp;</a></span>scatter_rgba() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &gt; sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">RGBAMask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">offsets</td><td><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> of byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04095">4095</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5fc3a281fe76ceb10fd300fac222ce93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc3a281fe76ceb10fd300fac222ce93">&#9670;&nbsp;</a></span>scatter_rgba() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="usm_scatter_rgba"></a>Transpose and scatter pixels to given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>. </p>
<p>Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>RGBAMask</code>. Each pixel's address must be 4 byte aligned. This is basically an inverse operation for gather_rgba. Unlike <code>gather_rgba</code>, this function imposes restrictions on possible <code>Mask</code> template argument values. It can only be one of the following: <code>ABGR</code>, <code>BGR</code>, <code>GR</code>, <code>R</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">RGBAMask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">offsets</td><td>vector of byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04063">4063</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, and <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>.</p>

</div>
</div>
<a id="ga4cc43d10a1ffceca5170c191c13117e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc43d10a1ffceca5170c191c13117e4">&#9670;&nbsp;</a></span>scatter_rgba() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std:: enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; sizeof(T) == 4&gt; sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04128">4128</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga98181703f7fe46bc0803f3c7365f4ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98181703f7fe46bc0803f3c7365f4ca2">&#9670;&nbsp;</a></span>scatter_rgba() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; N == 1&gt; sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">RGBAMask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">offset</td><td>scalar byte offset of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04119">4119</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga852c850b4bce5bfa54af798a2007ca9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852c850b4bce5bfa54af798a2007ca9d">&#9670;&nbsp;</a></span>split_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;split_barrier_action flag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::split_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic work-group split barrier. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">flag</td><td>- split barrier action. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00029">29</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga233d1933f5a0d5c6de69c1b8feecc93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233d1933f5a0d5c6de69c1b8feecc93e">&#9670;&nbsp;</a></span>split_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::split_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core.html#gafa86c8afcf13781bdecb4c245b402ee5">split_barrier_action</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00034">34</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4097686b52cc7f8d0ae2a9dfb327193d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4097686b52cc7f8d0ae2a9dfb327193d">&#9670;&nbsp;</a></span>store_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::store_2d </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>Vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D USM pointer block store. </p>
<p>Supported platforms: PVC VISA instruction: lsc_store_block2d.ugm</p>
<p>Stores elements at specified address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
    <tr><td class="paramname">Vals</td><td>is a vector to store of type T and size N, where N = BlockWidth * BlockHeight </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only cache hint properties are used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09536">9536</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
