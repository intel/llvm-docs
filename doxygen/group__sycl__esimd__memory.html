<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: Memory access API.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI Data Parallel C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory access API.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ESIMD APIs to access memory via accessors, USM pointers, perform per-element atomic operations.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Memory access API.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory.png" border="0" usemap="#group____sycl____esimd____memory" alt=""/></div>
<map name="group____sycl____esimd____memory" id="group____sycl____esimd____memory">
<area shape="rect" href="group__sycl__esimd.html" title="This is a low&#45;level API providing direct access to Intel GPU hardware features. ESIMD overview can be..." alt="" coords="5,80,192,105"/>
<area shape="rect" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="240,80,393,105"/>
<area shape="rect" href="group__sycl__esimd__memory__lsc.html" title=" " alt="" coords="441,5,631,31"/>
<area shape="rect" href="group__sycl__esimd__memory__atomics.html" title="Memory access functions which perform per&#45;lane atomic update using given operation...." alt="" coords="447,55,625,80"/>
<area shape="rect" href="group__sycl__esimd__memory__nbarrier.html" title=" " alt="" coords="460,104,612,129"/>
<area shape="rect" href="group__sycl__esimd__memory__slm.html" title=" " alt="" coords="455,154,617,194"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__sycl__esimd__memory__atomics"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html">Atomic memory access.</a></td></tr>
<tr class="memdesc:group__sycl__esimd__memory__atomics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory access functions which perform per-lane atomic update using given operation. "Per-lane" means that the atomicity guarantees of a vector atomic operation are the same as of N independent scalar atomic operations per lane (N is number of lanes). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__slm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html">Shared local memory access functions.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__nbarrier"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__nbarrier.html">Named barrier APIs.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__sycl__esimd__memory__lsc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html">LSC memory access APIs.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga83287b408425557fe20fb6a0f2780843"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga83287b408425557fe20fb6a0f2780843">__ESIMD_GET_SURF_HANDLE</a>(acc)&#160;&#160;&#160;get_surface_index(acc)</td></tr>
<tr class="separator:ga83287b408425557fe20fb6a0f2780843"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga658410cbb58b368bd2f0849dcc630f30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga658410cbb58b368bd2f0849dcc630f30">cl::__ESIMD_NS::fence_mask</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30afd897b249e67ab97244358d50d2782dc">cl::__ESIMD_NS::global_coherent_fence</a> = 0x1, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30abe21832b9b41608507f3353504e9f094">cl::__ESIMD_NS::l3_flush_instructions</a> = 0x2, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30ab2e7b06ddda154f239271c292cf2bf42">cl::__ESIMD_NS::l3_flush_texture_data</a> = 0x4, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30aba15e53179ebbc82a88a729b3909234b">cl::__ESIMD_NS::l3_flush_constant_data</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30a7992ba76348b6a6737aa76b2b64abd98">cl::__ESIMD_NS::l3_flush_rw_data</a> = 0x10, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30a43c36a5d31ec430ada80f411f0e04406">cl::__ESIMD_NS::local_barrier</a> = 0x20, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30a9548898fce7e3bb8f837ce67b543716c">cl::__ESIMD_NS::l1_flush_ro_data</a> = 0x40, 
<a class="el" href="group__sycl__esimd__memory.html#gga658410cbb58b368bd2f0849dcc630f30a8f8d2636030186874754276cf69dd69c">cl::__ESIMD_NS::sw_barrier</a> = 0x80
<br />
 }</td></tr>
<tr class="memdesc:ga658410cbb58b368bd2f0849dcc630f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represetns a bit mask to control behavior of esimd::fence.  <a href="group__sycl__esimd__memory.html#ga658410cbb58b368bd2f0849dcc630f30">More...</a><br /></td></tr>
<tr class="separator:ga658410cbb58b368bd2f0849dcc630f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d32978ca634000ff9b80ec5721e25e6"><td class="memTemplParams" colspan="2">template&lt;typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga7d32978ca634000ff9b80ec5721e25e6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__core.html#ga6c38ddcda4183107e0d18d0a4ff31806">SurfaceIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7d32978ca634000ff9b80ec5721e25e6">cl::__ESIMD_NS::get_surface_index</a> (AccessorTy acc)</td></tr>
<tr class="memdesc:ga7d32978ca634000ff9b80ec5721e25e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get surface index corresponding to a SYCL accessor.  <a href="group__sycl__esimd__memory.html#ga7d32978ca634000ff9b80ec5721e25e6">More...</a><br /></td></tr>
<tr class="separator:ga7d32978ca634000ff9b80ec5721e25e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefa3e17ffd3d3387ed511b4674eac904"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:gaefa3e17ffd3d3387ed511b4674eac904"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::isPowerOf2(N, 32), <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaefa3e17ffd3d3387ed511b4674eac904">cl::__ESIMD_NS::gather</a> (const Tx *p, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaefa3e17ffd3d3387ed511b4674eac904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads ("gathers") elements from different memory locations and returns a vector of them.  <a href="group__sycl__esimd__memory.html#gaefa3e17ffd3d3387ed511b4674eac904">More...</a><br /></td></tr>
<tr class="separator:gaefa3e17ffd3d3387ed511b4674eac904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f535e9230b4007618513cd75711fe1"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:gae6f535e9230b4007618513cd75711fe1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::isPowerOf2(N, 32)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae6f535e9230b4007618513cd75711fe1">cl::__ESIMD_NS::scatter</a> (Tx *p, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gae6f535e9230b4007618513cd75711fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#gae6f535e9230b4007618513cd75711fe1">More...</a><br /></td></tr>
<tr class="separator:gae6f535e9230b4007618513cd75711fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7859aa2448dbc52af444a809e9288e"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = vector_aligned_tag, class T  = detail::__raw_t&lt;Tx&gt;, typename  = std::enable_if_t&lt;is_simd_flag_type_v&lt;Flags&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga7d7859aa2448dbc52af444a809e9288e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7d7859aa2448dbc52af444a809e9288e">cl::__ESIMD_NS::block_load</a> (const Tx *addr, Flags={})</td></tr>
<tr class="memdesc:ga7d7859aa2448dbc52af444a809e9288e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from given memory address and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory.html#ga7d7859aa2448dbc52af444a809e9288e">More...</a><br /></td></tr>
<tr class="separator:ga7d7859aa2448dbc52af444a809e9288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a455b602a2bdc85fd680f53f4893d6f"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;is_simd_flag_type_v&lt;Flags&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:ga7a455b602a2bdc85fd680f53f4893d6f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7a455b602a2bdc85fd680f53f4893d6f">cl::__ESIMD_NS::block_load</a> (AccessorTy acc, uint32_t offset, Flags={})</td></tr>
<tr class="memdesc:ga7a455b602a2bdc85fd680f53f4893d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from given accessor and offset and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory.html#ga7a455b602a2bdc85fd680f53f4893d6f">More...</a><br /></td></tr>
<tr class="separator:ga7a455b602a2bdc85fd680f53f4893d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1065610d35693e1faa004a32c47fa212"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:ga1065610d35693e1faa004a32c47fa212"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1065610d35693e1faa004a32c47fa212">cl::__ESIMD_NS::block_store</a> (Tx *p, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt; vals)</td></tr>
<tr class="memdesc:ga1065610d35693e1faa004a32c47fa212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of a vector to a contiguous block of memory at given address.  <a href="group__sycl__esimd__memory.html#ga1065610d35693e1faa004a32c47fa212">More...</a><br /></td></tr>
<tr class="separator:ga1065610d35693e1faa004a32c47fa212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eaef94d00241d4703f2a722547678dc"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename AccessorTy , class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:ga2eaef94d00241d4703f2a722547678dc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2eaef94d00241d4703f2a722547678dc">cl::__ESIMD_NS::block_store</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt; vals)</td></tr>
<tr class="memdesc:ga2eaef94d00241d4703f2a722547678dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of a vector to a contiguous block of memory represented by an accessor and an offset within this accessor.  <a href="group__sycl__esimd__memory.html#ga2eaef94d00241d4703f2a722547678dc">More...</a><br /></td></tr>
<tr class="separator:ga2eaef94d00241d4703f2a722547678dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3179c8fc63af2bd2d647b9e66073d0cc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga3179c8fc63af2bd2d647b9e66073d0cc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(sizeof(<a class="el" href="classT.html">T</a>)&lt;=4) &amp;&amp;(N==1||N==8||N==16||N==32) &amp;&amp;!std::is_pointer&lt; AccessorTy &gt;::value, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3179c8fc63af2bd2d647b9e66073d0cc">cl::__ESIMD_NS::gather</a> (AccessorTy acc, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t glob_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga3179c8fc63af2bd2d647b9e66073d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbaf4ab8abca7ffb7af7ccb17941482"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1cbaf4ab8abca7ffb7af7ccb17941482"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(sizeof(<a class="el" href="classT.html">T</a>)&lt;=4) &amp;&amp;(N==1||N==8||N==16||N==32) &amp;&amp;!std::is_pointer&lt; AccessorTy &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1cbaf4ab8abca7ffb7af7ccb17941482">cl::__ESIMD_NS::scatter</a> (AccessorTy acc, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, N &gt; vals, uint32_t glob_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga1cbaf4ab8abca7ffb7af7ccb17941482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b3f78add06a251e420e611117ea06b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga16b3f78add06a251e420e611117ea06b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classT.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga16b3f78add06a251e420e611117ea06b">cl::__ESIMD_NS::scalar_load</a> (AccessorTy acc, uint32_t offset)</td></tr>
<tr class="memdesc:ga16b3f78add06a251e420e611117ea06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from an accessor.  <a href="group__sycl__esimd__memory.html#ga16b3f78add06a251e420e611117ea06b">More...</a><br /></td></tr>
<tr class="separator:ga16b3f78add06a251e420e611117ea06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf20f93108bbe2ae87042f5b5eaadb51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gacf20f93108bbe2ae87042f5b5eaadb51"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacf20f93108bbe2ae87042f5b5eaadb51">cl::__ESIMD_NS::scalar_store</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classT.html">T</a> val)</td></tr>
<tr class="memdesc:gacf20f93108bbe2ae87042f5b5eaadb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into an accessor.  <a href="group__sycl__esimd__memory.html#gacf20f93108bbe2ae87042f5b5eaadb51">More...</a><br /></td></tr>
<tr class="separator:gacf20f93108bbe2ae87042f5b5eaadb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4698fe56b5bcaa48c185c5e0efd668d0"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, rgba_channel_mask Mask, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:ga4698fe56b5bcaa48c185c5e0efd668d0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(<a class="el" href="classT.html">T</a>)==4), <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N *<a class="el" href="group__sycl__esimd__core.html#ga66d41afd47d36f4f137957e1fb2d5d4e">get_num_channels_enabled</a>(Mask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4698fe56b5bcaa48c185c5e0efd668d0">cl::__ESIMD_NS::gather_rgba</a> (const Tx *p, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga4698fe56b5bcaa48c185c5e0efd668d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8608987c44b3edc4f00c94bfdf080a9f"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, rgba_channel_mask Mask, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:ga8608987c44b3edc4f00c94bfdf080a9f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(<a class="el" href="classT.html">T</a>)==4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga8608987c44b3edc4f00c94bfdf080a9f">cl::__ESIMD_NS::scatter_rgba</a> (Tx *p, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N *<a class="el" href="group__sycl__esimd__core.html#ga66d41afd47d36f4f137957e1fb2d5d4e">get_num_channels_enabled</a>(Mask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga8608987c44b3edc4f00c94bfdf080a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3c3218cff4303df83d475442e5f3f2"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaeb3c3218cff4303df83d475442e5f3f2">cl::__ESIMD_NS::fence</a> (<a class="el" href="group__sycl__esimd__memory.html#ga658410cbb58b368bd2f0849dcc630f30">fence_mask</a> cntl)</td></tr>
<tr class="memdesc:gaeb3c3218cff4303df83d475442e5f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">esimd::fence sets the memory read/write order.  <a href="group__sycl__esimd__memory.html#gaeb3c3218cff4303df83d475442e5f3f2">More...</a><br /></td></tr>
<tr class="separator:gaeb3c3218cff4303df83d475442e5f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a53b701bb3450e03d9b549a1ad22de"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga42a53b701bb3450e03d9b549a1ad22de">cl::__ESIMD_NS::barrier</a> ()</td></tr>
<tr class="memdesc:ga42a53b701bb3450e03d9b549a1ad22de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group barrier.  <a href="group__sycl__esimd__memory.html#ga42a53b701bb3450e03d9b549a1ad22de">More...</a><br /></td></tr>
<tr class="separator:ga42a53b701bb3450e03d9b549a1ad22de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f0db9c929d2eb8659654a968f07753a"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:ga0f0db9c929d2eb8659654a968f07753a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, m *N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0f0db9c929d2eb8659654a968f07753a">cl::__ESIMD_NS::media_block_load</a> (AccessorTy acc, unsigned x, unsigned y)</td></tr>
<tr class="memdesc:ga0f0db9c929d2eb8659654a968f07753a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block load.  <a href="group__sycl__esimd__memory.html#ga0f0db9c929d2eb8659654a968f07753a">More...</a><br /></td></tr>
<tr class="separator:ga0f0db9c929d2eb8659654a968f07753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e548dd29c1e65f8a3763e5ff09270f"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:gaa2e548dd29c1e65f8a3763e5ff09270f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa2e548dd29c1e65f8a3763e5ff09270f">cl::__ESIMD_NS::media_block_store</a> (AccessorTy acc, unsigned x, unsigned y, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, m *N &gt; vals)</td></tr>
<tr class="memdesc:gaa2e548dd29c1e65f8a3763e5ff09270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block store.  <a href="group__sycl__esimd__memory.html#gaa2e548dd29c1e65f8a3763e5ff09270f">More...</a><br /></td></tr>
<tr class="separator:gaa2e548dd29c1e65f8a3763e5ff09270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd12d9ce3d73a96d12d4848a02496c1"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4cd12d9ce3d73a96d12d4848a02496c1">cl::__ESIMD_ENS::split_barrier</a> (<a class="el" href="group__sycl__esimd__core.html#ga39ad004c2d00aa56709f587436389215">split_barrier_action</a> flag)</td></tr>
<tr class="memdesc:ga4cd12d9ce3d73a96d12d4848a02496c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group split barrier.  <a href="group__sycl__esimd__memory.html#ga4cd12d9ce3d73a96d12d4848a02496c1">More...</a><br /></td></tr>
<tr class="separator:ga4cd12d9ce3d73a96d12d4848a02496c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ESIMD APIs to access memory via accessors, USM pointers, perform per-element atomic operations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga83287b408425557fe20fb6a0f2780843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83287b408425557fe20fb6a0f2780843">&#9670;&nbsp;</a></span>__ESIMD_GET_SURF_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __ESIMD_GET_SURF_HANDLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">acc</td><td>)</td>
          <td>&#160;&#160;&#160;get_surface_index(acc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00069">69</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga658410cbb58b368bd2f0849dcc630f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658410cbb58b368bd2f0849dcc630f30">&#9670;&nbsp;</a></span>fence_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sycl__esimd__memory.html#ga658410cbb58b368bd2f0849dcc630f30">cl::__ESIMD_NS::fence_mask</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represetns a bit mask to control behavior of esimd::fence. </p>
<p>Enum elements define semantics of the bits in the mask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30afd897b249e67ab97244358d50d2782dc"></a>global_coherent_fence&#160;</td><td class="fielddoc"><p>“Commit enable” - wait for fence to complete before continuing. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30abe21832b9b41608507f3353504e9f094"></a>l3_flush_instructions&#160;</td><td class="fielddoc"><p>Flush the instruction cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30ab2e7b06ddda154f239271c292cf2bf42"></a>l3_flush_texture_data&#160;</td><td class="fielddoc"><p>Flush sampler (texture) cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30aba15e53179ebbc82a88a729b3909234b"></a>l3_flush_constant_data&#160;</td><td class="fielddoc"><p>Flush constant cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30a7992ba76348b6a6737aa76b2b64abd98"></a>l3_flush_rw_data&#160;</td><td class="fielddoc"><p>Flush constant cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30a43c36a5d31ec430ada80f411f0e04406"></a>local_barrier&#160;</td><td class="fielddoc"><p>Issue SLM memory barrier only. If not set, the memory barrier is global. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30a9548898fce7e3bb8f837ce67b543716c"></a>l1_flush_ro_data&#160;</td><td class="fielddoc"><p>Flush L1 read - only data cache. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga658410cbb58b368bd2f0849dcc630f30a8f8d2636030186874754276cf69dd69c"></a>sw_barrier&#160;</td><td class="fielddoc"><p>Enable thread scheduling barrier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00750">750</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga42a53b701bb3450e03d9b549a1ad22de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a53b701bb3450e03d9b549a1ad22de">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic work-group barrier. </p>
<p>Performs barrier synchronization for all threads within the same thread group. The barrier instruction causes the executing thread to wait until all threads in the same thread group have executed the barrier instruction. Memory ordering is also guaranteed by this instruction. The behavior is undefined if this instruction is executed in divergent control flow. </p>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00782">782</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="esimd_2memory_8hpp_source.html#l00752">cl::__ESIMD_NS::global_coherent_fence</a>, and <a class="el" href="esimd_2memory_8hpp_source.html#l00762">cl::__ESIMD_NS::local_barrier</a>.</p>

<p class="reference">Referenced by <a class="el" href="experimental_2esimd_2memory_8hpp_source.html#l00226">cl::__ESIMD_ENS::named_barrier_signal()</a>.</p>

</div>
</div>
<a id="ga7a455b602a2bdc85fd680f53f4893d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a455b602a2bdc85fd680f53f4893d6f">&#9670;&nbsp;</a></span>block_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;is_simd_flag_type_v&lt;Flags&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;Tx, N&gt; cl::__ESIMD_NS::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of memory from given accessor and offset and returns the loaded data as a vector. </p>
<p>Actual code generated depends on the alignment parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load, <code>N * sizeof(Tx)</code> must be 1, 2, 4 or 8 owords long. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Accessor type (auto-deduced). </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. Auto-deduced from the <code>Flags</code> parameter. If it is less than <code>16</code>, then slower unaligned access is generated, othewise the access is aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to load from in bytes. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00240">240</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7d7859aa2448dbc52af444a809e9288e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7859aa2448dbc52af444a809e9288e">&#9670;&nbsp;</a></span>block_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename Flags  = vector_aligned_tag, class T  = detail::__raw_t&lt;Tx&gt;, typename  = std::enable_if_t&lt;is_simd_flag_type_v&lt;Flags&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;Tx, N&gt; cl::__ESIMD_NS::block_load </td>
          <td>(</td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of memory from given memory address and returns the loaded data as a vector. </p>
<p>Actual code generated depends on the alignment parameter. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load, <code>N * sizeof(Tx)</code> must be 1, 2, 4 or 8 owords long. </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. Auto-deduced from the <code>Flags</code> parameter. If it is less than <code>16</code>, then slower unaligned access is generated, othewise the access is aligned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to load from. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00201">201</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2eaef94d00241d4703f2a722547678dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eaef94d00241d4703f2a722547678dc">&#9670;&nbsp;</a></span>block_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, typename AccessorTy , class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores elements of a vector to a contiguous block of memory represented by an accessor and an offset within this accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to store, <code>N * sizeof(Tx)</code> must be 1, 2, 4 or 8 owords long. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Accessor type (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to store to. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to store at. It is in bytes and must be a multiple of <code>16</code>. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00300">300</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1065610d35693e1faa004a32c47fa212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1065610d35693e1faa004a32c47fa212">&#9670;&nbsp;</a></span>block_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::block_store </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores elements of a vector to a contiguous block of memory at given address. </p>
<p>The address must be at least <code>16</code> bytes-aligned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to store, <code>N * sizeof(Tx)</code> must be 1, 2, 4 or 8 owords long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The memory address to store at. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00272">272</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaeb3c3218cff4303df83d475442e5f3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb3c3218cff4303df83d475442e5f3f2">&#9670;&nbsp;</a></span>fence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::fence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__memory.html#ga658410cbb58b368bd2f0849dcc630f30">fence_mask</a>&#160;</td>
          <td class="paramname"><em>cntl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>esimd::fence sets the memory read/write order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cntl</td><td>A bitmask composed from <code>fence_mask</code> bits. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00772">772</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3179c8fc63af2bd2d647b9e66073d0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3179c8fc63af2bd2d647b9e66073d0cc">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(sizeof(<a class="el" href="classT.html">T</a>) &lt;= 4) &amp;&amp; (N == 1 || N == 8 || N == 16 || N == 32) &amp;&amp; !std::is_pointer&lt;AccessorTy&gt;::value, <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;<a class="el" href="classT.html">T</a>, N&gt; &gt; cl::__ESIMD_NS::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>glob_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="accessor_gather"></a>Accessor-based gather.</p>
<p>Collects elements located at given offsets in an accessor and returns them as a single <a class="el" href="classsimd.html">simd</a> object. An element can be 1, 2 or 4-byte value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>Element type; can only be a 1,2,4-byte integer, <code><a class="el" href="namespacecl_1_1sycl.html#ace272437c97f7995b37d773d67c50cc3">sycl::half</a></code> or <code>float</code>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. Can be <code>1</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to gather from. </td></tr>
    <tr><td class="paramname">offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed, their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00422">422</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaefa3e17ffd3d3387ed511b4674eac904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefa3e17ffd3d3387ed511b4674eac904">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::isPowerOf2(N, 32), <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;Tx, N&gt; &gt; cl::__ESIMD_NS::gather </td>
          <td>(</td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads ("gathers") elements from different memory locations and returns a vector of them. </p>
<p>Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. Access to any element's memory location can be disabled via the input vector of predicates (mask). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type, must be of size 4 or less. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read; can be <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">offsets</td><td>the vector of 32-bit offsets in bytes. For each lane <code>i</code>, ((byte*)p + offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00131">131</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4698fe56b5bcaa48c185c5e0efd668d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4698fe56b5bcaa48c185c5e0efd668d0">&#9670;&nbsp;</a></span>gather_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, rgba_channel_mask Mask, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; (sizeof(<a class="el" href="classT.html">T</a>) == 4), <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;Tx, N * <a class="el" href="group__sycl__esimd__core.html#ga66d41afd47d36f4f137957e1fb2d5d4e">get_num_channels_enabled</a>(Mask)&gt; &gt; cl::__ESIMD_NS::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">const Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="usm_gather_rgba"></a>Gather and transpose pixels from given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>. Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>Mask</code> template parameter. Each pixel's address must be 4 byte aligned. As an example, let's assume we want to read <code>n</code> pixels at address <code>addr</code>, skipping <code>G</code> and <code>B</code> channels. Each channel is a 32-bit float and the pixel data at given address in memory is: </p><div class="fragment"><div class="line">R1 G1 B1 A1 R2 G2 B2 A2 ... Rn Gn Bn An</div>
</div><!-- fragment --><p> Then this can be achieved by using </p><div class="fragment"><div class="line"><a class="code" href="classsimd.html">simd&lt;uint32_t, n&gt;</a> byte_offsets(0, 4*4 <span class="comment">/* byte size of a single pixel */</span>);</div>
<div class="line"><span class="keyword">auto</span> x = gather_rgba&lt;float, n, rgba_channel_mask::AR&gt;(addr, byte_offsets);</div>
</div><!-- fragment --><p> Returned <code>x</code> will contain <code>2*n</code> <code>float</code> elements: </p><div class="fragment"><div class="line">R1 R2 ... Rn A1 A2 ... An</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">Mask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">offsets</td><td>Byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00519">519</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga7d32978ca634000ff9b80ec5721e25e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d32978ca634000ff9b80ec5721e25e6">&#9670;&nbsp;</a></span>get_surface_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="group__sycl__esimd__core.html#ga6c38ddcda4183107e0d18d0a4ff31806">SurfaceIndex</a> cl::__ESIMD_NS::get_surface_index </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get surface index corresponding to a SYCL accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>a SYCL buffer or image accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the corresponding surface (aka "binding table index"). </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00060">60</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="sycl_2ext_2intel_2esimd_2common_8hpp_source.html#l00116">cl::__ESIMD_NS::detail::SLM_BTI</a>.</p>

</div>
</div>
<a id="ga0f0db9c929d2eb8659654a968f07753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f0db9c929d2eb8659654a968f07753a">&#9670;&nbsp;</a></span>media_block_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt;<a class="el" href="classT.html">T</a>, m * N&gt; cl::__ESIMD_NS::media_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Media block load. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>is the element data type. </td></tr>
    <tr><td class="paramname">m</td><td>is the height of the 2D block. </td></tr>
    <tr><td class="paramname">N</td><td>is the width of the 2D block. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is type of the SYCL accessor. </td></tr>
    <tr><td class="paramname">plane</td><td>is planar surface index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">x</td><td>is X-coordinate of the left upper rectangle corner in BYTES. </td></tr>
    <tr><td class="paramname">y</td><td>is Y-coordinate of the left upper rectangle corner in ROWS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linearized 2D block data read from surface. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00983">983</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="esimd_2memory_8hpp_source.html#l00069">__ESIMD_GET_SURF_HANDLE</a>.</p>

</div>
</div>
<a id="gaa2e548dd29c1e65f8a3763e5ff09270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2e548dd29c1e65f8a3763e5ff09270f">&#9670;&nbsp;</a></span>media_block_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::media_block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, m *N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Media block store. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>is the element data type. </td></tr>
    <tr><td class="paramname">m</td><td>is the height of the 2D block. </td></tr>
    <tr><td class="paramname">N</td><td>is the width of the 2D block. </td></tr>
    <tr><td class="paramname">is</td><td>AccessorTy type of the SYCL accessor. </td></tr>
    <tr><td class="paramname">plane</td><td>is planar surface index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">x</td><td>is X-coordinate of the left upper rectangle corner in BYTES. </td></tr>
    <tr><td class="paramname">y</td><td>is Y-coordinate of the left upper rectangle corner in ROWS. </td></tr>
    <tr><td class="paramname">vals</td><td>is the linearized 2D block data to be written to surface. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l01024">1024</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="esimd_2memory_8hpp_source.html#l00069">__ESIMD_GET_SURF_HANDLE</a>.</p>

</div>
</div>
<a id="ga16b3f78add06a251e420e611117ea06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b3f78add06a251e420e611117ea06b">&#9670;&nbsp;</a></span>scalar_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classT.html">T</a> cl::__ESIMD_NS::scalar_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a scalar value from an accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>Type of the value. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Type of the accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to load from. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00465">465</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gacf20f93108bbe2ae87042f5b5eaadb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf20f93108bbe2ae87042f5b5eaadb51">&#9670;&nbsp;</a></span>scalar_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_NS::scalar_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a scalar value into an accessor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>Type of the value. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>Type of the accessor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accessor to store to. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes. </td></tr>
    <tr><td class="paramname">val</td><td>The stored value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00479">479</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1cbaf4ab8abca7ffb7af7ccb17941482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbaf4ab8abca7ffb7af7ccb17941482">&#9670;&nbsp;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(sizeof(<a class="el" href="classT.html">T</a>) &lt;= 4) &amp;&amp; (N == 1 || N == 8 || N == 16 || N == 32) &amp;&amp; !std::is_pointer&lt;AccessorTy&gt;::value&gt; cl::__ESIMD_NS::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; <a class="el" href="classT.html">T</a>, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>glob_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="accessor_scatter"></a>Accessor-based scatter.</p>
<p>Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets. An element can be 1, 2 or 4-byte value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classT.html">T</a></td><td>Element type; can only be a 1,2,4-byte integer, <code><a class="el" href="namespacecl_1_1sycl.html#ace272437c97f7995b37d773d67c50cc3">sycl::half</a></code> or <code>float</code>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. Can be <code>1</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>Values to write. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00451">451</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae6f535e9230b4007618513cd75711fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6f535e9230b4007618513cd75711fe1">&#9670;&nbsp;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::isPowerOf2(N, 32)&gt; cl::__ESIMD_NS::scatter </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes ("scatters") elements of the input vector to different memory locations. </p>
<p>Each memory location is base address plus an offset - a value of the corresponding element in the input offset vector. Access to any element's memory location can be disabled via the input mask. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type, must be of size 4 or less. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to write; can be <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base address. </td></tr>
    <tr><td class="paramname">offsets</td><td>A vector of 32-bit offsets in bytes. For each lane <code>i</code>, ((byte*)p + offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to scatter. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00164">164</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8608987c44b3edc4f00c94bfdf080a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8608987c44b3edc4f00c94bfdf080a9f">&#9670;&nbsp;</a></span>scatter_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tx , int N, rgba_channel_mask Mask, class T  = detail::__raw_t&lt;Tx&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; (sizeof(<a class="el" href="classT.html">T</a>) == 4)&gt; cl::__ESIMD_NS::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">Tx *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1____ESIMD__NS_1_1simd.html">simd</a>&lt; Tx, N *<a class="el" href="group__sycl__esimd__core.html#ga66d41afd47d36f4f137957e1fb2d5d4e">get_num_channels_enabled</a>(Mask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#ga8e607b1f55c7193293bc8887aaeb82bb">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="usm_scatter_rgba"></a>Transpose and scatter pixels to given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>. Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>Mask</code> template parameter. Each pixel's address must be 4 byte aligned. This is basically an inverse operation for gather_rgba.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tx</td><td>Element type of the returned vector. Must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
    <tr><td class="paramname">Mask</td><td>A pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The USM base pointer representing memory address of the access. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">offsets</td><td>Byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="esimd_2memory_8hpp_source.html#l00548">548</a> of file <a class="el" href="esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4cd12d9ce3d73a96d12d4848a02496c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd12d9ce3d73a96d12d4848a02496c1">&#9670;&nbsp;</a></span>split_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void cl::__ESIMD_ENS::split_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core.html#ga39ad004c2d00aa56709f587436389215">split_barrier_action</a>&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic work-group split barrier. </p>

<p class="definition">Definition at line <a class="el" href="experimental_2esimd_2memory_8hpp_source.html#l00027">27</a> of file <a class="el" href="experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclasssimd_html"><div class="ttname"><a href="classsimd.html">simd</a></div><div class="ttdef"><b>Definition:</b> <a href="std_2experimental_2simd_8hpp_source.html#l01027">simd.hpp:1027</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
