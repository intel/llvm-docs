<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: LSC-specific memory access APIs.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory__lsc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LSC-specific memory access APIs.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a> &raquo; <a class="el" href="group__sycl__esimd__memory.html">Memory access API.</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This group combines types and functions specific to LSC, which is available in Intel GPUs starting from PVC and ACM.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for LSC-specific memory access APIs.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory__lsc.png" border="0" usemap="#agroup____sycl____esimd____memory____lsc" alt=""/></div>
<map name="agroup____sycl____esimd____memory____lsc" id="agroup____sycl____esimd____memory____lsc">
<area shape="rect" title="This group combines types and functions specific to LSC, which is available in Intel GPUs starting fr..." alt="" coords="207,5,365,45"/>
<area shape="rect" href="group__sycl__esimd__memory.html" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="5,13,159,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">sycl::_V1::ext::intel::experimental::esimd::config_2d_mem_access&lt; T, BlockWidth, BlockHeight, NBlocks &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container class to hold parameters for <code>load2d/store2d</code> <code>functions</code>  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7f152f10c9444355e56f3934d4a41b39"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga7f152f10c9444355e56f3934d4a41b39">sycl::_V1::ext::intel::esimd::native::lsc::atomic_op</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39acf9f3fde7326f1d8e64205f0e07a3695">sycl::_V1::ext::intel::esimd::native::lsc::inc</a> = 0x08
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a1feea25ecb958229287f885aebe7c49b">sycl::_V1::ext::intel::esimd::native::lsc::dec</a> = 0x09
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39aec4d1eb36b22d19728e9d1d23ca84d1c">sycl::_V1::ext::intel::esimd::native::lsc::load</a> = 0x0a
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a8cd892b7b97ef9489ae4479d3f4ef0fc">sycl::_V1::ext::intel::esimd::native::lsc::store</a> = 0x0b
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a34ec78fcc91ffb1e54cd85e4a0924332">sycl::_V1::ext::intel::esimd::native::lsc::add</a> = 0x0c
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a8a68dc3e925eacf92633be230722a140">sycl::_V1::ext::intel::esimd::native::lsc::sub</a> = 0x0d
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a36c5912f6e22a8791f1e2b080fec1f7e">sycl::_V1::ext::intel::esimd::native::lsc::smin</a> = 0x0e
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39abd92ac5ba2dc1a7673c98858cfbab0af">sycl::_V1::ext::intel::esimd::native::lsc::smax</a> = 0x0f
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a017163727bc806385f1453c130b4fce3">sycl::_V1::ext::intel::esimd::native::lsc::umin</a> = 0x10
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a82c1089b8c973b65be6d620f765ed1f5">sycl::_V1::ext::intel::esimd::native::lsc::umax</a> = 0x11
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a5314a49784395644281550cdf8e60c8d">sycl::_V1::ext::intel::esimd::native::lsc::cmpxchg</a> = 0x12
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a6d6fbe2c4e976a410868effe6deb2171">sycl::_V1::ext::intel::esimd::native::lsc::fadd</a> = 0x13
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a09097f6fa7db7027ada3d6d8e930f3bd">sycl::_V1::ext::intel::esimd::native::lsc::fsub</a> = 0x14
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a91b8694b07e3650d5332a6d51af36421">sycl::_V1::ext::intel::esimd::native::lsc::fmin</a> = 0x15
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a6245653b1ded5cde266a956a325465ce">sycl::_V1::ext::intel::esimd::native::lsc::fmax</a> = 0x16
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39ae4a112574052159467464500ceafe8f5">sycl::_V1::ext::intel::esimd::native::lsc::fcmpxchg</a> = 0x17
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39aaa8d31ef8411c3f53e6ebdc121d4478a">sycl::_V1::ext::intel::esimd::native::lsc::bit_and</a> = 0x18
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39a1bf8f4ebf2c8abd137da6ae913d24b7b">sycl::_V1::ext::intel::esimd::native::lsc::bit_or</a> = 0x19
, <a class="el" href="group__sycl__esimd__memory__lsc.html#gga7f152f10c9444355e56f3934d4a41b39ad5e6a1808b4174a20acda16d837e6739">sycl::_V1::ext::intel::esimd::native::lsc::bit_xor</a> = 0x1a
<br />
 }</td></tr>
<tr class="memdesc:ga7f152f10c9444355e56f3934d4a41b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC atomic operation codes.  <a href="group__sycl__esimd__memory__lsc.html#ga7f152f10c9444355e56f3934d4a41b39">More...</a><br /></td></tr>
<tr class="separator:ga7f152f10c9444355e56f3934d4a41b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab5ecb397ce268aaab6c909e8443db0e0"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </td></tr>
<tr class="memitem:gab5ecb397ce268aaab6c909e8443db0e0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gab5ecb397ce268aaab6c909e8443db0e0">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:gab5ecb397ce268aaab6c909e8443db0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM gather.  <a href="group__sycl__esimd__memory__lsc.html#gab5ecb397ce268aaab6c909e8443db0e0">More...</a><br /></td></tr>
<tr class="separator:gab5ecb397ce268aaab6c909e8443db0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1128f1576ca53032782d45521d4c60b8"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </td></tr>
<tr class="memitem:ga1128f1576ca53032782d45521d4c60b8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga1128f1576ca53032782d45521d4c60b8">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:ga1128f1576ca53032782d45521d4c60b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM gather.  <a href="group__sycl__esimd__memory__lsc.html#ga1128f1576ca53032782d45521d4c60b8">More...</a><br /></td></tr>
<tr class="separator:ga1128f1576ca53032782d45521d4c60b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga972c8ff6508adc58dc09fca76c1fe4c8"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga972c8ff6508adc58dc09fca76c1fe4c8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga972c8ff6508adc58dc09fca76c1fe4c8">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_load</a> (uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT flags=FlagsT{})</td></tr>
<tr class="memdesc:ga972c8ff6508adc58dc09fca76c1fe4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposed SLM gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#ga972c8ff6508adc58dc09fca76c1fe4c8">More...</a><br /></td></tr>
<tr class="separator:ga972c8ff6508adc58dc09fca76c1fe4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6feb5ec4d77e9119670a8186ed8013f"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gab6feb5ec4d77e9119670a8186ed8013f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gab6feb5ec4d77e9119670a8186ed8013f">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_load</a> (uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:gab6feb5ec4d77e9119670a8186ed8013f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposed SLM gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gab6feb5ec4d77e9119670a8186ed8013f">More...</a><br /></td></tr>
<tr class="separator:gab6feb5ec4d77e9119670a8186ed8013f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee6780b83f37c110c741d19f8b412f3b"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaee6780b83f37c110c741d19f8b412f3b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaee6780b83f37c110c741d19f8b412f3b">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:gaee6780b83f37c110c741d19f8b412f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer gather.  <a href="group__sycl__esimd__memory__lsc.html#gaee6780b83f37c110c741d19f8b412f3b">More...</a><br /></td></tr>
<tr class="separator:gaee6780b83f37c110c741d19f8b412f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa3c851d7beb8af38c8b754d270ee36"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga3fa3c851d7beb8af38c8b754d270ee36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga3fa3c851d7beb8af38c8b754d270ee36">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:ga3fa3c851d7beb8af38c8b754d270ee36"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer gather.  <a href="group__sycl__esimd__memory__lsc.html#ga3fa3c851d7beb8af38c8b754d270ee36">More...</a><br /></td></tr>
<tr class="separator:ga3fa3c851d7beb8af38c8b754d270ee36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020c090954f523630fb7336735657fcc"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga020c090954f523630fb7336735657fcc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga020c090954f523630fb7336735657fcc">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga020c090954f523630fb7336735657fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf942c19c0df072aaa9190aec2bb63b5"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:gabf942c19c0df072aaa9190aec2bb63b5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gabf942c19c0df072aaa9190aec2bb63b5">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="separator:gabf942c19c0df072aaa9190aec2bb63b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb98fccf2646293870dadcf3c0137db2"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gadb98fccf2646293870dadcf3c0137db2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gadb98fccf2646293870dadcf3c0137db2">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:gadb98fccf2646293870dadcf3c0137db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea0fd9f294b4c40f4bdedb03868e791"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga4ea0fd9f294b4c40f4bdedb03868e791"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga4ea0fd9f294b4c40f4bdedb03868e791">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (const T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="separator:ga4ea0fd9f294b4c40f4bdedb03868e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556ce3fe630fafba83af453226f57ae7"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga556ce3fe630fafba83af453226f57ae7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga556ce3fe630fafba83af453226f57ae7">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:ga556ce3fe630fafba83af453226f57ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based gather.  <a href="group__sycl__esimd__memory__lsc.html#ga556ce3fe630fafba83af453226f57ae7">More...</a><br /></td></tr>
<tr class="separator:ga556ce3fe630fafba83af453226f57ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1231989b18ba85720ebc09a7885a3d"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga5b1231989b18ba85720ebc09a7885a3d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga5b1231989b18ba85720ebc09a7885a3d">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga5b1231989b18ba85720ebc09a7885a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb05c22e655e661c97296763c7048335"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gabb05c22e655e661c97296763c7048335"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gabb05c22e655e661c97296763c7048335">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:gabb05c22e655e661c97296763c7048335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based gather.  <a href="group__sycl__esimd__memory__lsc.html#gabb05c22e655e661c97296763c7048335">More...</a><br /></td></tr>
<tr class="separator:gabb05c22e655e661c97296763c7048335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27f961f0811e7e76f9db20855887728a"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga27f961f0811e7e76f9db20855887728a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; sycl::detail::acc_properties::is_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga27f961f0811e7e76f9db20855887728a">sycl::_V1::ext::intel::experimental::esimd::lsc_gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="separator:ga27f961f0811e7e76f9db20855887728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad74ae0d9eecc990e01f1fb66188d6341"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gad74ae0d9eecc990e01f1fb66188d6341"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gad74ae0d9eecc990e01f1fb66188d6341">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (const T *p, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT={})</td></tr>
<tr class="memdesc:gad74ae0d9eecc990e01f1fb66188d6341"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer transposed gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gad74ae0d9eecc990e01f1fb66188d6341">More...</a><br /></td></tr>
<tr class="separator:gad74ae0d9eecc990e01f1fb66188d6341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b4479d454c636a7303589b29b4c918"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga09b4479d454c636a7303589b29b4c918"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga09b4479d454c636a7303589b29b4c918">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (const T *p, FlagsT)</td></tr>
<tr class="memdesc:ga09b4479d454c636a7303589b29b4c918"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of lsc_block_load without predicate parameter to simplify use of alignment parameter.  <a href="group__sycl__esimd__memory__lsc.html#ga09b4479d454c636a7303589b29b4c918">More...</a><br /></td></tr>
<tr class="separator:ga09b4479d454c636a7303589b29b4c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7299858491b41fee71ce8bcca46303d"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gaa7299858491b41fee71ce8bcca46303d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaa7299858491b41fee71ce8bcca46303d">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (const T *p, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; pass_thru, FlagsT={})</td></tr>
<tr class="memdesc:gaa7299858491b41fee71ce8bcca46303d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer transposed gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gaa7299858491b41fee71ce8bcca46303d">More...</a><br /></td></tr>
<tr class="separator:gaa7299858491b41fee71ce8bcca46303d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305ea746f956a5bebccd2556e2702134"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga305ea746f956a5bebccd2556e2702134"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga305ea746f956a5bebccd2556e2702134">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT flags=FlagsT{})</td></tr>
<tr class="memdesc:ga305ea746f956a5bebccd2556e2702134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#ga305ea746f956a5bebccd2556e2702134">More...</a><br /></td></tr>
<tr class="separator:ga305ea746f956a5bebccd2556e2702134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c661e1184af6512e7d58160567ee928"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga4c661e1184af6512e7d58160567ee928"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga4c661e1184af6512e7d58160567ee928">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT flags=FlagsT{})</td></tr>
<tr class="separator:ga4c661e1184af6512e7d58160567ee928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed0994c99b6ceb4b1bee794cda2295c"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga3ed0994c99b6ceb4b1bee794cda2295c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga3ed0994c99b6ceb4b1bee794cda2295c">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, FlagsT flags)</td></tr>
<tr class="memdesc:ga3ed0994c99b6ceb4b1bee794cda2295c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of lsc_block_load without predicate parameter to simplify use of alignment parameter.  <a href="group__sycl__esimd__memory__lsc.html#ga3ed0994c99b6ceb4b1bee794cda2295c">More...</a><br /></td></tr>
<tr class="separator:ga3ed0994c99b6ceb4b1bee794cda2295c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c9dba36c57cdeb58c182752ca8d297"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga77c9dba36c57cdeb58c182752ca8d297"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga77c9dba36c57cdeb58c182752ca8d297">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, uint32_t offset, FlagsT flags)</td></tr>
<tr class="separator:ga77c9dba36c57cdeb58c182752ca8d297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c396fe999c00ad10a025280cd56a6f"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga78c396fe999c00ad10a025280cd56a6f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga78c396fe999c00ad10a025280cd56a6f">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; pass_thru, FlagsT={})</td></tr>
<tr class="memdesc:ga78c396fe999c00ad10a025280cd56a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#ga78c396fe999c00ad10a025280cd56a6f">More...</a><br /></td></tr>
<tr class="separator:ga78c396fe999c00ad10a025280cd56a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a50bd14adab8f1095ce0f454c33aef9"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga3a50bd14adab8f1095ce0f454c33aef9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga3a50bd14adab8f1095ce0f454c33aef9">sycl::_V1::ext::intel::experimental::esimd::lsc_block_load</a> (AccessorTy acc, uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; pass_thru, FlagsT flags=FlagsT{})</td></tr>
<tr class="separator:ga3a50bd14adab8f1095ce0f454c33aef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b39366f8a774ff152b750cfd8d2cd07"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga2b39366f8a774ff152b750cfd8d2cd07"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga2b39366f8a774ff152b750cfd8d2cd07">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:ga2b39366f8a774ff152b750cfd8d2cd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer prefetch gather.  <a href="group__sycl__esimd__memory__lsc.html#ga2b39366f8a774ff152b750cfd8d2cd07">More...</a><br /></td></tr>
<tr class="separator:ga2b39366f8a774ff152b750cfd8d2cd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e954daee63bbca4dff392a7de3b3f0d"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga5e954daee63bbca4dff392a7de3b3f0d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga5e954daee63bbca4dff392a7de3b3f0d">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga5e954daee63bbca4dff392a7de3b3f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716d4a18216f616bff2c724147bd149a"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga716d4a18216f616bff2c724147bd149a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga716d4a18216f616bff2c724147bd149a">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (const T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga716d4a18216f616bff2c724147bd149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec1c743f49f7b2e00c07180eaed0aabc"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gaec1c743f49f7b2e00c07180eaed0aabc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaec1c743f49f7b2e00c07180eaed0aabc">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (const T *p, FlagsT={})</td></tr>
<tr class="memdesc:gaec1c743f49f7b2e00c07180eaed0aabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer prefetch transposed gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gaec1c743f49f7b2e00c07180eaed0aabc">More...</a><br /></td></tr>
<tr class="separator:gaec1c743f49f7b2e00c07180eaed0aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa857d3d1056ffb7ed5215d34106c23a0"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaa857d3d1056ffb7ed5215d34106c23a0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaa857d3d1056ffb7ed5215d34106c23a0">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:gaa857d3d1056ffb7ed5215d34106c23a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based prefetch gather.  <a href="group__sycl__esimd__memory__lsc.html#gaa857d3d1056ffb7ed5215d34106c23a0">More...</a><br /></td></tr>
<tr class="separator:gaa857d3d1056ffb7ed5215d34106c23a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed205c44626e2ab0879b3fc5a69138bc"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaed205c44626e2ab0879b3fc5a69138bc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaed205c44626e2ab0879b3fc5a69138bc">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, FlagsT flags=FlagsT{})</td></tr>
<tr class="memdesc:gaed205c44626e2ab0879b3fc5a69138bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed prefetch gather with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gaed205c44626e2ab0879b3fc5a69138bc">More...</a><br /></td></tr>
<tr class="separator:gaed205c44626e2ab0879b3fc5a69138bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51841452071a8b53e530194a3fce6237"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </td></tr>
<tr class="memitem:ga51841452071a8b53e530194a3fce6237"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga51841452071a8b53e530194a3fce6237">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_scatter</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:ga51841452071a8b53e530194a3fce6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM scatter.  <a href="group__sycl__esimd__memory__lsc.html#ga51841452071a8b53e530194a3fce6237">More...</a><br /></td></tr>
<tr class="separator:ga51841452071a8b53e530194a3fce6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297e98ccc4e2d12445f4fdcf49c4e9a3"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga297e98ccc4e2d12445f4fdcf49c4e9a3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga297e98ccc4e2d12445f4fdcf49c4e9a3">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_store</a> (uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, FlagsT flags=FlagsT{})</td></tr>
<tr class="memdesc:ga297e98ccc4e2d12445f4fdcf49c4e9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposed SLM scatter with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#ga297e98ccc4e2d12445f4fdcf49c4e9a3">More...</a><br /></td></tr>
<tr class="separator:ga297e98ccc4e2d12445f4fdcf49c4e9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8081477c17d72f2ee4d7dad4397d88f"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gad8081477c17d72f2ee4d7dad4397d88f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gad8081477c17d72f2ee4d7dad4397d88f">sycl::_V1::ext::intel::experimental::esimd::lsc_scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:gad8081477c17d72f2ee4d7dad4397d88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer scatter.  <a href="group__sycl__esimd__memory__lsc.html#gad8081477c17d72f2ee4d7dad4397d88f">More...</a><br /></td></tr>
<tr class="separator:gad8081477c17d72f2ee4d7dad4397d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cae892bebf2dcfb6c332909f415e8e"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:gab4cae892bebf2dcfb6c332909f415e8e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gab4cae892bebf2dcfb6c332909f415e8e">sycl::_V1::ext::intel::experimental::esimd::lsc_scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:gab4cae892bebf2dcfb6c332909f415e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36aad80d84d6f7133bdfdeb1f24a41e"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gad36aad80d84d6f7133bdfdeb1f24a41e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gad36aad80d84d6f7133bdfdeb1f24a41e">sycl::_V1::ext::intel::experimental::esimd::lsc_scatter</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:gad36aad80d84d6f7133bdfdeb1f24a41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3dd941ed899a312b4093d5ef1c5f7a8"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaf3dd941ed899a312b4093d5ef1c5f7a8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaf3dd941ed899a312b4093d5ef1c5f7a8">sycl::_V1::ext::intel::experimental::esimd::lsc_scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:gaf3dd941ed899a312b4093d5ef1c5f7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based scatter.  <a href="group__sycl__esimd__memory__lsc.html#gaf3dd941ed899a312b4093d5ef1c5f7a8">More...</a><br /></td></tr>
<tr class="separator:gaf3dd941ed899a312b4093d5ef1c5f7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d76173b8dad2141af91578804e9054"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga06d76173b8dad2141af91578804e9054"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga06d76173b8dad2141af91578804e9054">sycl::_V1::ext::intel::experimental::esimd::lsc_scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga06d76173b8dad2141af91578804e9054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ab8c166b782b0160299203ad18f83c"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gae7ab8c166b782b0160299203ad18f83c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gae7ab8c166b782b0160299203ad18f83c">sycl::_V1::ext::intel::experimental::esimd::lsc_block_store</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT={})</td></tr>
<tr class="memdesc:gae7ab8c166b782b0160299203ad18f83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer transposed scatter with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#gae7ab8c166b782b0160299203ad18f83c">More...</a><br /></td></tr>
<tr class="separator:gae7ab8c166b782b0160299203ad18f83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6ecbe7c9d3d9e4385028ed7c0cf83d3"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gab6ecbe7c9d3d9e4385028ed7c0cf83d3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gab6ecbe7c9d3d9e4385028ed7c0cf83d3">sycl::_V1::ext::intel::experimental::esimd::lsc_block_store</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, FlagsT flags)</td></tr>
<tr class="memdesc:gab6ecbe7c9d3d9e4385028ed7c0cf83d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of lsc_block_store without predicate parameter to simplify use of alignment parameter.  <a href="group__sycl__esimd__memory__lsc.html#gab6ecbe7c9d3d9e4385028ed7c0cf83d3">More...</a><br /></td></tr>
<tr class="separator:gab6ecbe7c9d3d9e4385028ed7c0cf83d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a68b0745d8ccf547536dde719fa7d9a"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga4a68b0745d8ccf547536dde719fa7d9a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga4a68b0745d8ccf547536dde719fa7d9a">sycl::_V1::ext::intel::experimental::esimd::lsc_block_store</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt; pred=1, FlagsT={})</td></tr>
<tr class="memdesc:ga4a68b0745d8ccf547536dde719fa7d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed scatter with 1 channel.  <a href="group__sycl__esimd__memory__lsc.html#ga4a68b0745d8ccf547536dde719fa7d9a">More...</a><br /></td></tr>
<tr class="separator:ga4a68b0745d8ccf547536dde719fa7d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916111e3cad79a8b39c12c8ecb87d5a9"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:ga916111e3cad79a8b39c12c8ecb87d5a9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga916111e3cad79a8b39c12c8ecb87d5a9">sycl::_V1::ext::intel::experimental::esimd::lsc_block_store</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, FlagsT flags=FlagsT{})</td></tr>
<tr class="separator:ga916111e3cad79a8b39c12c8ecb87d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ceb16735a6744200dc26ef3c7eaa85"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </td></tr>
<tr class="memitem:gae9ceb16735a6744200dc26ef3c7eaa85"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt; FlagsT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gae9ceb16735a6744200dc26ef3c7eaa85">sycl::_V1::ext::intel::experimental::esimd::lsc_block_store</a> (AccessorTy acc, __ESIMD_DNS::DeviceAccessorOffsetT offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt; vals, FlagsT flags)</td></tr>
<tr class="memdesc:gae9ceb16735a6744200dc26ef3c7eaa85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of lsc_block_store without predicate parameter to simplify use of alignment parameter.  <a href="group__sycl__esimd__memory__lsc.html#gae9ceb16735a6744200dc26ef3c7eaa85">More...</a><br /></td></tr>
<tr class="separator:gae9ceb16735a6744200dc26ef3c7eaa85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b22aad8ce5326ba6ecce630c7e96a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </td></tr>
<tr class="memitem:ga54b22aad8ce5326ba6ecce630c7e96a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga54b22aad8ce5326ba6ecce630c7e96a1">sycl::_V1::ext::intel::experimental::esimd::lsc_load_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y)</td></tr>
<tr class="memdesc:ga54b22aad8ce5326ba6ecce630c7e96a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block load.  <a href="group__sycl__esimd__memory__lsc.html#ga54b22aad8ce5326ba6ecce630c7e96a1">More...</a><br /></td></tr>
<tr class="separator:ga54b22aad8ce5326ba6ecce630c7e96a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c84cd33547d291ee7986d61e65aa4f"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false, false&gt;()&gt; </td></tr>
<tr class="memitem:gaa7c84cd33547d291ee7986d61e65aa4f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaa7c84cd33547d291ee7986d61e65aa4f">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y)</td></tr>
<tr class="memdesc:gaa7c84cd33547d291ee7986d61e65aa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block prefetch.  <a href="group__sycl__esimd__memory__lsc.html#gaa7c84cd33547d291ee7986d61e65aa4f">More...</a><br /></td></tr>
<tr class="separator:gaa7c84cd33547d291ee7986d61e65aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ed09ebe6eb2d9662dac2913a49931b"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false, false&gt;()&gt; </td></tr>
<tr class="memitem:ga74ed09ebe6eb2d9662dac2913a49931b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga74ed09ebe6eb2d9662dac2913a49931b">sycl::_V1::ext::intel::experimental::esimd::lsc_store_2d</a> (T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; Vals)</td></tr>
<tr class="memdesc:ga74ed09ebe6eb2d9662dac2913a49931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block store.  <a href="group__sycl__esimd__memory__lsc.html#ga74ed09ebe6eb2d9662dac2913a49931b">More...</a><br /></td></tr>
<tr class="separator:ga74ed09ebe6eb2d9662dac2913a49931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee81777dc15edc04c5c28cfd4bfcf54b"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </td></tr>
<tr class="memitem:gaee81777dc15edc04c5c28cfd4bfcf54b"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE SYCL_ESIMD_FUNCTION <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaee81777dc15edc04c5c28cfd4bfcf54b">sycl::_V1::ext::intel::experimental::esimd::lsc_load_2d</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;payload)</td></tr>
<tr class="memdesc:gaee81777dc15edc04c5c28cfd4bfcf54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>2D</code> stateless block load <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed.  <a href="group__sycl__esimd__memory__lsc.html#gaee81777dc15edc04c5c28cfd4bfcf54b">More...</a><br /></td></tr>
<tr class="separator:gaee81777dc15edc04c5c28cfd4bfcf54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6cf7a1a8492641c9d83d2aa4ddb1ec"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </td></tr>
<tr class="memitem:ga0e6cf7a1a8492641c9d83d2aa4ddb1ec"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE SYCL_ESIMD_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga0e6cf7a1a8492641c9d83d2aa4ddb1ec">sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch_2d</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;payload)</td></tr>
<tr class="memdesc:ga0e6cf7a1a8492641c9d83d2aa4ddb1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>2D</code> stateless block prefetch <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed.  <a href="group__sycl__esimd__memory__lsc.html#ga0e6cf7a1a8492641c9d83d2aa4ddb1ec">More...</a><br /></td></tr>
<tr class="separator:ga0e6cf7a1a8492641c9d83d2aa4ddb1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61bc053bd928545e497668ea5e77f1a"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false, false&gt;()&gt; </td></tr>
<tr class="memitem:gac61bc053bd928545e497668ea5e77f1a"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE SYCL_ESIMD_FUNCTION void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gac61bc053bd928545e497668ea5e77f1a">sycl::_V1::ext::intel::experimental::esimd::lsc_store_2d</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;payload, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; Data)</td></tr>
<tr class="memdesc:gac61bc053bd928545e497668ea5e77f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>2D</code> stateless block store <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed.  <a href="group__sycl__esimd__memory__lsc.html#gac61bc053bd928545e497668ea5e77f1a">More...</a><br /></td></tr>
<tr class="separator:gac61bc053bd928545e497668ea5e77f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d15ff90c910663cc04866767c26a120"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </td></tr>
<tr class="memitem:ga6d15ff90c910663cc04866767c26a120"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga6d15ff90c910663cc04866767c26a120">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga6d15ff90c910663cc04866767c26a120"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga6d15ff90c910663cc04866767c26a120">More...</a><br /></td></tr>
<tr class="separator:ga6d15ff90c910663cc04866767c26a120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb85655eafc44cdfe3d5b865f17df7d7"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </td></tr>
<tr class="memitem:gafb85655eafc44cdfe3d5b865f17df7d7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gafb85655eafc44cdfe3d5b865f17df7d7">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:gafb85655eafc44cdfe3d5b865f17df7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="group__sycl__esimd__memory__lsc.html#gafb85655eafc44cdfe3d5b865f17df7d7">More...</a><br /></td></tr>
<tr class="separator:gafb85655eafc44cdfe3d5b865f17df7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417c531396e07a9bffede4335603a40e"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </td></tr>
<tr class="memitem:ga417c531396e07a9bffede4335603a40e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga417c531396e07a9bffede4335603a40e">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga417c531396e07a9bffede4335603a40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga417c531396e07a9bffede4335603a40e">More...</a><br /></td></tr>
<tr class="separator:ga417c531396e07a9bffede4335603a40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4f5d3d8836f91963afc0de142c2672"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:ga3d4f5d3d8836f91963afc0de142c2672"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga3d4f5d3d8836f91963afc0de142c2672">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga3d4f5d3d8836f91963afc0de142c2672"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga3d4f5d3d8836f91963afc0de142c2672">More...</a><br /></td></tr>
<tr class="separator:ga3d4f5d3d8836f91963afc0de142c2672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1ec8e0ab865592aa9cad105f0e3927"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:ga4f1ec8e0ab865592aa9cad105f0e3927"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga4f1ec8e0ab865592aa9cad105f0e3927">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga4f1ec8e0ab865592aa9cad105f0e3927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf7f056315ce1962e5fdaa439cc0994"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:ga0bf7f056315ce1962e5fdaa439cc0994"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga0bf7f056315ce1962e5fdaa439cc0994">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga0bf7f056315ce1962e5fdaa439cc0994"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga0bf7f056315ce1962e5fdaa439cc0994">More...</a><br /></td></tr>
<tr class="separator:ga0bf7f056315ce1962e5fdaa439cc0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26701cf6b5620b6eb5b44c7fa7d33f91"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga26701cf6b5620b6eb5b44c7fa7d33f91"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga26701cf6b5620b6eb5b44c7fa7d33f91">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga26701cf6b5620b6eb5b44c7fa7d33f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a7c090448a2856c17182734ebcdb71"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:gab5a7c090448a2856c17182734ebcdb71"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">sycl::ext::intel::esimd::atomic_op::store</a> &amp;&amp;Op !=sycl::ext::intel::esimd::atomic_op::xchg)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gab5a7c090448a2856c17182734ebcdb71">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:gab5a7c090448a2856c17182734ebcdb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b09cae0dfd8defe7406e0306464f73"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:ga21b09cae0dfd8defe7406e0306464f73"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga21b09cae0dfd8defe7406e0306464f73">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga21b09cae0dfd8defe7406e0306464f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga21b09cae0dfd8defe7406e0306464f73">More...</a><br /></td></tr>
<tr class="separator:ga21b09cae0dfd8defe7406e0306464f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a13f8b7584d4a1bbe97f176942059e"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga07a13f8b7584d4a1bbe97f176942059e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga07a13f8b7584d4a1bbe97f176942059e">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga07a13f8b7584d4a1bbe97f176942059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802c4cdd9583288401c5fb4318a6f329"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </td></tr>
<tr class="memitem:ga802c4cdd9583288401c5fb4318a6f329"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga802c4cdd9583288401c5fb4318a6f329">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="separator:ga802c4cdd9583288401c5fb4318a6f329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b5c1d8a0d366f33154fff40ce445bb"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:ga51b5c1d8a0d366f33154fff40ce445bb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read &gt; &amp;&amp;(Op==<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">sycl::ext::intel::esimd::atomic_op::load</a>||__ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga51b5c1d8a0d366f33154fff40ce445bb">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga51b5c1d8a0d366f33154fff40ce445bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga51b5c1d8a0d366f33154fff40ce445bb">More...</a><br /></td></tr>
<tr class="separator:ga51b5c1d8a0d366f33154fff40ce445bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c644731ba04a717fabdb4c2ce1bdf8"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaa0c644731ba04a717fabdb4c2ce1bdf8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaa0c644731ba04a717fabdb4c2ce1bdf8">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:gaa0c644731ba04a717fabdb4c2ce1bdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter.  <a href="group__sycl__esimd__memory__lsc.html#gaa0c644731ba04a717fabdb4c2ce1bdf8">More...</a><br /></td></tr>
<tr class="separator:gaa0c644731ba04a717fabdb4c2ce1bdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8828a49a2f30cea1dfaac32d1b9273d9"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:ga8828a49a2f30cea1dfaac32d1b9273d9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga8828a49a2f30cea1dfaac32d1b9273d9">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga8828a49a2f30cea1dfaac32d1b9273d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga8828a49a2f30cea1dfaac32d1b9273d9">More...</a><br /></td></tr>
<tr class="separator:ga8828a49a2f30cea1dfaac32d1b9273d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86bcd8a5335e9efe1ee3c2b8e554e7cd"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga86bcd8a5335e9efe1ee3c2b8e554e7cd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga86bcd8a5335e9efe1ee3c2b8e554e7cd">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga86bcd8a5335e9efe1ee3c2b8e554e7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter.  <a href="group__sycl__esimd__memory__lsc.html#ga86bcd8a5335e9efe1ee3c2b8e554e7cd">More...</a><br /></td></tr>
<tr class="separator:ga86bcd8a5335e9efe1ee3c2b8e554e7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08eaeb98ae6480eaf5ce761476d91b23"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:ga08eaeb98ae6480eaf5ce761476d91b23"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga08eaeb98ae6480eaf5ce761476d91b23">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ga08eaeb98ae6480eaf5ce761476d91b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="group__sycl__esimd__memory__lsc.html#ga08eaeb98ae6480eaf5ce761476d91b23">More...</a><br /></td></tr>
<tr class="separator:ga08eaeb98ae6480eaf5ce761476d91b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7968bf7d8bc3f038e2daf48ee04e606"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaa7968bf7d8bc3f038e2daf48ee04e606"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#gaa7968bf7d8bc3f038e2daf48ee04e606">sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga63a8c9a8d6aa33b7467e1ce1740a26ab">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf51bfab85c59e73b6e89714841780859">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:gaa7968bf7d8bc3f038e2daf48ee04e606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter.  <a href="group__sycl__esimd__memory__lsc.html#gaa7968bf7d8bc3f038e2daf48ee04e606">More...</a><br /></td></tr>
<tr class="separator:gaa7968bf7d8bc3f038e2daf48ee04e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d0e7f37a789976d253a5955bd97ece3"><td class="memTemplParams" colspan="2">template&lt;lsc_memory_kind Kind = lsc_memory_kind::untyped_global, lsc_fence_op FenceOp = lsc_fence_op::none, lsc_scope Scope = lsc_scope::group, int N = 16&gt; </td></tr>
<tr class="memitem:ga9d0e7f37a789976d253a5955bd97ece3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__lsc.html#ga9d0e7f37a789976d253a5955bd97ece3">sycl::_V1::ext::intel::experimental::esimd::lsc_fence</a> (<a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt; pred=1)</td></tr>
<tr class="memdesc:ga9d0e7f37a789976d253a5955bd97ece3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory fence.  <a href="group__sycl__esimd__memory__lsc.html#ga9d0e7f37a789976d253a5955bd97ece3">More...</a><br /></td></tr>
<tr class="separator:ga9d0e7f37a789976d253a5955bd97ece3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This group combines types and functions specific to LSC, which is available in Intel GPUs starting from PVC and ACM. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7f152f10c9444355e56f3934d4a41b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f152f10c9444355e56f3934d4a41b39">&#9670;&nbsp;</a></span>atomic_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum sycl::_V1::ext::intel::esimd::native::lsc::atomic_op : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LSC atomic operation codes. </p>
<p><code>atomic_update&lt;native::lsc::atomic_op::inc&gt;(...);</code> is a short-cut to <code>lsc_atomic_update&lt;atomic_op::inc&gt;(...);</code> with default cache and data size controls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39acf9f3fde7326f1d8e64205f0e07a3695"></a>inc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a1feea25ecb958229287f885aebe7c49b"></a>dec&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39aec4d1eb36b22d19728e9d1d23ca84d1c"></a>load&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a8cd892b7b97ef9489ae4479d3f4ef0fc"></a>store&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a34ec78fcc91ffb1e54cd85e4a0924332"></a>add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a8a68dc3e925eacf92633be230722a140"></a>sub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a36c5912f6e22a8791f1e2b080fec1f7e"></a>smin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39abd92ac5ba2dc1a7673c98858cfbab0af"></a>smax&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a017163727bc806385f1453c130b4fce3"></a>umin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a82c1089b8c973b65be6d620f765ed1f5"></a>umax&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a5314a49784395644281550cdf8e60c8d"></a>cmpxchg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a6d6fbe2c4e976a410868effe6deb2171"></a>fadd&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a09097f6fa7db7027ada3d6d8e930f3bd"></a>fsub&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a91b8694b07e3650d5332a6d51af36421"></a>fmin&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a6245653b1ded5cde266a956a325465ce"></a>fmax&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39ae4a112574052159467464500ceafe8f5"></a>fcmpxchg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39aaa8d31ef8411c3f53e6ebdc121d4478a"></a>bit_and&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39a1bf8f4ebf2c8abd137da6ae913d24b7b"></a>bit_or&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga7f152f10c9444355e56f3934d4a41b39ad5e6a1808b4174a20acda16d837e6739"></a>bit_xor&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2native_2common_8hpp_source.html#l00039">39</a> of file <a class="el" href="ext_2intel_2esimd_2native_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga08eaeb98ae6480eaf5ce761476d91b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08eaeb98ae6480eaf5ce761476d91b23">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand (expected value). </td></tr>
    <tr><td class="paramname">src1</td><td>is the second atomic operand (new value). </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02651">2651</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="ga8828a49a2f30cea1dfaac32d1b9273d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8828a49a2f30cea1dfaac32d1b9273d9">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_device_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02591">2591</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="ga51b5c1d8a0d366f33154fff40ce445bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b5c1d8a0d366f33154fff40ce445bb">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; (Op == <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">sycl::ext::intel::esimd::atomic_op::load</a> || __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02533">2533</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa7968bf7d8bc3f038e2daf48ee04e606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7968bf7d8bc3f038e2daf48ee04e606">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand (expected value). </td></tr>
    <tr><td class="paramname">src1</td><td>is the second atomic operand (new value). </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02682">2682</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="ga86bcd8a5335e9efe1ee3c2b8e554e7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86bcd8a5335e9efe1ee3c2b8e554e7cd">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02620">2620</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="gaa0c644731ba04a717fabdb4c2ce1bdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c644731ba04a717fabdb4c2ce1bdf8">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>lsc_atomic_update</code> that uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> as a parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02561">2561</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga21b09cae0dfd8defe7406e0306464f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b09cae0dfd8defe7406e0306464f73">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand (expected value). </td></tr>
    <tr><td class="paramname">src1</td><td>is the second atomic operand (new value). </td></tr>
    <tr><td class="paramname">pred</td><td>predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02470">2470</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="ga0bf7f056315ce1962e5fdaa439cc0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf7f056315ce1962e5fdaa439cc0994">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02412">2412</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="ga3d4f5d3d8836f91963afc0de142c2672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d4f5d3d8836f91963afc0de142c2672">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.ugm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02372">2372</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga07a13f8b7584d4a1bbe97f176942059e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a13f8b7584d4a1bbe97f176942059e">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02484">2484</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="ga26701cf6b5620b6eb5b44c7fa7d33f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26701cf6b5620b6eb5b44c7fa7d33f91">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02425">2425</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="ga802c4cdd9583288401c5fb4318a6f329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802c4cdd9583288401c5fb4318a6f329">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02498">2498</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="gab5a7c090448a2856c17182734ebcdb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a7c090448a2856c17182734ebcdb71">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; ((Op != <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">sycl::ext::intel::esimd::atomic_op::store</a> &amp;&amp; Op != sycl::ext::intel::esimd::atomic_op::xchg) || N == 1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02442">2442</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="ga4f1ec8e0ab865592aa9cad105f0e3927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f1ec8e0ab865592aa9cad105f0e3927">&#9670;&nbsp;</a></span>lsc_atomic_update() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02386">2386</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3ed0994c99b6ceb4b1bee794cda2295c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed0994c99b6ceb4b1bee794cda2295c">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of lsc_block_load without predicate parameter to simplify use of alignment parameter. </p>
<p>Collects elements located at surface and returns them as a single <a class="el" href="classsimd.html">simd</a> object. When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
    <tr><td class="paramname">flags</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. The elements of the returned vector for which the corresponding element in <code>pred</code> is 0 are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01135">1135</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga78c396fe999c00ad10a025280cd56a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c396fe999c00ad10a025280cd56a6f">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based transposed gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at surface and returns them as a single <a class="el" href="classsimd.html">simd</a> object. When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Operation is skipped for index 'i' if pred[i] == 0 and the result element is taken from <code>pass_thru</code>[i]. Otherwise, the operation is performed. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>contains the values copied to the result when the corresponding element from <code>pred</code> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01196">1196</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga305ea746f956a5bebccd2556e2702134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305ea746f956a5bebccd2556e2702134">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based transposed gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at surface and returns them as a single <a class="el" href="classsimd.html">simd</a> object. When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Zero means operation is skipped entirely, non-zero - operation is performed. The default is '1' - perform the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. The elements of the returned vector for which the corresponding element in <code>pred</code> is 0 are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01076">1076</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga77c9dba36c57cdeb58c182752ca8d297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c9dba36c57cdeb58c182752ca8d297">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01150">1150</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3a50bd14adab8f1095ce0f454c33aef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a50bd14adab8f1095ce0f454c33aef9">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01214">1214</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4c661e1184af6512e7d58160567ee928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c661e1184af6512e7d58160567ee928">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01093">1093</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga09b4479d454c636a7303589b29b4c918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b4479d454c636a7303589b29b4c918">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of lsc_block_load without predicate parameter to simplify use of alignment parameter. </p>
<p>Accesses contiguous block of memory of <code>NElts * S</code> bytes starting from given address, where S is a byte size of an "element" defined by the <code>DS</code> template parameter. The maximum size of accessed block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. The elements of the returned vector for which the corresponding element in <code>pred</code> is 0 are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00984">984</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa7299858491b41fee71ce8bcca46303d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7299858491b41fee71ce8bcca46303d">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer transposed gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Accesses contiguous block of memory of <code>NElts * S</code> bytes starting from given address, where S is a byte size of an "element" defined by the <code>DS</code> template parameter. The maximum size of accessed block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Zero means operation is skipped entirely, non-zero - operation is performed. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>contains the vector which elements are copied to the returned result when the corresponding element of <code>pred</code> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01028">1028</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad74ae0d9eecc990e01f1fb66188d6341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad74ae0d9eecc990e01f1fb66188d6341">&#9670;&nbsp;</a></span>lsc_block_load() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_load </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer transposed gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Accesses contiguous block of memory of <code>NElts * S</code> bytes starting from given address, where S is a byte size of an "element" defined by the <code>DS</code> template parameter. The maximum size of accessed block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. 8 bytes alignment is required for 64 bit data, 32 bit data and <code>NElts</code> equal to 128, 16 bit data and <code>NElts</code> equal to 256, 8 bit data and <code>NElts</code> equal to 512. Otherwise 4 bytes alignment is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">Flags</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Zero means operation is skipped entirely, non-zero - operation is performed. The default is '1' - perform the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. The elements of the returned vector for which the corresponding element in <code>pred</code> is 0 are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00943">943</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae9ceb16735a6744200dc26ef3c7eaa85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ceb16735a6744200dc26ef3c7eaa85">&#9670;&nbsp;</a></span>lsc_block_store() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of lsc_block_store without predicate parameter to simplify use of alignment parameter. </p>
<p>Scatters elements to surface. When <code>DS</code> equals <code>lsc_data_size::u64</code> or <code>sizeof(T)</code> equal to 8 the address must be 8-byte aligned, otherwise - 4-bytes aligned. Allowed values for the data size are <code>lsc_data_size::u32</code>, <code>lsc_data_size::u64</code>, <code>lsc_data_size::u8</code>, <code>lsc_data_size::u16</code>. When data size is either <code>lsc_data_size::u8</code> or <code>lsc_data_size::u16</code> the data is treated as 32 bit data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. 8 bytes alignment is required for 64 bit data, 32 bit data and <code>NElts</code> equal to 128, 16 bit data and <code>NElts</code> equal to 256, 8 bit data and <code>NElts</code> equal to 512. Otherwise 4 bytes alignment is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">flags</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01751">1751</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4a68b0745d8ccf547536dde719fa7d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a68b0745d8ccf547536dde719fa7d9a">&#9670;&nbsp;</a></span>lsc_block_store() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based transposed scatter with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.ugm</p>
<p>Scatters elements to surface. When <code>DS</code> equals <code>lsc_data_size::u64</code> or <code>sizeof(T)</code> equal to 8 the address must be 8-byte aligned, otherwise - 4-bytes aligned. Allowed values for the data size are <code>lsc_data_size::u32</code>, <code>lsc_data_size::u64</code>, <code>lsc_data_size::u8</code>, <code>lsc_data_size::u16</code>. When data size is either <code>lsc_data_size::u8</code> or <code>lsc_data_size::u16</code> the data is treated as 32 bit data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. 8 bytes alignment is required for 64 bit data, 32 bit data and <code>NElts</code> equal to 128, 16 bit data and <code>NElts</code> equal to 256, 8 bit data and <code>NElts</code> equal to 512. Otherwise 4 bytes alignment is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">Flags</td><td>is the alignment specifier type tag. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Zero means operation is skipped entirely, non-zero - operation is performed. The default is '1' - perform the operation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01690">1690</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga916111e3cad79a8b39c12c8ecb87d5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga916111e3cad79a8b39c12c8ecb87d5a9">&#9670;&nbsp;</a></span>lsc_block_store() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename AccessorTy , typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01707">1707</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab6ecbe7c9d3d9e4385028ed7c0cf83d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6ecbe7c9d3d9e4385028ed7c0cf83d3">&#9670;&nbsp;</a></span>lsc_block_store() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of lsc_block_store without predicate parameter to simplify use of alignment parameter. </p>
<p>Scatters elements to specific address. When <code>DS</code> equals <code>lsc_data_size::u64</code> or <code>sizeof(T)</code> equal to 8 the address must be 8-byte aligned, otherwise - 4-bytes aligned. Allowed values for the data size are <code>lsc_data_size::u32</code>, <code>lsc_data_size::u64</code>, <code>lsc_data_size::u8</code>, <code>lsc_data_size::u16</code>. When data size is either <code>lsc_data_size::u8</code> or <code>lsc_data_size::u16</code> the data is treated as 32 bit data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. 8 bytes alignment is required for 64 bit data, 32 bit data and <code>NElts</code> equal to 128, 16 bit data and <code>NElts</code> equal to 256, 8 bit data and <code>NElts</code> equal to 512. Otherwise 4 bytes alignment is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">flags</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01643">1643</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae7ab8c166b782b0160299203ad18f83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ab8c166b782b0160299203ad18f83c">&#9670;&nbsp;</a></span>lsc_block_store() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_block_store </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer transposed scatter with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.ugm</p>
<p>Scatters elements to specific address. When <code>DS</code> equals <code>lsc_data_size::u64</code> or <code>sizeof(T)</code> equal to 8 the address must be 8-byte aligned, otherwise - 4-bytes aligned. Allowed values for the data size are <code>lsc_data_size::u32</code>, <code>lsc_data_size::u64</code>, <code>lsc_data_size::u8</code>, <code>lsc_data_size::u16</code>. When data size is either <code>lsc_data_size::u8</code> or <code>lsc_data_size::u16</code> the data is treated as 32 bit data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512. 8 bytes alignment is required for 64 bit data, 32 bit data and <code>NElts</code> equal to 128, 16 bit data and <code>NElts</code> equal to 256, 8 bit data and <code>NElts</code> equal to 512. Otherwise 4 bytes alignment is required.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">Flags</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">pred</td><td>is operation predicate. Zero means operation is skipped entirely, non-zero - operation is performed. The default is '1' - perform the operation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01604">1604</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga9d0e7f37a789976d253a5955bd97ece3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d0e7f37a789976d253a5955bd97ece3">&#9670;&nbsp;</a></span>lsc_fence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;lsc_memory_kind Kind = lsc_memory_kind::untyped_global, lsc_fence_op FenceOp = lsc_fence_op::none, lsc_scope Scope = lsc_scope::group, int N = 16&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_fence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory fence. </p>
<p>Supported platforms: DG2, PVC</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Kind</td><td>is the Sfid shaded function. </td></tr>
    <tr><td class="paramname">FenceOp</td><td>is the fence operation. </td></tr>
    <tr><td class="paramname">Scope</td><td>is the operation scope. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02701">2701</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gabb05c22e655e661c97296763c7048335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb05c22e655e661c97296763c7048335">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at surface and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>contains the vector which elements are copied to the returned result when the corresponding element of <code>pred</code> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00856">856</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga556ce3fe630fafba83af453226f57ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556ce3fe630fafba83af453226f57ae7">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at surface and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00782">782</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga27f961f0811e7e76f9db20855887728a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27f961f0811e7e76f9db20855887728a">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; sycl::detail::acc_properties::is_local_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00896">896</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5b1231989b18ba85720ebc09a7885a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1231989b18ba85720ebc09a7885a3d">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00821">821</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga3fa3c851d7beb8af38c8b754d270ee36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa3c851d7beb8af38c8b754d270ee36">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at specified address and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>contains the vector which elements are copied to the returned result when the corresponding element of <code>pred</code> is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00702">702</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaee6780b83f37c110c741d19f8b412f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee6780b83f37c110c741d19f8b412f3b">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Collects elements located at specified address and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00669">669</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gabf942c19c0df072aaa9190aec2bb63b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf942c19c0df072aaa9190aec2bb63b5">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00725">725</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga020c090954f523630fb7336735657fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020c090954f523630fb7336735657fcc">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00715">715</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4ea0fd9f294b4c40f4bdedb03868e791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea0fd9f294b4c40f4bdedb03868e791">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00749">749</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gadb98fccf2646293870dadcf3c0137db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb98fccf2646293870dadcf3c0137db2">&#9670;&nbsp;</a></span>lsc_gather() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00738">738</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaee81777dc15edc04c5c28cfd4bfcf54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee81777dc15edc04c5c28cfd4bfcf54b">&#9670;&nbsp;</a></span>lsc_load_2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ESIMD_INLINE SYCL_ESIMD_FUNCTION <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_load_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>2D</code> stateless block load <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed. </p>
<p>Note: No software mitigation for hardware bugs is possible for this function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the element data type </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>the block width in number of elements </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>block height in number of elements </td></tr>
    <tr><td class="paramname">NBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramname">Transposed</td><td>is the transposed version or not. </td></tr>
    <tr><td class="paramname">Transformed</td><td>is apply VNNI transform or not. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>is <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> holding all the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N, where N is getNextPowerOf2(Height) * Width * NBlocks, if transposed getNextPowerOf2(Width) * Height * NBlocks, otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02101">2101</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00566">sycl::_V1::ext::intel::esimd::detail::check_cache_hints()</a>.</p>

</div>
</div>
<a id="ga54b22aad8ce5326ba6ecce630c7e96a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54b22aad8ce5326ba6ecce630c7e96a1">&#9670;&nbsp;</a></span>lsc_load_2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_load_2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D USM pointer block load. </p>
<p>Supported platforms: PVC VISA instruction: lsc_load_block2d.ugm</p>
<p>Collects elements located at specified address and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">NBlocks</td><td>is the number of blocks. </td></tr>
    <tr><td class="paramname">Transposed</td><td>is the transposed version or not. </td></tr>
    <tr><td class="paramname">Transformed</td><td>is apply VNNI transform or not. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N, where N is BlockWidth * BlockHeight * NBlocks, if transformed; otherwise, N = roundUpNextMultiple(BlockHeight, 4 / sizeof(T)) * getNextPowerOf2(BlockWidth) * NBlocks </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01793">1793</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaed205c44626e2ab0879b3fc5a69138bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed205c44626e2ab0879b3fc5a69138bc">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &amp;&amp; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__ESIMD_DNS::DeviceAccessorOffsetT&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based transposed prefetch gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Prefetches elements located at surface of <code>NElts * S</code> bytes starting from given offset, where S is a byte size of an "element" defined by the <code>DS</code> template parameter. The maximum size of accessed block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offset</td><td>is the zero-based offset in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01390">1390</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa857d3d1056ffb7ed5215d34106c23a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa857d3d1056ffb7ed5215d34106c23a0">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_read&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based prefetch gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Prefetches elements located at surface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01326">1326</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaec1c743f49f7b2e00c07180eaed0aabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec1c743f49f7b2e00c07180eaed0aabc">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">sycl::ext::intel::esimd::is_simd_flag_type_v</a>&lt;FlagsT&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer prefetch transposed gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Prefetches elements located at contiguous block of memory of <code>NElts * S</code> bytes starting from given address, where S is a byte size of an "element" defined by the <code>DS</code> template parameter. The maximum size of prefetched block is 512 bytes for PVC and 256 bytes for ACM (DG2). When sizeof(T) equal to 8 the address must be 8-byte aligned. Also, 8-bytes alignment is required when the function has to load more than 256-bytes. In all other cases 4-byte alignment is required. When T is 1- or 2-byte type the data is treated as 4-byte data. Allowed <code>NElts</code> values for 64 bit data are 1, 2, 3, 4, 8, 16, 32, 64. Allowed <code>NElts</code> values for 32 bit data are 1, 2, 3, 4, 8, 16, 32, 64, 128. Allowed <code>NElts</code> values for 16 bit data are 2, 4, 8, 16, 32, 64, 128, 256. Allowed <code>NElts</code> values for 8 bit data are 4, 8, 12, 16, 32, 64, 128, 256, 512.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">FlagsT</td><td>is the alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01296">1296</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga2b39366f8a774ff152b750cfd8d2cd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b39366f8a774ff152b750cfd8d2cd07">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer prefetch gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.ugm</p>
<p>Prefetches elements located at specified address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01240">1240</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5e954daee63bbca4dff392a7de3b3f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e954daee63bbca4dff392a7de3b3f0d">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01251">1251</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga716d4a18216f616bff2c724147bd149a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga716d4a18216f616bff2c724147bd149a">&#9670;&nbsp;</a></span>lsc_prefetch() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01261">1261</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga0e6cf7a1a8492641c9d83d2aa4ddb1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e6cf7a1a8492641c9d83d2aa4ddb1ec">&#9670;&nbsp;</a></span>lsc_prefetch_2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ESIMD_INLINE SYCL_ESIMD_FUNCTION void sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>2D</code> stateless block prefetch <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed. </p>
<p>Note: No software mitigation for hardware bugs is possible for this function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the element data type </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>the block width in number of elements </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>block height in number of elements </td></tr>
    <tr><td class="paramname">NBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramname">Transposed</td><td>is the transposed version or not. </td></tr>
    <tr><td class="paramname">Transformed</td><td>is apply VNNI transform or not. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>is <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> holding all the data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02197">2197</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00566">sycl::_V1::ext::intel::esimd::detail::check_cache_hints()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09405">sycl::_V1::ext::intel::esimd::prefetch()</a>.</p>

</div>
</div>
<a id="gaa7c84cd33547d291ee7986d61e65aa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c84cd33547d291ee7986d61e65aa4f">&#9670;&nbsp;</a></span>lsc_prefetch_2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false, false&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_prefetch_2d </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D USM pointer block prefetch. </p>
<p>Supported platforms: PVC VISA instruction: lsc_load_block2d.ugm</p>
<p>Prefetches elements located at specified address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">NBlocks</td><td>is the number of blocks. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01827">1827</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf3dd941ed899a312b4093d5ef1c5f7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3dd941ed899a312b4093d5ef1c5f7a8">&#9670;&nbsp;</a></span>lsc_scatter() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_device_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; __ESIMD_DNS::DeviceAccessorOffsetT, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessor-based scatter. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.ugm</p>
<p>Scatters elements to surface.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>is the <a class="el" href="classsycl_1_1__V1_1_1accessor.html">sycl::accessor</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>is the SYCL accessor. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01524">1524</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga06d76173b8dad2141af91578804e9054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d76173b8dad2141af91578804e9054">&#9670;&nbsp;</a></span>lsc_scatter() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::is_local_accessor_with_v&lt; AccessorTy, __ESIMD_DNS::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::experimental::esimd::lsc_scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01561">1561</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad8081477c17d72f2ee4d7dad4397d88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8081477c17d72f2ee4d7dad4397d88f">&#9670;&nbsp;</a></span>lsc_scatter() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USM pointer scatter. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.ugm</p>
<p>Scatters elements to specific address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>is the base pointer. </td></tr>
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01470">1470</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab4cae892bebf2dcfb6c332909f415e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cae892bebf2dcfb6c332909f415e8e">&#9670;&nbsp;</a></span>lsc_scatter() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">sycl::ext::intel::esimd::simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01483">1483</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad36aad80d84d6f7133bdfdeb1f24a41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad36aad80d84d6f7133bdfdeb1f24a41e">&#9670;&nbsp;</a></span>lsc_scatter() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; N == 1&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_scatter </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01494">1494</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga417c531396e07a9bffede4335603a40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga417c531396e07a9bffede4335603a40e">&#9670;&nbsp;</a></span>lsc_slm_atomic_update() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.slm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand (expected value). </td></tr>
    <tr><td class="paramname">src1</td><td>is the second atomic operand (new value). </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02345">2345</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src1</a>.</p>

</div>
</div>
<a id="gafb85655eafc44cdfe3d5b865f17df7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb85655eafc44cdfe3d5b865f17df7d7">&#9670;&nbsp;</a></span>lsc_slm_atomic_update() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.slm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02321">2321</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2math_8hpp_source.html#l00528">sycl::_V1::ext::intel::experimental::esimd::src0</a>.</p>

</div>
</div>
<a id="ga6d15ff90c910663cc04866767c26a120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d15ff90c910663cc04866767c26a120">&#9670;&nbsp;</a></span>lsc_slm_atomic_update() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM atomic. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_atomic_&lt;OP&gt;.slm</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>is operation type. </td></tr>
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02299">2299</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab6feb5ec4d77e9119670a8186ed8013f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6feb5ec4d77e9119670a8186ed8013f">&#9670;&nbsp;</a></span>lsc_slm_block_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposed SLM gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.slm</p>
<p>Collects elements located at slm and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the zero-based offset for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is the predicate; if it contains 0, then the actual load is not performed and <code>pass_thru</code> is returned. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>contains the vector that is returned if the parameter <code>pred</code> contains 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00639">639</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="memory__properties_8hpp_source.html#l00098">sycl::_V1::ext::intel::esimd::alignment</a>.</p>

</div>
</div>
<a id="ga972c8ff6508adc58dc09fca76c1fe4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga972c8ff6508adc58dc09fca76c1fe4c8">&#9670;&nbsp;</a></span>lsc_slm_block_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposed SLM gather with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.slm</p>
<p>Collects elements located at slm and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the zero-based offset for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is the predicate; if it contains 0, then the actual load is not performed and the returned value is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00612">612</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga297e98ccc4e2d12445f4fdcf49c4e9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga297e98ccc4e2d12445f4fdcf49c4e9a3">&#9670;&nbsp;</a></span>lsc_slm_block_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts, lsc_data_size DS = lsc_data_size::default_size, typename FlagsT  = __ESIMD_DNS::dqword_element_aligned_tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FlagsT&#160;</td>
          <td class="paramname"><em>flags</em> = <code>FlagsT{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposed SLM scatter with 1 channel. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.slm</p>
<p>Scatters elements located to slm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size (unused/obsolete). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is the zero-based offset for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01439">1439</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1128f1576ca53032782d45521d4c60b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1128f1576ca53032782d45521d4c60b8">&#9670;&nbsp;</a></span>lsc_slm_gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.slm</p>
<p>Collects elements located at slm and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>values copied to the result when the corresponding element of <code>pred</code> is zero.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00588">588</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gab5ecb397ce268aaab6c909e8443db0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ecb397ce268aaab6c909e8443db0e0">&#9670;&nbsp;</a></span>lsc_slm_gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N * NElts&gt; sycl::_V1::ext::intel::experimental::esimd::lsc_slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM gather. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_load.slm</p>
<p>Collects elements located at slm and returns them as a single <a class="el" href="classsimd.html">simd</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to load per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is a vector of type T and size N * NElts </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00562">562</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga51841452071a8b53e530194a3fce6237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51841452071a8b53e530194a3fce6237">&#9670;&nbsp;</a></span>lsc_slm_scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int NElts = 1, lsc_data_size DS = lsc_data_size::default_size, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_slm_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N *NElts &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>pred</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SLM scatter. </p>
<p>Supported platforms: DG2, PVC VISA instruction: lsc_store.slm</p>
<p>Scatters elements located to slm.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">NElts</td><td>is the number of elements to store per address. </td></tr>
    <tr><td class="paramname">DS</td><td>is the data size. </td></tr>
    <tr><td class="paramname">N</td><td>is the number of channels (platform dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>is the zero-based offsets for SLM buffer in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>is values to store. </td></tr>
    <tr><td class="paramname">pred</td><td>is predicates. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01419">1419</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac61bc053bd928545e497668ea5e77f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac61bc053bd928545e497668ea5e77f1a">&#9670;&nbsp;</a></span>lsc_store_2d() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false, false&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ESIMD_INLINE SYCL_ESIMD_FUNCTION void sycl::_V1::ext::intel::experimental::esimd::lsc_store_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html">config_2d_mem_access</a>&lt; T, BlockWidth, BlockHeight, NBlocks &gt; &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>Data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of <code>2D</code> stateless block store <code>with</code> parameters passed as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> Note: Compatibility with future hardware versions is not guaranteed. </p>
<p>Note: No software mitigation for hardware bugs is possible for this function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is the element data type </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>the block width in number of elements </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>block height in number of elements </td></tr>
    <tr><td class="paramname">NBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>is <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1experimental_1_1esimd_1_1config__2d__mem__access.html" title="Container class to hold parameters for load2d/store2d functions">config_2d_mem_access</a></code> <code>object</code> holding all the data </td></tr>
    <tr><td class="paramname">Data</td><td>is the data to be stored. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02243">2243</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00566">sycl::_V1::ext::intel::esimd::detail::check_cache_hints()</a>.</p>

</div>
</div>
<a id="ga74ed09ebe6eb2d9662dac2913a49931b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ed09ebe6eb2d9662dac2913a49931b">&#9670;&nbsp;</a></span>lsc_store_2d() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int BlockWidth, int BlockHeight = 1, cache_hint L1H = cache_hint::none, cache_hint L2H = cache_hint::none, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false, false&gt;()&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::experimental::esimd::lsc_store_2d </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>SurfacePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>Vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D USM pointer block store. </p>
<p>Supported platforms: PVC VISA instruction: lsc_store_block2d.ugm</p>
<p>Stores elements at specified address.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is element type. </td></tr>
    <tr><td class="paramname">BlockWidth</td><td>is the block width in number of elements. </td></tr>
    <tr><td class="paramname">BlockHeight</td><td>is the block height in number of elements. </td></tr>
    <tr><td class="paramname">L1H</td><td>is L1 cache hint. </td></tr>
    <tr><td class="paramname">L2H</td><td>is L2 cache hint. </td></tr>
    <tr><td class="paramname">N</td><td>is the data size </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the surface base address for this operation. </td></tr>
    <tr><td class="paramname">SurfaceWidth</td><td>is the surface width minus 1 in bytes </td></tr>
    <tr><td class="paramname">SurfaceHeight</td><td>is the surface height minus 1 in rows </td></tr>
    <tr><td class="paramname">SurfacePitch</td><td>is the surface pitch minus 1 in bytes </td></tr>
    <tr><td class="paramname">X</td><td>is zero based X-coordinate of the left upper rectangle corner in number of elements. </td></tr>
    <tr><td class="paramname">Y</td><td>is zero based Y-coordinate of the left upper rectangle corner in rows. </td></tr>
    <tr><td class="paramname">Vals</td><td>is a vector to store of type T and size N, where N = roundUpNextMultiple(BlockHeight, 4 / sizeof(T)) * getNextPowerOf2(BlockWidth) * NBlocks </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l01864">1864</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
