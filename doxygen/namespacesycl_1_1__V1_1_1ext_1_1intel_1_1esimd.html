<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: sycl::_V1::ext::intel::esimd Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sycl::_V1::ext::intel::esimd Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1native"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1native.html">native</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1xmx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1xmx.html">xmx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__on__tag.html">saturation_on_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gen hardware supports applying saturation to results of certain operations.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__on__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__off__tag.html">saturation_off_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type tag represents "saturation off" behavior.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__off__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1element__aligned__tag.html">element_aligned_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1element__aligned__tag.html" title="element_aligned_tag type.">element_aligned_tag</a></code> type.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1element__aligned__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1vector__aligned__tag.html">vector_aligned_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1vector__aligned__tag.html" title="vector_aligned_tag type.">vector_aligned_tag</a></code> type.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1vector__aligned__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1overaligned__tag.html">overaligned_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1overaligned__tag.html" title="overaligned_tag type.">overaligned_tag</a></code> type.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1overaligned__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type.html">is_simd_flag_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if type is a simd load/store flag.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type_3_01element__aligned__tag_01_4.html">is_simd_flag_type&lt; element_aligned_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type_3_01vector__aligned__tag_01_4.html">is_simd_flag_type&lt; vector_aligned_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type_3_01overaligned__tag_3_01N_01_4_01_4.html">is_simd_flag_type&lt; overaligned_tag&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type_3_01detail_1_1dqword__element__aligned__tag_01_4.html">is_simd_flag_type&lt; detail::dqword_element_aligned_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main simd vector class.  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a reference to a sub-region of a base simd object.  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1properties.html">properties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html">cache_hint_L1_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'cache_hint_L1', 'cache_hint_L2' and 'cache_hint_L3' properties are used to specify L1, L2, L3 cache hints available in target device.  <a href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L2__key.html">cache_hint_L2_key</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L3__key.html">cache_hint_L3_key</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view_3_01BaseTy_00_01region1d__scalar__t_3_01ViewedElemT_01_4_01_4.html">simd_view&lt; BaseTy, region1d_scalar_t&lt; ViewedElemT &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> class with a single element.  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view_3_01BaseTy_00_01region1d__scalar__t_3_01ViewedElemT_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view_3_01BaseTy_00_01std_1_1pair_3_01region1443f936375187e4cf2883298c22718aa.html">simd_view&lt; BaseTy, std::pair&lt; region1d_scalar_t&lt; ViewedElemT &gt;, NestedRegion &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of nested <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> class with a single element.  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view_3_01BaseTy_00_01std_1_1pair_3_01region1443f936375187e4cf2883298c22718aa.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1slm__allocator.html">slm_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII-style class used to implement "semi-dynamic" SLM allocation.  <a href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1slm__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa7f23bfb7a49467cb71be35ae09953eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#gaa7f23bfb7a49467cb71be35ae09953eb">uchar</a> = unsigned char</td></tr>
<tr class="separator:gaa7f23bfb7a49467cb71be35ae09953eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdae91abcb480a0607e1370cd0cf7bfe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#gabdae91abcb480a0607e1370cd0cf7bfe">ushort</a> = unsigned short</td></tr>
<tr class="separator:gabdae91abcb480a0607e1370cd0cf7bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9aaba24424a05116eb8c5f94858b4b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> = unsigned int</td></tr>
<tr class="separator:gaf9aaba24424a05116eb8c5f94858b4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f7fa652eebf3bdf4266307fd9cb1ed2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga5f7fa652eebf3bdf4266307fd9cb1ed2">SurfaceIndex</a> = unsigned int</td></tr>
<tr class="memdesc:ga5f7fa652eebf3bdf4266307fd9cb1ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surface index type.  <a href="group__sycl__esimd__core.html#ga5f7fa652eebf3bdf4266307fd9cb1ed2">More...</a><br /></td></tr>
<tr class="separator:ga5f7fa652eebf3bdf4266307fd9cb1ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb949a660e6d8b2bc4b78a48497d334f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:abb949a660e6d8b2bc4b78a48497d334f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abb949a660e6d8b2bc4b78a48497d334f">mask_type_t</a> = detail::simd_mask_storage_t&lt; N &gt;</td></tr>
<tr class="separator:abb949a660e6d8b2bc4b78a48497d334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b174757556cf232286ece7fad45393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad4b174757556cf232286ece7fad45393">alignment_key</a> = <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1alignment__key.html">sycl::ext::oneapi::experimental::alignment_key</a></td></tr>
<tr class="memdesc:ad4b174757556cf232286ece7fad45393"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'alignment' property is used to specify the alignment of memory accessed in ESIMD memory operation such as <a class="el" href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0" title="Each of the following block load functions loads a contiguous memory block from the address reference...">block_load()</a>.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad4b174757556cf232286ece7fad45393">More...</a><br /></td></tr>
<tr class="separator:ad4b174757556cf232286ece7fad45393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b006c911799da60e033f530e0dc049"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ae5b006c911799da60e033f530e0dc049">default_cache_hint_L1</a> = <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html#a2cd710fee969081dc50a59f025cde42e">cache_hint_L1_key::value_t</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> &gt;</td></tr>
<tr class="separator:ae5b006c911799da60e033f530e0dc049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0463d617c322158e8155296a548fb0c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a0463d617c322158e8155296a548fb0c6">default_cache_hint_L2</a> = <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L2__key.html#abaff15b19c231d6347cf92e3f892c1d2">cache_hint_L2_key::value_t</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> &gt;</td></tr>
<tr class="separator:a0463d617c322158e8155296a548fb0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e122af9d5c5cadfb1688680a4320ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a21e122af9d5c5cadfb1688680a4320ab">default_cache_hint_L3</a> = <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L3__key.html#a3635aa7d6a9dd198082d5263c293da4b">cache_hint_L3_key::value_t</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a> &gt;</td></tr>
<tr class="separator:a21e122af9d5c5cadfb1688680a4320ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf9f3ea8534fe5107b78fc8ae5509d3"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gabdf9f3ea8534fe5107b78fc8ae5509d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a> = detail::simd_mask_type&lt; N &gt;</td></tr>
<tr class="memdesc:gabdf9f3ea8534fe5107b78fc8ae5509d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a simd mask os size <code>N</code>.  <a href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">More...</a><br /></td></tr>
<tr class="separator:gabdf9f3ea8534fe5107b78fc8ae5509d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga461b484b4e6dfd73881ed8c3fbc68060"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga461b484b4e6dfd73881ed8c3fbc68060">rgba_channel</a> : uint8_t { <a class="el" href="group__sycl__esimd__core.html#gga461b484b4e6dfd73881ed8c3fbc68060ae1e1d3d40573127e9ee0480caf1283d6">R</a>
, <a class="el" href="group__sycl__esimd__core.html#gga461b484b4e6dfd73881ed8c3fbc68060adfcf28d0734569a6a693bc8194de62bf">G</a>
, <a class="el" href="group__sycl__esimd__core.html#gga461b484b4e6dfd73881ed8c3fbc68060a9d5ed678fe57bcca610140957afab571">B</a>
, <a class="el" href="group__sycl__esimd__core.html#gga461b484b4e6dfd73881ed8c3fbc68060a7fc56270e7a70fa81a5935b72eacbe29">A</a>
 }</td></tr>
<tr class="memdesc:ga461b484b4e6dfd73881ed8c3fbc68060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pixel's channel.  <a href="group__sycl__esimd__core.html#ga461b484b4e6dfd73881ed8c3fbc68060">More...</a><br /></td></tr>
<tr class="separator:ga461b484b4e6dfd73881ed8c3fbc68060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51955fda2c80af216ff563a4202122e8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga51955fda2c80af216ff563a4202122e8">raw_send_eot</a> : uint8_t { <a class="el" href="group__sycl__esimd__core.html#gga51955fda2c80af216ff563a4202122e8a7eeac285a734b808407d5038c4bdddd8">not_eot</a> = 0
, <a class="el" href="group__sycl__esimd__core.html#gga51955fda2c80af216ff563a4202122e8a8cc16517b421262382c5cf28e0ed9a4b">eot</a> = 1
 }</td></tr>
<tr class="memdesc:ga51955fda2c80af216ff563a4202122e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify if end of thread should be set.  <a href="group__sycl__esimd__core.html#ga51955fda2c80af216ff563a4202122e8">More...</a><br /></td></tr>
<tr class="separator:ga51955fda2c80af216ff563a4202122e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c57bf607a193c9aa50d6da351f635cd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga5c57bf607a193c9aa50d6da351f635cd">raw_send_sendc</a> : uint8_t { <a class="el" href="group__sycl__esimd__core.html#gga5c57bf607a193c9aa50d6da351f635cdab846ab6bb97056f604308db965c80026">not_sendc</a> = 0
, <a class="el" href="group__sycl__esimd__core.html#gga5c57bf607a193c9aa50d6da351f635cda158eca3797cc18cf2393c33034a5cdc5">sendc</a> = 1
 }</td></tr>
<tr class="memdesc:ga5c57bf607a193c9aa50d6da351f635cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify if sendc should be used.  <a href="group__sycl__esimd__core.html#ga5c57bf607a193c9aa50d6da351f635cd">More...</a><br /></td></tr>
<tr class="separator:ga5c57bf607a193c9aa50d6da351f635cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d9236d9d20da467da1697426b1b8e4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga51d9236d9d20da467da1697426b1b8e4">rgba_channel_mask</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4ae1e1d3d40573127e9ee0480caf1283d6">R</a> = detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4adfcf28d0734569a6a693bc8194de62bf">G</a> = detail::chG
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4af214a7d42e0de5875d55189e01e2e187">GR</a> = detail::chG | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a9d5ed678fe57bcca610140957afab571">B</a> = detail::chB
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a19d3326f3137cbadd21ce901a9bed4a7">BR</a> = detail::chB | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a461b1990fe86af962cd15a16a26dceb8">BG</a> = detail::chB | detail::chG
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a2ad5640ebdec72fc79531d1778c6c2dc">BGR</a> = detail::chB | detail::chG | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a7fc56270e7a70fa81a5935b72eacbe29">A</a> = detail::chA
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a5b61a1b298a0d06efa6933a97e68d763">AR</a> = detail::chA | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4a6b712da7b7ccf80851beb06de6c32e6c">AG</a> = detail::chA | detail::chG
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4af789016f11d31013049f5517794dbe86">AGR</a> = detail::chA | detail::chG | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4ab86fc6b051f63d73de262d4c34e3a0a9">AB</a> = detail::chA | detail::chB
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4ab8fcc69d250d3ed23c05e0105ea381db">ABR</a> = detail::chA | detail::chB | detail::chR
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4ac674bd9db27f385695e713d85b4f7188">ABG</a> = detail::chA | detail::chB | detail::chG
, <a class="el" href="group__sycl__esimd__core.html#gga51d9236d9d20da467da1697426b1b8e4adce7d10c2f9ffc8ed9e7b6a3f7d8ba6c">ABGR</a> = detail::chA | detail::chB | detail::chG | detail::chR
<br />
 }</td></tr>
<tr class="memdesc:ga51d9236d9d20da467da1697426b1b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pixel's channel mask - all possible combinations of enabled channels.  <a href="group__sycl__esimd__core.html#ga51d9236d9d20da467da1697426b1b8e4">More...</a><br /></td></tr>
<tr class="separator:ga51d9236d9d20da467da1697426b1b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d821293325e83ff7ea04b0562225aa"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#gad3d821293325e83ff7ea04b0562225aa">atomic_op</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa34ec78fcc91ffb1e54cd85e4a0924332">add</a> = 0x0
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8a68dc3e925eacf92633be230722a140">sub</a> = 0x1
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695">inc</a> = 0x2
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b">dec</a> = 0x3
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa017163727bc806385f1453c130b4fce3">umin</a> = 0x4
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa82c1089b8c973b65be6d620f765ed1f5">umax</a> = 0x5
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">xchg</a> = 0x6
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa5314a49784395644281550cdf8e60c8d">cmpxchg</a> = 0x7
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaaa8d31ef8411c3f53e6ebdc121d4478a">bit_and</a> = 0x8
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1bf8f4ebf2c8abd137da6ae913d24b7b">bit_or</a> = 0x9
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaad5e6a1808b4174a20acda16d837e6739">bit_xor</a> = 0xa
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa36c5912f6e22a8791f1e2b080fec1f7e">smin</a> = 0xb
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaabd92ac5ba2dc1a7673c98858cfbab0af">smax</a> = 0xc
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce">fmax</a> = 0x10
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421">fmin</a> = 0x11
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5">fcmpxchg</a> = 0x12
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaafc01fcd1835c2d3c70415339827e6e73">fcmpwr</a> = fcmpxchg
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171">fadd</a> = 0x13
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd">fsub</a> = 0x14
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">load</a> = 0x15
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">store</a> = 0x16
, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaab5531e780dbe82f68cb3de21c5ee7153">predec</a> = 0xff
<br />
 }</td></tr>
<tr class="memdesc:gad3d821293325e83ff7ea04b0562225aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an atomic operation.  <a href="group__sycl__esimd__core.html#gad3d821293325e83ff7ea04b0562225aa">More...</a><br /></td></tr>
<tr class="separator:gad3d821293325e83ff7ea04b0562225aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2bc84aa5bf46a74db45b0051772eed"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eed">fence_scope</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eedadb0f6f37ebeb6ea09489124345af2a45">group</a> = 0
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eedaf5ddaf0ca7929578b408c909429f68f2">local</a> = 1
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eeda13181d8cc01e390bf64c9e4b0d7a79f3">tile</a> = 2
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eeda0aa0be2a866411d9ff03515227454947">gpu</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eeda2e98f7cfbcdadfeb431fec785e549c59">gpus</a> = 4
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eeda54b53072540eeeb8f8e9343e71f28176">system</a> = 5
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eeda2fc7d4831e1ec78f7c70926152fca677">system_acquire</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:abd2bc84aa5bf46a74db45b0051772eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scope that <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> operation should apply to.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eed">More...</a><br /></td></tr>
<tr class="separator:abd2bc84aa5bf46a74db45b0051772eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f841ed03c4b1992d2b6a227d9df818"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818">fence_flush_op</a> : uint8_t { <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818aeb9885e11bb255862e765a54558fd1ad">evict</a> = 1
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818ac9ef7a446d9608ed2229ef347d13af7e">invalidate</a> = 2
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818a123402c04dcfb6625f688f771a5fc05d">clean</a> = 4
 }</td></tr>
<tr class="memdesc:ad1f841ed03c4b1992d2b6a227d9df818"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cache flush operation to apply to caches after <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> is complete.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818">More...</a><br /></td></tr>
<tr class="separator:ad1f841ed03c4b1992d2b6a227d9df818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81b63371b6d962b629a18d19e5e4796"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796">memory_kind</a> : uint8_t { <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796a9c70933aff6b2a6d08c687a6cbb6b765">global</a> = 0
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796a78805a221a988e79ef3f42d7c5bfd418">image</a> = 2
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796af5ddaf0ca7929578b408c909429f68f2">local</a> = 3
 }</td></tr>
<tr class="memdesc:ad81b63371b6d962b629a18d19e5e4796"><td class="mdescLeft">&#160;</td><td class="mdescRight">The target memory kind for <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> operation.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796">More...</a><br /></td></tr>
<tr class="separator:ad81b63371b6d962b629a18d19e5e4796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e02a716e3ba958acf101e2503052dc7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> : uint8_t { <a class="el" href="group__sycl__esimd__logical.html#gga3e02a716e3ba958acf101e2503052dc7a9dd4e461268c8034f5c8564e155c67a6">x</a> = 0xAA
, <a class="el" href="group__sycl__esimd__logical.html#gga3e02a716e3ba958acf101e2503052dc7a415290769594460e2e485922904f345d">y</a> = 0xCC
, <a class="el" href="group__sycl__esimd__logical.html#gga3e02a716e3ba958acf101e2503052dc7afbade9e36a3f36d3d676c1b808451dd7">z</a> = 0xF0
 }</td></tr>
<tr class="memdesc:ga3e02a716e3ba958acf101e2503052dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum is used to encode all possible logical operations performed on the 3 input operands.  <a href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">More...</a><br /></td></tr>
<tr class="separator:ga3e02a716e3ba958acf101e2503052dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga906135fd4810a79321d334ff5a6f917f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">fence_mask</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa352e1a80b6a794d0635d97bce7be7a99">global_coherent_fence</a> = 0x1
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917faecbd2e70ac0a720e0637bef6d3436f64">l2_flush_instructions</a> = 0x2
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fadbfc05dab2e2f87874de2d77b1fbd87e">l2_flush_texture_data</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa366cc36ca4e0f2747a4e8b7c92a316f1">l2_flush_constant_data</a> = 0x8
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa94e99d3ee1634b6ae3e5d556ef8de693">l2_flush_rw_data</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa3fb710e2fb45d755fb367baaf61c4d58">local_barrier</a> = 0x20
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa7555392d8038cb3d5f52d9d8f3394cb8">l1_flush_ro_data</a> = 0x40
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">__SYCL_DEPRECATED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga906135fd4810a79321d334ff5a6f917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represetns a bit mask to control behavior of esimd::fence.  <a href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">More...</a><br /></td></tr>
<tr class="separator:ga906135fd4810a79321d334ff5a6f917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4685c99aefa9c4f30766c92970dfc6ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6ca">cache_level</a> : uint8_t { <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6caa9ec4c0afd450ceac7adb81c3bcfc9732">L1</a> = 1
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6caa7e6aa2d53f6ee2b1a34b017fa403cb76">L2</a> = 2
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6caa842ce6eb510f7e7047da883915ec90e0">L3</a> = 3
 }</td></tr>
<tr class="memdesc:a4685c99aefa9c4f30766c92970dfc6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1, L2 or L3 cache hint levels. L3 is reserved for future use.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6ca">More...</a><br /></td></tr>
<tr class="separator:a4685c99aefa9c4f30766c92970dfc6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6d2e5ce8bbe9ce80bac4d1467b1e6c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6c">cache_hint</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6caaf9f686f9eb416162d298446a94cfafb">uncached</a> = 1
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca1fb1a060534164a18a99494122825190">cached</a> = 2
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6caa9c64c25d98516dabbeaa44fa4b798fe">write_back</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca99f2e1bde3d240b180ae0b0b9ccfc135">write_through</a> = 4
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6caabb0256a318439745ab0b343d64b9ba0">streaming</a> = 5
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca2f45cbd63698443b09ad479d71ae024c">read_invalidate</a> = 6
, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca86e617a69861a14387319427caad5dab">const_cached</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a4a6d2e5ce8bbe9ce80bac4d1467b1e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1, L2 or L3 cache hints.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6c">More...</a><br /></td></tr>
<tr class="separator:a4a6d2e5ce8bbe9ce80bac4d1467b1e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab5eca9ca12bb6fe52e4226b2f427d657"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gab5eca9ca12bb6fe52e4226b2f427d657"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__misc.html#gab5eca9ca12bb6fe52e4226b2f427d657">merge</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; a, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; b, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; m)</td></tr>
<tr class="memdesc:gab5eca9ca12bb6fe52e4226b2f427d657"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Merges" elements of the input simd object according to the merge mask.  <a href="group__sycl__esimd__misc.html#gab5eca9ca12bb6fe52e4226b2f427d657">More...</a><br /></td></tr>
<tr class="separator:gab5eca9ca12bb6fe52e4226b2f427d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d0cfde09531d7cb8a8cd37ccec6733"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ga05d0cfde09531d7cb8a8cd37ccec6733"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__misc.html#ga05d0cfde09531d7cb8a8cd37ccec6733">merge</a> (<a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; a, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; b, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; m)</td></tr>
<tr class="memdesc:ga05d0cfde09531d7cb8a8cd37ccec6733"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Merges" elements of the input masks according to the merge mask.  <a href="group__sycl__esimd__misc.html#ga05d0cfde09531d7cb8a8cd37ccec6733">More...</a><br /></td></tr>
<tr class="separator:ga05d0cfde09531d7cb8a8cd37ccec6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d755b4085be4498b1896f00b31fc8d"><td class="memTemplParams" colspan="2">template&lt;class BaseT1 , class BaseT2 , class RegionT1 , class RegionT2 , class  = std::enable_if_t&lt;              (shape_type&lt;RegionT1&gt;::length == shape_type&lt;RegionT2&gt;::length) &amp;&amp;              std::is_same_v&lt;detail::element_type_t&lt;BaseT1&gt;,                             detail::element_type_t&lt;BaseT2&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga06d755b4085be4498b1896f00b31fc8d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__misc.html#ga06d755b4085be4498b1896f00b31fc8d">merge</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseT1, RegionT1 &gt; v1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseT2, RegionT2 &gt; v2, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; shape_type&lt; RegionT1 &gt;::length &gt; m)</td></tr>
<tr class="memdesc:ga06d755b4085be4498b1896f00b31fc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Merges" elements of vectors referenced by the input views.  <a href="group__sycl__esimd__misc.html#ga06d755b4085be4498b1896f00b31fc8d">More...</a><br /></td></tr>
<tr class="separator:ga06d755b4085be4498b1896f00b31fc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396920b19a2a11ac0295e6718f7884f6"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga396920b19a2a11ac0295e6718f7884f6">is_channel_enabled</a> (<a class="el" href="group__sycl__esimd__core.html#ga51d9236d9d20da467da1697426b1b8e4">rgba_channel_mask</a> M, <a class="el" href="group__sycl__esimd__core.html#ga461b484b4e6dfd73881ed8c3fbc68060">rgba_channel</a> Ch)</td></tr>
<tr class="separator:ga396920b19a2a11ac0295e6718f7884f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a91f7c27b62c89109ee70a41543f7a"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a> (<a class="el" href="group__sycl__esimd__core.html#ga51d9236d9d20da467da1697426b1b8e4">rgba_channel_mask</a> M)</td></tr>
<tr class="separator:ga89a91f7c27b62c89109ee70a41543f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecf0a87977cd7f053497029b28c3248"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , int SZ&gt; </td></tr>
<tr class="memitem:ga3ecf0a87977cd7f053497029b28c3248"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;!detail::is_generic_floating_point_v&lt; T0 &gt;||std::is_same_v&lt; T1, T0 &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T0, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga3ecf0a87977cd7f053497029b28c3248">saturate</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; src)</td></tr>
<tr class="memdesc:ga3ecf0a87977cd7f053497029b28c3248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion of input vector elements of type <code>T1</code> into vector of elements of type <code>T0</code> with saturation.  <a href="group__sycl__esimd__math.html#ga3ecf0a87977cd7f053497029b28c3248">More...</a><br /></td></tr>
<tr class="separator:ga3ecf0a87977cd7f053497029b28c3248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbd16812409e8652ddf65a1f840c97b"><td class="memTemplParams" colspan="2">template&lt;typename TRes , typename TArg , int SZ&gt; </td></tr>
<tr class="memitem:gafdbd16812409e8652ddf65a1f840c97b"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_DETAIL __ESIMD_API std::enable_if_t&lt; !std::is_same&lt; std::remove_const_t&lt; TRes &gt;, std::remove_const_t&lt; TArg &gt; &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; TRes, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gafdbd16812409e8652ddf65a1f840c97b">abs</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; TArg, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:gafdbd16812409e8652ddf65a1f840c97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute value (vector version)  <a href="group__sycl__esimd__math.html#gafdbd16812409e8652ddf65a1f840c97b">More...</a><br /></td></tr>
<tr class="separator:gafdbd16812409e8652ddf65a1f840c97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f666541e5ba8b78468b985be2385e5e"><td class="memTemplParams" colspan="2">template&lt;typename TRes , typename TArg &gt; </td></tr>
<tr class="memitem:ga9f666541e5ba8b78468b985be2385e5e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;!std::is_same&lt; std::remove_const_t&lt; TRes &gt;, std::remove_const_t&lt; TArg &gt; &gt;::value &amp;&amp;detail::is_esimd_scalar&lt; TRes &gt;::value &amp;&amp;detail::is_esimd_scalar&lt; TArg &gt;::value, std::remove_const_t&lt; TRes &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga9f666541e5ba8b78468b985be2385e5e">abs</a> (TArg <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:ga9f666541e5ba8b78468b985be2385e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute value (scalar version)  <a href="group__sycl__esimd__math.html#ga9f666541e5ba8b78468b985be2385e5e">More...</a><br /></td></tr>
<tr class="separator:ga9f666541e5ba8b78468b985be2385e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86d881a6246d18006062d1236011a8e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , int SZ&gt; </td></tr>
<tr class="memitem:gac86d881a6246d18006062d1236011a8e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gac86d881a6246d18006062d1236011a8e">abs</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:gac86d881a6246d18006062d1236011a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute value (vector version).  <a href="group__sycl__esimd__math.html#gac86d881a6246d18006062d1236011a8e">More...</a><br /></td></tr>
<tr class="separator:gac86d881a6246d18006062d1236011a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee143e781ef77af2039cdcb1a94c7257"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:gaee143e781ef77af2039cdcb1a94c7257"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_esimd_scalar&lt; T1 &gt;::value, std::remove_const_t&lt; T1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gaee143e781ef77af2039cdcb1a94c7257">abs</a> (T1 <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:gaee143e781ef77af2039cdcb1a94c7257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get absolute value (scalar version).  <a href="group__sycl__esimd__math.html#gaee143e781ef77af2039cdcb1a94c7257">More...</a><br /></td></tr>
<tr class="separator:gaee143e781ef77af2039cdcb1a94c7257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15bbbe6053607b7de885f3107e246cbe"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga15bbbe6053607b7de885f3107e246cbe"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga15bbbe6053607b7de885f3107e246cbe">simd&lt; T, SZ &gt;</a> (<a class="el" href="group__sycl__esimd__math.html#ga9236b80f637149a052789fae513a08c3">max</a>)(<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T</td></tr>
<tr class="memdesc:ga15bbbe6053607b7de885f3107e246cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects component-wise the maximum of the two vectors.  <a href="group__sycl__esimd__math.html#ga15bbbe6053607b7de885f3107e246cbe">More...</a><br /></td></tr>
<tr class="separator:ga15bbbe6053607b7de885f3107e246cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9236b80f637149a052789fae513a08c3"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> int class <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga9236b80f637149a052789fae513a08c3">max</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, T <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:ga9236b80f637149a052789fae513a08c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5078aa7b504f90edc49716dc7d945fb6"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> class T()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga5078aa7b504f90edc49716dc7d945fb6">max</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, T <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:ga5078aa7b504f90edc49716dc7d945fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d784e05bff82c964fba5c4d6947db4e"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga6d784e05bff82c964fba5c4d6947db4e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga6d784e05bff82c964fba5c4d6947db4e">simd&lt; T, SZ &gt;</a> (<a class="el" href="group__sycl__esimd__math.html#ga300539f1db7ecc7d0c725b8629da724c">min</a>)(<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T</td></tr>
<tr class="memdesc:ga6d784e05bff82c964fba5c4d6947db4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects component-wise the minimum of the two vectors.  <a href="group__sycl__esimd__math.html#ga6d784e05bff82c964fba5c4d6947db4e">More...</a><br /></td></tr>
<tr class="separator:ga6d784e05bff82c964fba5c4d6947db4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300539f1db7ecc7d0c725b8629da724c"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> int class <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga300539f1db7ecc7d0c725b8629da724c">min</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, T <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:ga300539f1db7ecc7d0c725b8629da724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069aa993c3d86c1cdff73927fbe55e82"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> class T()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga069aa993c3d86c1cdff73927fbe55e82">min</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, T <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:ga069aa993c3d86c1cdff73927fbe55e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822d8e9ed5ce7692047e516818ea46ed"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga822d8e9ed5ce7692047e516818ea46ed"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga822d8e9ed5ce7692047e516818ea46ed">inv</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga822d8e9ed5ce7692047e516818ea46ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversion - calculates (1/x).  <a href="group__sycl__esimd__math__ext.html#ga822d8e9ed5ce7692047e516818ea46ed">More...</a><br /></td></tr>
<tr class="separator:ga822d8e9ed5ce7692047e516818ea46ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935e2274eb8c62fbe2e80a39291ad44f"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga935e2274eb8c62fbe2e80a39291ad44f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga935e2274eb8c62fbe2e80a39291ad44f">inv</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga935e2274eb8c62fbe2e80a39291ad44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#ga935e2274eb8c62fbe2e80a39291ad44f">More...</a><br /></td></tr>
<tr class="separator:ga935e2274eb8c62fbe2e80a39291ad44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf568d99cf9ae18e4297da0014fa0ef42"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gaf568d99cf9ae18e4297da0014fa0ef42"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gaf568d99cf9ae18e4297da0014fa0ef42">log2</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gaf568d99cf9ae18e4297da0014fa0ef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logarithm base 2.  <a href="group__sycl__esimd__math__ext.html#gaf568d99cf9ae18e4297da0014fa0ef42">More...</a><br /></td></tr>
<tr class="separator:gaf568d99cf9ae18e4297da0014fa0ef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a3dc88e48712416272fba1da4e2107"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga69a3dc88e48712416272fba1da4e2107"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga69a3dc88e48712416272fba1da4e2107">log2</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga69a3dc88e48712416272fba1da4e2107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#ga69a3dc88e48712416272fba1da4e2107">More...</a><br /></td></tr>
<tr class="separator:ga69a3dc88e48712416272fba1da4e2107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74e82ab4a1caf543055ab36a0aee450"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gaf74e82ab4a1caf543055ab36a0aee450"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gaf74e82ab4a1caf543055ab36a0aee450">exp2</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gaf74e82ab4a1caf543055ab36a0aee450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponent base 2.  <a href="group__sycl__esimd__math__ext.html#gaf74e82ab4a1caf543055ab36a0aee450">More...</a><br /></td></tr>
<tr class="separator:gaf74e82ab4a1caf543055ab36a0aee450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab21e1885c692416cd6cc26075350756f"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gab21e1885c692416cd6cc26075350756f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gab21e1885c692416cd6cc26075350756f">exp2</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gab21e1885c692416cd6cc26075350756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#gab21e1885c692416cd6cc26075350756f">More...</a><br /></td></tr>
<tr class="separator:gab21e1885c692416cd6cc26075350756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a26efa7d0b76ed6af44a6211c900432"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga2a26efa7d0b76ed6af44a6211c900432"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga2a26efa7d0b76ed6af44a6211c900432">sqrt</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga2a26efa7d0b76ed6af44a6211c900432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root.  <a href="group__sycl__esimd__math__ext.html#ga2a26efa7d0b76ed6af44a6211c900432">More...</a><br /></td></tr>
<tr class="separator:ga2a26efa7d0b76ed6af44a6211c900432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462bf2d6670e699baa8c040e5da0fea6"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga462bf2d6670e699baa8c040e5da0fea6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga462bf2d6670e699baa8c040e5da0fea6">sqrt</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga462bf2d6670e699baa8c040e5da0fea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#ga462bf2d6670e699baa8c040e5da0fea6">More...</a><br /></td></tr>
<tr class="separator:ga462bf2d6670e699baa8c040e5da0fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861795777f06415a98e9ea4abfec9754"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &gt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga861795777f06415a98e9ea4abfec9754"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga861795777f06415a98e9ea4abfec9754">sqrt_ieee</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga861795777f06415a98e9ea4abfec9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">IEEE754-compliant square root. Supports <code>float</code> and <code>double</code>.  <a href="group__sycl__esimd__math__ext.html#ga861795777f06415a98e9ea4abfec9754">More...</a><br /></td></tr>
<tr class="separator:ga861795777f06415a98e9ea4abfec9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga597298c2ffd418cc68bed8d1f24f516e"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &gt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga597298c2ffd418cc68bed8d1f24f516e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga597298c2ffd418cc68bed8d1f24f516e">sqrt_ieee</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga597298c2ffd418cc68bed8d1f24f516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#ga597298c2ffd418cc68bed8d1f24f516e">More...</a><br /></td></tr>
<tr class="separator:ga597298c2ffd418cc68bed8d1f24f516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40561a4566735aea863286f6d1cd83f6"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga40561a4566735aea863286f6d1cd83f6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga40561a4566735aea863286f6d1cd83f6">rsqrt</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga40561a4566735aea863286f6d1cd83f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root reciprocal - calculates <code>1/sqrt(x)</code>.  <a href="group__sycl__esimd__math__ext.html#ga40561a4566735aea863286f6d1cd83f6">More...</a><br /></td></tr>
<tr class="separator:ga40561a4566735aea863286f6d1cd83f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc64c5724399e48b920d87ac26a21647"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gadc64c5724399e48b920d87ac26a21647"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gadc64c5724399e48b920d87ac26a21647">rsqrt</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gadc64c5724399e48b920d87ac26a21647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#gadc64c5724399e48b920d87ac26a21647">More...</a><br /></td></tr>
<tr class="separator:gadc64c5724399e48b920d87ac26a21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4bf739f18b4c5960418f57036e9ab61"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gad4bf739f18b4c5960418f57036e9ab61"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gad4bf739f18b4c5960418f57036e9ab61">sin</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gad4bf739f18b4c5960418f57036e9ab61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine.  <a href="group__sycl__esimd__math__ext.html#gad4bf739f18b4c5960418f57036e9ab61">More...</a><br /></td></tr>
<tr class="separator:gad4bf739f18b4c5960418f57036e9ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3dc9e803cc8c37e24d9edf634baf0f5"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gad3dc9e803cc8c37e24d9edf634baf0f5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gad3dc9e803cc8c37e24d9edf634baf0f5">sin</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gad3dc9e803cc8c37e24d9edf634baf0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#gad3dc9e803cc8c37e24d9edf634baf0f5">More...</a><br /></td></tr>
<tr class="separator:gad3dc9e803cc8c37e24d9edf634baf0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2769e2ad1b4d1cebb819ed7317917681"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga2769e2ad1b4d1cebb819ed7317917681"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga2769e2ad1b4d1cebb819ed7317917681">cos</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga2769e2ad1b4d1cebb819ed7317917681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine.  <a href="group__sycl__esimd__math__ext.html#ga2769e2ad1b4d1cebb819ed7317917681">More...</a><br /></td></tr>
<tr class="separator:ga2769e2ad1b4d1cebb819ed7317917681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5592eb546b70920db33f9ce3dbc2a7d5"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga5592eb546b70920db33f9ce3dbc2a7d5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga5592eb546b70920db33f9ce3dbc2a7d5">cos</a> (T src, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga5592eb546b70920db33f9ce3dbc2a7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__math__ext.html#ga5592eb546b70920db33f9ce3dbc2a7d5">More...</a><br /></td></tr>
<tr class="separator:ga5592eb546b70920db33f9ce3dbc2a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ce131c03d661ecbe8a7de05343bf48"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga59ce131c03d661ecbe8a7de05343bf48"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga59ce131c03d661ecbe8a7de05343bf48">pow</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; U, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga59ce131c03d661ecbe8a7de05343bf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power - calculates <code>src0</code> in power of <code>src1</code>.  <a href="group__sycl__esimd__math__ext.html#ga59ce131c03d661ecbe8a7de05343bf48">More...</a><br /></td></tr>
<tr class="separator:ga59ce131c03d661ecbe8a7de05343bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cce5c386f7be502f3eb7f389e613d8"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga16cce5c386f7be502f3eb7f389e613d8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga16cce5c386f7be502f3eb7f389e613d8">pow</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, U <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga16cce5c386f7be502f3eb7f389e613d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(vector, scalar) version.  <a href="group__sycl__esimd__math__ext.html#ga16cce5c386f7be502f3eb7f389e613d8">More...</a><br /></td></tr>
<tr class="separator:ga16cce5c386f7be502f3eb7f389e613d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga037866307a16423a8c6500be50abc25a"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &lt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:ga037866307a16423a8c6500be50abc25a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#ga037866307a16423a8c6500be50abc25a">pow</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, U <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga037866307a16423a8c6500be50abc25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(scalar, scalar) version.  <a href="group__sycl__esimd__math__ext.html#ga037866307a16423a8c6500be50abc25a">More...</a><br /></td></tr>
<tr class="separator:ga037866307a16423a8c6500be50abc25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fae07ca5c5e0ec93076a9333abba68"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &gt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gab9fae07ca5c5e0ec93076a9333abba68"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gab9fae07ca5c5e0ec93076a9333abba68">div_ieee</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; U, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gab9fae07ca5c5e0ec93076a9333abba68"><td class="mdescLeft">&#160;</td><td class="mdescRight">IEEE754-compliant floating-point division. Supports <code>float</code> and <code>double</code>.  <a href="group__sycl__esimd__math__ext.html#gab9fae07ca5c5e0ec93076a9333abba68">More...</a><br /></td></tr>
<tr class="separator:gab9fae07ca5c5e0ec93076a9333abba68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37f3e42336b9ae66935225220ad2d25"><td class="memTemplParams" colspan="2">template&lt;class T , int N, class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &gt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gaf37f3e42336b9ae66935225220ad2d25"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gaf37f3e42336b9ae66935225220ad2d25">div_ieee</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, U <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gaf37f3e42336b9ae66935225220ad2d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">(vector, scalar) version.  <a href="group__sycl__esimd__math__ext.html#gaf37f3e42336b9ae66935225220ad2d25">More...</a><br /></td></tr>
<tr class="separator:gaf37f3e42336b9ae66935225220ad2d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6415842c21de353e75376abb03a007d"><td class="memTemplParams" colspan="2">template&lt;class T , class U , class Sat  = saturation_off_tag, class  = std::enable_if_t&lt;  detail::is_generic_floating_point_v&lt;T&gt; &amp;&amp; (sizeof(T) &gt;= 4)  &gt;&gt; </td></tr>
<tr class="memitem:gab6415842c21de353e75376abb03a007d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math__ext.html#gab6415842c21de353e75376abb03a007d">div_ieee</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, U <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gab6415842c21de353e75376abb03a007d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(scalar, scalar) version.  <a href="group__sycl__esimd__math__ext.html#gab6415842c21de353e75376abb03a007d">More...</a><br /></td></tr>
<tr class="separator:gab6415842c21de353e75376abb03a007d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1e32133ce621a7e200583872d317f0"><td class="memTemplParams" colspan="2">template&lt;class T , int SZ, class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga1e1e32133ce621a7e200583872d317f0"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_DETAIL ESIMD_NODEBUG ESIMD_INLINE <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga1e1e32133ce621a7e200583872d317f0">log</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga1e1e32133ce621a7e200583872d317f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the given argument.  <a href="group__sycl__esimd__math.html#ga1e1e32133ce621a7e200583872d317f0">More...</a><br /></td></tr>
<tr class="separator:ga1e1e32133ce621a7e200583872d317f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d81f413cfc95c1be02b568a2b6736d6"><td class="memTemplParams" colspan="2">template&lt;class T , class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga4d81f413cfc95c1be02b568a2b6736d6"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga4d81f413cfc95c1be02b568a2b6736d6">log</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:ga4d81f413cfc95c1be02b568a2b6736d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f075adf91118854cd78e07da326004"><td class="memTemplParams" colspan="2">template&lt;class T , int SZ, class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:gab8f075adf91118854cd78e07da326004"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gab8f075adf91118854cd78e07da326004">exp</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gab8f075adf91118854cd78e07da326004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes e raised to the power of the given argument.  <a href="group__sycl__esimd__math.html#gab8f075adf91118854cd78e07da326004">More...</a><br /></td></tr>
<tr class="separator:gab8f075adf91118854cd78e07da326004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbcff9f9f4a3359785620c6de0b7fd8c"><td class="memTemplParams" colspan="2">template&lt;class T , class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:gabbcff9f9f4a3359785620c6de0b7fd8c"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gabbcff9f9f4a3359785620c6de0b7fd8c">exp</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="separator:gabbcff9f9f4a3359785620c6de0b7fd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d29d144817bbf0b7e1101e68b159887"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga7d29d144817bbf0b7e1101e68b159887"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga7d29d144817bbf0b7e1101e68b159887">rndd</a> (sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga7d29d144817bbf0b7e1101e68b159887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-down (also known as <code>floor</code>).  <a href="group__sycl__esimd__conv.html#ga7d29d144817bbf0b7e1101e68b159887">More...</a><br /></td></tr>
<tr class="separator:ga7d29d144817bbf0b7e1101e68b159887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af2d41d0423e7fd8ddc4e6ff0c64b07"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga3af2d41d0423e7fd8ddc4e6ff0c64b07"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga3af2d41d0423e7fd8ddc4e6ff0c64b07">rndd</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga3af2d41d0423e7fd8ddc4e6ff0c64b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__conv.html#ga3af2d41d0423e7fd8ddc4e6ff0c64b07">More...</a><br /></td></tr>
<tr class="separator:ga3af2d41d0423e7fd8ddc4e6ff0c64b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e69bf55ce2f7434b2a119937eb2355"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga65e69bf55ce2f7434b2a119937eb2355"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga65e69bf55ce2f7434b2a119937eb2355">rndu</a> (sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga65e69bf55ce2f7434b2a119937eb2355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-up (also known as <code>ceil</code>).  <a href="group__sycl__esimd__conv.html#ga65e69bf55ce2f7434b2a119937eb2355">More...</a><br /></td></tr>
<tr class="separator:ga65e69bf55ce2f7434b2a119937eb2355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f44ad8112b261d1860b376ba5c52dd7"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga5f44ad8112b261d1860b376ba5c52dd7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga5f44ad8112b261d1860b376ba5c52dd7">rndu</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga5f44ad8112b261d1860b376ba5c52dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__conv.html#ga5f44ad8112b261d1860b376ba5c52dd7">More...</a><br /></td></tr>
<tr class="separator:ga5f44ad8112b261d1860b376ba5c52dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ebfaeecf599f2a636f0a2a074934f8"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga90ebfaeecf599f2a636f0a2a074934f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga90ebfaeecf599f2a636f0a2a074934f8">rnde</a> (sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga90ebfaeecf599f2a636f0a2a074934f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-to-even (also known as <code>round</code>).  <a href="group__sycl__esimd__conv.html#ga90ebfaeecf599f2a636f0a2a074934f8">More...</a><br /></td></tr>
<tr class="separator:ga90ebfaeecf599f2a636f0a2a074934f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189b512009de1f6dc5a3ad39ef6712d1"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga189b512009de1f6dc5a3ad39ef6712d1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga189b512009de1f6dc5a3ad39ef6712d1">rnde</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga189b512009de1f6dc5a3ad39ef6712d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__conv.html#ga189b512009de1f6dc5a3ad39ef6712d1">More...</a><br /></td></tr>
<tr class="separator:ga189b512009de1f6dc5a3ad39ef6712d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97230aac80fb36e93cab9c34de56957"><td class="memTemplParams" colspan="2">template&lt;typename T , int SZ, class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:gab97230aac80fb36e93cab9c34de56957"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#gab97230aac80fb36e93cab9c34de56957">rndz</a> (sycl::ext::intel::esimd ::<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gab97230aac80fb36e93cab9c34de56957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-to-zero (also known as <code>trunc</code>).  <a href="group__sycl__esimd__conv.html#gab97230aac80fb36e93cab9c34de56957">More...</a><br /></td></tr>
<tr class="separator:gab97230aac80fb36e93cab9c34de56957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9623dd3a0d2e5becf449b965b7aa08f2"><td class="memTemplParams" colspan="2">template&lt;typename T , class Sat  = sycl::ext::intel::esimd ::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga9623dd3a0d2e5becf449b965b7aa08f2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga9623dd3a0d2e5becf449b965b7aa08f2">rndz</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga9623dd3a0d2e5becf449b965b7aa08f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version.  <a href="group__sycl__esimd__conv.html#ga9623dd3a0d2e5becf449b965b7aa08f2">More...</a><br /></td></tr>
<tr class="separator:ga9623dd3a0d2e5becf449b965b7aa08f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8295b89a5701ea342bc425548f0b2fa4"><td class="memTemplParams" colspan="2">template&lt;typename RT , int SZ, class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga8295b89a5701ea342bc425548f0b2fa4"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; RT, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga8295b89a5701ea342bc425548f0b2fa4">floor</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga8295b89a5701ea342bc425548f0b2fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Floor" operation, vector version - alias of <code>rndd</code>.  <a href="group__sycl__esimd__conv.html#ga8295b89a5701ea342bc425548f0b2fa4">More...</a><br /></td></tr>
<tr class="separator:ga8295b89a5701ea342bc425548f0b2fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a6b0aca4a82d9e6b3a7b485660f745b"><td class="memTemplParams" colspan="2">template&lt;typename RT , class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga9a6b0aca4a82d9e6b3a7b485660f745b"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE RT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga9a6b0aca4a82d9e6b3a7b485660f745b">floor</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga9a6b0aca4a82d9e6b3a7b485660f745b"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Floor" operation, scalar version - alias of <code>rndd</code>.  <a href="group__sycl__esimd__conv.html#ga9a6b0aca4a82d9e6b3a7b485660f745b">More...</a><br /></td></tr>
<tr class="separator:ga9a6b0aca4a82d9e6b3a7b485660f745b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa245e1efc673a01dc85eeb223f76fb12"><td class="memTemplParams" colspan="2">template&lt;typename RT , int SZ, class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:gaa245e1efc673a01dc85eeb223f76fb12"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; RT, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#gaa245e1efc673a01dc85eeb223f76fb12">ceil</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gaa245e1efc673a01dc85eeb223f76fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Ceiling" operation, vector version - alias of <code>rndu</code>.  <a href="group__sycl__esimd__conv.html#gaa245e1efc673a01dc85eeb223f76fb12">More...</a><br /></td></tr>
<tr class="separator:gaa245e1efc673a01dc85eeb223f76fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga504ab612affae6a65d687d5a3b494a4c"><td class="memTemplParams" colspan="2">template&lt;typename RT , class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga504ab612affae6a65d687d5a3b494a4c"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE RT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga504ab612affae6a65d687d5a3b494a4c">ceil</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga504ab612affae6a65d687d5a3b494a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Ceiling" operation, scalar version - alias of <code>rndu</code>.  <a href="group__sycl__esimd__conv.html#ga504ab612affae6a65d687d5a3b494a4c">More...</a><br /></td></tr>
<tr class="separator:ga504ab612affae6a65d687d5a3b494a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f92c819f24ffc24e91682b6b43f9509"><td class="memTemplParams" colspan="2">template&lt;typename RT , int SZ, class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:ga7f92c819f24ffc24e91682b6b43f9509"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; RT, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga7f92c819f24ffc24e91682b6b43f9509">trunc</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; float, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; &amp;<a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:ga7f92c819f24ffc24e91682b6b43f9509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to integral value using the round to zero rounding mode (vector version).  <a href="group__sycl__esimd__conv.html#ga7f92c819f24ffc24e91682b6b43f9509">More...</a><br /></td></tr>
<tr class="separator:ga7f92c819f24ffc24e91682b6b43f9509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b2352d4bdeba9363893bf3ac7bcb7c"><td class="memTemplParams" colspan="2">template&lt;typename RT , class Sat  = sycl::ext::intel::esimd::saturation_off_tag&gt; </td></tr>
<tr class="memitem:gac9b2352d4bdeba9363893bf3ac7bcb7c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API RT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#gac9b2352d4bdeba9363893bf3ac7bcb7c">trunc</a> (float <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gac9b2352d4bdeba9363893bf3ac7bcb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round to integral value using the round to zero rounding mode (scalar version).  <a href="group__sycl__esimd__conv.html#gac9b2352d4bdeba9363893bf3ac7bcb7c">More...</a><br /></td></tr>
<tr class="separator:gac9b2352d4bdeba9363893bf3ac7bcb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE std::enable_if_t&lt;(N==8||N==16||N==32), <a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">pack_mask</a> (<a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a <a class="el" href="classsimd__mask.html">simd_mask</a> into a single unsigned 32-bit integer value.  <a href="group__sycl__esimd__bitmanip.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">More...</a><br /></td></tr>
<tr class="separator:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d2cf4ee41b680a38ed5c201c9d7925"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gaf5d2cf4ee41b680a38ed5c201c9d7925"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE std::enable_if_t&lt;(N==8||N==16||N==32), <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gaf5d2cf4ee41b680a38ed5c201c9d7925">unpack_mask</a> (<a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:gaf5d2cf4ee41b680a38ed5c201c9d7925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an unsigned 32-bit integer value into a <a class="el" href="classsimd__mask.html">simd_mask</a>.  <a href="group__sycl__esimd__bitmanip.html#gaf5d2cf4ee41b680a38ed5c201c9d7925">More...</a><br /></td></tr>
<tr class="separator:gaf5d2cf4ee41b680a38ed5c201c9d7925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N !=8 &amp;&amp;N !=16 &amp;&amp;N&lt; 32), <a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">pack_mask</a> (<a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>)</td></tr>
<tr class="memdesc:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__sycl__esimd__bitmanip.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">pack_mask</a> specialization when the number of elements <code>N</code> is not <code>8</code>, <code>16</code> or <code>32</code>.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">More...</a><br /></td></tr>
<tr class="separator:ga5a1cd6929d9af5ad87895285cc2cfdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd04c6328b094822b5932520bc7b4d70"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:gadd04c6328b094822b5932520bc7b4d70"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(std::is_same_v&lt; T, <a class="el" href="group__sycl__esimd__core.html#gabdae91abcb480a0607e1370cd0cf7bfe">ushort</a> &gt;||std::is_same_v&lt; T, <a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> &gt;)&amp;&amp;(N &gt; 0 &amp;&amp;N&lt;=32), <a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gadd04c6328b094822b5932520bc7b4d70">ballot</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; mask)</td></tr>
<tr class="memdesc:gadd04c6328b094822b5932520bc7b4d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare source vector elements against zero and return a bitfield combining the comparison result.  <a href="group__sycl__esimd__bitmanip.html#gadd04c6328b094822b5932520bc7b4d70">More...</a><br /></td></tr>
<tr class="separator:gadd04c6328b094822b5932520bc7b4d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fdf3f39890b414b633f0de1de39ebac"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ga2fdf3f39890b414b633f0de1de39ebac"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T)&lt;=4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga2fdf3f39890b414b633f0de1de39ebac">cbit</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src)</td></tr>
<tr class="memdesc:ga2fdf3f39890b414b633f0de1de39ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of bits set in the source operand per element.  <a href="group__sycl__esimd__bitmanip.html#ga2fdf3f39890b414b633f0de1de39ebac">More...</a><br /></td></tr>
<tr class="separator:ga2fdf3f39890b414b633f0de1de39ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4504b52be7098631e399fe90f294bfb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4504b52be7098631e399fe90f294bfb5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T)&lt;=4), uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga4504b52be7098631e399fe90f294bfb5">cbit</a> (T src)</td></tr>
<tr class="memdesc:ga4504b52be7098631e399fe90f294bfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>cbit</code> - both input and output are scalars rather than vectors.  <a href="group__sycl__esimd__bitmanip.html#ga4504b52be7098631e399fe90f294bfb5">More...</a><br /></td></tr>
<tr class="separator:ga4504b52be7098631e399fe90f294bfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc47a172d5c870427de50b9bc54f19d6"><td class="memTemplParams" colspan="2">template&lt;typename BaseTy , typename RegionTy &gt; </td></tr>
<tr class="memitem:gacc47a172d5c870427de50b9bc54f19d6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type &gt;::value &amp;&amp;(sizeof(typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type)&lt;=4) &amp;&amp;(<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::length==1), uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gacc47a172d5c870427de50b9bc54f19d6">cbit</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt; src)</td></tr>
<tr class="memdesc:gacc47a172d5c870427de50b9bc54f19d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>cbit</code>, that takes <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> object as an argument, e.g.  <a href="group__sycl__esimd__bitmanip.html#gacc47a172d5c870427de50b9bc54f19d6">More...</a><br /></td></tr>
<tr class="separator:gacc47a172d5c870427de50b9bc54f19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d8736d5d67ac6802edd79ca33894ce"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:ga66d8736d5d67ac6802edd79ca33894ce"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T)==4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga66d8736d5d67ac6802edd79ca33894ce">fbl</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src)</td></tr>
<tr class="memdesc:ga66d8736d5d67ac6802edd79ca33894ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the per element number of the first bit set in the source operand starting from the least significant bit.  <a href="group__sycl__esimd__bitmanip.html#ga66d8736d5d67ac6802edd79ca33894ce">More...</a><br /></td></tr>
<tr class="separator:ga66d8736d5d67ac6802edd79ca33894ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cbdbc453628e090b5d6f7abb68947d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf3cbdbc453628e090b5d6f7abb68947d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T)==4), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gaf3cbdbc453628e090b5d6f7abb68947d">fbl</a> (T src)</td></tr>
<tr class="memdesc:gaf3cbdbc453628e090b5d6f7abb68947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>fbl</code> - both input and output are scalars rather than vectors.  <a href="group__sycl__esimd__bitmanip.html#gaf3cbdbc453628e090b5d6f7abb68947d">More...</a><br /></td></tr>
<tr class="separator:gaf3cbdbc453628e090b5d6f7abb68947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9edd4390eff8ddc811ba0d2a7a6363b4"><td class="memTemplParams" colspan="2">template&lt;typename BaseTy , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga9edd4390eff8ddc811ba0d2a7a6363b4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type &gt;::value &amp;&amp;(sizeof(typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type)==4) &amp;&amp;(<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::length==1), typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga9edd4390eff8ddc811ba0d2a7a6363b4">fbl</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt; src)</td></tr>
<tr class="memdesc:ga9edd4390eff8ddc811ba0d2a7a6363b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>fbl</code>, that takes <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> object as an argument, e.g.  <a href="group__sycl__esimd__bitmanip.html#ga9edd4390eff8ddc811ba0d2a7a6363b4">More...</a><br /></td></tr>
<tr class="separator:ga9edd4390eff8ddc811ba0d2a7a6363b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_signed&lt; T &gt;::value &amp;&amp;(sizeof(T)==4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gae8152fa9315c5e7dd33a0e39abfd3aaf">fbh</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src)</td></tr>
<tr class="memdesc:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the per element number of the first bit set in the source operand starting from the most significant bit (sign bit is skipped).  <a href="group__sycl__esimd__bitmanip.html#gae8152fa9315c5e7dd33a0e39abfd3aaf">More...</a><br /></td></tr>
<tr class="separator:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_signed&lt; T &gt;::value &amp;&amp;(sizeof(T)==4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#gae8152fa9315c5e7dd33a0e39abfd3aaf">fbh</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; src)</td></tr>
<tr class="memdesc:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the per element number of the first bit set in the source operand starting from the most significant bit (sign bit is counted).  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#gae8152fa9315c5e7dd33a0e39abfd3aaf">More...</a><br /></td></tr>
<tr class="separator:gae8152fa9315c5e7dd33a0e39abfd3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4203486a84b4f2869e574c54ed837212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4203486a84b4f2869e574c54ed837212"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; T &gt;::value &amp;&amp;(sizeof(T)==4), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#ga4203486a84b4f2869e574c54ed837212">fbh</a> (T src)</td></tr>
<tr class="memdesc:ga4203486a84b4f2869e574c54ed837212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>fbh</code> - both input and output are scalars rather than vectors.  <a href="group__sycl__esimd__bitmanip.html#ga4203486a84b4f2869e574c54ed837212">More...</a><br /></td></tr>
<tr class="separator:ga4203486a84b4f2869e574c54ed837212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb3c99bbf3c241f2662e4e115631c722"><td class="memTemplParams" colspan="2">template&lt;typename BaseTy , typename RegionTy &gt; </td></tr>
<tr class="memitem:gaeb3c99bbf3c241f2662e4e115631c722"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral&lt; typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type &gt;::value &amp;&amp;(sizeof(typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type)==4) &amp;&amp;(<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::length==1), typename <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt;::element_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__bitmanip.html#gaeb3c99bbf3c241f2662e4e115631c722">fbh</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; BaseTy, RegionTy &gt; src)</td></tr>
<tr class="memdesc:gaeb3c99bbf3c241f2662e4e115631c722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar version of <code>fbh</code>, that takes <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> object as an argument, e.g.  <a href="group__sycl__esimd__bitmanip.html#gaeb3c99bbf3c241f2662e4e115631c722">More...</a><br /></td></tr>
<tr class="separator:gaeb3c99bbf3c241f2662e4e115631c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc019b5b04f7dddda7b310db65c50db6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , int N, class Sat  = saturation_off_tag&gt; </td></tr>
<tr class="memitem:gadc019b5b04f7dddda7b310db65c50db6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_dword_type&lt; T1 &gt;::value &amp;&amp;detail::is_dword_type&lt; T2 &gt;::value &amp;&amp;detail::is_dword_type&lt; T3 &gt;::value &amp;&amp;detail::is_dword_type&lt; T4 &gt;::value, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gadc019b5b04f7dddda7b310db65c50db6">dp4a</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T2, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T3, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T4, N &gt; src2, <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> <a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a>={})</td></tr>
<tr class="memdesc:gadc019b5b04f7dddda7b310db65c50db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DP4A.  <a href="group__sycl__esimd__math.html#gadc019b5b04f7dddda7b310db65c50db6">More...</a><br /></td></tr>
<tr class="separator:gadc019b5b04f7dddda7b310db65c50db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea553f537e63a24596d4ce71d5f692d"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , int SZ&gt; </td></tr>
<tr class="memitem:ga0ea553f537e63a24596d4ce71d5f692d"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE ESIMD_NODEBUG T0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga0ea553f537e63a24596d4ce71d5f692d">hmax</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; v)</td></tr>
<tr class="memdesc:ga0ea553f537e63a24596d4ce71d5f692d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ESIMD_DETAIL.  <a href="group__sycl__esimd__math.html#ga0ea553f537e63a24596d4ce71d5f692d">More...</a><br /></td></tr>
<tr class="separator:ga0ea553f537e63a24596d4ce71d5f692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fddd6f25c832583d676537a53e4b90"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , int SZ&gt; </td></tr>
<tr class="memitem:gab5fddd6f25c832583d676537a53e4b90"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE ESIMD_NODEBUG T0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gab5fddd6f25c832583d676537a53e4b90">hmin</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; v)</td></tr>
<tr class="memdesc:gab5fddd6f25c832583d676537a53e4b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 'minimum' operation reduction over elements of the input vector, that is, returns the minimal vector element.  <a href="group__sycl__esimd__math.html#gab5fddd6f25c832583d676537a53e4b90">More...</a><br /></td></tr>
<tr class="separator:gab5fddd6f25c832583d676537a53e4b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b9e668cc53698602f417ab6c0336098"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , int SZ, typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ga2b9e668cc53698602f417ab6c0336098"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE ESIMD_NODEBUG T0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga2b9e668cc53698602f417ab6c0336098">reduce</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T1, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; v, BinaryOperation op)</td></tr>
<tr class="memdesc:ga2b9e668cc53698602f417ab6c0336098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reduction over elements of the input vector.  <a href="group__sycl__esimd__math.html#ga2b9e668cc53698602f417ab6c0336098">More...</a><br /></td></tr>
<tr class="separator:ga2b9e668cc53698602f417ab6c0336098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74228738f3c57eb391a849af2edb341f"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga74228738f3c57eb391a849af2edb341f">operator~</a> (<a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> x)</td></tr>
<tr class="separator:ga74228738f3c57eb391a849af2edb341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e167953d951399346e82b50f697d665"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga5e167953d951399346e82b50f697d665">operator|</a> (<a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> x, <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> y)</td></tr>
<tr class="separator:ga5e167953d951399346e82b50f697d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9944e6430d34b5e2d94379dd246be2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga2e9944e6430d34b5e2d94379dd246be2">operator&amp;</a> (<a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> x, <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> y)</td></tr>
<tr class="separator:ga2e9944e6430d34b5e2d94379dd246be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd9e739b81b320a13fa27b000b7ef2cf"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#gadd9e739b81b320a13fa27b000b7ef2cf">operator^</a> (<a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> x, <a class="el" href="group__sycl__esimd__logical.html#ga3e02a716e3ba958acf101e2503052dc7">bfn_t</a> y)</td></tr>
<tr class="separator:gadd9e739b81b320a13fa27b000b7ef2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04df516a05558aeefa7092cbf872e53d"><td class="memTemplParams" colspan="2">template&lt;bfn_t FuncControl, typename T , int N&gt; </td></tr>
<tr class="memitem:ga04df516a05558aeefa7092cbf872e53d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; T &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga04df516a05558aeefa7092cbf872e53d">bfn</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; src2)</td></tr>
<tr class="memdesc:ga04df516a05558aeefa7092cbf872e53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary function computation with three vector operands.  <a href="group__sycl__esimd__logical.html#ga04df516a05558aeefa7092cbf872e53d">More...</a><br /></td></tr>
<tr class="separator:ga04df516a05558aeefa7092cbf872e53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3facdc5c171447d9eca68b66fa50e445"><td class="memTemplParams" colspan="2">template&lt;bfn_t FuncControl, typename T &gt; </td></tr>
<tr class="memitem:ga3facdc5c171447d9eca68b66fa50e445"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_NODEBUG ESIMD_INLINE std::enable_if_t&lt; __ESIMD_DNS::is_esimd_scalar&lt; T &gt;::value &amp;&amp;std::is_integral_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__logical.html#ga3facdc5c171447d9eca68b66fa50e445">bfn</a> (T <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, T <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, T src2)</td></tr>
<tr class="memdesc:ga3facdc5c171447d9eca68b66fa50e445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs binary function computation with three scalar operands.  <a href="group__sycl__esimd__logical.html#ga3facdc5c171447d9eca68b66fa50e445">More...</a><br /></td></tr>
<tr class="separator:ga3facdc5c171447d9eca68b66fa50e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac79031fe34435266a492a2ff54a757"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ga6ac79031fe34435266a492a2ff54a757"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga6ac79031fe34435266a492a2ff54a757">addc</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;carry, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:ga6ac79031fe34435266a492a2ff54a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs add with carry of 2 unsigned 32-bit vectors.  <a href="group__sycl__esimd__math.html#ga6ac79031fe34435266a492a2ff54a757">More...</a><br /></td></tr>
<tr class="separator:ga6ac79031fe34435266a492a2ff54a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e832696ff83b900880673bcb866772"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gab6e832696ff83b900880673bcb866772"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gab6e832696ff83b900880673bcb866772">addc</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;carry, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, uint32_t <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:gab6e832696ff83b900880673bcb866772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs add with carry of a unsigned 32-bit vector and scalar.  <a href="group__sycl__esimd__math.html#gab6e832696ff83b900880673bcb866772">More...</a><br /></td></tr>
<tr class="separator:gab6e832696ff83b900880673bcb866772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111ce420f6c4ca0e0b224a555a7d85a8"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ga111ce420f6c4ca0e0b224a555a7d85a8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga111ce420f6c4ca0e0b224a555a7d85a8">addc</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;carry, uint32_t <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:ga111ce420f6c4ca0e0b224a555a7d85a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs add with carry of a unsigned 32-bit scalar and vector.  <a href="group__sycl__esimd__math.html#ga111ce420f6c4ca0e0b224a555a7d85a8">More...</a><br /></td></tr>
<tr class="separator:ga111ce420f6c4ca0e0b224a555a7d85a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1181ec60e13f165680d80af9e13cd8ce"><td class="memItemLeft" align="right" valign="top">__ESIMD_API uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga1181ec60e13f165680d80af9e13cd8ce">addc</a> (uint32_t &amp;carry, uint32_t <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, uint32_t <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:ga1181ec60e13f165680d80af9e13cd8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs add with carry of a unsigned 32-bit scalars.  <a href="group__sycl__esimd__math.html#ga1181ec60e13f165680d80af9e13cd8ce">More...</a><br /></td></tr>
<tr class="separator:ga1181ec60e13f165680d80af9e13cd8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada8f7410d1e437b10000e4c38558ee8a"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gada8f7410d1e437b10000e4c38558ee8a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gada8f7410d1e437b10000e4c38558ee8a">subb</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;borrow, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:gada8f7410d1e437b10000e4c38558ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs substraction with borrow of 2 unsigned 32-bit vectors.  <a href="group__sycl__esimd__math.html#gada8f7410d1e437b10000e4c38558ee8a">More...</a><br /></td></tr>
<tr class="separator:gada8f7410d1e437b10000e4c38558ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18c187bf0b79c8127a870967826a6b6"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gaa18c187bf0b79c8127a870967826a6b6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gaa18c187bf0b79c8127a870967826a6b6">subb</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;borrow, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, uint32_t <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:gaa18c187bf0b79c8127a870967826a6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs substraction with borrow of unsigned 32-bit vector and scalar.  <a href="group__sycl__esimd__math.html#gaa18c187bf0b79c8127a870967826a6b6">More...</a><br /></td></tr>
<tr class="separator:gaa18c187bf0b79c8127a870967826a6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6544cddef97f3017f18f74ec7e38d3e"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:gaa6544cddef97f3017f18f74ec7e38d3e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gaa6544cddef97f3017f18f74ec7e38d3e">subb</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; &amp;borrow, uint32_t <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; uint32_t, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:gaa6544cddef97f3017f18f74ec7e38d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs substraction with borrow of unsigned 32-bit scalar and vector.  <a href="group__sycl__esimd__math.html#gaa6544cddef97f3017f18f74ec7e38d3e">More...</a><br /></td></tr>
<tr class="separator:gaa6544cddef97f3017f18f74ec7e38d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2338204aae7af8e38cb672fdf22a6cac"><td class="memItemLeft" align="right" valign="top">__ESIMD_API uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga2338204aae7af8e38cb672fdf22a6cac">subb</a> (uint32_t &amp;borrow, uint32_t <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, uint32_t <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>)</td></tr>
<tr class="memdesc:ga2338204aae7af8e38cb672fdf22a6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs substraction with borrow of 2 unsigned 32-bit scalars.  <a href="group__sycl__esimd__math.html#ga2338204aae7af8e38cb672fdf22a6cac">More...</a><br /></td></tr>
<tr class="separator:ga2338204aae7af8e38cb672fdf22a6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab7e2565190784e2305c3e6afd78569d"><td class="memItemLeft" align="right" valign="top">__ESIMD_API uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gaab7e2565190784e2305c3e6afd78569d">rdtsc</a> ()</td></tr>
<tr class="memdesc:gaab7e2565190784e2305c3e6afd78569d"><td class="mdescLeft">&#160;</td><td class="mdescRight">rdtsc - get the value of timestamp counter.  <a href="group__sycl__esimd__math.html#gaab7e2565190784e2305c3e6afd78569d">More...</a><br /></td></tr>
<tr class="separator:gaab7e2565190784e2305c3e6afd78569d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplParams" colspan="2">template&lt;typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__core.html#ga5f7fa652eebf3bdf4266307fd9cb1ed2">SurfaceIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">get_surface_index</a> (AccessorTy acc)</td></tr>
<tr class="memdesc:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get surface index corresponding to a SYCL accessor.  <a href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">More...</a><br /></td></tr>
<tr class="separator:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-1) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3)  <a href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">More...</a><br /></td></tr>
<tr class="separator:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb545348460db14b403c4923f4532764"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">More...</a><br /></td></tr>
<tr class="separator:gacb545348460db14b403c4923f4532764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">More...</a><br /></td></tr>
<tr class="separator:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-4) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">More...</a><br /></td></tr>
<tr class="separator:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac4176f6b0d7fc589e443f73c4315a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (usm-ga-5) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">More...</a><br /></td></tr>
<tr class="separator:gac4176f6b0d7fc589e443f73c4315a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">gather</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaaaea88e37c82e73114d497ed3cba6048"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-6) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">More...</a><br /></td></tr>
<tr class="separator:gaaaea88e37c82e73114d497ed3cba6048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9908f885e11383b3d9ae90d12aef54a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-7) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">More...</a><br /></td></tr>
<tr class="separator:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-8) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">More...</a><br /></td></tr>
<tr class="separator:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">gather</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1ff4da96a8c706907eb6275cac6c374a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-ga-9) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">More...</a><br /></td></tr>
<tr class="separator:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">gather</a> (const Tx *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7434161e9dec4e48d95379efe31e8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">More...</a><br /></td></tr>
<tr class="separator:ga7434161e9dec4e48d95379efe31e8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6599de1385f2655db2a9a800d5f00fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-1)  <a href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">More...</a><br /></td></tr>
<tr class="separator:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">scatter</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga157294a3866261bb5653b95c21d20dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">More...</a><br /></td></tr>
<tr class="separator:ga157294a3866261bb5653b95c21d20dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">More...</a><br /></td></tr>
<tr class="separator:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga757b89941e01477057602ad88da9912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-4)  <a href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">More...</a><br /></td></tr>
<tr class="separator:ga757b89941e01477057602ad88da9912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">scatter</a> (Tx *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaf371739a39a0af6f5676082708aa2d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">More...</a><br /></td></tr>
<tr class="separator:gaf371739a39a0af6f5676082708aa2d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">block_store</a> (Tx *addr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga364d8c4536dc36d2132adbd21f7e953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of memory at the given address <code>addr</code>.  <a href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">More...</a><br /></td></tr>
<tr class="separator:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">block_load</a> (const T *ptr, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7894851ec14747893eac472ad8add7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!).  <a href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">More...</a><br /></td></tr>
<tr class="separator:ga7894851ec14747893eac472ad8add7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">block_load</a> (const T *ptr, size_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga480ebe06c1d5d2050d8e2603d62de995"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, props={}); // (usm-bl-2) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">More...</a><br /></td></tr>
<tr class="separator:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">block_load</a> (const T *ptr, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-3) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">More...</a><br /></td></tr>
<tr class="separator:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:gad65df008f55259009a111386082da30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-4) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">More...</a><br /></td></tr>
<tr class="separator:gad65df008f55259009a111386082da30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">block_load</a> (const T *ptr, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa9252b08b7c4467a792391d854dd559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-5) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">More...</a><br /></td></tr>
<tr class="separator:gaa9252b08b7c4467a792391d854dd559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-6) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">More...</a><br /></td></tr>
<tr class="separator:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">block_load</a> (const Tx *addr, Flags)</td></tr>
<tr class="memdesc:gaf853809d4b13a456607b0e10525e0e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given memory address <code>addr</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">More...</a><br /></td></tr>
<tr class="separator:gaf853809d4b13a456607b0e10525e0e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;              is_simd_flag_type_v&lt;Flags&gt; &amp;&amp;              detail::is_device_accessor_with_v&lt;                  AccessorTy, detail::accessor_mode_cap::can_read&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">block_load</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, Flags flags)</td></tr>
<tr class="memdesc:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given accessor <code>acc</code> and <code>byte_offset</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">More...</a><br /></td></tr>
<tr class="separator:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">More...</a><br /></td></tr>
<tr class="separator:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">block_load</a> (AccessorT acc, PropertyListT={})</td></tr>
<tr class="memdesc:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, props = {}); // (acc-bl-2) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">More...</a><br /></td></tr>
<tr class="separator:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:ga25fa0c8cc614de20602c6b59cae470a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-3) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">More...</a><br /></td></tr>
<tr class="separator:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">block_load</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-4) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">More...</a><br /></td></tr>
<tr class="separator:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">block_load</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:gad8ad8f44d928b312fe483062bd87c21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-5) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">More...</a><br /></td></tr>
<tr class="separator:gad8ad8f44d928b312fe483062bd87c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">block_load</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga32d25f4fe10f0c79bbed061293813da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-6) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">More...</a><br /></td></tr>
<tr class="separator:ga32d25f4fe10f0c79bbed061293813da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">block_store</a> (T *ptr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT={})</td></tr>
<tr class="memdesc:ga67a5b4228984629dd3215235c3bc3829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block store functions stores a contiguous memory block to the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!) with data specified by 'vals'.  <a href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">More...</a><br /></td></tr>
<tr class="separator:ga67a5b4228984629dd3215235c3bc3829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa81d900f8d9b9954362c8420182619a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-2) simd&lt;T, N&gt; vals, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">More...</a><br /></td></tr>
<tr class="separator:gaa81d900f8d9b9954362c8420182619a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a8d7a6bae27bfef7ecb44d8b3610bc626">detail::is_property_list_v</a>&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">block_store</a> (T *ptr, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, simd&lt;T, N&gt; vals, // (usm-bs-3) simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">More...</a><br /></td></tr>
<tr class="separator:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5128f1ec8f70e26fe4258bbb49123133"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-4) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">More...</a><br /></td></tr>
<tr class="separator:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">block_store</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0fd624e96124663a6ae4c920706007f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block_store functions stores the vector 'vals' to a contiguous memory block at the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">More...</a><br /></td></tr>
<tr class="separator:ga0fd624e96124663a6ae4c920706007f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">block_store</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeaa6f746325b1be167c897ff9a554e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, props = {}); // (acc-bs-2) This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">More...</a><br /></td></tr>
<tr class="separator:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">block_store</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga59adec9467f16b6031eba98db1d38c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> and <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">More...</a><br /></td></tr>
<tr class="separator:ga59adec9467f16b6031eba98db1d38c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">block_store</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga30be02856481196cc276e77cf721d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, // (acc-bs-4) simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">More...</a><br /></td></tr>
<tr class="separator:ga30be02856481196cc276e77cf721d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; byte_offsets, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gac409b1352b9c6e41558277de95fa9b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_gather"></a>Accessor-based gather.  <a href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">More...</a><br /></td></tr>
<tr class="separator:gac409b1352b9c6e41558277de95fa9b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">gather</a> (AccessorT acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset)</td></tr>
<tr class="memdesc:gaa32a70edd8b9e78619e8625877debfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and broadcasts the element located at <code>acc</code> and byte offset <code>glob_offset</code> to a vector and returns it as a <a class="el" href="classsimd.html">simd</a> object.  <a href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">More...</a><br /></td></tr>
<tr class="separator:gaa32a70edd8b9e78619e8625877debfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0e451ceb76100adc0313158b6f37e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3)  <a href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">More...</a><br /></td></tr>
<tr class="separator:ga0e451ceb76100adc0313158b6f37e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3690bd1701c99a14d84d30f41cdde08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">More...</a><br /></td></tr>
<tr class="separator:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">More...</a><br /></td></tr>
<tr class="separator:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga20645123e4dcd440cb2bd220ab746ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-4) This function is identical to (acc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">More...</a><br /></td></tr>
<tr class="separator:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae8d131ce16330c0f088929e97f8bab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (acc-ga-5) This function is identical to (acc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">More...</a><br /></td></tr>
<tr class="separator:gae8d131ce16330c0f088929e97f8bab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-6) This function is identical to (acc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">More...</a><br /></td></tr>
<tr class="separator:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d43b1baaab951d4142e49e50d875a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">More...</a><br /></td></tr>
<tr class="separator:ga5d43b1baaab951d4142e49e50d875a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga767b97791462434ce040062cfe9ff819"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">More...</a><br /></td></tr>
<tr class="separator:ga767b97791462434ce040062cfe9ff819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1b1e1eef8e77177e7433f558e4521f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">More...</a><br /></td></tr>
<tr class="separator:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_scatter"></a>Accessor-based scatter.  <a href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">More...</a><br /></td></tr>
<tr class="separator:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2cea67d78dd64774281e59176dc1f204"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-2)  <a href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">More...</a><br /></td></tr>
<tr class="separator:ga2cea67d78dd64774281e59176dc1f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaadd878ac42b167a591ef02609ebbd12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-3)  <a href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">More...</a><br /></td></tr>
<tr class="separator:gaadd878ac42b167a591ef02609ebbd12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-4)  <a href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">More...</a><br /></td></tr>
<tr class="separator:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga097b8aadcd461c076d70226f01925390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets.  <a href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">More...</a><br /></td></tr>
<tr class="separator:ga097b8aadcd461c076d70226f01925390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae1810c383d33e257f39a6d97ae15a0a7">detail::isPowerOf2</a>(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1d32f7dd4b7ccb79e581b5a568085855">scatter</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> glob_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">scalar_load</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> offset)</td></tr>
<tr class="memdesc:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from an accessor.  <a href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">More...</a><br /></td></tr>
<tr class="separator:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">scalar_store</a> (AccessorTy acc, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> offset, T val)</td></tr>
<tr class="memdesc:ga70654519014529d4217fee666d2bce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into an accessor.  <a href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">More...</a><br /></td></tr>
<tr class="separator:ga70654519014529d4217fee666d2bce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">gather_rgba</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_gather_rgba"></a>Gather and transpose pixels from given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">More...</a><br /></td></tr>
<tr class="separator:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">gather_rgba</a> (const T *p, OffsetSimdViewT offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49a890423f6afbba762d935b13200831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">More...</a><br /></td></tr>
<tr class="separator:ga49a890423f6afbba762d935b13200831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">gather_rgba</a> (const T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">More...</a><br /></td></tr>
<tr class="separator:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">scatter_rgba</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_scatter_rgba"></a>Transpose and scatter pixels to given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">More...</a><br /></td></tr>
<tr class="separator:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">scatter_rgba</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">More...</a><br /></td></tr>
<tr class="separator:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">scatter_rgba</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">More...</a><br /></td></tr>
<tr class="separator:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4cc43d10a1ffceca5170c191c13117e4">scatter_rgba</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;((N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">gather_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather and transpose pixels from the given memory locations defined by the base specified by <code>acc</code>, the global offset <code>global_offset</code> and a vector of offsets <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">More...</a><br /></td></tr>
<tr class="separator:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">scatter_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a>, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">detail::DeviceAccessorOffsetT</a> global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28490b843690be3630d11e68998cf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector.  <a href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">More...</a><br /></td></tr>
<tr class="separator:ga28490b843690be3630d11e68998cf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplParams" colspan="2">template&lt;uint32_t SLMSize&gt; </td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">slm_init</a> ()</td></tr>
<tr class="memdesc:ga927d068c295204a54147ac9626cfe0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">More...</a><br /></td></tr>
<tr class="separator:ga927d068c295204a54147ac9626cfe0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346b7902be6b67d13f0034d77767722a"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">slm_init</a> (uint32_t size)</td></tr>
<tr class="memdesc:ga346b7902be6b67d13f0034d77767722a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">More...</a><br /></td></tr>
<tr class="separator:ga346b7902be6b67d13f0034d77767722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-1) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3)  <a href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">More...</a><br /></td></tr>
<tr class="separator:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeeaea968caad1111d9b1f878decee783"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">More...</a><br /></td></tr>
<tr class="separator:gaeeaea968caad1111d9b1f878decee783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf03a9216e379b075244936b633469cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">More...</a><br /></td></tr>
<tr class="separator:gaf03a9216e379b075244936b633469cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece7a3dd172984bf59f46482230a2448"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-4) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">More...</a><br /></td></tr>
<tr class="separator:gaece7a3dd172984bf59f46482230a2448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (slm-ga-5) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">More...</a><br /></td></tr>
<tr class="separator:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga764fcd9753f206ab8c420785ba433a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-6) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">More...</a><br /></td></tr>
<tr class="separator:ga764fcd9753f206ab8c420785ba433a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-7) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">More...</a><br /></td></tr>
<tr class="separator:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae6fcc63ae70c075518179d4da63976dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-8) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">More...</a><br /></td></tr>
<tr class="separator:gae6fcc63ae70c075518179d4da63976dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">slm_gather</a> (OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gacc98080310feeaf350db9310986ef1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (slm-ga-9) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">More...</a><br /></td></tr>
<tr class="separator:gacc98080310feeaf350db9310986ef1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">slm_scalar_load</a> (uint32_t offset)</td></tr>
<tr class="memdesc:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">More...</a><br /></td></tr>
<tr class="separator:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">slm_scatter</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga452f04de1896d50b415bfcdff867a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-1) void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2)  <a href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">More...</a><br /></td></tr>
<tr class="separator:ga452f04de1896d50b415bfcdff867a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">slm_scatter</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga17da97cf44fd768030ee06b7321151bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">More...</a><br /></td></tr>
<tr class="separator:ga17da97cf44fd768030ee06b7321151bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-3) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">More...</a><br /></td></tr>
<tr class="separator:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gafe51d24eb859e430fb759b91851cac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-4) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">More...</a><br /></td></tr>
<tr class="separator:gafe51d24eb859e430fb759b91851cac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">slm_scalar_store</a> (uint32_t offset, T val)</td></tr>
<tr class="memdesc:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">More...</a><br /></td></tr>
<tr class="separator:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">slm_gather_rgba</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">More...</a><br /></td></tr>
<tr class="separator:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask Mask&gt; </td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">slm_scatter_rgba</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(Mask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">More...</a><br /></td></tr>
<tr class="separator:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">slm_block_load</a> (uint32_t byte_offset, Flags)</td></tr>
<tr class="memdesc:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given byte-offset <code>offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">More...</a><br /></td></tr>
<tr class="separator:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">slm_block_load</a> (uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_load functions loads a contiguous memory block from SLM (Shared Local Memory) and the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">More...</a><br /></td></tr>
<tr class="separator:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">slm_block_load</a> (uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;N&gt; pred, props = {}); // (slm-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">More...</a><br /></td></tr>
<tr class="separator:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">slm_block_load</a> (uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gac26a70b8c5b5bae45aa2f68189316f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (slm-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">More...</a><br /></td></tr>
<tr class="separator:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">block_load</a> (AccessorT lacc, uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9348416d24efcd644d5c4ec03550279"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, props={}); // (lacc-bl-1) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">More...</a><br /></td></tr>
<tr class="separator:gae9348416d24efcd644d5c4ec03550279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">block_load</a> (AccessorT lacc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4d32f796205c30b9a1e1f98299579059"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, props={}); // (lacc-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">More...</a><br /></td></tr>
<tr class="separator:ga4d32f796205c30b9a1e1f98299579059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5be8a3908c474653637bfc5b1cca58de"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">More...</a><br /></td></tr>
<tr class="separator:ga5be8a3908c474653637bfc5b1cca58de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">block_load</a> (AccessorT lacc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-4) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">More...</a><br /></td></tr>
<tr class="separator:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-5) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">More...</a><br /></td></tr>
<tr class="separator:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">block_load</a> (AccessorT lacc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gafb08d45df0c2e84e8ae599863fed761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-6) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">More...</a><br /></td></tr>
<tr class="separator:gafb08d45df0c2e84e8ae599863fed761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags &gt; </td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">slm_block_store</a> (uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of SLM memory at the given byte-offset <code>offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">More...</a><br /></td></tr>
<tr class="separator:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_store functions stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">More...</a><br /></td></tr>
<tr class="separator:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-2) props = {}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">More...</a><br /></td></tr>
<tr class="separator:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad481435bb21bb308d9e9879e096ad329"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-1) simd&lt;T, N&gt; vals, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">More...</a><br /></td></tr>
<tr class="separator:gad481435bb21bb308d9e9879e096ad329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">block_store</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad6cdaada3b83282c9feaa3df3fb46432"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-2) props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">More...</a><br /></td></tr>
<tr class="separator:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8641f19548717b4da73177f3612808fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={});  <a href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">More...</a><br /></td></tr>
<tr class="separator:ga8641f19548717b4da73177f3612808fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">block_store</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga66a15b020bd88413f2ca069c6806c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-4) simd_mask&lt;1&gt; pred, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">More...</a><br /></td></tr>
<tr class="separator:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7e9fb3b595ef693f1319288ca16446eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="slm_atomic_update0"></a> <a href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">More...</a><br /></td></tr>
<tr class="separator:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; pred = 1); // (lacc-au0-1) Atomically updates <code>N</code> memory locations in SLM ssociated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">More...</a><br /></td></tr>
<tr class="separator:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">One argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">More...</a><br /></td></tr>
<tr class="separator:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;1&gt; pred = 1); // (lacc-au1-1)  <a href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">More...</a><br /></td></tr>
<tr class="separator:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">More...</a><br /></td></tr>
<tr class="separator:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;1&gt; pred = 1); // (lacc-au2-1)  <a href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">More...</a><br /></td></tr>
<tr class="separator:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9ca317137669bb87b6b0741d434d5834"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">More...</a><br /></td></tr>
<tr class="separator:ga9ca317137669bb87b6b0741d434d5834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga61ed2c099e12fc7505d061e617c241fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (usm-au0-2)  <a href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">More...</a><br /></td></tr>
<tr class="separator:ga61ed2c099e12fc7505d061e617c241fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga60a6e250570f0318924f443351dcd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-3)  <a href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">More...</a><br /></td></tr>
<tr class="separator:ga60a6e250570f0318924f443351dcd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">atomic_update</a> (T *p, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga299c6985b6669fe4d0965a13223452c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, props = {}); /// (usm-au0-4)  <a href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">More...</a><br /></td></tr>
<tr class="separator:ga299c6985b6669fe4d0965a13223452c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">atomic_update</a> (T *p, Toffset byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">More...</a><br /></td></tr>
<tr class="separator:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6624b909565dd8a01cca82f94118658f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">More...</a><br /></td></tr>
<tr class="separator:ga6624b909565dd8a01cca82f94118658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d32dac41faa2752a3a100179c047164"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">More...</a><br /></td></tr>
<tr class="separator:ga5d32dac41faa2752a3a100179c047164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa8235f4973a7f07671e65884d6a4e407"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (usm-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">More...</a><br /></td></tr>
<tr class="separator:gaa8235f4973a7f07671e65884d6a4e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3163517455229f9359dc7befcdaf33ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">More...</a><br /></td></tr>
<tr class="separator:ga3163517455229f9359dc7befcdaf33ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaa11a4e5e6db9766b05f53882c5969894"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">More...</a><br /></td></tr>
<tr class="separator:gaa11a4e5e6db9766b05f53882c5969894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7818fd03a76ec89e81453fc2eed03315"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update2"></a>Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">More...</a><br /></td></tr>
<tr class="separator:ga7818fd03a76ec89e81453fc2eed03315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b0e94818140af7667c53ed1900f8227"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (usm-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">More...</a><br /></td></tr>
<tr class="separator:ga8b0e94818140af7667c53ed1900f8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga50118f07f0d1ce05b1f3af664e61f377"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}) // (usm-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">More...</a><br /></td></tr>
<tr class="separator:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b969ac66b06344433b03d7a42c5adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}) // (usm-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">More...</a><br /></td></tr>
<tr class="separator:ga8b969ac66b06344433b03d7a42c5adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gadfc93c8742970952cb25c39099e90017"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">More...</a><br /></td></tr>
<tr class="separator:gadfc93c8742970952cb25c39099e90017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7a0e01d45006dc95652b9576a8468333"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">More...</a><br /></td></tr>
<tr class="separator:ga7a0e01d45006dc95652b9576a8468333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece5430efdfa55ea8851a6a4baffc367"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (acc-au0-2) A variation of <code>atomic_update</code> API without mask operand  <a href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">More...</a><br /></td></tr>
<tr class="separator:gaece5430efdfa55ea8851a6a4baffc367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-3) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">More...</a><br /></td></tr>
<tr class="separator:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0b4df1e247b58fad96a6ac29fca17892"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, props = {}); /// (acc-au0-4) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.  <a href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">More...</a><br /></td></tr>
<tr class="separator:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">atomic_update</a> (AccessorTy acc, Toffset byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga026c23b583bbddb6c43fa0db20c15267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">More...</a><br /></td></tr>
<tr class="separator:ga026c23b583bbddb6c43fa0db20c15267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">atomic_update</a> (AccessorTy acc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gac6fcffa3281c801923e6ca78d7681553"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar using <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">More...</a><br /></td></tr>
<tr class="separator:gac6fcffa3281c801923e6ca78d7681553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga12af50e667b8379c85ba2fbd69c9642a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">More...</a><br /></td></tr>
<tr class="separator:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:ga911d8084626d7c07dc3d5a358e8d6118"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">More...</a><br /></td></tr>
<tr class="separator:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (acc-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">More...</a><br /></td></tr>
<tr class="separator:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gab12baf4188b777673f2293f506f5c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">More...</a><br /></td></tr>
<tr class="separator:gab12baf4188b777673f2293f506f5c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gace9371b37fcc89eee8dd82d7957c9aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">More...</a><br /></td></tr>
<tr class="separator:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">atomic_op::store</a> &amp;&amp;Op !=<a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8fb8e41d797861ffe5ef78c9b4353f3b">atomic_op::xchg</a>)||N==1), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object and uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">More...</a><br /></td></tr>
<tr class="separator:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab1cb38958ce5611fbb683250b6d37b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update2"></a> <a href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">More...</a><br /></td></tr>
<tr class="separator:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">More...</a><br /></td></tr>
<tr class="separator:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2453919e91d9887fde4bc32fb858212c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (acc-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">More...</a><br /></td></tr>
<tr class="separator:ga2453919e91d9887fde4bc32fb858212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, PropertyListT props={})</td></tr>
<tr class="memdesc:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT, byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">More...</a><br /></td></tr>
<tr class="separator:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaf02d6524019b24c7f1444aec1057ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">More...</a><br /></td></tr>
<tr class="separator:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Tx, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga0164810c5dc8e6862f0188fb93b75640"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar and <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> is used.  <a href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">More...</a><br /></td></tr>
<tr class="separator:ga0164810c5dc8e6862f0188fb93b75640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplParams" colspan="2">template&lt;uint8_t cntl&gt; </td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">fence</a> ()</td></tr>
<tr class="memdesc:ga6894e650e3d2d8252726536d4055aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">esimd::fence</a> sets the memory read/write order.  <a href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">More...</a><br /></td></tr>
<tr class="separator:ga6894e650e3d2d8252726536d4055aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2eefea21b6197da16a58d10ecb1d7a38">fence</a> (<a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">fence_mask</a> cntl)</td></tr>
<tr class="separator:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplParams" colspan="2">template&lt;memory_kind Kind = memory_kind::global, fence_flush_op FenceOp = fence_flush_op::none, fence_scope Scope = fence_scope::group&gt; </td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">fence</a> ()</td></tr>
<tr class="memdesc:ga671467f8fc485a53380db7359bb9c193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory fence.  <a href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">More...</a><br /></td></tr>
<tr class="separator:ga671467f8fc485a53380db7359bb9c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">barrier</a> ()</td></tr>
<tr class="memdesc:gaf339323c524d7aad3ef8d592c197d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group barrier.  <a href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">More...</a><br /></td></tr>
<tr class="separator:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, m *N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">media_block_load</a> (AccessorTy acc, unsigned x, unsigned y)</td></tr>
<tr class="memdesc:gacb4ea356b65d551c454e43430a266a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block load.  <a href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">More...</a><br /></td></tr>
<tr class="separator:gacb4ea356b65d551c454e43430a266a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">media_block_store</a> (AccessorTy acc, unsigned x, unsigned y, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, m *N &gt; vals)</td></tr>
<tr class="memdesc:ga7228e366d106365df6b40f4f192004ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block store.  <a href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">More...</a><br /></td></tr>
<tr class="separator:ga7228e366d106365df6b40f4f192004ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy , typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">block_load</a> (AccessorTy acc, uint32_t byte_offset, Flags flags)</td></tr>
<tr class="memdesc:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given local-accessor <code>acc</code> and <code>byte_offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">More...</a><br /></td></tr>
<tr class="separator:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename Flags &gt; </td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">block_store</a> (AccessorT acc, uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, Flags flags)</td></tr>
<tr class="memdesc:ga3770b4bddea00af67e996df884f1310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of block_store that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">More...</a><br /></td></tr>
<tr class="separator:ga3770b4bddea00af67e996df884f1310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga46229a4f362e8ffae317a1b69ff22046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3)  <a href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">More...</a><br /></td></tr>
<tr class="separator:ga46229a4f362e8ffae317a1b69ff22046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">More...</a><br /></td></tr>
<tr class="separator:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf0e84c0a304d1986dc243b965c157834"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">More...</a><br /></td></tr>
<tr class="separator:gaf0e84c0a304d1986dc243b965c157834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-4) This function is identical to (lacc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">More...</a><br /></td></tr>
<tr class="separator:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (lacc-ga-5) This function is identical to (lacc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">More...</a><br /></td></tr>
<tr class="separator:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">gather</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-6) This function is identical to (lacc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">More...</a><br /></td></tr>
<tr class="separator:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5d43b1baaab951d4142e49e50d875a92">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d43b1baaab951d4142e49e50d875a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5d43b1baaab951d4142e49e50d875a92">More...</a><br /></td></tr>
<tr class="separator:ga5d43b1baaab951d4142e49e50d875a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga767b97791462434ce040062cfe9ff819">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga767b97791462434ce040062cfe9ff819"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga767b97791462434ce040062cfe9ff819">More...</a><br /></td></tr>
<tr class="separator:ga767b97791462434ce040062cfe9ff819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga1b1e1eef8e77177e7433f558e4521f92">gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1b1e1eef8e77177e7433f558e4521f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga1b1e1eef8e77177e7433f558e4521f92">More...</a><br /></td></tr>
<tr class="separator:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">gather</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gae8edb9934390ed9f0485689d7e21a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">More...</a><br /></td></tr>
<tr class="separator:gae8edb9934390ed9f0485689d7e21a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">scatter</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab4754c6fc7ec658643ff5552bc5907f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter that uses local accessor as a parameter template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-1)  <a href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">More...</a><br /></td></tr>
<tr class="separator:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">scatter</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-2)  <a href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">More...</a><br /></td></tr>
<tr class="separator:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7d1e59064714e4494d2f44bd48788b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-3)  <a href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">More...</a><br /></td></tr>
<tr class="separator:ga7d1e59064714e4494d2f44bd48788b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa204bc7f7a825040148c900e0b4e0a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-4)  <a href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">More...</a><br /></td></tr>
<tr class="separator:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga097b8aadcd461c076d70226f01925390">scatter</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, uint32_t glob_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga097b8aadcd461c076d70226f01925390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter that uses local accessor as a parameter.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga097b8aadcd461c076d70226f01925390">More...</a><br /></td></tr>
<tr class="separator:ga097b8aadcd461c076d70226f01925390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac74cbc4141970dfbd259060d2597e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-1) void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2)  <a href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">More...</a><br /></td></tr>
<tr class="separator:gac74cbc4141970dfbd259060d2597e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">More...</a><br /></td></tr>
<tr class="separator:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac194ba4693e7c9aee73f63c959947f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (usm-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">More...</a><br /></td></tr>
<tr class="separator:gac194ba4693e7c9aee73f63c959947f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">prefetch</a> (const T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">More...</a><br /></td></tr>
<tr class="separator:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">More...</a><br /></td></tr>
<tr class="separator:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga68cb007526441a43e5a72668a52fc3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">More...</a><br /></td></tr>
<tr class="separator:ga68cb007526441a43e5a72668a52fc3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">prefetch</a> (const T *p, OffsetT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7ffd04632e53c13cae50f95c8266428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">More...</a><br /></td></tr>
<tr class="separator:ga7ffd04632e53c13cae50f95c8266428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">prefetch</a> (const T *p, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0eb8934c359d7b74a1979513576ba0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, PropertyListT props = {}); // (usm-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">More...</a><br /></td></tr>
<tr class="separator:ga0eb8934c359d7b74a1979513576ba0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">prefetch</a> (const T *p, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(usm-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">More...</a><br /></td></tr>
<tr class="separator:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">prefetch</a> (const T *p, PropertyListT props={})</td></tr>
<tr class="memdesc:ga78527de7e485b381788e4b031b29b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, PropertyListT props = {}); // (usm-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">More...</a><br /></td></tr>
<tr class="separator:ga78527de7e485b381788e4b031b29b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga76862c56e39d4464ee6015f0c69ac537"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-1) void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2)  <a href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">More...</a><br /></td></tr>
<tr class="separator:ga76862c56e39d4464ee6015f0c69ac537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">More...</a><br /></td></tr>
<tr class="separator:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1aa325722f031578760777bc849efe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (acc-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">More...</a><br /></td></tr>
<tr class="separator:ga1aa325722f031578760777bc849efe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">prefetch</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab1304b5dbfe4f787c09221b4e427b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">More...</a><br /></td></tr>
<tr class="separator:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gadc4bd79c567f680523a2277b67ce5a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">More...</a><br /></td></tr>
<tr class="separator:gadc4bd79c567f680523a2277b67ce5a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3b61e9602ee8be170bcba87227501525"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">More...</a><br /></td></tr>
<tr class="separator:ga3b61e9602ee8be170bcba87227501525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">prefetch</a> (AccessorT acc, OffsetT byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae5b4ee36004127672acde85ce8b05d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">More...</a><br /></td></tr>
<tr class="separator:gae5b4ee36004127672acde85ce8b05d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">prefetch</a> (AccessorT acc, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5629d544041ea068f46b2d16edbf528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, PropertyListT props = {}); // (acc-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">More...</a><br /></td></tr>
<tr class="separator:ga5629d544041ea068f46b2d16edbf528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">prefetch</a> (AccessorT acc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab36701169020a7a0ac58009a54ea935"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(acc-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">More...</a><br /></td></tr>
<tr class="separator:gaab36701169020a7a0ac58009a54ea935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">prefetch</a> (AccessorT acc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8876c22da7059ca756e04cd16da42218"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, PropertyListT props = {}); // (acc-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">More...</a><br /></td></tr>
<tr class="separator:ga8876c22da7059ca756e04cd16da42218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">load_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; load_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block load.  <a href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">More...</a><br /></td></tr>
<tr class="separator:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">prefetch_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, false, false&gt;(), typename PropertyListT = empty_properties_t&gt; void prefetch_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block prefetch.  <a href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">More...</a><br /></td></tr>
<tr class="separator:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">store_2d</a> (T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; Vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block store.  <a href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">More...</a><br /></td></tr>
<tr class="separator:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">gather_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather_rgba that uses local accessor as a parameter.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">More...</a><br /></td></tr>
<tr class="separator:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga28490b843690be3630d11e68998cf1ee">scatter_rgba</a> (AccessorT acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; vals, uint32_t global_offset=0, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28490b843690be3630d11e68998cf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter_rgba that uses local accessor as a parameter Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga28490b843690be3630d11e68998cf1ee">More...</a><br /></td></tr>
<tr class="separator:ga28490b843690be3630d11e68998cf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1d5d5278888f08f1a42508835d5025"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_src1, uint8_t num_dst, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2, typename T3 , int n3&gt; </td></tr>
<tr class="memitem:gaaa1d5d5278888f08f1a42508835d5025"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#gaaa1d5d5278888f08f1a42508835d5025">raw_sends</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_dst, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T3, n3 &gt; msg_src1, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:gaaa1d5d5278888f08f1a42508835d5025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw sends.  <a href="group__sycl__esimd__raw__send.html#gaaa1d5d5278888f08f1a42508835d5025">More...</a><br /></td></tr>
<tr class="separator:gaaa1d5d5278888f08f1a42508835d5025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9444b504c0e00055bcabf05e901235e0"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_dst, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2&gt; </td></tr>
<tr class="memitem:ga9444b504c0e00055bcabf05e901235e0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#ga9444b504c0e00055bcabf05e901235e0">raw_send</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_dst, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src0, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:ga9444b504c0e00055bcabf05e901235e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw send.  <a href="group__sycl__esimd__raw__send.html#ga9444b504c0e00055bcabf05e901235e0">More...</a><br /></td></tr>
<tr class="separator:ga9444b504c0e00055bcabf05e901235e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_src1, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2&gt; </td></tr>
<tr class="memitem:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#gaaeab6bdb75216352cf3ce5ccaf6f14df">raw_sends</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_src0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src1, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw sends.  <a href="group__sycl__esimd__raw__send.html#gaaeab6bdb75216352cf3ce5ccaf6f14df">More...</a><br /></td></tr>
<tr class="separator:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1&gt; </td></tr>
<tr class="memitem:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#ga3824d7fdb8a5cd64954bd0b6ce4130ba">raw_send</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_src0, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw send.  <a href="group__sycl__esimd__raw__send.html#ga3824d7fdb8a5cd64954bd0b6ce4130ba">More...</a><br /></td></tr>
<tr class="separator:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e076c41817c1d8d94dcdec2fb7d7e9"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From , int N&gt; </td></tr>
<tr class="memitem:ga73e076c41817c1d8d94dcdec2fb7d7e9"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; To, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__conv.html#ga73e076c41817c1d8d94dcdec2fb7d7e9">convert</a> (const <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; From, N &gt; &amp;val)</td></tr>
<tr class="memdesc:ga73e076c41817c1d8d94dcdec2fb7d7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covert from a simd object with element type <code>From</code> to a simd object with element type <code>To</code>.  <a href="group__sycl__esimd__conv.html#ga73e076c41817c1d8d94dcdec2fb7d7e9">More...</a><br /></td></tr>
<tr class="separator:ga73e076c41817c1d8d94dcdec2fb7d7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fec1f4ede6b8cc99d02d8bd9895fee"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ac8fec1f4ede6b8cc99d02d8bd9895fee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ac8fec1f4ede6b8cc99d02d8bd9895fee">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ac8fec1f4ede6b8cc99d02d8bd9895fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC version of no argument variant of the <code>atomic_update</code> - accepts <code><a class="el" href="group__sycl__esimd__memory__lsc.html#ga7f152f10c9444355e56f3934d4a41b39" title="LSC atomic operation codes.">native::lsc::atomic_op</a></code> instead of <code>atomic_op</code> as atomic operation template argument.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ac8fec1f4ede6b8cc99d02d8bd9895fee">More...</a><br /></td></tr>
<tr class="separator:ac8fec1f4ede6b8cc99d02d8bd9895fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ab41e12b646172519cd7afa15c2c79"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:a21ab41e12b646172519cd7afa15c2c79"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a21ab41e12b646172519cd7afa15c2c79">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:a21ab41e12b646172519cd7afa15c2c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb09130f25c5aa2b37f3bd2a73dfff5"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:a6eb09130f25c5aa2b37f3bd2a73dfff5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a6eb09130f25c5aa2b37f3bd2a73dfff5">atomic_update</a> (T *p, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:a6eb09130f25c5aa2b37f3bd2a73dfff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b66cd124fac4c210fa11f21031df9"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:a351b66cd124fac4c210fa11f21031df9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a351b66cd124fac4c210fa11f21031df9">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a351b66cd124fac4c210fa11f21031df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC version of the single-argument atomic update.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a351b66cd124fac4c210fa11f21031df9">More...</a><br /></td></tr>
<tr class="separator:a351b66cd124fac4c210fa11f21031df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01010980880455a97851de688f40546b"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:a01010980880455a97851de688f40546b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API __ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a01010980880455a97851de688f40546b">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:a01010980880455a97851de688f40546b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c9906ce9e0c7f7e43af0fdbd54e5b4"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:aa1c9906ce9e0c7f7e43af0fdbd54e5b4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#aa1c9906ce9e0c7f7e43af0fdbd54e5b4">atomic_update</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:aa1c9906ce9e0c7f7e43af0fdbd54e5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d898f212bc87eee7512ce733c12388"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:a61d898f212bc87eee7512ce733c12388"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a61d898f212bc87eee7512ce733c12388">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a61d898f212bc87eee7512ce733c12388"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC version of the two-argument atomic update.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a61d898f212bc87eee7512ce733c12388">More...</a><br /></td></tr>
<tr class="separator:a61d898f212bc87eee7512ce733c12388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b80f62981d0e7e7e103a712ac5a63c"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ae8b80f62981d0e7e7e103a712ac5a63c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ae8b80f62981d0e7e7e103a712ac5a63c">atomic_update</a> (T *p, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ae8b80f62981d0e7e7e103a712ac5a63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0fa592940d6d9eb4889ccec9232633"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:afd0fa592940d6d9eb4889ccec9232633"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#afd0fa592940d6d9eb4889ccec9232633">atomic_update</a> (T *p, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:afd0fa592940d6d9eb4889ccec9232633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97606d1cfafe3f13dbd0f0702b52a63"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ab97606d1cfafe3f13dbd0f0702b52a63"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ab97606d1cfafe3f13dbd0f0702b52a63">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:ab97606d1cfafe3f13dbd0f0702b52a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f6bc9efc7e67433152b858273b6c3a"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </td></tr>
<tr class="memitem:a39f6bc9efc7e67433152b858273b6c3a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a39f6bc9efc7e67433152b858273b6c3a">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:a39f6bc9efc7e67433152b858273b6c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0949e7fdd6fdffee0c3b97a15b6b20"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:a1b0949e7fdd6fdffee0c3b97a15b6b20"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a1b0949e7fdd6fdffee0c3b97a15b6b20">atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:a1b0949e7fdd6fdffee0c3b97a15b6b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72a78dca03cce6db793477e700cfc35"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ab72a78dca03cce6db793477e700cfc35"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ab72a78dca03cce6db793477e700cfc35">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ab72a78dca03cce6db793477e700cfc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC version of the single-argument atomic update.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ab72a78dca03cce6db793477e700cfc35">More...</a><br /></td></tr>
<tr class="separator:ab72a78dca03cce6db793477e700cfc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d467f5b3f58fe4f788ae1a94b1e5497"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </td></tr>
<tr class="memitem:a2d467f5b3f58fe4f788ae1a94b1e5497"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a2d467f5b3f58fe4f788ae1a94b1e5497">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:a2d467f5b3f58fe4f788ae1a94b1e5497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af154f00e8a82075abd0945ee7ff2ea43"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:af154f00e8a82075abd0945ee7ff2ea43"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#af154f00e8a82075abd0945ee7ff2ea43">atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:af154f00e8a82075abd0945ee7ff2ea43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66541b12a501ed8f4a9cf5fe34e8635c"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:a66541b12a501ed8f4a9cf5fe34e8635c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a66541b12a501ed8f4a9cf5fe34e8635c">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt; offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:a66541b12a501ed8f4a9cf5fe34e8635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LSC version of the two-argument atomic update.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a66541b12a501ed8f4a9cf5fe34e8635c">More...</a><br /></td></tr>
<tr class="separator:a66541b12a501ed8f4a9cf5fe34e8635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953482a331c56c14546a3c87b4093719"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </td></tr>
<tr class="memitem:a953482a331c56c14546a3c87b4093719"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a953482a331c56c14546a3c87b4093719">atomic_update</a> (AccessorTy acc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:a953482a331c56c14546a3c87b4093719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed360c0684c09d75e0ec29041a8ca2d"><td class="memTemplParams" colspan="2">template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:aeed360c0684c09d75e0ec29041a8ca2d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#aeed360c0684c09d75e0ec29041a8ca2d">atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="separator:aeed360c0684c09d75e0ec29041a8ca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga85e424379075a6edb97883cf27d95247"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__off__tag.html">saturation_off_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#ga85e424379075a6edb97883cf27d95247">saturation_off</a> {}</td></tr>
<tr class="memdesc:ga85e424379075a6edb97883cf27d95247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag object representing "saturation off" behavior.  <a href="group__sycl__esimd__core.html#ga85e424379075a6edb97883cf27d95247">More...</a><br /></td></tr>
<tr class="separator:ga85e424379075a6edb97883cf27d95247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf95ec9d922e554637627d939b3f6511"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1saturation__on__tag.html">saturation_on_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core.html#gabf95ec9d922e554637627d939b3f6511">saturation_on</a> {}</td></tr>
<tr class="memdesc:gabf95ec9d922e554637627d939b3f6511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag object representing "saturation on" behavior.  <a href="group__sycl__esimd__core.html#gabf95ec9d922e554637627d939b3f6511">More...</a><br /></td></tr>
<tr class="separator:gabf95ec9d922e554637627d939b3f6511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7186bfccfc9361bed4557cd8a994c5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1element__aligned__tag.html">element_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core__align.html#ga7f7186bfccfc9361bed4557cd8a994c5">element_aligned</a> = {}</td></tr>
<tr class="separator:ga7f7186bfccfc9361bed4557cd8a994c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0395514baf0e6c5613afa3d4127b9ec9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1vector__aligned__tag.html">vector_aligned_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core__align.html#ga0395514baf0e6c5613afa3d4127b9ec9">vector_aligned</a> = {}</td></tr>
<tr class="separator:ga0395514baf0e6c5613afa3d4127b9ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c03632a8c7ef768d714a4fbd14da911"><td class="memTemplParams" colspan="2">template&lt;unsigned N&gt; </td></tr>
<tr class="memitem:ga7c03632a8c7ef768d714a4fbd14da911"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1overaligned__tag.html">overaligned_tag</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core__align.html#ga7c03632a8c7ef768d714a4fbd14da911">overaligned</a> = {}</td></tr>
<tr class="separator:ga7c03632a8c7ef768d714a4fbd14da911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a102a7d0c547e457f534d87f450908f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a102a7d0c547e457f534d87f450908f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a> = <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1is__simd__flag__type.html">is_simd_flag_type</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ga0a102a7d0c547e457f534d87f450908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if given type is a simd load/store flag.  <a href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">More...</a><br /></td></tr>
<tr class="separator:ga0a102a7d0c547e457f534d87f450908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e71710411c5038378f418933653f42"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a></td></tr>
<tr class="separator:gaf5e71710411c5038378f418933653f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1181d76d70bf78e70b785a92b22e6d22"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a></td></tr>
<tr class="separator:ga1181d76d70bf78e70b785a92b22e6d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b68e56617744b1131dbb9f3090ef423"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga2b68e56617744b1131dbb9f3090ef423">sat</a></td></tr>
<tr class="separator:ga2b68e56617744b1131dbb9f3090ef423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f719dfcd71f24e8fe68091ce686e7c4"><td class="memItemLeft" align="right" valign="top">__ESIMD_API SZ <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, SZ &gt; <a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a></td></tr>
<tr class="separator:ga5f719dfcd71f24e8fe68091ce686e7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad424e8d557d429897d5c56be77eb976d"><td class="memItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, <a class="el" href="group__sycl__esimd__math.html#ga5f719dfcd71f24e8fe68091ce686e7c4">SZ</a> &gt; Sat int class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__math.html#gad424e8d557d429897d5c56be77eb976d">Sat</a></td></tr>
<tr class="separator:gad424e8d557d429897d5c56be77eb976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c6924db507261817b495c60ae30e81"><td class="memTemplParams" colspan="2">template&lt;int K&gt; </td></tr>
<tr class="memitem:a38c6924db507261817b495c60ae30e81"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1alignment__key.html#a522a0f945ce5e5ae66655a187acf3476">alignment_key::value_t</a>&lt; K &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">alignment</a></td></tr>
<tr class="separator:a38c6924db507261817b495c60ae30e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0e8435a30392d744c410f5d886a899"><td class="memTemplParams" colspan="2">template&lt;cache_hint Hint&gt; </td></tr>
<tr class="memitem:a9d0e8435a30392d744c410f5d886a899"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html#a2cd710fee969081dc50a59f025cde42e">cache_hint_L1_key::value_t</a>&lt; Hint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a9d0e8435a30392d744c410f5d886a899">cache_hint_L1</a></td></tr>
<tr class="separator:a9d0e8435a30392d744c410f5d886a899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96da3846b9ec4e1ea23617a513b3d96a"><td class="memTemplParams" colspan="2">template&lt;cache_hint Hint&gt; </td></tr>
<tr class="memitem:a96da3846b9ec4e1ea23617a513b3d96a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L2__key.html#abaff15b19c231d6347cf92e3f892c1d2">cache_hint_L2_key::value_t</a>&lt; Hint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a96da3846b9ec4e1ea23617a513b3d96a">cache_hint_L2</a></td></tr>
<tr class="separator:a96da3846b9ec4e1ea23617a513b3d96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969cb03e77d7d772c2fabc901f407532"><td class="memTemplParams" colspan="2">template&lt;cache_hint Hint&gt; </td></tr>
<tr class="memitem:a969cb03e77d7d772c2fabc901f407532"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L3__key.html#a3635aa7d6a9dd198082d5263c293da4b">cache_hint_L3_key::value_t</a>&lt; Hint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a969cb03e77d7d772c2fabc901f407532">cache_hint_L3</a></td></tr>
<tr class="separator:a969cb03e77d7d772c2fabc901f407532"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad4b174757556cf232286ece7fad45393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b174757556cf232286ece7fad45393">&#9670;&nbsp;</a></span>alignment_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad4b174757556cf232286ece7fad45393">sycl::_V1::ext::intel::esimd::alignment_key</a> = typedef <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1alignment__key.html">sycl::ext::oneapi::experimental::alignment_key</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The 'alignment' property is used to specify the alignment of memory accessed in ESIMD memory operation such as <a class="el" href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0" title="Each of the following block load functions loads a contiguous memory block from the address reference...">block_load()</a>. </p>
<p>Case1: ESIMD memory operation accepts only USM pointer parameter. The 'alignment' property specifies the alignment of the memory accessed by the USM pointer. Case2: ESIMD memory operation accepts two parameters: either (accessor + offset) or (USM pointer + offset). The 'alignment' property specifies the alignment of the memory accesed by those two parameters. </p>

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00096">96</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="ae5b006c911799da60e033f530e0dc049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b006c911799da60e033f530e0dc049">&#9670;&nbsp;</a></span>default_cache_hint_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ae5b006c911799da60e033f530e0dc049">sycl::_V1::ext::intel::esimd::default_cache_hint_L1</a> = typedef <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html#a2cd710fee969081dc50a59f025cde42e">cache_hint_L1_key::value_t</a>&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00153">153</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="a0463d617c322158e8155296a548fb0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0463d617c322158e8155296a548fb0c6">&#9670;&nbsp;</a></span>default_cache_hint_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a0463d617c322158e8155296a548fb0c6">sycl::_V1::ext::intel::esimd::default_cache_hint_L2</a> = typedef <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L2__key.html#abaff15b19c231d6347cf92e3f892c1d2">cache_hint_L2_key::value_t</a>&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00154">154</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="a21e122af9d5c5cadfb1688680a4320ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e122af9d5c5cadfb1688680a4320ab">&#9670;&nbsp;</a></span>default_cache_hint_L3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a21e122af9d5c5cadfb1688680a4320ab">sycl::_V1::ext::intel::esimd::default_cache_hint_L3</a> = typedef <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L3__key.html#a3635aa7d6a9dd198082d5263c293da4b">cache_hint_L3_key::value_t</a>&lt;<a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8">cache_hint::none</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00155">155</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="abb949a660e6d8b2bc4b78a48497d334f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb949a660e6d8b2bc4b78a48497d334f">&#9670;&nbsp;</a></span>mask_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abb949a660e6d8b2bc4b78a48497d334f">sycl::_V1::ext::intel::esimd::mask_type_t</a> = typedef detail::simd_mask_storage_t&lt;N&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2detail_2types_8hpp_source.html#l00391">391</a> of file <a class="el" href="ext_2intel_2esimd_2detail_2types_8hpp_source.html">types.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6d2e5ce8bbe9ce80bac4d1467b1e6c">&#9670;&nbsp;</a></span>cache_hint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4a6d2e5ce8bbe9ce80bac4d1467b1e6c">sycl::_V1::ext::intel::esimd::cache_hint</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>L1, L2 or L3 cache hints. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6caaf9f686f9eb416162d298446a94cfafb"></a>uncached&#160;</td><td class="fielddoc"><p>load/store/atomic: do not cache data to cache; </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca1fb1a060534164a18a99494122825190"></a>cached&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6caa9c64c25d98516dabbeaa44fa4b798fe"></a>write_back&#160;</td><td class="fielddoc"><p>store: write data into cache level and mark the cache line as "dirty". </p>
<p>Upon eviction, the "dirty" data will be written into the furthest subsequent cache; </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca99f2e1bde3d240b180ae0b0b9ccfc135"></a>write_through&#160;</td><td class="fielddoc"><p>store: immediately write data to the subsequent furthest cache, marking the cache line in the current cache as "not dirty"; </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6caabb0256a318439745ab0b343d64b9ba0"></a>streaming&#160;</td><td class="fielddoc"><p>load: cache data to cache using the evict-first policy to minimize cache pollution caused by temporary streaming data that may only be accessed once or twice; store/atomic: same as write-through, but use the evict-first policy to limit cache pollution by streaming; </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca2f45cbd63698443b09ad479d71ae024c"></a>read_invalidate&#160;</td><td class="fielddoc"><p>load: asserts that the cache line containing the data will not be read again until it’s overwritten, therefore the load operation can invalidate the cache line and discard "dirty" data. </p>
<p>If the assertion is violated (the cache line is read again) then behavior is undefined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a6d2e5ce8bbe9ce80bac4d1467b1e6ca86e617a69861a14387319427caad5dab"></a>const_cached&#160;</td><td class="fielddoc"><p>load, L2 cache only, next gen GPU after Xe required: asserts that the L2 cache line containing the data will not be written until all invocations of the shader or kernel execution are finished. </p>
<p>If the assertion is violated (the cache line is written), the behavior is undefined. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00028">28</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="a4685c99aefa9c4f30766c92970dfc6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4685c99aefa9c4f30766c92970dfc6ca">&#9670;&nbsp;</a></span>cache_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a4685c99aefa9c4f30766c92970dfc6ca">sycl::_V1::ext::intel::esimd::cache_level</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>L1, L2 or L3 cache hint levels. L3 is reserved for future use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4685c99aefa9c4f30766c92970dfc6caa9ec4c0afd450ceac7adb81c3bcfc9732"></a>L1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4685c99aefa9c4f30766c92970dfc6caa7e6aa2d53f6ee2b1a34b017fa403cb76"></a>L2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4685c99aefa9c4f30766c92970dfc6caa842ce6eb510f7e7047da883915ec90e0"></a>L3&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00025">25</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="ad1f841ed03c4b1992d2b6a227d9df818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f841ed03c4b1992d2b6a227d9df818">&#9670;&nbsp;</a></span>fence_flush_op</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad1f841ed03c4b1992d2b6a227d9df818">sycl::_V1::ext::intel::esimd::fence_flush_op</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cache flush operation to apply to caches after <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> is complete. </p>
<p>Supported platforms: DG2, PVC </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1f841ed03c4b1992d2b6a227d9df818a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1f841ed03c4b1992d2b6a227d9df818aeb9885e11bb255862e765a54558fd1ad"></a>evict&#160;</td><td class="fielddoc"><p>no operation; </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1f841ed03c4b1992d2b6a227d9df818ac9ef7a446d9608ed2229ef347d13af7e"></a>invalidate&#160;</td><td class="fielddoc"><p>R/W: evict dirty lines; R/W and RO: invalidate clean lines. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad1f841ed03c4b1992d2b6a227d9df818a123402c04dcfb6625f688f771a5fc05d"></a>clean&#160;</td><td class="fielddoc"><p>R/W and RO: invalidate all clean lines;. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00384">384</a> of file <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a id="abd2bc84aa5bf46a74db45b0051772eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2bc84aa5bf46a74db45b0051772eed">&#9670;&nbsp;</a></span>fence_scope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#abd2bc84aa5bf46a74db45b0051772eed">sycl::_V1::ext::intel::esimd::fence_scope</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The scope that <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> operation should apply to. </p>
<p>Supported platforms: DG2, PVC </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eedadb0f6f37ebeb6ea09489124345af2a45"></a>group&#160;</td><td class="fielddoc"><p>Wait until all previous memory transactions from this thread are observed within the local thread-group. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eedaf5ddaf0ca7929578b408c909429f68f2"></a>local&#160;</td><td class="fielddoc"><p>Wait until all previous memory transactions from this thread are observed within the local sub-slice. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eeda13181d8cc01e390bf64c9e4b0d7a79f3"></a>tile&#160;</td><td class="fielddoc"><p>Wait until all previous memory transactions from this thread are observed in the local tile. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eeda0aa0be2a866411d9ff03515227454947"></a>gpu&#160;</td><td class="fielddoc"><p>Wait until all previous memory transactions from this thread are observed in the local GPU. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eeda2e98f7cfbcdadfeb431fec785e549c59"></a>gpus&#160;</td><td class="fielddoc"><p>Wait until all previous memory transactions from this thread are observed across all GPUs in the system. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eeda54b53072540eeeb8f8e9343e71f28176"></a>system&#160;</td><td class="fielddoc"><p>Global memory data-port only: wait until all previous memory transactions from this thread are observed at the "system" level. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd2bc84aa5bf46a74db45b0051772eeda2fc7d4831e1ec78f7c70926152fca677"></a>system_acquire&#160;</td><td class="fielddoc"><p>Global memory data-port only: for GPUs that do not follow PCIe Write ordering for downstream writes targeting device memory, this op will commit to device memory all downstream and peer writes that have reached the device. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00350">350</a> of file <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<a id="ad81b63371b6d962b629a18d19e5e4796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81b63371b6d962b629a18d19e5e4796">&#9670;&nbsp;</a></span>memory_kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ad81b63371b6d962b629a18d19e5e4796">sycl::_V1::ext::intel::esimd::memory_kind</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The target memory kind for <a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">fence()</a> operation. </p>
<p>Supported platforms: DG2, PVC </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad81b63371b6d962b629a18d19e5e4796a9c70933aff6b2a6d08c687a6cbb6b765"></a>global&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad81b63371b6d962b629a18d19e5e4796a78805a221a988e79ef3f42d7c5bfd418"></a>image&#160;</td><td class="fielddoc"><p>untyped global memory </p>
</td></tr>
<tr><td class="fieldname"><a id="ad81b63371b6d962b629a18d19e5e4796af5ddaf0ca7929578b408c909429f68f2"></a>local&#160;</td><td class="fielddoc"><p>image (also known as typed global memory) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00397">397</a> of file <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html">common.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66541b12a501ed8f4a9cf5fe34e8635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66541b12a501ed8f4a9cf5fe34e8635c">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSC version of the two-argument atomic update. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02913">2913</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="ab72a78dca03cce6db793477e700cfc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72a78dca03cce6db793477e700cfc35">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSC version of the single-argument atomic update. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02877">2877</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="ab97606d1cfafe3f13dbd0f0702b52a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97606d1cfafe3f13dbd0f0702b52a63">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02843">2843</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a953482a331c56c14546a3c87b4093719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953482a331c56c14546a3c87b4093719">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02927">2927</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="a2d467f5b3f58fe4f788ae1a94b1e5497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d467f5b3f58fe4f788ae1a94b1e5497">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02888">2888</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="a39f6bc9efc7e67433152b858273b6c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f6bc9efc7e67433152b858273b6c3a">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02853">2853</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="aeed360c0684c09d75e0ec29041a8ca2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed360c0684c09d75e0ec29041a8ca2d">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02939">2939</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="af154f00e8a82075abd0945ee7ff2ea43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af154f00e8a82075abd0945ee7ff2ea43">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02900">2900</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="a1b0949e7fdd6fdffee0c3b97a15b6b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0949e7fdd6fdffee0c3b97a15b6b20">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_accessor_v&lt;AccessorTy&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02865">2865</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a61d898f212bc87eee7512ce733c12388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d898f212bc87eee7512ce733c12388">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSC version of the two-argument atomic update. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02809">2809</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="a351b66cd124fac4c210fa11f21031df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351b66cd124fac4c210fa11f21031df9">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSC version of the single-argument atomic update. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02779">2779</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="ac8fec1f4ede6b8cc99d02d8bd9895fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fec1f4ede6b8cc99d02d8bd9895fee">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; Toffset, N &gt;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LSC version of no argument variant of the <code>atomic_update</code> - accepts <code><a class="el" href="group__sycl__esimd__memory__lsc.html#ga7f152f10c9444355e56f3934d4a41b39" title="LSC atomic operation codes.">native::lsc::atomic_op</a></code> instead of <code>atomic_op</code> as atomic operation template argument. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02751">2751</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ae8b80f62981d0e7e7e103a712ac5a63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b80f62981d0e7e7e103a712ac5a63c">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02821">2821</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="a01010980880455a97851de688f40546b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01010980880455a97851de688f40546b">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API __ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02789">2789</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="a21ab41e12b646172519cd7afa15c2c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ab41e12b646172519cd7afa15c2c79">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename OffsetObjT , typename RegionTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html">simd_view</a>&lt; OffsetObjT, RegionTy &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02759">2759</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="afd0fa592940d6d9eb4889ccec9232633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0fa592940d6d9eb4889ccec9232633">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02831">2831</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src1</a>.</p>

</div>
</div>
<a id="aa1c9906ce9e0c7f7e43af0fdbd54e5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c9906ce9e0c7f7e43af0fdbd54e5b4">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02799">2799</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="a6eb09130f25c5aa2b37f3bd2a73dfff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb09130f25c5aa2b37f3bd2a73dfff5">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;native::lsc::atomic_op Op, typename T , int N, typename Toffset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral_v&lt;Toffset&gt; &amp;&amp; __ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toffset&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l02769">2769</a> of file <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae8152fa9315c5e7dd33a0e39abfd3aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8152fa9315c5e7dd33a0e39abfd3aaf">&#9670;&nbsp;</a></span>fbh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_signed&lt;T&gt;::value &amp;&amp; (sizeof(T) == 4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::fbh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the per element number of the first bit set in the source operand starting from the most significant bit (sign bit is counted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src0</td><td>the source operand to count bits in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the same type as the source operand, where each element is set to the number first bit set in corresponding element of the source operand. <code>0xFFFFffff</code> is returned for an element equal to <code>0</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00805">805</a> of file <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>.</p>

</div>
</div>
<a id="ga1b1e1eef8e77177e7433f558e4521f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1e1eef8e77177e7433f558e4521f92">&#9670;&nbsp;</a></span>gather() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (lacc-ga-9) This function is identical to (lacc-ga-3) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08472">8472</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga767b97791462434ce040062cfe9ff819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767b97791462434ce040062cfe9ff819">&#9670;&nbsp;</a></span>gather() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-8) This function is identical to (lacc-ga-2) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08450">8450</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5d43b1baaab951d4142e49e50d875a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d43b1baaab951d4142e49e50d875a92">&#9670;&nbsp;</a></span>gather() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; (detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::gather </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, </p>
<p>simd&lt;T, N&gt; gather(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-7) This function is identical to (lacc-ga-1) except that the <code>byte_offsets</code> is represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08427">8427</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga12445cfacbfd6f5758d3e0d3daa4b6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12445cfacbfd6f5758d3e0d3daa4b6f8">&#9670;&nbsp;</a></span>gather_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt; sycl::_V1::ext::intel::esimd::gather_rgba </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>global_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of gather_rgba that uses local accessor as a parameter. </p>
<p>Gather and transpose pixels from the given memory locations defined by the base specified by <code>acc</code>, the global offset <code>global_offset</code> and a vector of offsets <code>offsets</code>. Up to 4 32-bit data elements may be accessed at each address depending on the channel mask <code>RGBAMask</code>. Each pixel's address must be 4-byte aligned. For usage examples, see <a class="el" href="group__sycl__esimd__memory.html#usm_gather_rgba">usm_gather_rgba</a> above, the only difference would be the usage of an accessor instead of a usm pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RGBAMask</td><td>A pixel's channel mask. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type for the memory to be loaded/gathered. The returned vector elements must match the accessor data type. The loaded elements must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>Number of pixels to access (matches the size of the <code>offsets</code> vector). Must be 8, 16 or 32. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor representing memory address of the access. </td></tr>
    <tr><td class="paramname">offsets</td><td>Byte offsets of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">global_offset</td><td>Byte offset of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Pixels with zero corresponding mask's predicate are not accessed. Their values in the resulting vector are undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Read data - up to N*4 values of type <code>Tx</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09574">9574</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5a1cd6929d9af5ad87895285cc2cfdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a1cd6929d9af5ad87895285cc2cfdbb">&#9670;&nbsp;</a></span>pack_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N != 8 &amp;&amp; N != 16 &amp;&amp; N &lt; 32), <a class="el" href="group__sycl__esimd__core.html#gaf9aaba24424a05116eb8c5f94858b4b3">uint</a>&gt; sycl::_V1::ext::intel::esimd::pack_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>src0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__sycl__esimd__bitmanip.html#ga5a1cd6929d9af5ad87895285cc2cfdbb">pack_mask</a> specialization when the number of elements <code>N</code> is not <code>8</code>, <code>16</code> or <code>32</code>. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00668">668</a> of file <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00646">pack_mask()</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">src0</a>.</p>

</div>
</div>
<a id="ga097b8aadcd461c076d70226f01925390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097b8aadcd461c076d70226f01925390">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::scatter </td>
          <td>(</td>
          <td class="paramtype">AccessorTy&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>glob_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of scatter that uses local accessor as a parameter. </p>
<p>Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets. An element can be a 1, 2 or 4-byte value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type; can only be a 1,2,4-byte integer, <code><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a></code> or <code>float</code>. </td></tr>
    <tr><td class="paramname">N</td><td>The number of vector elements. Can be <code>1</code>, <code>8</code>, <code>16</code> or <code>32</code>. </td></tr>
    <tr><td class="paramname">AccessorTy</td><td>The accessor type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>The accessor to scatter to. </td></tr>
    <tr><td class="paramname">offsets</td><td>Per-element offsets in bytes. </td></tr>
    <tr><td class="paramname">vals</td><td>Values to write. </td></tr>
    <tr><td class="paramname">glob_offset</td><td>Offset in bytes added to each individual element's offset to compute actual memory access offset for that element. </td></tr>
    <tr><td class="paramname">mask</td><td>Memory access mask. Elements with zero corresponding mask's predicate are not accessed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l08715">8715</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga28490b843690be3630d11e68998cf1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28490b843690be3630d11e68998cf1ee">&#9670;&nbsp;</a></span>scatter_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write&gt; &gt; sycl::_V1::ext::intel::esimd::scatter_rgba </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>global_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of scatter_rgba that uses local accessor as a parameter Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector. </p>
<p>See <a class="el" href="group__sycl__esimd__memory.html#usm_gather_rgba">usm_gather_rgba</a> for information about the operation semantics and parameter restrictions/interdependencies.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RGBAMask</td><td>Pixel's channel mask. </td></tr>
    <tr><td class="paramname">AccessorT</td><td>The accessor type for the memory to be stored/scattered. The returned vector elements must match the accessor data type. The loaded elements must be 4 bytes in size. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>Byte offsets of each element. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">global_offset</td><td>Byte offset of the pixels relative to the base pointer. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask. All-1 by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l09601">9601</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a38c6924db507261817b495c60ae30e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c6924db507261817b495c60ae30e81">&#9670;&nbsp;</a></span>alignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1oneapi_1_1experimental_1_1alignment__key.html#a522a0f945ce5e5ae66655a187acf3476">alignment_key::value_t</a>&lt;K&gt; sycl::_V1::ext::intel::esimd::alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00098">98</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l01646">block_load()</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00639">sycl::_V1::ext::intel::experimental::esimd::lsc_slm_block_load()</a>.</p>

</div>
</div>
<a id="a9d0e8435a30392d744c410f5d886a899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0e8435a30392d744c410f5d886a899">&#9670;&nbsp;</a></span>cache_hint_L1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cache_hint Hint&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L1__key.html#a2cd710fee969081dc50a59f025cde42e">cache_hint_L1_key::value_t</a>&lt;Hint&gt; sycl::_V1::ext::intel::esimd::cache_hint_L1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00130">130</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="a96da3846b9ec4e1ea23617a513b3d96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96da3846b9ec4e1ea23617a513b3d96a">&#9670;&nbsp;</a></span>cache_hint_L2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cache_hint Hint&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L2__key.html#abaff15b19c231d6347cf92e3f892c1d2">cache_hint_L2_key::value_t</a>&lt;Hint&gt; sycl::_V1::ext::intel::esimd::cache_hint_L2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00132">132</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
<a id="a969cb03e77d7d772c2fabc901f407532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969cb03e77d7d772c2fabc901f407532">&#9670;&nbsp;</a></span>cache_hint_L3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;cache_hint Hint&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1cache__hint__L3__key.html#a3635aa7d6a9dd198082d5263c293da4b">cache_hint_L3_key::value_t</a>&lt;Hint&gt; sycl::_V1::ext::intel::esimd::cache_hint_L3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="memory__properties_8hpp_source.html#l00134">134</a> of file <a class="el" href="memory__properties_8hpp_source.html">memory_properties.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesycl.html">sycl</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1.html">_V1</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1_1_1ext.html">ext</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel.html">intel</a></li><li class="navelem"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html">esimd</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
