<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: include/sycl/ext/intel/esimd/memory.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ext_2intel_2esimd_2memory_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">memory.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html">sycl/ext/intel/esimd/common.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="esimd_2detail_2memory__intrin_8hpp_source.html">sycl/ext/intel/esimd/detail/memory_intrin.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ext_2intel_2esimd_2detail_2types_8hpp_source.html">sycl/ext/intel/esimd/detail/types.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="ext_2intel_2esimd_2detail_2util_8hpp_source.html">sycl/ext/intel/esimd/detail/util.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="memory__properties_8hpp_source.html">sycl/ext/intel/esimd/memory_properties.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="sycl_2ext_2intel_2esimd_2simd_8hpp_source.html">sycl/ext/intel/esimd/simd.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="simd__view_8hpp_source.html">sycl/ext/intel/esimd/simd_view.hpp</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="half__type_8hpp_source.html">sycl/half_type.hpp</a>&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for memory.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="ext_2intel_2esimd_2memory_8hpp__incl.png" border="0" usemap="#ainclude_2sycl_2ext_2intel_2esimd_2memory_8hpp" alt=""/></div>
<map name="ainclude_2sycl_2ext_2intel_2esimd_2memory_8hpp" id="ainclude_2sycl_2ext_2intel_2esimd_2memory_8hpp">
<area shape="rect" title=" " alt="" coords="2228,5,2385,47"/>
<area shape="rect" href="ext_2intel_2esimd_2common_8hpp.html" title=" " alt="" coords="2159,631,2310,672"/>
<area shape="rect" title=" " alt="" coords="2517,1010,2584,1037"/>
<area shape="rect" href="memory__properties_8hpp.html" title=" " alt="" coords="485,720,667,761"/>
<area shape="rect" href="esimd_2detail_2memory__intrin_8hpp.html" title=" " alt="" coords="2303,363,2494,404"/>
<area shape="rect" href="ext_2intel_2esimd_2detail_2types_8hpp.html" title=" " alt="" coords="2514,452,2665,493"/>
<area shape="rect" href="half__type_8hpp.html" title=" " alt="" coords="2819,921,2960,947"/>
<area shape="rect" title=" " alt="" coords="479,1092,564,1119"/>
<area shape="rect" href="ext_2intel_2esimd_2detail_2util_8hpp.html" title=" " alt="" coords="2861,95,3011,136"/>
<area shape="rect" href="sycl_2ext_2intel_2esimd_2simd_8hpp.html" title=" " alt="" coords="2686,95,2837,136"/>
<area shape="rect" href="simd__view_8hpp.html" title=" " alt="" coords="2897,363,3047,404"/>
<area shape="rect" href="defines_8hpp.html" title=" " alt="" coords="2373,727,2541,754"/>
<area shape="rect" href="exception_8hpp.html" title=" " alt="" coords="1681,727,1825,754"/>
<area shape="rect" title=" " alt="" coords="1103,1092,1195,1119"/>
<area shape="rect" href="ext_2intel_2esimd_2detail_2defines__elementary_8hpp.html" title=" " alt="" coords="890,817,1113,858"/>
<area shape="rect" href="ext_2intel_2esimd_2native_2common_8hpp.html" title=" " alt="" coords="2334,817,2490,858"/>
<area shape="rect" href="detail_2defines__elementary_8hpp.html" title=" " alt="" coords="2099,913,2239,955"/>
<area shape="rect" href="backend__types_8hpp.html" title=" " alt="" coords="2081,824,2258,851"/>
<area shape="rect" href="cl_8h.html" title=" " alt="" coords="1523,824,1639,851"/>
<area shape="rect" href="detail_2common_8hpp.html" title=" " alt="" coords="1664,824,1843,851"/>
<area shape="rect" href="export_8hpp.html" title=" " alt="" coords="2075,1010,2237,1037"/>
<area shape="rect" href="pi_8h.html" title=" " alt="" coords="1956,921,2073,947"/>
<area shape="rect" title=" " alt="" coords="1511,921,1569,947"/>
<area shape="rect" title=" " alt="" coords="1867,824,1954,851"/>
<area shape="rect" title=" " alt="" coords="1237,824,1315,851"/>
<area shape="rect" title=" " alt="" coords="1339,824,1447,851"/>
<area shape="rect" title=" " alt="" coords="1585,1010,1655,1037"/>
<area shape="rect" title=" " alt="" coords="823,921,883,947"/>
<area shape="rect" href="iostream__proxy_8hpp.html" title=" " alt="" coords="1679,1003,1830,1044"/>
<area shape="rect" href="experimental_2fpga__utils_8hpp.html" title=" " alt="" coords="144,817,341,858"/>
<area shape="rect" href="property__value_8hpp.html" title=" " alt="" coords="306,1003,497,1044"/>
<area shape="rect" href="oneapi_2experimental_2common__annotated__properties_2properties_8hpp.html" title=" " alt="" coords="365,809,595,865"/>
<area shape="rect" href="oneapi_2properties_2properties_8hpp.html" title=" " alt="" coords="163,913,354,955"/>
<area shape="rect" href="oneapi_2latency__control_2properties_8hpp.html" title=" " alt="" coords="379,913,552,955"/>
<area shape="rect" href="stl__type__traits_8hpp.html" title=" " alt="" coords="619,817,765,858"/>
<area shape="rect" href="elem__type__traits_8hpp.html" title=" " alt="" coords="2201,541,2407,583"/>
<area shape="rect" href="types__elementary_8hpp.html" title=" " alt="" coords="2633,631,2844,672"/>
<area shape="rect" href="region_8hpp.html" title=" " alt="" coords="2634,541,2785,583"/>
<area shape="rect" title=" " alt="" coords="729,921,799,947"/>
<area shape="rect" href="bit__cast_8hpp.html" title=" " alt="" coords="3024,1010,3155,1037"/>
<area shape="rect" href="vector__traits_8hpp.html" title=" " alt="" coords="2609,1003,2743,1044"/>
<area shape="rect" title=" " alt="" coords="3241,1010,3327,1037"/>
<area shape="rect" title=" " alt="" coords="2819,1010,2877,1037"/>
<area shape="rect" title=" " alt="" coords="2902,1010,2999,1037"/>
<area shape="rect" href="simd__mask__impl_8hpp.html" title=" " alt="" coords="2605,184,2811,225"/>
<area shape="rect" href="simd__obj__impl_8hpp.html" title=" " alt="" coords="2671,273,2862,315"/>
<area shape="rect" href="intrin_8hpp.html" title=" " alt="" coords="2919,541,3070,583"/>
<area shape="rect" href="sycl__util_8hpp.html" title=" " alt="" coords="2722,363,2873,404"/>
<area shape="rect" href="invoke__simd_8hpp.html" title=" " alt="" coords="3089,273,3301,315"/>
<area shape="rect" href="simd__view__impl_8hpp.html" title=" " alt="" coords="2846,452,3047,493"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ext_2intel_2esimd_2memory_8hpp__dep__incl.png" border="0" usemap="#ainclude_2sycl_2ext_2intel_2esimd_2memory_8hppdep" alt=""/></div>
<map name="ainclude_2sycl_2ext_2intel_2esimd_2memory_8hppdep" id="ainclude_2sycl_2ext_2intel_2esimd_2memory_8hppdep">
<area shape="rect" title=" " alt="" coords="48,5,205,47"/>
<area shape="rect" href="ext_2intel_2experimental_2esimd_2memory_8hpp.html" title=" " alt="" coords="5,95,248,136"/>
<area shape="rect" href="esimd_8hpp.html" title=" " alt="" coords="48,184,205,225"/>
</map>
</div>
</div>
<p><a href="ext_2intel_2esimd_2memory_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesycl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl.html">sycl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1.html">sycl::_V1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext.html">sycl::_V1::ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel.html">sycl::_V1::ext::intel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html">sycl::_V1::ext::intel::esimd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html">sycl::_V1::ext::intel::esimd::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae3e0557f145264f207e6d08beb916a75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ext_2intel_2esimd_2memory_8hpp.html#ae3e0557f145264f207e6d08beb916a75">__ESIMD_FP_ATOMIC_OP_TYPE_CHECK</a>(T)</td></tr>
<tr class="separator:ae3e0557f145264f207e6d08beb916a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aefe3bb028a9f7c3cda660fa6e5edb650"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aefe3bb028a9f7c3cda660fa6e5edb650">sycl::_V1::ext::intel::esimd::detail::DeviceAccessorOffsetT</a> = uint32_t</td></tr>
<tr class="separator:aefe3bb028a9f7c3cda660fa6e5edb650"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga906135fd4810a79321d334ff5a6f917f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">sycl::_V1::ext::intel::esimd::fence_mask</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa352e1a80b6a794d0635d97bce7be7a99">sycl::_V1::ext::intel::esimd::global_coherent_fence</a> = 0x1
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917faecbd2e70ac0a720e0637bef6d3436f64">sycl::_V1::ext::intel::esimd::l2_flush_instructions</a> = 0x2
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fadbfc05dab2e2f87874de2d77b1fbd87e">sycl::_V1::ext::intel::esimd::l2_flush_texture_data</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa366cc36ca4e0f2747a4e8b7c92a316f1">sycl::_V1::ext::intel::esimd::l2_flush_constant_data</a> = 0x8
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa94e99d3ee1634b6ae3e5d556ef8de693">sycl::_V1::ext::intel::esimd::l2_flush_rw_data</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa3fb710e2fb45d755fb367baaf61c4d58">sycl::_V1::ext::intel::esimd::local_barrier</a> = 0x20
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fa7555392d8038cb3d5f52d9d8f3394cb8">sycl::_V1::ext::intel::esimd::l1_flush_ro_data</a> = 0x40
, <a class="el" href="group__sycl__esimd__memory.html#gga906135fd4810a79321d334ff5a6f917fac2c596df65a2f667ba83c864588c4cc0">sycl::_V1::ext::intel::esimd::__SYCL_DEPRECATED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga906135fd4810a79321d334ff5a6f917f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represetns a bit mask to control behavior of esimd::fence.  <a href="group__sycl__esimd__memory.html#ga906135fd4810a79321d334ff5a6f917f">More...</a><br /></td></tr>
<tr class="separator:ga906135fd4810a79321d334ff5a6f917f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplParams" colspan="2">template&lt;typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API SurfaceIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">sycl::_V1::ext::intel::esimd::get_surface_index</a> (AccessorTy acc)</td></tr>
<tr class="memdesc:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get surface index corresponding to a SYCL accessor.  <a href="group__sycl__esimd__memory.html#gac1cffe68c0ac49b088dcadff58a6a2da">More...</a><br /></td></tr>
<tr class="separator:gac1cffe68c0ac49b088dcadff58a6a2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad14ff9b36d5670b45b626f588a6ec93"><td class="memTemplParams" colspan="2">template&lt;typename RT , typename T , int N&gt; </td></tr>
<tr class="memitem:aad14ff9b36d5670b45b626f588a6ec93"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE <a class="el" href="classsimd.html">simd</a>&lt; RT, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aad14ff9b36d5670b45b626f588a6ec93">sycl::_V1::ext::intel::esimd::detail::lsc_format_input</a> (<a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; Vals)</td></tr>
<tr class="separator:aad14ff9b36d5670b45b626f588a6ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102d0133df8fdfae47fb8ee81327d44c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T1 , int N&gt; </td></tr>
<tr class="memitem:a102d0133df8fdfae47fb8ee81327d44c"><td class="memTemplItemLeft" align="right" valign="top">ESIMD_INLINE <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a102d0133df8fdfae47fb8ee81327d44c">sycl::_V1::ext::intel::esimd::detail::lsc_format_ret</a> (<a class="el" href="classsimd.html">simd</a>&lt; T1, N &gt; Vals)</td></tr>
<tr class="separator:a102d0133df8fdfae47fb8ee81327d44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55252ee9bd8e5655446d1876e53d9249"><td class="memTemplParams" colspan="2">template&lt;typename PropertyListT , cache_level Level&gt; </td></tr>
<tr class="memitem:a55252ee9bd8e5655446d1876e53d9249"><td class="memTemplItemLeft" align="right" valign="top">constexpr cache_hint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a55252ee9bd8e5655446d1876e53d9249">sycl::_V1::ext::intel::esimd::detail::getCacheHintForIntrin</a> ()</td></tr>
<tr class="memdesc:a55252ee9bd8e5655446d1876e53d9249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a cache hint with the given 'Level' to pass it to ESIMD/GENX intrinsics.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a55252ee9bd8e5655446d1876e53d9249">More...</a><br /></td></tr>
<tr class="separator:a55252ee9bd8e5655446d1876e53d9249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897c2ef5c46311208df0d65cf1be864d"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS, typename PropertyListT , int N, typename OffsetT &gt; </td></tr>
<tr class="memitem:a897c2ef5c46311208df0d65cf1be864d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsimd.html">simd</a>&lt; T, N *NElts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a897c2ef5c46311208df0d65cf1be864d">sycl::_V1::ext::intel::esimd::detail::gather_impl</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N *NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:a897c2ef5c46311208df0d65cf1be864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer gather.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a897c2ef5c46311208df0d65cf1be864d">More...</a><br /></td></tr>
<tr class="separator:a897c2ef5c46311208df0d65cf1be864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94bdb40e6a58501fed535d2c58af012"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, lsc_data_size DS, typename PropertyListT , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:aa94bdb40e6a58501fed535d2c58af012"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aa94bdb40e6a58501fed535d2c58af012">sycl::_V1::ext::intel::esimd::detail::scatter_impl</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *NElts &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:aa94bdb40e6a58501fed535d2c58af012"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer scatter.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#aa94bdb40e6a58501fed535d2c58af012">More...</a><br /></td></tr>
<tr class="separator:aa94bdb40e6a58501fed535d2c58af012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea1071d41d33c10445a37f98bfe6098"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a2ea1071d41d33c10445a37f98bfe6098">sycl::_V1::ext::intel::esimd::detail::isMaskedGatherScatterLLVMAvailable</a> ()</td></tr>
<tr class="separator:a2ea1071d41d33c10445a37f98bfe6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-1) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3)  <a href="group__sycl__esimd__memory.html#gacb9f0f82354b45e8fb2203c96b6e0210">More...</a><br /></td></tr>
<tr class="separator:gacb9f0f82354b45e8fb2203c96b6e0210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb545348460db14b403c4923f4532764"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb545348460db14b403c4923f4532764"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-2) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gacb545348460db14b403c4923f4532764">More...</a><br /></td></tr>
<tr class="separator:gacb545348460db14b403c4923f4532764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-3) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaa152d4063042d8ad059e5fbc7bd8c758">More...</a><br /></td></tr>
<tr class="separator:gaa152d4063042d8ad059e5fbc7bd8c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-4) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gad1e9ee8a7af1db1da3c397728c4aa413">More...</a><br /></td></tr>
<tr class="separator:gad1e9ee8a7af1db1da3c397728c4aa413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac4176f6b0d7fc589e443f73c4315a937"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac4176f6b0d7fc589e443f73c4315a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (usm-ga-5) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gac4176f6b0d7fc589e443f73c4315a937">More...</a><br /></td></tr>
<tr class="separator:gac4176f6b0d7fc589e443f73c4315a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaaaea88e37c82e73114d497ed3cba6048"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaaaea88e37c82e73114d497ed3cba6048"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-ga-6) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gaaaea88e37c82e73114d497ed3cba6048">More...</a><br /></td></tr>
<tr class="separator:gaaaea88e37c82e73114d497ed3cba6048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9908f885e11383b3d9ae90d12aef54a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (usm-ga-7) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga9908f885e11383b3d9ae90d12aef54a1">More...</a><br /></td></tr>
<tr class="separator:ga9908f885e11383b3d9ae90d12aef54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-ga-8) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#gae9bd8b51383a95837bc3c04ea702aa1d">More...</a><br /></td></tr>
<tr class="separator:gae9bd8b51383a95837bc3c04ea702aa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">sycl::_V1::ext::intel::esimd::gather</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1ff4da96a8c706907eb6275cac6c374a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; gather(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-ga-9) Loads ("gathers") elements of the type 'T' from memory locations addressed by the base pointer <code>p</code> and byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory.html#ga1ff4da96a8c706907eb6275cac6c374a">More...</a><br /></td></tr>
<tr class="separator:ga1ff4da96a8c706907eb6275cac6c374a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga7434161e9dec4e48d95379efe31e8308"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">sycl::_V1::ext::intel::esimd::gather</a> (const Tx *p, Toffset offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7434161e9dec4e48d95379efe31e8308"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga7434161e9dec4e48d95379efe31e8308">More...</a><br /></td></tr>
<tr class="separator:ga7434161e9dec4e48d95379efe31e8308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6599de1385f2655db2a9a800d5f00fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-sc-1)  <a href="group__sycl__esimd__memory.html#ga6599de1385f2655db2a9a800d5f00fc6">More...</a><br /></td></tr>
<tr class="separator:ga6599de1385f2655db2a9a800d5f00fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga157294a3866261bb5653b95c21d20dd2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga157294a3866261bb5653b95c21d20dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga157294a3866261bb5653b95c21d20dd2">More...</a><br /></td></tr>
<tr class="separator:ga157294a3866261bb5653b95c21d20dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes ("scatters") elements of the input vector to different memory locations.  <a href="group__sycl__esimd__memory.html#ga06f2b46b3a704cdf02dc7f44b7a7ae80">More...</a><br /></td></tr>
<tr class="separator:ga06f2b46b3a704cdf02dc7f44b7a7ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga757b89941e01477057602ad88da9912f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">sycl::_V1::ext::intel::esimd::scatter</a> (T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga757b89941e01477057602ad88da9912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(T *p, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (usm-sc-4)  <a href="group__sycl__esimd__memory.html#ga757b89941e01477057602ad88da9912f">More...</a><br /></td></tr>
<tr class="separator:ga757b89941e01477057602ad88da9912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaf371739a39a0af6f5676082708aa2d56"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">sycl::_V1::ext::intel::esimd::scatter</a> (Tx *p, Toffset offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaf371739a39a0af6f5676082708aa2d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gaf371739a39a0af6f5676082708aa2d56">More...</a><br /></td></tr>
<tr class="separator:gaf371739a39a0af6f5676082708aa2d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bc9c6fdcb3389204cf2154101aa544"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, typename PropertyListT &gt; </td></tr>
<tr class="memitem:ae4bc9c6fdcb3389204cf2154101aa544"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae4bc9c6fdcb3389204cf2154101aa544">sycl::_V1::ext::intel::esimd::detail::block_load_impl</a> (const T *p, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:ae4bc9c6fdcb3389204cf2154101aa544"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer transposed gather with 1 channel.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ae4bc9c6fdcb3389204cf2154101aa544">More...</a><br /></td></tr>
<tr class="separator:ae4bc9c6fdcb3389204cf2154101aa544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa30a9f562948b5c2b9aabf73d4be43"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, typename PropertyListT , typename AccessorT &gt; </td></tr>
<tr class="memitem:a3aa30a9f562948b5c2b9aabf73d4be43"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a3aa30a9f562948b5c2b9aabf73d4be43">sycl::_V1::ext::intel::esimd::detail::block_load_impl</a> (AccessorT acc, DeviceAccessorOffsetT offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred)</td></tr>
<tr class="memdesc:a3aa30a9f562948b5c2b9aabf73d4be43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed gather with 1 channel.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a3aa30a9f562948b5c2b9aabf73d4be43">More...</a><br /></td></tr>
<tr class="separator:a3aa30a9f562948b5c2b9aabf73d4be43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9366d8bc67669937e7e4d99cf2746a67"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, typename PropertyListT , typename AccessorT &gt; </td></tr>
<tr class="memitem:a9366d8bc67669937e7e4d99cf2746a67"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9366d8bc67669937e7e4d99cf2746a67">sycl::_V1::ext::intel::esimd::detail::block_load_impl</a> (AccessorT acc, DeviceAccessorOffsetT offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; pass_thru)</td></tr>
<tr class="memdesc:a9366d8bc67669937e7e4d99cf2746a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based transposed gather with 1 channel.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9366d8bc67669937e7e4d99cf2746a67">More...</a><br /></td></tr>
<tr class="separator:a9366d8bc67669937e7e4d99cf2746a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6dfb5dd6310d4b59bb04e1ee82d238"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, typename PropertyListT &gt; </td></tr>
<tr class="memitem:a7c6dfb5dd6310d4b59bb04e1ee82d238"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a7c6dfb5dd6310d4b59bb04e1ee82d238">sycl::_V1::ext::intel::esimd::detail::block_store_impl</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred)</td></tr>
<tr class="separator:a7c6dfb5dd6310d4b59bb04e1ee82d238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e913701ddd71395ba5384c9e788f34"><td class="memTemplParams" colspan="2">template&lt;typename T , int NElts, typename PropertyListT , typename AccessorT &gt; </td></tr>
<tr class="memitem:ab8e913701ddd71395ba5384c9e788f34"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ab8e913701ddd71395ba5384c9e788f34">sycl::_V1::ext::intel::esimd::detail::block_store_impl</a> (AccessorT acc, DeviceAccessorOffsetT offset, <a class="el" href="classsimd.html">simd</a>&lt; T, NElts &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred)</td></tr>
<tr class="separator:ab8e913701ddd71395ba5384c9e788f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">sycl::_V1::ext::intel::esimd::block_store</a> (Tx *addr, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga364d8c4536dc36d2132adbd21f7e953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of memory at the given address <code>addr</code>.  <a href="group__sycl__esimd__memory.html#ga364d8c4536dc36d2132adbd21f7e953b">More...</a><br /></td></tr>
<tr class="separator:ga364d8c4536dc36d2132adbd21f7e953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7894851ec14747893eac472ad8add7b0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7894851ec14747893eac472ad8add7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!).  <a href="group__sycl__esimd__memory__block.html#ga7894851ec14747893eac472ad8add7b0">More...</a><br /></td></tr>
<tr class="separator:ga7894851ec14747893eac472ad8add7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga480ebe06c1d5d2050d8e2603d62de995"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, props={}); // (usm-bl-2) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga480ebe06c1d5d2050d8e2603d62de995">More...</a><br /></td></tr>
<tr class="separator:ga480ebe06c1d5d2050d8e2603d62de995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-3) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#ga8615bdbbe10f01eed1890d41b3c10bbf">More...</a><br /></td></tr>
<tr class="separator:ga8615bdbbe10f01eed1890d41b3c10bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad65df008f55259009a111386082da30f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:gad65df008f55259009a111386082da30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (usm-bl-4) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#gad65df008f55259009a111386082da30f">More...</a><br /></td></tr>
<tr class="separator:gad65df008f55259009a111386082da30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa9252b08b7c4467a792391d854dd559a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa9252b08b7c4467a792391d854dd559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-5) This function loads a contiguous memory block from USM pointer <code>ptr</code>.  <a href="group__sycl__esimd__memory__block.html#gaa9252b08b7c4467a792391d854dd559a">More...</a><br /></td></tr>
<tr class="separator:gaa9252b08b7c4467a792391d854dd559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">sycl::_V1::ext::intel::esimd::block_load</a> (const T *ptr, size_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(const T* ptr, size_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (usm-bl-6) This function loads a contiguous memory block from address referenced by USM pointer <code>ptr</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga277bed1c03435c7fc557a3ceb86ab2c5">More...</a><br /></td></tr>
<tr class="separator:ga277bed1c03435c7fc557a3ceb86ab2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:gaf853809d4b13a456607b0e10525e0e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">sycl::_V1::ext::intel::esimd::block_load</a> (const Tx *addr, Flags)</td></tr>
<tr class="memdesc:gaf853809d4b13a456607b0e10525e0e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given memory address <code>addr</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf853809d4b13a456607b0e10525e0e17">More...</a><br /></td></tr>
<tr class="separator:gaf853809d4b13a456607b0e10525e0e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplParams" colspan="2">template&lt;typename Tx , int N, typename AccessorTy , typename Flags  = vector_aligned_tag, typename  = std::enable_if_t&lt;              is_simd_flag_type_v&lt;Flags&gt; &amp;&amp;              detail::is_device_accessor_with_v&lt;                  AccessorTy, detail::accessor_mode_cap::can_read&gt;&gt;, class T  = detail::__raw_t&lt;Tx&gt;&gt; </td></tr>
<tr class="memitem:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorTy acc, detail::DeviceAccessorOffsetT byte_offset, Flags flags)</td></tr>
<tr class="memdesc:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of memory from the given accessor <code>acc</code> and <code>byte_offset</code> and returns the loaded data as a vector.  <a href="group__sycl__esimd__memory__block.html#gaf6ce51fcd9012aac82528d731cb21b5c">More...</a><br /></td></tr>
<tr class="separator:gaf6ce51fcd9012aac82528d731cb21b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, detail::DeviceAccessorOffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block load functions loads a contiguous memory block from the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga49ae87e4075911a7e92549fb1e25fdb8">More...</a><br /></td></tr>
<tr class="separator:ga49ae87e4075911a7e92549fb1e25fdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, PropertyListT={})</td></tr>
<tr class="memdesc:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, props = {}); // (acc-bl-2) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga1cef3de9f1cac6acf5d11fcf3a07ab43">More...</a><br /></td></tr>
<tr class="separator:ga1cef3de9f1cac6acf5d11fcf3a07ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, detail::DeviceAccessorOffsetT byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:ga25fa0c8cc614de20602c6b59cae470a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-3) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga25fa0c8cc614de20602c6b59cae470a0">More...</a><br /></td></tr>
<tr class="separator:ga25fa0c8cc614de20602c6b59cae470a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, detail::DeviceAccessorOffsetT byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, OffsetT byte_offset, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-4) This function loads a contiguous memory block referenced by accessor <code>acc</code> and the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__block.html#ga3972b27da87b098bd3a5a4210e5cf58e">More...</a><br /></td></tr>
<tr class="separator:ga3972b27da87b098bd3a5a4210e5cf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad8ad8f44d928b312fe483062bd87c21b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT={})</td></tr>
<tr class="memdesc:gad8ad8f44d928b312fe483062bd87c21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props = {}); // (acc-bl-5) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gad8ad8f44d928b312fe483062bd87c21b">More...</a><br /></td></tr>
<tr class="separator:gad8ad8f44d928b312fe483062bd87c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga32d25f4fe10f0c79bbed061293813da6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT acc, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga32d25f4fe10f0c79bbed061293813da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(AccessorT acc, simd_mask&lt;1&gt; pred, props = {}); // (acc-bl-6) This function loads a contiguous memory block referenced by accessor <code>acc</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga32d25f4fe10f0c79bbed061293813da6">More...</a><br /></td></tr>
<tr class="separator:ga32d25f4fe10f0c79bbed061293813da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga67a5b4228984629dd3215235c3bc3829"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT={})</td></tr>
<tr class="memdesc:ga67a5b4228984629dd3215235c3bc3829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block store functions stores a contiguous memory block to the address referenced by the USM pointer 'ptr', or from 'ptr + offset', where 'offset' is the offset in bytes (not in elements!) with data specified by 'vals'.  <a href="group__sycl__esimd__memory__block.html#ga67a5b4228984629dd3215235c3bc3829">More...</a><br /></td></tr>
<tr class="separator:ga67a5b4228984629dd3215235c3bc3829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa81d900f8d9b9954362c8420182619a6"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa81d900f8d9b9954362c8420182619a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-2) simd&lt;T, N&gt; vals, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#gaa81d900f8d9b9954362c8420182619a6">More...</a><br /></td></tr>
<tr class="separator:gaa81d900f8d9b9954362c8420182619a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT={})</td></tr>
<tr class="memdesc:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, simd&lt;T, N&gt; vals, // (usm-bs-3) simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga9c3e5935f0c9edd7a6e35d49e5c088ba">More...</a><br /></td></tr>
<tr class="separator:ga9c3e5935f0c9edd7a6e35d49e5c088ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">sycl::_V1::ext::intel::esimd::block_store</a> (T *ptr, size_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5128f1ec8f70e26fe4258bbb49123133"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(T* ptr, size_t byte_offset, // (usm-bs-4) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={}); This function stores a contiguous memory block to USM pointer <code>ptr</code> and byte-offset <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga5128f1ec8f70e26fe4258bbb49123133">More...</a><br /></td></tr>
<tr class="separator:ga5128f1ec8f70e26fe4258bbb49123133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0fd624e96124663a6ae4c920706007f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, detail::DeviceAccessorOffsetT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0fd624e96124663a6ae4c920706007f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following block_store functions stores the vector 'vals' to a contiguous memory block at the address referenced by accessor 'acc', or from 'acc + byte_offset', The parameter 'pred' is the one element predicate.  <a href="group__sycl__esimd__memory__block.html#ga0fd624e96124663a6ae4c920706007f4">More...</a><br /></td></tr>
<tr class="separator:ga0fd624e96124663a6ae4c920706007f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeaa6f746325b1be167c897ff9a554e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, props = {}); // (acc-bs-2) This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#gaeaa6f746325b1be167c897ff9a554e1b">More...</a><br /></td></tr>
<tr class="separator:gaeaa6f746325b1be167c897ff9a554e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga59adec9467f16b6031eba98db1d38c04"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, detail::DeviceAccessorOffsetT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga59adec9467f16b6031eba98db1d38c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, OffsetT byte_offset, // (acc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> and <code>byte_offset</code> with data specified by <code>vals</code>.  <a href="group__sycl__esimd__memory__block.html#ga59adec9467f16b6031eba98db1d38c04">More...</a><br /></td></tr>
<tr class="separator:ga59adec9467f16b6031eba98db1d38c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga30be02856481196cc276e77cf721d74e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga30be02856481196cc276e77cf721d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(AccessorT acc, simd&lt;T, N&gt; vals, // (acc-bs-4) simd_mask&lt;1&gt; pred, props = {}); This function stores a contiguous memory block to accessor <code>acc</code> with data specified by <code>vals</code> and implied offset=0.  <a href="group__sycl__esimd__memory__block.html#ga30be02856481196cc276e77cf721d74e">More...</a><br /></td></tr>
<tr class="separator:ga30be02856481196cc276e77cf721d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gac409b1352b9c6e41558277de95fa9b71"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; detail::DeviceAccessorOffsetT, N &gt; byte_offsets, detail::DeviceAccessorOffsetT glob_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gac409b1352b9c6e41558277de95fa9b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_gather"></a>Accessor-based gather.  <a href="group__sycl__esimd__memory.html#gac409b1352b9c6e41558277de95fa9b71">More...</a><br /></td></tr>
<tr class="separator:gac409b1352b9c6e41558277de95fa9b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:gaa32a70edd8b9e78619e8625877debfc9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, detail::DeviceAccessorOffsetT glob_offset)</td></tr>
<tr class="memdesc:gaa32a70edd8b9e78619e8625877debfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and broadcasts the element located at <code>acc</code> and byte offset <code>glob_offset</code> to a vector and returns it as a <a class="el" href="classsimd.html">simd</a> object.  <a href="group__sycl__esimd__memory.html#gaa32a70edd8b9e78619e8625877debfc9">More...</a><br /></td></tr>
<tr class="separator:gaa32a70edd8b9e78619e8625877debfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0e451ceb76100adc0313158b6f37e866"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0e451ceb76100adc0313158b6f37e866"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3)  <a href="group__sycl__esimd__memory.html#ga0e451ceb76100adc0313158b6f37e866">More...</a><br /></td></tr>
<tr class="separator:ga0e451ceb76100adc0313158b6f37e866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3690bd1701c99a14d84d30f41cdde08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3690bd1701c99a14d84d30f41cdde08d">More...</a><br /></td></tr>
<tr class="separator:ga3690bd1701c99a14d84d30f41cdde08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga3f30620c5263fd5c2a79059d05b4e3e2">More...</a><br /></td></tr>
<tr class="separator:ga3f30620c5263fd5c2a79059d05b4e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga20645123e4dcd440cb2bd220ab746ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (acc-ga-4) This function is identical to (acc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga20645123e4dcd440cb2bd220ab746ec1">More...</a><br /></td></tr>
<tr class="separator:ga20645123e4dcd440cb2bd220ab746ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae8d131ce16330c0f088929e97f8bab5d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae8d131ce16330c0f088929e97f8bab5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (acc-ga-5) This function is identical to (acc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gae8d131ce16330c0f088929e97f8bab5d">More...</a><br /></td></tr>
<tr class="separator:gae8d131ce16330c0f088929e97f8bab5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (acc-ga-6) This function is identical to (acc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#gaf12e8c9393d9c731bdaf73f8d408b17d">More...</a><br /></td></tr>
<tr class="separator:gaf12e8c9393d9c731bdaf73f8d408b17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d43b1baaab951d4142e49e50d875a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga5d43b1baaab951d4142e49e50d875a92">More...</a><br /></td></tr>
<tr class="separator:ga5d43b1baaab951d4142e49e50d875a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga767b97791462434ce040062cfe9ff819"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga767b97791462434ce040062cfe9ff819">More...</a><br /></td></tr>
<tr class="separator:ga767b97791462434ce040062cfe9ff819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1b1e1eef8e77177e7433f558e4521f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="group__sycl__esimd__memory.html#ga1b1e1eef8e77177e7433f558e4521f92">More...</a><br /></td></tr>
<tr class="separator:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_scatter"></a>Accessor-based scatter.  <a href="group__sycl__esimd__memory.html#ga6dca741e4dcb7ee702fe8b19684c445e">More...</a><br /></td></tr>
<tr class="separator:ga6dca741e4dcb7ee702fe8b19684c445e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2cea67d78dd64774281e59176dc1f204"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2cea67d78dd64774281e59176dc1f204"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-2)  <a href="group__sycl__esimd__memory.html#ga2cea67d78dd64774281e59176dc1f204">More...</a><br /></td></tr>
<tr class="separator:ga2cea67d78dd64774281e59176dc1f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaadd878ac42b167a591ef02609ebbd12b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaadd878ac42b167a591ef02609ebbd12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-sc-3)  <a href="group__sycl__esimd__memory.html#gaadd878ac42b167a591ef02609ebbd12b">More...</a><br /></td></tr>
<tr class="separator:gaadd878ac42b167a591ef02609ebbd12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorTy , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorTy, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorTy acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (acc-sc-4)  <a href="group__sycl__esimd__memory.html#gac5378beb33dbb1ada7aa21df6a2edcbd">More...</a><br /></td></tr>
<tr class="separator:gac5378beb33dbb1ada7aa21df6a2edcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::isPowerOf2(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; detail::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, detail::DeviceAccessorOffsetT glob_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga097b8aadcd461c076d70226f01925390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes elements of a <a class="el" href="classsimd.html">simd</a> object into an accessor at given offsets.  <a href="group__sycl__esimd__memory.html#ga097b8aadcd461c076d70226f01925390">More...</a><br /></td></tr>
<tr class="separator:ga097b8aadcd461c076d70226f01925390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::isPowerOf2(N, 32)) &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1d32f7dd4b7ccb79e581b5a568085855">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, detail::DeviceAccessorOffsetT glob_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga1d32f7dd4b7ccb79e581b5a568085855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">sycl::_V1::ext::intel::esimd::scalar_load</a> (AccessorTy acc, detail::DeviceAccessorOffsetT offset)</td></tr>
<tr class="memdesc:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from an accessor.  <a href="group__sycl__esimd__memory.html#ga2f837b1a07e95b6f9a73947d71d36c6e">More...</a><br /></td></tr>
<tr class="separator:ga2f837b1a07e95b6f9a73947d71d36c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga70654519014529d4217fee666d2bce0d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">sycl::_V1::ext::intel::esimd::scalar_store</a> (AccessorTy acc, detail::DeviceAccessorOffsetT offset, T val)</td></tr>
<tr class="memdesc:ga70654519014529d4217fee666d2bce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into an accessor.  <a href="group__sycl__esimd__memory.html#ga70654519014529d4217fee666d2bce0d">More...</a><br /></td></tr>
<tr class="separator:ga70654519014529d4217fee666d2bce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_gather_rgba"></a>Gather and transpose pixels from given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga11a0bcf038027eb73c63a9e2a2b84dce">More...</a><br /></td></tr>
<tr class="separator:ga11a0bcf038027eb73c63a9e2a2b84dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga49a890423f6afbba762d935b13200831"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, OffsetSimdViewT offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49a890423f6afbba762d935b13200831"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga49a890423f6afbba762d935b13200831">More...</a><br /></td></tr>
<tr class="separator:ga49a890423f6afbba762d935b13200831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">sycl::_V1::ext::intel::esimd::gather_rgba</a> (const T *p, Toffset offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>gather_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#gab48301f49cffd0e72ea23c49e6c4ed87">More...</a><br /></td></tr>
<tr class="separator:gab48301f49cffd0e72ea23c49e6c4ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603190ad927bd07d8905a0f1f8eac1f9"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask M&gt; </td></tr>
<tr class="memitem:a603190ad927bd07d8905a0f1f8eac1f9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a603190ad927bd07d8905a0f1f8eac1f9">sycl::_V1::ext::intel::esimd::detail::validate_rgba_write_channel_mask</a> ()</td></tr>
<tr class="separator:a603190ad927bd07d8905a0f1f8eac1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_scatter_rgba"></a>Transpose and scatter pixels to given memory locations defined by the base pointer <code>p</code> and <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga5fc3a281fe76ceb10fd300fac222ce93">More...</a><br /></td></tr>
<tr class="separator:ga5fc3a281fe76ceb10fd300fac222ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename OffsetSimdViewT , typename RegionTy &gt; </td></tr>
<tr class="memitem:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory.html#ga66b12c692e0ca18d800cee6a69e0feb3">More...</a><br /></td></tr>
<tr class="separator:ga66b12c692e0ca18d800cee6a69e0feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;N==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, Toffset offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>scatter_rgba</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory.html#ga98181703f7fe46bc0803f3c7365f4ca2">More...</a><br /></td></tr>
<tr class="separator:ga98181703f7fe46bc0803f3c7365f4ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4cc43d10a1ffceca5170c191c13117e4">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="separator:ga4cc43d10a1ffceca5170c191c13117e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;((N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">sycl::_V1::ext::intel::esimd::gather_rgba</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; detail::DeviceAccessorOffsetT, N &gt; offsets, detail::DeviceAccessorOffsetT global_offset=0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather and transpose pixels from the given memory locations defined by the base specified by <code>acc</code>, the global offset <code>global_offset</code> and a vector of offsets <code>offsets</code>.  <a href="group__sycl__esimd__memory.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">More...</a><br /></td></tr>
<tr class="separator:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;sizeof(T)==4 &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; detail::DeviceAccessorOffsetT, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, detail::DeviceAccessorOffsetT global_offset=0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28490b843690be3630d11e68998cf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector.  <a href="group__sycl__esimd__memory.html#ga28490b843690be3630d11e68998cf1ee">More...</a><br /></td></tr>
<tr class="separator:ga28490b843690be3630d11e68998cf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6017662d822b0c760a5fe307068571c3"><td class="memTemplParams" colspan="2">template&lt;sycl::ext::intel::esimd::atomic_op Op, typename T , int N, unsigned NumSrc, bool IsLSC = false&gt; </td></tr>
<tr class="memitem:a6017662d822b0c760a5fe307068571c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a6017662d822b0c760a5fe307068571c3">sycl::_V1::ext::intel::esimd::detail::check_atomic</a> ()</td></tr>
<tr class="memdesc:a6017662d822b0c760a5fe307068571c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the legality of an atomic call in terms of size and type.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a6017662d822b0c760a5fe307068571c3">More...</a><br /></td></tr>
<tr class="separator:a6017662d822b0c760a5fe307068571c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplParams" colspan="2">template&lt;uint32_t SLMSize&gt; </td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">sycl::_V1::ext::intel::esimd::slm_init</a> ()</td></tr>
<tr class="memdesc:ga927d068c295204a54147ac9626cfe0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">More...</a><br /></td></tr>
<tr class="separator:ga927d068c295204a54147ac9626cfe0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346b7902be6b67d13f0034d77767722a"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">sycl::_V1::ext::intel::esimd::slm_init</a> (uint32_t size)</td></tr>
<tr class="memdesc:ga346b7902be6b67d13f0034d77767722a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">More...</a><br /></td></tr>
<tr class="separator:ga346b7902be6b67d13f0034d77767722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-1) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3)  <a href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">More...</a><br /></td></tr>
<tr class="separator:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeeaea968caad1111d9b1f878decee783"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">More...</a><br /></td></tr>
<tr class="separator:gaeeaea968caad1111d9b1f878decee783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf03a9216e379b075244936b633469cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">More...</a><br /></td></tr>
<tr class="separator:gaf03a9216e379b075244936b633469cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece7a3dd172984bf59f46482230a2448"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-4) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">More...</a><br /></td></tr>
<tr class="separator:gaece7a3dd172984bf59f46482230a2448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (slm-ga-5) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">More...</a><br /></td></tr>
<tr class="separator:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga764fcd9753f206ab8c420785ba433a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-6) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">More...</a><br /></td></tr>
<tr class="separator:ga764fcd9753f206ab8c420785ba433a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-7) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">More...</a><br /></td></tr>
<tr class="separator:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae6fcc63ae70c075518179d4da63976dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-8) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">More...</a><br /></td></tr>
<tr class="separator:gae6fcc63ae70c075518179d4da63976dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gacc98080310feeaf350db9310986ef1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (slm-ga-9) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">More...</a><br /></td></tr>
<tr class="separator:gacc98080310feeaf350db9310986ef1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">sycl::_V1::ext::intel::esimd::slm_scalar_load</a> (uint32_t offset)</td></tr>
<tr class="memdesc:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">More...</a><br /></td></tr>
<tr class="separator:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">sycl::_V1::ext::intel::esimd::slm_scatter</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga452f04de1896d50b415bfcdff867a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-1) void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2)  <a href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">More...</a><br /></td></tr>
<tr class="separator:ga452f04de1896d50b415bfcdff867a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">sycl::_V1::ext::intel::esimd::slm_scatter</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga17da97cf44fd768030ee06b7321151bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">More...</a><br /></td></tr>
<tr class="separator:ga17da97cf44fd768030ee06b7321151bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">sycl::_V1::ext::intel::esimd::slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-3) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">More...</a><br /></td></tr>
<tr class="separator:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">sycl::_V1::ext::intel::esimd::slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gafe51d24eb859e430fb759b91851cac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-4) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">More...</a><br /></td></tr>
<tr class="separator:gafe51d24eb859e430fb759b91851cac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">sycl::_V1::ext::intel::esimd::slm_scalar_store</a> (uint32_t offset, T val)</td></tr>
<tr class="memdesc:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">More...</a><br /></td></tr>
<tr class="separator:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4), <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">sycl::_V1::ext::intel::esimd::slm_gather_rgba</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">More...</a><br /></td></tr>
<tr class="separator:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask Mask&gt; </td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">sycl::_V1::ext::intel::esimd::slm_scatter_rgba</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(Mask)&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">More...</a><br /></td></tr>
<tr class="separator:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, Flags)</td></tr>
<tr class="memdesc:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given byte-offset <code>offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">More...</a><br /></td></tr>
<tr class="separator:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_load functions loads a contiguous memory block from SLM (Shared Local Memory) and the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">More...</a><br /></td></tr>
<tr class="separator:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;N&gt; pred, props = {}); // (slm-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">More...</a><br /></td></tr>
<tr class="separator:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gac26a70b8c5b5bae45aa2f68189316f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (slm-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">More...</a><br /></td></tr>
<tr class="separator:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9348416d24efcd644d5c4ec03550279"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, props={}); // (lacc-bl-1) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">More...</a><br /></td></tr>
<tr class="separator:gae9348416d24efcd644d5c4ec03550279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4d32f796205c30b9a1e1f98299579059"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, props={}); // (lacc-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">More...</a><br /></td></tr>
<tr class="separator:ga4d32f796205c30b9a1e1f98299579059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5be8a3908c474653637bfc5b1cca58de"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">More...</a><br /></td></tr>
<tr class="separator:ga5be8a3908c474653637bfc5b1cca58de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-4) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">More...</a><br /></td></tr>
<tr class="separator:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-5) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">More...</a><br /></td></tr>
<tr class="separator:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gafb08d45df0c2e84e8ae599863fed761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-6) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">More...</a><br /></td></tr>
<tr class="separator:gafb08d45df0c2e84e8ae599863fed761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags &gt; </td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of SLM memory at the given byte-offset <code>offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">More...</a><br /></td></tr>
<tr class="separator:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_store functions stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">More...</a><br /></td></tr>
<tr class="separator:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-2) props = {}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">More...</a><br /></td></tr>
<tr class="separator:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad481435bb21bb308d9e9879e096ad329"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-1) simd&lt;T, N&gt; vals, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">More...</a><br /></td></tr>
<tr class="separator:gad481435bb21bb308d9e9879e096ad329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad6cdaada3b83282c9feaa3df3fb46432"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-2) props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">More...</a><br /></td></tr>
<tr class="separator:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8641f19548717b4da73177f3612808fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={});  <a href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">More...</a><br /></td></tr>
<tr class="separator:ga8641f19548717b4da73177f3612808fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga66a15b020bd88413f2ca069c6806c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-4) simd_mask&lt;1&gt; pred, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">More...</a><br /></td></tr>
<tr class="separator:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47193729318c4b62257931c5cca73d5"><td class="memTemplParams" colspan="2">template&lt;typename T , sycl::ext::intel::esimd::atomic_op Op&gt; </td></tr>
<tr class="memitem:ad47193729318c4b62257931c5cca73d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ad47193729318c4b62257931c5cca73d5">sycl::_V1::ext::intel::esimd::detail::lsc_to_internal_atomic_op</a> ()</td></tr>
<tr class="separator:ad47193729318c4b62257931c5cca73d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ef31867a5616fe2c1266007f5c109"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS&gt; </td></tr>
<tr class="memitem:a250ef31867a5616fe2c1266007f5c109"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a250ef31867a5616fe2c1266007f5c109">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a250ef31867a5616fe2c1266007f5c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a250ef31867a5616fe2c1266007f5c109">More...</a><br /></td></tr>
<tr class="separator:a250ef31867a5616fe2c1266007f5c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347c322e68fdafd27698e55fa0d275b9"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS&gt; </td></tr>
<tr class="memitem:a347c322e68fdafd27698e55fa0d275b9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==1, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a347c322e68fdafd27698e55fa0d275b9">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a347c322e68fdafd27698e55fa0d275b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a347c322e68fdafd27698e55fa0d275b9">More...</a><br /></td></tr>
<tr class="separator:a347c322e68fdafd27698e55fa0d275b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652791e8cce8b9248a44dda8e68e9e0f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS&gt; </td></tr>
<tr class="memitem:a652791e8cce8b9248a44dda8e68e9e0f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a652791e8cce8b9248a44dda8e68e9e0f">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a652791e8cce8b9248a44dda8e68e9e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SLM atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a652791e8cce8b9248a44dda8e68e9e0f">More...</a><br /></td></tr>
<tr class="separator:a652791e8cce8b9248a44dda8e68e9e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7e9fb3b595ef693f1319288ca16446eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="slm_atomic_update0"></a> <a href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">More...</a><br /></td></tr>
<tr class="separator:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; pred = 1); // (lacc-au0-1) Atomically updates <code>N</code> memory locations in SLM ssociated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">More...</a><br /></td></tr>
<tr class="separator:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">One argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">More...</a><br /></td></tr>
<tr class="separator:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;1&gt; pred = 1); // (lacc-au1-1)  <a href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">More...</a><br /></td></tr>
<tr class="separator:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">More...</a><br /></td></tr>
<tr class="separator:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;1&gt; pred = 1); // (lacc-au2-1)  <a href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">More...</a><br /></td></tr>
<tr class="separator:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64178f9129263df403b5fe4c8d5e956"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS, typename PropertyListT , typename Toffset &gt; </td></tr>
<tr class="memitem:ad64178f9129263df403b5fe4c8d5e956"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ad64178f9129263df403b5fe4c8d5e956">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:ad64178f9129263df403b5fe4c8d5e956"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#ad64178f9129263df403b5fe4c8d5e956">More...</a><br /></td></tr>
<tr class="separator:ad64178f9129263df403b5fe4c8d5e956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4f6b41644cc9c7db2ed17b5cf96637"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS, typename PropertyListT , typename Toffset &gt; </td></tr>
<tr class="memitem:a9f4f6b41644cc9c7db2ed17b5cf96637"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==1, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9f4f6b41644cc9c7db2ed17b5cf96637">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a9f4f6b41644cc9c7db2ed17b5cf96637"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9f4f6b41644cc9c7db2ed17b5cf96637">More...</a><br /></td></tr>
<tr class="separator:a9f4f6b41644cc9c7db2ed17b5cf96637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba19d24325848a955526df4dfd891b4"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS, typename PropertyListT , typename Toffset &gt; </td></tr>
<tr class="memitem:abba19d24325848a955526df4dfd891b4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==2, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#abba19d24325848a955526df4dfd891b4">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:abba19d24325848a955526df4dfd891b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">USM pointer atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#abba19d24325848a955526df4dfd891b4">More...</a><br /></td></tr>
<tr class="separator:abba19d24325848a955526df4dfd891b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a31310895b9d66d956e91387c20b950"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS = lsc_data_size::default_size, typename PropertyListT , typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:a0a31310895b9d66d956e91387c20b950"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a0a31310895b9d66d956e91387c20b950">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a0a31310895b9d66d956e91387c20b950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a0a31310895b9d66d956e91387c20b950">More...</a><br /></td></tr>
<tr class="separator:a0a31310895b9d66d956e91387c20b950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc23eba3732fdf81ea70a3ac0ba57bca"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS, typename PropertyListT , typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:afc23eba3732fdf81ea70a3ac0ba57bca"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#afc23eba3732fdf81ea70a3ac0ba57bca">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:afc23eba3732fdf81ea70a3ac0ba57bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#afc23eba3732fdf81ea70a3ac0ba57bca">More...</a><br /></td></tr>
<tr class="separator:afc23eba3732fdf81ea70a3ac0ba57bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db1eade78a05669237f5d99eeef6158"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, lsc_data_size DS, typename PropertyListT , typename AccessorTy , typename Toffset &gt; </td></tr>
<tr class="memitem:a4db1eade78a05669237f5d99eeef6158"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a4db1eade78a05669237f5d99eeef6158">sycl::_V1::ext::intel::esimd::detail::atomic_update_impl</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; pred)</td></tr>
<tr class="memdesc:a4db1eade78a05669237f5d99eeef6158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor-based atomic.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a4db1eade78a05669237f5d99eeef6158">More...</a><br /></td></tr>
<tr class="separator:a4db1eade78a05669237f5d99eeef6158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga9ca317137669bb87b6b0741d434d5834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga9ca317137669bb87b6b0741d434d5834"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga9ca317137669bb87b6b0741d434d5834">More...</a><br /></td></tr>
<tr class="separator:ga9ca317137669bb87b6b0741d434d5834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga61ed2c099e12fc7505d061e617c241fb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga61ed2c099e12fc7505d061e617c241fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (usm-au0-2)  <a href="group__sycl__esimd__memory__atomics.html#ga61ed2c099e12fc7505d061e617c241fb">More...</a><br /></td></tr>
<tr class="separator:ga61ed2c099e12fc7505d061e617c241fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga60a6e250570f0318924f443351dcd01d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga60a6e250570f0318924f443351dcd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (usm-au0-3)  <a href="group__sycl__esimd__memory__atomics.html#ga60a6e250570f0318924f443351dcd01d">More...</a><br /></td></tr>
<tr class="separator:ga60a6e250570f0318924f443351dcd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga299c6985b6669fe4d0965a13223452c0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga299c6985b6669fe4d0965a13223452c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, props = {}); /// (usm-au0-4)  <a href="group__sycl__esimd__memory__atomics.html#ga299c6985b6669fe4d0965a13223452c0">More...</a><br /></td></tr>
<tr class="separator:ga299c6985b6669fe4d0965a13223452c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, Toffset byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga49c30960f901e1ac8ddd3f6db43a1327">More...</a><br /></td></tr>
<tr class="separator:ga49c30960f901e1ac8ddd3f6db43a1327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6624b909565dd8a01cca82f94118658f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6624b909565dd8a01cca82f94118658f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga6624b909565dd8a01cca82f94118658f">More...</a><br /></td></tr>
<tr class="separator:ga6624b909565dd8a01cca82f94118658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d32dac41faa2752a3a100179c047164"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d32dac41faa2752a3a100179c047164"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *ptr, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga5d32dac41faa2752a3a100179c047164">More...</a><br /></td></tr>
<tr class="separator:ga5d32dac41faa2752a3a100179c047164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa8235f4973a7f07671e65884d6a4e407"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa8235f4973a7f07671e65884d6a4e407"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (usm-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#gaa8235f4973a7f07671e65884d6a4e407">More...</a><br /></td></tr>
<tr class="separator:gaa8235f4973a7f07671e65884d6a4e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3163517455229f9359dc7befcdaf33ac"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3163517455229f9359dc7befcdaf33ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (usm-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#ga3163517455229f9359dc7befcdaf33ac">More...</a><br /></td></tr>
<tr class="separator:ga3163517455229f9359dc7befcdaf33ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gaa11a4e5e6db9766b05f53882c5969894"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt; &amp;&amp;((Op !=atomic_op::store &amp;&amp;Op !=atomic_op::xchg)||N==1), <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">sycl::_V1::ext::intel::esimd::atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaa11a4e5e6db9766b05f53882c5969894"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gaa11a4e5e6db9766b05f53882c5969894">More...</a><br /></td></tr>
<tr class="separator:gaa11a4e5e6db9766b05f53882c5969894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7818fd03a76ec89e81453fc2eed03315"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7818fd03a76ec89e81453fc2eed03315"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="usm_atomic_update2"></a>Atomically updates <code>N</code> memory locations represented by a USM pointer and a vector of offsets relative to the pointer, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__atomics.html#ga7818fd03a76ec89e81453fc2eed03315">More...</a><br /></td></tr>
<tr class="separator:ga7818fd03a76ec89e81453fc2eed03315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b0e94818140af7667c53ed1900f8227"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b0e94818140af7667c53ed1900f8227"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (usm-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#ga8b0e94818140af7667c53ed1900f8227">More...</a><br /></td></tr>
<tr class="separator:ga8b0e94818140af7667c53ed1900f8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga50118f07f0d1ce05b1f3af664e61f377"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}) // (usm-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga50118f07f0d1ce05b1f3af664e61f377">More...</a><br /></td></tr>
<tr class="separator:ga50118f07f0d1ce05b1f3af664e61f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8b969ac66b06344433b03d7a42c5adef"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">sycl::_V1::ext::intel::esimd::atomic_update</a> (T *p, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8b969ac66b06344433b03d7a42c5adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(T *p, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}) // (usm-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#ga8b969ac66b06344433b03d7a42c5adef">More...</a><br /></td></tr>
<tr class="separator:ga8b969ac66b06344433b03d7a42c5adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset &gt; </td></tr>
<tr class="memitem:gadfc93c8742970952cb25c39099e90017"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; Toffset &gt;, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">sycl::_V1::ext::intel::esimd::atomic_update</a> (Tx *p, Toffset byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gadfc93c8742970952cb25c39099e90017"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gadfc93c8742970952cb25c39099e90017">More...</a><br /></td></tr>
<tr class="separator:gadfc93c8742970952cb25c39099e90017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7a0e01d45006dc95652b9576a8468333"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7a0e01d45006dc95652b9576a8468333"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update0"></a> <a href="group__sycl__esimd__memory__atomics.html#ga7a0e01d45006dc95652b9576a8468333">More...</a><br /></td></tr>
<tr class="separator:ga7a0e01d45006dc95652b9576a8468333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece5430efdfa55ea8851a6a4baffc367"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece5430efdfa55ea8851a6a4baffc367"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, props = {}); /// (acc-au0-2) A variation of <code>atomic_update</code> API without mask operand  <a href="group__sycl__esimd__memory__atomics.html#gaece5430efdfa55ea8851a6a4baffc367">More...</a><br /></td></tr>
<tr class="separator:gaece5430efdfa55ea8851a6a4baffc367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd_mask&lt;N&gt; mask, props = {}); /// (acc-au0-3) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object.  <a href="group__sycl__esimd__memory__atomics.html#ga5725ccf8dfc4ecb5cc114b85c7327d23">More...</a><br /></td></tr>
<tr class="separator:ga5725ccf8dfc4ecb5cc114b85c7327d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0b4df1e247b58fad96a6ac29fca17892"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, props = {}); /// (acc-au0-4) A variation of <code>atomic_update</code> API with <code>offsets</code> represented as <code><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a></code> object and no mask operand.  <a href="group__sycl__esimd__memory__atomics.html#ga0b4df1e247b58fad96a6ac29fca17892">More...</a><br /></td></tr>
<tr class="separator:ga0b4df1e247b58fad96a6ac29fca17892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga026c23b583bbddb6c43fa0db20c15267"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga026c23b583bbddb6c43fa0db20c15267"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#ga026c23b583bbddb6c43fa0db20c15267">More...</a><br /></td></tr>
<tr class="separator:ga026c23b583bbddb6c43fa0db20c15267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gac6fcffa3281c801923e6ca78d7681553"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gac6fcffa3281c801923e6ca78d7681553"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>byte_offset</code> represented as scalar using <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#gac6fcffa3281c801923e6ca78d7681553">More...</a><br /></td></tr>
<tr class="separator:gac6fcffa3281c801923e6ca78d7681553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga12af50e667b8379c85ba2fbd69c9642a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update1"></a> <a href="group__sycl__esimd__memory__atomics.html#ga12af50e667b8379c85ba2fbd69c9642a">More...</a><br /></td></tr>
<tr class="separator:ga12af50e667b8379c85ba2fbd69c9642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, PropertyListT props={})</td></tr>
<tr class="memdesc:ga911d8084626d7c07dc3d5a358e8d6118"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-2)  <a href="group__sycl__esimd__memory__atomics.html#ga911d8084626d7c07dc3d5a358e8d6118">More...</a><br /></td></tr>
<tr class="separator:ga911d8084626d7c07dc3d5a358e8d6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask, props = {}); // (acc-au1-3)  <a href="group__sycl__esimd__memory__atomics.html#ga8d12ab7b93126d3af6531bf1cbfc830b">More...</a><br /></td></tr>
<tr class="separator:ga8d12ab7b93126d3af6531bf1cbfc830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab12baf4188b777673f2293f506f5c58a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, PropertyListT props={})</td></tr>
<tr class="memdesc:gab12baf4188b777673f2293f506f5c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorT acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, props = {}); // (acc-au1-4)  <a href="group__sycl__esimd__memory__atomics.html#gab12baf4188b777673f2293f506f5c58a">More...</a><br /></td></tr>
<tr class="separator:gab12baf4188b777673f2293f506f5c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=atomic_op::store &amp;&amp;Op !=atomic_op::xchg)||N==1), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gace9371b37fcc89eee8dd82d7957c9aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object.  <a href="group__sycl__esimd__memory__atomics.html#gace9371b37fcc89eee8dd82d7957c9aab">More...</a><br /></td></tr>
<tr class="separator:gace9371b37fcc89eee8dd82d7957c9aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt; &amp;&amp;((Op !=atomic_op::store &amp;&amp;Op !=atomic_op::xchg)||N==1), <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offset</code> represented as scalar object and uses <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code>.  <a href="group__sycl__esimd__memory__atomics.html#ga1cf5795cf5ae37d90a75ca3cf6f4f7aa">More...</a><br /></td></tr>
<tr class="separator:ga1cf5795cf5ae37d90a75ca3cf6f4f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;std::is_integral_v&lt; Toffset &gt; &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab1cb38958ce5611fbb683250b6d37b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="accessor_atomic_update2"></a> <a href="group__sycl__esimd__memory__atomics.html#gab1cb38958ce5611fbb683250b6d37b9f">More...</a><br /></td></tr>
<tr class="separator:gab1cb38958ce5611fbb683250b6d37b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename Toffset , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; Toffset, N &gt; byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, simd&lt;Toffset, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-2)  <a href="group__sycl__esimd__memory__atomics.html#gaf72b54d4c40c5b335642b721bbd3cd0c">More...</a><br /></td></tr>
<tr class="separator:gaf72b54d4c40c5b335642b721bbd3cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2453919e91d9887fde4bc32fb858212c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2453919e91d9887fde4bc32fb858212c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask, props = {}); // (acc-au2-3)  <a href="group__sycl__esimd__memory__atomics.html#ga2453919e91d9887fde4bc32fb858212c">More...</a><br /></td></tr>
<tr class="separator:ga2453919e91d9887fde4bc32fb858212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename OffsetSimdViewT , typename AccessorTy , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, OffsetSimdViewT byte_offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; src1, PropertyListT props={})</td></tr>
<tr class="memdesc:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(AccessorTy acc, OffsetSimdViewT, byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, props = {}); // (acc-au2-4)  <a href="group__sycl__esimd__memory__atomics.html#gaedaa2fddfad01be856f0ac3e92dea8f4">More...</a><br /></td></tr>
<tr class="separator:gaedaa2fddfad01be856f0ac3e92dea8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename Toffset , typename AccessorTy &gt; </td></tr>
<tr class="memitem:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_device_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, Toffset offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:gaf02d6524019b24c7f1444aec1057ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar.  <a href="group__sycl__esimd__memory__atomics.html#gaf02d6524019b24c7f1444aec1057ebbe">More...</a><br /></td></tr>
<tr class="separator:gaf02d6524019b24c7f1444aec1057ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename Tx , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga0164810c5dc8e6862f0188fb93b75640"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorTy &gt;, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorTy acc, uint32_t offset, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src0, <a class="el" href="classsimd.html">simd</a>&lt; Tx, N &gt; src1, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask)</td></tr>
<tr class="memdesc:ga0164810c5dc8e6862f0188fb93b75640"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of <code>atomic_update</code> API with <code>offsets</code> represented as scalar and <code><a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a></code> is used.  <a href="group__sycl__esimd__memory__atomics.html#ga0164810c5dc8e6862f0188fb93b75640">More...</a><br /></td></tr>
<tr class="separator:ga0164810c5dc8e6862f0188fb93b75640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplParams" colspan="2">template&lt;uint8_t cntl&gt; </td></tr>
<tr class="memitem:ga6894e650e3d2d8252726536d4055aa0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">sycl::_V1::ext::intel::esimd::fence</a> ()</td></tr>
<tr class="memdesc:ga6894e650e3d2d8252726536d4055aa0e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e" title="esimd::fence sets the memory read/write order.">esimd::fence</a> sets the memory read/write order.  <a href="group__sycl__esimd__memory.html#ga6894e650e3d2d8252726536d4055aa0e">More...</a><br /></td></tr>
<tr class="separator:ga6894e650e3d2d8252726536d4055aa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2eefea21b6197da16a58d10ecb1d7a38">sycl::_V1::ext::intel::esimd::fence</a> (fence_mask cntl)</td></tr>
<tr class="separator:ga2eefea21b6197da16a58d10ecb1d7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplParams" colspan="2">template&lt;memory_kind Kind = memory_kind::global, fence_flush_op FenceOp = fence_flush_op::none, fence_scope Scope = fence_scope::group&gt; </td></tr>
<tr class="memitem:ga671467f8fc485a53380db7359bb9c193"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">sycl::_V1::ext::intel::esimd::fence</a> ()</td></tr>
<tr class="memdesc:ga671467f8fc485a53380db7359bb9c193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory fence.  <a href="group__sycl__esimd__memory.html#ga671467f8fc485a53380db7359bb9c193">More...</a><br /></td></tr>
<tr class="separator:ga671467f8fc485a53380db7359bb9c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">sycl::_V1::ext::intel::esimd::barrier</a> ()</td></tr>
<tr class="memdesc:gaf339323c524d7aad3ef8d592c197d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic work-group barrier.  <a href="group__sycl__esimd__memory.html#gaf339323c524d7aad3ef8d592c197d7ae">More...</a><br /></td></tr>
<tr class="separator:gaf339323c524d7aad3ef8d592c197d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:gacb4ea356b65d551c454e43430a266a20"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsimd.html">simd</a>&lt; T, m *N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">sycl::_V1::ext::intel::esimd::media_block_load</a> (AccessorTy acc, unsigned x, unsigned y)</td></tr>
<tr class="memdesc:gacb4ea356b65d551c454e43430a266a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block load.  <a href="group__sycl__esimd__memory.html#gacb4ea356b65d551c454e43430a266a20">More...</a><br /></td></tr>
<tr class="separator:gacb4ea356b65d551c454e43430a266a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplParams" colspan="2">template&lt;typename T , int m, int N, typename AccessorTy , unsigned plane = 0&gt; </td></tr>
<tr class="memitem:ga7228e366d106365df6b40f4f192004ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">sycl::_V1::ext::intel::esimd::media_block_store</a> (AccessorTy acc, unsigned x, unsigned y, <a class="el" href="classsimd.html">simd</a>&lt; T, m *N &gt; vals)</td></tr>
<tr class="memdesc:ga7228e366d106365df6b40f4f192004ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media block store.  <a href="group__sycl__esimd__memory.html#ga7228e366d106365df6b40f4f192004ba">More...</a><br /></td></tr>
<tr class="separator:ga7228e366d106365df6b40f4f192004ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy , typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorTy acc, uint32_t byte_offset, Flags flags)</td></tr>
<tr class="memdesc:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given local-accessor <code>acc</code> and <code>byte_offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory.html#ga88f61c5e7a95c1d17f66b3dbf06f6106">More...</a><br /></td></tr>
<tr class="separator:ga88f61c5e7a95c1d17f66b3dbf06f6106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename Flags &gt; </td></tr>
<tr class="memitem:ga3770b4bddea00af67e996df884f1310c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;<a class="el" href="std_2experimental_2simd_8hpp.html#a78a28e5bfbe3a0f2cbc16b706346988b">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT acc, uint32_t offset, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, Flags flags)</td></tr>
<tr class="memdesc:ga3770b4bddea00af67e996df884f1310c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of block_store that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#ga3770b4bddea00af67e996df884f1310c">More...</a><br /></td></tr>
<tr class="separator:ga3770b4bddea00af67e996df884f1310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga46229a4f362e8ffae317a1b69ff22046"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga46229a4f362e8ffae317a1b69ff22046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-1) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3)  <a href="group__sycl__esimd__memory.html#ga46229a4f362e8ffae317a1b69ff22046">More...</a><br /></td></tr>
<tr class="separator:ga46229a4f362e8ffae317a1b69ff22046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-ga-2) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#ga2d2f59b6d09c35bfe9f285fc50bb2029">More...</a><br /></td></tr>
<tr class="separator:ga2d2f59b6d09c35bfe9f285fc50bb2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf0e84c0a304d1986dc243b965c157834"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf0e84c0a304d1986dc243b965c157834"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-3) Supported platforms: DG2, PVC in most cases.  <a href="group__sycl__esimd__memory.html#gaf0e84c0a304d1986dc243b965c157834">More...</a><br /></td></tr>
<tr class="separator:gaf0e84c0a304d1986dc243b965c157834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (lacc-ga-4) This function is identical to (lacc-ga-1) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga4ceac1668c5a35e5da1a90e8e3200875">More...</a><br /></td></tr>
<tr class="separator:ga4ceac1668c5a35e5da1a90e8e3200875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename MaskT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;std::is_same_v&lt; MaskT, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt;&gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, MaskT mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props // (lacc-ga-5) This function is identical to (lacc-ga-2) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga81d896e0dbfd1d31f3052fd5484ecd5f">More...</a><br /></td></tr>
<tr class="separator:ga81d896e0dbfd1d31f3052fd5484ecd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; gather(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (lacc-ga-6) This function is identical to (lacc-ga-3) except that vector size is fixed to 1.  <a href="group__sycl__esimd__memory.html#ga361bb93f02b78ef43b5c78f3b9a14484">More...</a><br /></td></tr>
<tr class="separator:ga361bb93f02b78ef43b5c78f3b9a14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5d43b1baaab951d4142e49e50d875a92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5d43b1baaab951d4142e49e50d875a92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5d43b1baaab951d4142e49e50d875a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga5d43b1baaab951d4142e49e50d875a92">More...</a><br /></td></tr>
<tr class="separator:ga5d43b1baaab951d4142e49e50d875a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga767b97791462434ce040062cfe9ff819"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga767b97791462434ce040062cfe9ff819">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga767b97791462434ce040062cfe9ff819"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga767b97791462434ce040062cfe9ff819">More...</a><br /></td></tr>
<tr class="separator:ga767b97791462434ce040062cfe9ff819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;), <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga1b1e1eef8e77177e7433f558e4521f92">sycl::_V1::ext::intel::esimd::gather</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1b1e1eef8e77177e7433f558e4521f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT,  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga1b1e1eef8e77177e7433f558e4521f92">More...</a><br /></td></tr>
<tr class="separator:ga1b1e1eef8e77177e7433f558e4521f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:gae8edb9934390ed9f0485689d7e21a00e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">sycl::_V1::ext::intel::esimd::gather</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t glob_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gae8edb9934390ed9f0485689d7e21a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather that uses local accessor as a parameter.  <a href="group__sycl__esimd__memory.html#gae8edb9934390ed9f0485689d7e21a00e">More...</a><br /></td></tr>
<tr class="separator:gae8edb9934390ed9f0485689d7e21a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gab4754c6fc7ec658643ff5552bc5907f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter that uses local accessor as a parameter template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-1)  <a href="group__sycl__esimd__memory.html#gab4754c6fc7ec658643ff5552bc5907f7">More...</a><br /></td></tr>
<tr class="separator:gab4754c6fc7ec658643ff5552bc5907f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-2)  <a href="group__sycl__esimd__memory.html#gacb2c6a4ee8b73ab52f75a66877fa5a46">More...</a><br /></td></tr>
<tr class="separator:gacb2c6a4ee8b73ab52f75a66877fa5a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7d1e59064714e4494d2f44bd48788b36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7d1e59064714e4494d2f44bd48788b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename AccessorT, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (lacc-sc-3)  <a href="group__sycl__esimd__memory.html#ga7d1e59064714e4494d2f44bd48788b36">More...</a><br /></td></tr>
<tr class="separator:ga7d1e59064714e4494d2f44bd48788b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa204bc7f7a825040148c900e0b4e0a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void scatter(AccessorT acc, OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (lacc-sc-4)  <a href="group__sycl__esimd__memory.html#gaa204bc7f7a825040148c900e0b4e0a21">More...</a><br /></td></tr>
<tr class="separator:gaa204bc7f7a825040148c900e0b4e0a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorTy &gt; </td></tr>
<tr class="memitem:ga097b8aadcd461c076d70226f01925390"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorTy, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga097b8aadcd461c076d70226f01925390">sycl::_V1::ext::intel::esimd::scatter</a> (AccessorTy acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; vals, uint32_t glob_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga097b8aadcd461c076d70226f01925390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter that uses local accessor as a parameter.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga097b8aadcd461c076d70226f01925390">More...</a><br /></td></tr>
<tr class="separator:ga097b8aadcd461c076d70226f01925390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac74cbc4141970dfbd259060d2597e08e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac74cbc4141970dfbd259060d2597e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-1) void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2)  <a href="group__sycl__esimd__memory.html#gac74cbc4141970dfbd259060d2597e08e">More...</a><br /></td></tr>
<tr class="separator:gac74cbc4141970dfbd259060d2597e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac311042ed7d2a3446ad9ab78b9f7d505">More...</a><br /></td></tr>
<tr class="separator:gac311042ed7d2a3446ad9ab78b9f7d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac194ba4693e7c9aee73f63c959947f76"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gac194ba4693e7c9aee73f63c959947f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (usm-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gac194ba4693e7c9aee73f63c959947f76">More...</a><br /></td></tr>
<tr class="separator:gac194ba4693e7c9aee73f63c959947f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd&lt;OffsetT, N&gt; byte_offsets, PropertyListT props = {}); // (usm-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga2c0b6e34163d6dabbab61d2681c07c93">More...</a><br /></td></tr>
<tr class="separator:ga2c0b6e34163d6dabbab61d2681c07c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (usm-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga23c5e7c8323cdcf85d018fbf4299b698">More...</a><br /></td></tr>
<tr class="separator:ga23c5e7c8323cdcf85d018fbf4299b698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga68cb007526441a43e5a72668a52fc3d4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga68cb007526441a43e5a72668a52fc3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (usm-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga68cb007526441a43e5a72668a52fc3d4">More...</a><br /></td></tr>
<tr class="separator:ga68cb007526441a43e5a72668a52fc3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga7ffd04632e53c13cae50f95c8266428e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetT byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga7ffd04632e53c13cae50f95c8266428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (usm-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga7ffd04632e53c13cae50f95c8266428e">More...</a><br /></td></tr>
<tr class="separator:ga7ffd04632e53c13cae50f95c8266428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga0eb8934c359d7b74a1979513576ba0be"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga0eb8934c359d7b74a1979513576ba0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, OffsetT byte_offset, PropertyListT props = {}); // (usm-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga0eb8934c359d7b74a1979513576ba0be">More...</a><br /></td></tr>
<tr class="separator:ga0eb8934c359d7b74a1979513576ba0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(usm-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaf2d595c9381e5a0414aeb53b548f2c83">More...</a><br /></td></tr>
<tr class="separator:gaf2d595c9381e5a0414aeb53b548f2c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga78527de7e485b381788e4b031b29b39c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">sycl::_V1::ext::intel::esimd::prefetch</a> (const T *p, PropertyListT props={})</td></tr>
<tr class="memdesc:ga78527de7e485b381788e4b031b29b39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename PropertyListT = empty_properties_t&gt; void prefetch(const T *p, PropertyListT props = {}); // (usm-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga78527de7e485b381788e4b031b29b39c">More...</a><br /></td></tr>
<tr class="separator:ga78527de7e485b381788e4b031b29b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga76862c56e39d4464ee6015f0c69ac537"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga76862c56e39d4464ee6015f0c69ac537"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-1) void prefetch(AccessorT acc, simd&lt;OffsetT, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2)  <a href="group__sycl__esimd__memory.html#ga76862c56e39d4464ee6015f0c69ac537">More...</a><br /></td></tr>
<tr class="separator:ga76862c56e39d4464ee6015f0c69ac537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-2) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaeb0c6d83efd2b2c9a3e05d0999f0ecfd">More...</a><br /></td></tr>
<tr class="separator:gaeb0c6d83efd2b2c9a3e05d0999f0ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1aa325722f031578760777bc849efe36"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1aa325722f031578760777bc849efe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {}); // (acc-pf-3) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga1aa325722f031578760777bc849efe36">More...</a><br /></td></tr>
<tr class="separator:ga1aa325722f031578760777bc849efe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; OffsetT, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab1304b5dbfe4f787c09221b4e427b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (acc-pf-4) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab1304b5dbfe4f787c09221b4e427b87">More...</a><br /></td></tr>
<tr class="separator:gaab1304b5dbfe4f787c09221b4e427b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gadc4bd79c567f680523a2277b67ce5a77"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gadc4bd79c567f680523a2277b67ce5a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (acc-pf-5) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gadc4bd79c567f680523a2277b67ce5a77">More...</a><br /></td></tr>
<tr class="separator:gadc4bd79c567f680523a2277b67ce5a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga3b61e9602ee8be170bcba87227501525"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga3b61e9602ee8be170bcba87227501525"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (acc-pf-6) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga3b61e9602ee8be170bcba87227501525">More...</a><br /></td></tr>
<tr class="separator:ga3b61e9602ee8be170bcba87227501525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae5b4ee36004127672acde85ce8b05d7b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetT byte_offset, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae5b4ee36004127672acde85ce8b05d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, simd_mask&lt;1&gt; mask, PropertyListT props = {}); // (acc-pf-7) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gae5b4ee36004127672acde85ce8b05d7b">More...</a><br /></td></tr>
<tr class="separator:gae5b4ee36004127672acde85ce8b05d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename OffsetT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5629d544041ea068f46b2d16edbf528d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; std::is_integral_v&lt; OffsetT &gt; &amp;&amp;detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, OffsetT byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5629d544041ea068f46b2d16edbf528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename OffsetT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, uint32_t byte_offset, PropertyListT props = {}); // (acc-pf-8) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga5629d544041ea068f46b2d16edbf528d">More...</a><br /></td></tr>
<tr class="separator:ga5629d544041ea068f46b2d16edbf528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaab36701169020a7a0ac58009a54ea935"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; 1 &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaab36701169020a7a0ac58009a54ea935"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, simd_mask&lt;1&gt; mask, PropertyListT props = {}); //(acc-pf-9) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#gaab36701169020a7a0ac58009a54ea935">More...</a><br /></td></tr>
<tr class="separator:gaab36701169020a7a0ac58009a54ea935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplParams" colspan="2">template&lt;typename T , int VS = 1, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8876c22da7059ca756e04cd16da42218"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_device_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">sycl::_V1::ext::intel::esimd::prefetch</a> (AccessorT acc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8876c22da7059ca756e04cd16da42218"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int VS = 1, typename AccessorT, typename PropertyListT = empty_properties_t&gt; void prefetch(AccessorT acc, PropertyListT props = {}); // (acc-pf-10) Supported platforms: DG2, PVC only.  <a href="group__sycl__esimd__memory.html#ga8876c22da7059ca756e04cd16da42218">More...</a><br /></td></tr>
<tr class="separator:ga8876c22da7059ca756e04cd16da42218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">sycl::_V1::ext::intel::esimd::load_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, bool Transposed = false, bool Transformed = false, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, Transposed, Transformed&gt;(), typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; load_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block load.  <a href="group__sycl__esimd__memory.html#gaa4bb3bbc96f311cf8d34ac6879de5e17">More...</a><br /></td></tr>
<tr class="separator:gaa4bb3bbc96f311cf8d34ac6879de5e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, NBlocks, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">sycl::_V1::ext::intel::esimd::prefetch_2d</a> (const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props={})</td></tr>
<tr class="memdesc:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int BlockWidth, int BlockHeight = 1, int NBlocks = 1, int N = detail::get_lsc_block_2d_data_size&lt; T, NBlocks, BlockHeight, BlockWidth, false, false&gt;(), typename PropertyListT = empty_properties_t&gt; void prefetch_2d(const T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, PropertyListT props = {}); 2D USM pointer block prefetch.  <a href="group__sycl__esimd__memory.html#ga6283ab7040a03799e7b3aee0f1be6afc">More...</a><br /></td></tr>
<tr class="separator:ga6283ab7040a03799e7b3aee0f1be6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplParams" colspan="2">template&lt;typename T , int BlockWidth, int BlockHeight = 1, int N = detail::get_lsc_block_2d_data_size&lt;              T, 1u, BlockHeight, BlockWidth, false ,              false &gt;(), typename PropertyListT  = oneapi::experimental::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">sycl::_V1::ext::intel::esimd::store_2d</a> (T *Ptr, unsigned SurfaceWidth, unsigned SurfaceHeight, unsigned SurfacePitch, int X, int Y, <a class="el" href="classsimd.html">simd</a>&lt; T, N &gt; Vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D USM pointer block store.  <a href="group__sycl__esimd__memory.html#ga4097686b52cc7f8d0ae2a9dfb327193d">More...</a><br /></td></tr>
<tr class="separator:ga4097686b52cc7f8d0ae2a9dfb327193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt;, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">sycl::_V1::ext::intel::esimd::gather_rgba</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, uint32_t global_offset=0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of gather_rgba that uses local accessor as a parameter.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga12445cfacbfd6f5758d3e0d3daa4b6f8">More...</a><br /></td></tr>
<tr class="separator:ga12445cfacbfd6f5758d3e0d3daa4b6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplParams" colspan="2">template&lt;rgba_channel_mask RGBAMask = rgba_channel_mask::ABGR, typename AccessorT , int N, typename T  = typename AccessorT::value_type&gt; </td></tr>
<tr class="memitem:ga28490b843690be3630d11e68998cf1ee"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga28490b843690be3630d11e68998cf1ee">sycl::_V1::ext::intel::esimd::scatter_rgba</a> (AccessorT acc, <a class="el" href="classsimd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsimd.html">simd</a>&lt; T, N *get_num_channels_enabled(RGBAMask)&gt; vals, uint32_t global_offset=0, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28490b843690be3630d11e68998cf1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of scatter_rgba that uses local accessor as a parameter Gather data from the memory addressed by accessor <code>acc</code>, offset common for all loaded elements <code>global_offset</code> and per-element offsets <code>offsets</code>, and return it as simd vector.  <a href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#ga28490b843690be3630d11e68998cf1ee">More...</a><br /></td></tr>
<tr class="separator:ga28490b843690be3630d11e68998cf1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1d5d5278888f08f1a42508835d5025"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_src1, uint8_t num_dst, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2, typename T3 , int n3&gt; </td></tr>
<tr class="memitem:gaaa1d5d5278888f08f1a42508835d5025"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#gaaa1d5d5278888f08f1a42508835d5025">sycl::_V1::ext::intel::esimd::raw_sends</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_dst, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T3, n3 &gt; msg_src1, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:gaaa1d5d5278888f08f1a42508835d5025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw sends.  <a href="group__sycl__esimd__raw__send.html#gaaa1d5d5278888f08f1a42508835d5025">More...</a><br /></td></tr>
<tr class="separator:gaaa1d5d5278888f08f1a42508835d5025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9444b504c0e00055bcabf05e901235e0"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_dst, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2&gt; </td></tr>
<tr class="memitem:ga9444b504c0e00055bcabf05e901235e0"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#ga9444b504c0e00055bcabf05e901235e0">sycl::_V1::ext::intel::esimd::raw_send</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_dst, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src0, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:ga9444b504c0e00055bcabf05e901235e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw send.  <a href="group__sycl__esimd__raw__send.html#ga9444b504c0e00055bcabf05e901235e0">More...</a><br /></td></tr>
<tr class="separator:ga9444b504c0e00055bcabf05e901235e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, uint8_t num_src1, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1, typename T2 , int n2&gt; </td></tr>
<tr class="memitem:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#gaaeab6bdb75216352cf3ce5ccaf6f14df">sycl::_V1::ext::intel::esimd::raw_sends</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_src0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T2, n2 &gt; msg_src1, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw sends.  <a href="group__sycl__esimd__raw__send.html#gaaeab6bdb75216352cf3ce5ccaf6f14df">More...</a><br /></td></tr>
<tr class="separator:gaaeab6bdb75216352cf3ce5ccaf6f14df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memTemplParams" colspan="2">template&lt;uint8_t exec_size, uint8_t sfid, uint8_t num_src0, raw_send_eot eot = raw_send_eot::not_eot, raw_send_sendc sendc = raw_send_sendc::not_sendc, typename T1 , int n1&gt; </td></tr>
<tr class="memitem:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__raw__send.html#ga3824d7fdb8a5cd64954bd0b6ce4130ba">sycl::_V1::ext::intel::esimd::raw_send</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">sycl::ext::intel::esimd::simd</a>&lt; T1, n1 &gt; msg_src0, uint32_t ex_desc, uint32_t msg_desc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">sycl::ext::intel::esimd::simd_mask</a>&lt; exec_size &gt; mask=1)</td></tr>
<tr class="memdesc:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw send.  <a href="group__sycl__esimd__raw__send.html#ga3824d7fdb8a5cd64954bd0b6ce4130ba">More...</a><br /></td></tr>
<tr class="separator:ga3824d7fdb8a5cd64954bd0b6ce4130ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae3e0557f145264f207e6d08beb916a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e0557f145264f207e6d08beb916a75">&#9670;&nbsp;</a></span>__ESIMD_FP_ATOMIC_OP_TYPE_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __ESIMD_FP_ATOMIC_OP_TYPE_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  static_assert(is_type&lt;T, float, sycl::half, double&gt;(),                       \</div>
<div class="line">                <span class="stringliteral">&quot;float, double or sycl::half type is expected&quot;</span>);</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04257">4257</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_0d7e0c259facfc42867cbdec0029234e.html">sycl</a></li><li class="navelem"><a class="el" href="dir_772cb676c9cb27b05c05d69faa4dcaec.html">ext</a></li><li class="navelem"><a class="el" href="dir_9e5686b40de5c2050d46e853c748fa09.html">intel</a></li><li class="navelem"><a class="el" href="dir_64a3f50f2fa52ffb870376eba8d01e5a.html">esimd</a></li><li class="navelem"><a class="el" href="ext_2intel_2esimd_2memory_8hpp.html">memory.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
