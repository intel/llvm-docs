<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: cl::sycl::handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI Data Parallel C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcl_1_1sycl_1_1handler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcl_1_1sycl_1_1handler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::handler Class Reference<div class="ingroups"><a class="el" href="group__sycl__api.html">DPC++ User API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Command group handler class.  
 <a href="classcl_1_1sycl_1_1handler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="handler_8hpp_source.html">CL/sycl/handler.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaefeb39ac45bff2a7e4e40308ffc2ffc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaefeb39ac45bff2a7e4e40308ffc2ffc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">remove_cv_ref_t</a> = typename <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a374ddfe6f1bd73a40de7fc63f3870800">detail::remove_cv_t</a>&lt; <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt; <a class="el" href="classT.html">T</a> &gt; &gt;</td></tr>
<tr class="separator:aaefeb39ac45bff2a7e4e40308ffc2ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1ff6744816686a4abffc42f4276610"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T &gt; </td></tr>
<tr class="memitem:a6d1ff6744816686a4abffc42f4276610"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a6d1ff6744816686a4abffc42f4276610">is_same_type</a> = std::is_same&lt; <a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">remove_cv_ref_t</a>&lt; U &gt;, <a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">remove_cv_ref_t</a>&lt; <a class="el" href="classT.html">T</a> &gt; &gt;</td></tr>
<tr class="separator:a6d1ff6744816686a4abffc42f4276610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab6e38c9f1c74a6353d9328a2a6950d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aab6e38c9f1c74a6353d9328a2a6950d6">handler</a> (const <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;)=delete</td></tr>
<tr class="separator:aab6e38c9f1c74a6353d9328a2a6950d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d56a475a807c51c9f750bb6c8ee15e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a87d56a475a807c51c9f750bb6c8ee15e">handler</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a87d56a475a807c51c9f750bb6c8ee15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386591bd9bd6a952393ce61d8d48ce5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a386591bd9bd6a952393ce61d8d48ce5c">operator=</a> (const <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;)=delete</td></tr>
<tr class="separator:a386591bd9bd6a952393ce61d8d48ce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234cd372ff6a74e0721838d17c4adf8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a234cd372ff6a74e0721838d17c4adf8b">operator=</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a234cd372ff6a74e0721838d17c4adf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4e8ab1956f2f591030f1d5fe24ba6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#afd4e8ab1956f2f591030f1d5fe24ba6c">use_kernel_bundle</a> (const <a class="el" href="classcl_1_1sycl_1_1kernel__bundle.html">kernel_bundle</a>&lt; <a class="el" href="namespacecl_1_1sycl.html#a2704d20220e08bb580fed24428b051d0aee7004c7949d83f130592f15d98ca343">bundle_state::executable</a> &gt; &amp;ExecBundle)</td></tr>
<tr class="separator:afd4e8ab1956f2f591030f1d5fe24ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15174598d704c69779e60fdb86da80e"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget&gt; </td></tr>
<tr class="memitem:ae15174598d704c69779e60fdb86da80e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae15174598d704c69779e60fdb86da80e">require</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt; Acc)</td></tr>
<tr class="memdesc:ae15174598d704c69779e60fdb86da80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires access to the memory object associated with the placeholder accessor.  <a href="classcl_1_1sycl_1_1handler.html#ae15174598d704c69779e60fdb86da80e">More...</a><br /></td></tr>
<tr class="separator:ae15174598d704c69779e60fdb86da80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a22feb8adda7a95632c517f5d27fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad5a22feb8adda7a95632c517f5d27fb7">depends_on</a> (<a class="el" href="classcl_1_1sycl_1_1event.html">event</a> Event)</td></tr>
<tr class="memdesc:ad5a22feb8adda7a95632c517f5d27fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers event dependencies on this command group.  <a href="classcl_1_1sycl_1_1handler.html#ad5a22feb8adda7a95632c517f5d27fb7">More...</a><br /></td></tr>
<tr class="separator:ad5a22feb8adda7a95632c517f5d27fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9452505fe71cac26fc00aa9f9438036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac9452505fe71cac26fc00aa9f9438036">depends_on</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;Events)</td></tr>
<tr class="memdesc:ac9452505fe71cac26fc00aa9f9438036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers event dependencies on this command group.  <a href="classcl_1_1sycl_1_1handler.html#ac9452505fe71cac26fc00aa9f9438036">More...</a><br /></td></tr>
<tr class="separator:ac9452505fe71cac26fc00aa9f9438036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f8f35825802c6e026f2dcd343bb093"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93f8f35825802c6e026f2dcd343bb093"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt; <a class="el" href="structcl_1_1sycl_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a>&lt; <a class="el" href="classT.html">T</a> &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a93f8f35825802c6e026f2dcd343bb093">set_arg</a> (int ArgIndex, <a class="el" href="classT.html">T</a> &amp;&amp;Arg)</td></tr>
<tr class="memdesc:a93f8f35825802c6e026f2dcd343bb093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets argument for OpenCL interoperability kernels.  <a href="classcl_1_1sycl_1_1handler.html#a93f8f35825802c6e026f2dcd343bb093">More...</a><br /></td></tr>
<tr class="separator:a93f8f35825802c6e026f2dcd343bb093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7ddca219b45fd8eebbf768f4abff0"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:aebd7ddca219b45fd8eebbf768f4abff0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aebd7ddca219b45fd8eebbf768f4abff0">set_arg</a> (int ArgIndex, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Arg)</td></tr>
<tr class="separator:aebd7ddca219b45fd8eebbf768f4abff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc24e638930b88ddd619cf6759183892"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:abc24e638930b88ddd619cf6759183892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#abc24e638930b88ddd619cf6759183892">set_args</a> (Ts &amp;&amp;... Args)</td></tr>
<tr class="memdesc:abc24e638930b88ddd619cf6759183892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arguments for OpenCL interoperability kernels.  <a href="classcl_1_1sycl_1_1handler.html#abc24e638930b88ddd619cf6759183892">More...</a><br /></td></tr>
<tr class="separator:abc24e638930b88ddd619cf6759183892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725e255af60b5545d5af97e1420856b0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a725e255af60b5545d5af97e1420856b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a725e255af60b5545d5af97e1420856b0">single_task</a> (KernelType <a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)</td></tr>
<tr class="memdesc:a725e255af60b5545d5af97e1420856b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function as a function object type.  <a href="classcl_1_1sycl_1_1handler.html#a725e255af60b5545d5af97e1420856b0">More...</a><br /></td></tr>
<tr class="separator:a725e255af60b5545d5af97e1420856b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534a4723975d044713a59904347f6587"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a534a4723975d044713a59904347f6587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, KernelType <a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)</td></tr>
<tr class="separator:a534a4723975d044713a59904347f6587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbbab5eb387f10ff4b033122df43a90"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:addbbab5eb387f10ff4b033122df43a90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#addbbab5eb387f10ff4b033122df43a90">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, KernelType <a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)</td></tr>
<tr class="separator:addbbab5eb387f10ff4b033122df43a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629a69df01bd0b2886a06e54bb7c72f9"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a629a69df01bd0b2886a06e54bb7c72f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a629a69df01bd0b2886a06e54bb7c72f9">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, KernelType <a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)</td></tr>
<tr class="separator:a629a69df01bd0b2886a06e54bb7c72f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872858163218e46e1e387e77a740db1c"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:a872858163218e46e1e387e77a740db1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a872858163218e46e1e387e77a740db1c">__SYCL_DEPRECATED</a> (&quot;run_on_host_intel() is deprecated, use <a class="el" href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">host_task</a>() <a class="el" href="namespacecl_1_1sycl.html#a44f4f8651c501bc92fd763973a52e9de">instead</a>&quot;) void run_on_host_intel(FuncT Func)</td></tr>
<tr class="memdesc:a872858163218e46e1e387e77a740db1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel on host device.  <a href="classcl_1_1sycl_1_1handler.html#a872858163218e46e1e387e77a740db1c">More...</a><br /></td></tr>
<tr class="separator:a872858163218e46e1e387e77a740db1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82560520adb4928d72d273bc58ab23e"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:ad82560520adb4928d72d273bc58ab23e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt; <a class="el" href="structcl_1_1sycl_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt; <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt; FuncT &gt;, void()&gt;::value||<a class="el" href="structcl_1_1sycl_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt; <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt; FuncT &gt;, void(<a class="el" href="classcl_1_1sycl_1_1interop__handle.html">interop_handle</a>)&gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">host_task</a> (FuncT &amp;&amp;Func)</td></tr>
<tr class="memdesc:ad82560520adb4928d72d273bc58ab23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to the SYCL runtime to invoke <code>Func</code> once.  <a href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">More...</a><br /></td></tr>
<tr class="separator:ad82560520adb4928d72d273bc58ab23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74e7320265eb2b5518a6b7574c0efc4"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:ae74e7320265eb2b5518a6b7574c0efc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae74e7320265eb2b5518a6b7574c0efc4">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:ae74e7320265eb2b5518a6b7574c0efc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offset.  <a href="classcl_1_1sycl_1_1handler.html#ae74e7320265eb2b5518a6b7574c0efc4">More...</a><br /></td></tr>
<tr class="separator:ae74e7320265eb2b5518a6b7574c0efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d12e14c96f7fb5fad4897694aa8e6b"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:af8d12e14c96f7fb5fad4897694aa8e6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af8d12e14c96f7fb5fad4897694aa8e6b">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; ExecutionRange, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:af8d12e14c96f7fb5fad4897694aa8e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>.  <a href="classcl_1_1sycl_1_1handler.html#af8d12e14c96f7fb5fad4897694aa8e6b">More...</a><br /></td></tr>
<tr class="separator:af8d12e14c96f7fb5fad4897694aa8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be5cd0b5253a4043f5b31fabdf0282"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:ad4be5cd0b5253a4043f5b31fabdf0282"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad4be5cd0b5253a4043f5b31fabdf0282">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; Range, Reduction Redu, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:ad4be5cd0b5253a4043f5b31fabdf0282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>.  <a href="classcl_1_1sycl_1_1handler.html#ad4be5cd0b5253a4043f5b31fabdf0282">More...</a><br /></td></tr>
<tr class="separator:ad4be5cd0b5253a4043f5b31fabdf0282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57969f51b93ad25e9236e553160331f"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:ab57969f51b93ad25e9236e553160331f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt; Reduction::has_fast_atomics &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ab57969f51b93ad25e9236e553160331f">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, Reduction Redu, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:ab57969f51b93ad25e9236e553160331f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for()</a> accepting <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> <code>Range</code> and one reduction object.  <a href="classcl_1_1sycl_1_1handler.html#ab57969f51b93ad25e9236e553160331f">More...</a><br /></td></tr>
<tr class="separator:ab57969f51b93ad25e9236e553160331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb1a573c60c8171eb18d29742d8dc79"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:a1bb1a573c60c8171eb18d29742d8dc79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt; Reduction::has_atomic_add_float64 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a1bb1a573c60c8171eb18d29742d8dc79">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, Reduction Redu, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a1bb1a573c60c8171eb18d29742d8dc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for()</a> accepting <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> <code>Range</code> and one reduction object.  <a href="classcl_1_1sycl_1_1handler.html#a1bb1a573c60c8171eb18d29742d8dc79">More...</a><br /></td></tr>
<tr class="separator:a1bb1a573c60c8171eb18d29742d8dc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363b659305da790fe9308469d808ec6"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:ad363b659305da790fe9308469d808ec6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;!Reduction::has_fast_atomics &amp;&amp;!Reduction::has_atomic_add_float64 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad363b659305da790fe9308469d808ec6">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, Reduction Redu, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:ad363b659305da790fe9308469d808ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>.  <a href="classcl_1_1sycl_1_1handler.html#ad363b659305da790fe9308469d808ec6">More...</a><br /></td></tr>
<tr class="separator:ad363b659305da790fe9308469d808ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7583d35f90314ba18fa1d82228d848b2"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:a7583d35f90314ba18fa1d82228d848b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;!Reduction::has_fast_atomics &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a7583d35f90314ba18fa1d82228d848b2">parallel_for_Impl</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, Reduction Redu, KernelType <a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)</td></tr>
<tr class="separator:a7583d35f90314ba18fa1d82228d848b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5fea4c270885d5070acb47b9f12537"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </td></tr>
<tr class="memitem:a1f5fea4c270885d5070acb47b9f12537"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(sizeof...(RestT) &gt;=3 &amp;&amp;<a class="el" href="structcl_1_1sycl_1_1ext_1_1oneapi_1_1detail_1_1AreAllButLastReductions.html">ext::oneapi::detail::AreAllButLastReductions</a>&lt; RestT... &gt;::value)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a1f5fea4c270885d5070acb47b9f12537">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; Range, RestT... Rest)</td></tr>
<tr class="separator:a1f5fea4c270885d5070acb47b9f12537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec30a7bedd1f4c22f79eab95b7332d50"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:aec30a7bedd1f4c22f79eab95b7332d50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aec30a7bedd1f4c22f79eab95b7332d50">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:aec30a7bedd1f4c22f79eab95b7332d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch.  <a href="classcl_1_1sycl_1_1handler.html#aec30a7bedd1f4c22f79eab95b7332d50">More...</a><br /></td></tr>
<tr class="separator:aec30a7bedd1f4c22f79eab95b7332d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df44e513e2361d48bba3415378e53e1"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a3df44e513e2361d48bba3415378e53e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a3df44e513e2361d48bba3415378e53e1">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; WorkGroupSize, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a3df44e513e2361d48bba3415378e53e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch.  <a href="classcl_1_1sycl_1_1handler.html#a3df44e513e2361d48bba3415378e53e1">More...</a><br /></td></tr>
<tr class="separator:a3df44e513e2361d48bba3415378e53e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c00c28d8158a7b69b4c7ad726614f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a20c00c28d8158a7b69b4c7ad726614f4">single_task</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:a20c00c28d8158a7b69b4c7ad726614f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a SYCL kernel.  <a href="classcl_1_1sycl_1_1handler.html#a20c00c28d8158a7b69b4c7ad726614f4">More...</a><br /></td></tr>
<tr class="separator:a20c00c28d8158a7b69b4c7ad726614f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c87396f2312a10cd760c8eb132cf197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a5c87396f2312a10cd760c8eb132cf197">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a5c87396f2312a10cd760c8eb132cf197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4924bfca94f90fc3a158bf6992a24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a8b4924bfca94f90fc3a158bf6992a24c">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a8b4924bfca94f90fc3a158bf6992a24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1286d152a25c9e362b1c6a8ab16f37bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a1286d152a25c9e362b1c6a8ab16f37bc">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="separator:a1286d152a25c9e362b1c6a8ab16f37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671be44200e47260093598af1d201d09"><td class="memTemplParams" colspan="2">template&lt;int Dims&gt; </td></tr>
<tr class="memitem:a671be44200e47260093598af1d201d09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a671be44200e47260093598af1d201d09">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:a671be44200e47260093598af1d201d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classcl_1_1sycl_1_1handler.html#a671be44200e47260093598af1d201d09">More...</a><br /></td></tr>
<tr class="separator:a671be44200e47260093598af1d201d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710a56f0785983f0e4f3943679e0f3a7"><td class="memTemplParams" colspan="2">template&lt;int Dims&gt; </td></tr>
<tr class="memitem:a710a56f0785983f0e4f3943679e0f3a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a710a56f0785983f0e4f3943679e0f3a7">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; NDRange, <a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel)</td></tr>
<tr class="memdesc:a710a56f0785983f0e4f3943679e0f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classcl_1_1sycl_1_1handler.html#a710a56f0785983f0e4f3943679e0f3a7">More...</a><br /></td></tr>
<tr class="separator:a710a56f0785983f0e4f3943679e0f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68d8445ce652ee6f2df4ce661513a81"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:aa68d8445ce652ee6f2df4ce661513a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aa68d8445ce652ee6f2df4ce661513a81">single_task</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:aa68d8445ce652ee6f2df4ce661513a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function.  <a href="classcl_1_1sycl_1_1handler.html#aa68d8445ce652ee6f2df4ce661513a81">More...</a><br /></td></tr>
<tr class="separator:aa68d8445ce652ee6f2df4ce661513a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075114560e9ff5d9436b15b976196ec3"><td class="memTemplParams" colspan="2">template&lt;typename FuncT &gt; </td></tr>
<tr class="memitem:a075114560e9ff5d9436b15b976196ec3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a075114560e9ff5d9436b15b976196ec3">__SYCL_DEPRECATED</a> (&quot;interop_task() is deprecated, use <a class="el" href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">host_task</a>() <a class="el" href="namespacecl_1_1sycl.html#a44f4f8651c501bc92fd763973a52e9de">instead</a>&quot;) void interop_task(FuncT Func)</td></tr>
<tr class="memdesc:a075114560e9ff5d9436b15b976196ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a lambda on the host.  <a href="classcl_1_1sycl_1_1handler.html#a075114560e9ff5d9436b15b976196ec3">More...</a><br /></td></tr>
<tr class="separator:a075114560e9ff5d9436b15b976196ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27950d7477807980f668aec8df17f5d0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a27950d7477807980f668aec8df17f5d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a27950d7477807980f668aec8df17f5d0">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a27950d7477807980f668aec8df17f5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range.  <a href="classcl_1_1sycl_1_1handler.html#a27950d7477807980f668aec8df17f5d0">More...</a><br /></td></tr>
<tr class="separator:a27950d7477807980f668aec8df17f5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf95dcc744853e18aa81de7c44d1462"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a1bf95dcc744853e18aa81de7c44d1462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a1bf95dcc744853e18aa81de7c44d1462">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a1bf95dcc744853e18aa81de7c44d1462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classcl_1_1sycl_1_1handler.html#a1bf95dcc744853e18aa81de7c44d1462">More...</a><br /></td></tr>
<tr class="separator:a1bf95dcc744853e18aa81de7c44d1462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f75fd1a8f3fd3e55228873ae739101"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:af7f75fd1a8f3fd3e55228873ae739101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af7f75fd1a8f3fd3e55228873ae739101">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; NDRange, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:af7f75fd1a8f3fd3e55228873ae739101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines and invokes a SYCL kernel function for the specified range and offsets.  <a href="classcl_1_1sycl_1_1handler.html#af7f75fd1a8f3fd3e55228873ae739101">More...</a><br /></td></tr>
<tr class="separator:af7f75fd1a8f3fd3e55228873ae739101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030fa979a9d4dc26c340cdd6028f051a"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a030fa979a9d4dc26c340cdd6028f051a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a030fa979a9d4dc26c340cdd6028f051a">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a030fa979a9d4dc26c340cdd6028f051a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel.  <a href="classcl_1_1sycl_1_1handler.html#a030fa979a9d4dc26c340cdd6028f051a">More...</a><br /></td></tr>
<tr class="separator:a030fa979a9d4dc26c340cdd6028f051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959728223dda817d3593c6e3e104b0ff"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a959728223dda817d3593c6e3e104b0ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a959728223dda817d3593c6e3e104b0ff">parallel_for_work_group</a> (<a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a> Kernel, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkGroups, <a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; WorkGroupSize, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>))</td></tr>
<tr class="memdesc:a959728223dda817d3593c6e3e104b0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical kernel invocation method of a kernel.  <a href="classcl_1_1sycl_1_1handler.html#a959728223dda817d3593c6e3e104b0ff">More...</a><br /></td></tr>
<tr class="separator:a959728223dda817d3593c6e3e104b0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ac55c7343044b1280e3f650842b2fa"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:af1ac55c7343044b1280e3f650842b2fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af1ac55c7343044b1280e3f650842b2fa">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Src, std::shared_ptr&lt; T_Dst &gt; Dst)</td></tr>
<tr class="memdesc:af1ac55c7343044b1280e3f650842b2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src into the memory pointed by Dst.  <a href="classcl_1_1sycl_1_1handler.html#af1ac55c7343044b1280e3f650842b2fa">More...</a><br /></td></tr>
<tr class="separator:af1ac55c7343044b1280e3f650842b2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f29616b3b3476b8a936320825b6d143"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a5f29616b3b3476b8a936320825b6d143"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a5f29616b3b3476b8a936320825b6d143">copy</a> (std::shared_ptr&lt; T_Src &gt; Src, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Dst)</td></tr>
<tr class="memdesc:a5f29616b3b3476b8a936320825b6d143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory pointed by Src into the memory object accessed by Dst.  <a href="classcl_1_1sycl_1_1handler.html#a5f29616b3b3476b8a936320825b6d143">More...</a><br /></td></tr>
<tr class="separator:a5f29616b3b3476b8a936320825b6d143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ef5dbc3cd1700248581e59a1225b21"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:af3ef5dbc3cd1700248581e59a1225b21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#af3ef5dbc3cd1700248581e59a1225b21">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Src, T_Dst *Dst)</td></tr>
<tr class="memdesc:af3ef5dbc3cd1700248581e59a1225b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src into the memory pointed by Dst.  <a href="classcl_1_1sycl_1_1handler.html#af3ef5dbc3cd1700248581e59a1225b21">More...</a><br /></td></tr>
<tr class="separator:af3ef5dbc3cd1700248581e59a1225b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d402737cbdce196b0278d6b3e6de84"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a29d402737cbdce196b0278d6b3e6de84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a29d402737cbdce196b0278d6b3e6de84">copy</a> (const T_Src *Src, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Dst)</td></tr>
<tr class="memdesc:a29d402737cbdce196b0278d6b3e6de84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory pointed by Src into the memory object accessed by Dst.  <a href="classcl_1_1sycl_1_1handler.html#a29d402737cbdce196b0278d6b3e6de84">More...</a><br /></td></tr>
<tr class="separator:a29d402737cbdce196b0278d6b3e6de84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfccda42f0d1957d65c2ca1e9e2d5097"><td class="memTemplParams" colspan="2">template&lt;typename T_Src , int Dims_Src, access::mode AccessMode_Src, access::target AccessTarget_Src, typename T_Dst , int Dims_Dst, access::mode AccessMode_Dst, access::target AccessTarget_Dst, access::placeholder IsPlaceholder_Src = access::placeholder::false_t, access::placeholder IsPlaceholder_Dst = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:adfccda42f0d1957d65c2ca1e9e2d5097"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#adfccda42f0d1957d65c2ca1e9e2d5097">copy</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims_Src, AccessMode_Src, AccessTarget_Src, IsPlaceholder_Src &gt; Src, <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims_Dst, AccessMode_Dst, AccessTarget_Dst, IsPlaceholder_Dst &gt; Dst)</td></tr>
<tr class="memdesc:adfccda42f0d1957d65c2ca1e9e2d5097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of memory object accessed by Src to the memory object accessed by Dst.  <a href="classcl_1_1sycl_1_1handler.html#adfccda42f0d1957d65c2ca1e9e2d5097">More...</a><br /></td></tr>
<tr class="separator:adfccda42f0d1957d65c2ca1e9e2d5097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0250574969ee1bf7743596662c847e"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </td></tr>
<tr class="memitem:a2e0250574969ee1bf7743596662c847e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a2e0250574969ee1bf7743596662c847e">update_host</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; <a class="el" href="classT.html">T</a>, Dims, AccessMode, AccessTarget, IsPlaceholder &gt; Acc)</td></tr>
<tr class="memdesc:a2e0250574969ee1bf7743596662c847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides guarantees that the memory object accessed via Acc is updated on the host after command group object execution is complete.  <a href="classcl_1_1sycl_1_1handler.html#a2e0250574969ee1bf7743596662c847e">More...</a><br /></td></tr>
<tr class="separator:a2e0250574969ee1bf7743596662c847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2211d108eb3b208b1a2b73da1161e79b"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t, typename PropertyListT  = property_list&gt; </td></tr>
<tr class="memitem:a2211d108eb3b208b1a2b73da1161e79b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a2211d108eb3b208b1a2b73da1161e79b">fill</a> (<a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; <a class="el" href="classT.html">T</a>, Dims, AccessMode, AccessTarget, IsPlaceholder, PropertyListT &gt; Dst, const <a class="el" href="classT.html">T</a> &amp;Pattern)</td></tr>
<tr class="memdesc:a2211d108eb3b208b1a2b73da1161e79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills memory pointed by accessor with the pattern given.  <a href="classcl_1_1sycl_1_1handler.html#a2211d108eb3b208b1a2b73da1161e79b">More...</a><br /></td></tr>
<tr class="separator:a2211d108eb3b208b1a2b73da1161e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77b0cbec35d932eba1bd1a022673d21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae77b0cbec35d932eba1bd1a022673d21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae77b0cbec35d932eba1bd1a022673d21">fill</a> (void *Ptr, const <a class="el" href="classT.html">T</a> &amp;Pattern, size_t Count)</td></tr>
<tr class="memdesc:ae77b0cbec35d932eba1bd1a022673d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classcl_1_1sycl_1_1handler.html#ae77b0cbec35d932eba1bd1a022673d21">More...</a><br /></td></tr>
<tr class="separator:ae77b0cbec35d932eba1bd1a022673d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb8db7997ed35447d3850c88986839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a9bcb8db7997ed35447d3850c88986839">ext_oneapi_barrier</a> ()</td></tr>
<tr class="memdesc:a9bcb8db7997ed35447d3850c88986839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classcl_1_1sycl_1_1handler.html#a9bcb8db7997ed35447d3850c88986839">More...</a><br /></td></tr>
<tr class="separator:a9bcb8db7997ed35447d3850c88986839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa263b98900a3e67d195b5bc591c50ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aa263b98900a3e67d195b5bc591c50ef3">barrier</a> ()</td></tr>
<tr class="memdesc:aa263b98900a3e67d195b5bc591c50ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classcl_1_1sycl_1_1handler.html#aa263b98900a3e67d195b5bc591c50ef3">More...</a><br /></td></tr>
<tr class="separator:aa263b98900a3e67d195b5bc591c50ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907da4602b971c8c03c31efddc6a5c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a907da4602b971c8c03c31efddc6a5c68">ext_oneapi_barrier</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList)</td></tr>
<tr class="memdesc:a907da4602b971c8c03c31efddc6a5c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classcl_1_1sycl_1_1handler.html#a907da4602b971c8c03c31efddc6a5c68">More...</a><br /></td></tr>
<tr class="separator:a907da4602b971c8c03c31efddc6a5c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47e84a26e37471055033a37e7fd285f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ac47e84a26e37471055033a37e7fd285f">barrier</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList)</td></tr>
<tr class="memdesc:ac47e84a26e37471055033a37e7fd285f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classcl_1_1sycl_1_1handler.html#ac47e84a26e37471055033a37e7fd285f">More...</a><br /></td></tr>
<tr class="separator:ac47e84a26e37471055033a37e7fd285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110067774f86c17741d3dbcaba51de0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a110067774f86c17741d3dbcaba51de0c">memcpy</a> (void *Dest, const void *Src, size_t Count)</td></tr>
<tr class="memdesc:a110067774f86c17741d3dbcaba51de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1handler.html#a110067774f86c17741d3dbcaba51de0c">More...</a><br /></td></tr>
<tr class="separator:a110067774f86c17741d3dbcaba51de0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852354ad3880f3ffdd5c1c9884bdc8f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a852354ad3880f3ffdd5c1c9884bdc8f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a852354ad3880f3ffdd5c1c9884bdc8f3">copy</a> (const <a class="el" href="classT.html">T</a> *Src, <a class="el" href="classT.html">T</a> *Dest, size_t Count)</td></tr>
<tr class="memdesc:a852354ad3880f3ffdd5c1c9884bdc8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1handler.html#a852354ad3880f3ffdd5c1c9884bdc8f3">More...</a><br /></td></tr>
<tr class="separator:a852354ad3880f3ffdd5c1c9884bdc8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc9b24930b0343613e9746734ec540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#abacc9b24930b0343613e9746734ec540">memset</a> (void *Dest, int Value, size_t Count)</td></tr>
<tr class="memdesc:abacc9b24930b0343613e9746734ec540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classcl_1_1sycl_1_1handler.html#abacc9b24930b0343613e9746734ec540">More...</a><br /></td></tr>
<tr class="separator:abacc9b24930b0343613e9746734ec540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e350f915111b129b22eba2989382863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a2e350f915111b129b22eba2989382863">prefetch</a> (const void *Ptr, size_t Count)</td></tr>
<tr class="memdesc:a2e350f915111b129b22eba2989382863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classcl_1_1sycl_1_1handler.html#a2e350f915111b129b22eba2989382863">More...</a><br /></td></tr>
<tr class="separator:a2e350f915111b129b22eba2989382863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3927ea447ace567f102c608d8b358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae7f3927ea447ace567f102c608d8b358">mem_advise</a> (const void *Ptr, size_t Length, int Advice)</td></tr>
<tr class="memdesc:ae7f3927ea447ace567f102c608d8b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classcl_1_1sycl_1_1handler.html#ae7f3927ea447ace567f102c608d8b358">More...</a><br /></td></tr>
<tr class="separator:ae7f3927ea447ace567f102c608d8b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad7cdb542aa2a076f6714e683ee827d4e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad7cdb542aa2a076f6714e683ee827d4e">detail::queue_impl</a></td></tr>
<tr class="separator:ad7cdb542aa2a076f6714e683ee827d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe93ea8d613a9b7224780404781c279"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder, typename PropertyListT &gt; </td></tr>
<tr class="memitem:a4fe93ea8d613a9b7224780404781c279"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a4fe93ea8d613a9b7224780404781c279">accessor</a></td></tr>
<tr class="separator:a4fe93ea8d613a9b7224780404781c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb498cc698f57626f0746b3365a880e"><td class="memTemplParams" colspan="2">template&lt;typename DataT , int Dimensions, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:adbb498cc698f57626f0746b3365a880e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#adbb498cc698f57626f0746b3365a880e">detail::image_accessor</a></td></tr>
<tr class="separator:adbb498cc698f57626f0746b3365a880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cdd83c821525ef93cdeb8332fd7de8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ad6cdd83c821525ef93cdeb8332fd7de8">stream</a></td></tr>
<tr class="separator:ad6cdd83c821525ef93cdeb8332fd7de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca0ca308f0eac9343990d58cd54374"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a5fca0ca308f0eac9343990d58cd54374">detail::stream_impl</a></td></tr>
<tr class="separator:a5fca0ca308f0eac9343990d58cd54374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dcba71eada00c9cca712c46e86ceb4"><td class="memTemplParams" colspan="2">template&lt;typename T , class BinaryOperation , int Dims, bool IsUSM, access::placeholder IsPlaceholder&gt; </td></tr>
<tr class="memitem:a57dcba71eada00c9cca712c46e86ceb4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#a57dcba71eada00c9cca712c46e86ceb4">ext::oneapi::detail::reduction_impl</a></td></tr>
<tr class="separator:a57dcba71eada00c9cca712c46e86ceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb994ca2bdbf38e10d7742a7e97f8f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aaabb994ca2bdbf38e10d7742a7e97f8f">::MockHandler</a></td></tr>
<tr class="separator:aaabb994ca2bdbf38e10d7742a7e97f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46bc683d37b6005434a0bceb5389f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1device.html">device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#aa46bc683d37b6005434a0bceb5389f8c">detail::getDeviceFromHandler</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;)</td></tr>
<tr class="separator:aa46bc683d37b6005434a0bceb5389f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548b3b019349fdb34b6be5d88d2165a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1handler.html#ae548b3b019349fdb34b6be5d88d2165a">detail::associateWithHandler</a> (<a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;, <a class="el" href="classcl_1_1sycl_1_1detail_1_1AccessorBaseHost.html">detail::AccessorBaseHost</a> *, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598">access::target</a>)</td></tr>
<tr class="separator:ae548b3b019349fdb34b6be5d88d2165a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Command group handler class. </p>
<p>Objects of the handler class collect information about command group, such as kernel, requirements to the memory, arguments for the kernel.</p>
<div class="fragment"><div class="line"><a class="code" href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">sycl::queue::submit</a>([](handler &amp;CGH){</div>
<div class="line">  CGH.require(Accessor1);   <span class="comment">// Adds a requirement to the memory object.</span></div>
<div class="line">  CGH.setArg(0, Accessor2); <span class="comment">// Registers accessor given as an argument to</span></div>
<div class="line">                            <span class="comment">// the kernel + adds a requirement to the memory</span></div>
<div class="line">                            <span class="comment">// object.</span></div>
<div class="line">  CGH.setArg(1, N);         <span class="comment">// Registers value given as an argument to the</span></div>
<div class="line">                            <span class="comment">// kernel.</span></div>
<div class="line">  <span class="comment">// The following registers KernelFunctor to be a kernel that will be</span></div>
<div class="line">  <span class="comment">// executed in case of queue is bound to the host device, Kernel - for</span></div>
<div class="line">  <span class="comment">// an OpenCL device. This function clearly indicates that command group</span></div>
<div class="line">  <span class="comment">// represents kernel execution.</span></div>
<div class="line">  CGH.parallel_for(KernelFunctor, Kernel);</div>
<div class="line"> });</div>
</div><!-- fragment --><p>The command group can represent absolutely different operations. Depending on the operation we need to store different data. But, in most cases, it's impossible to say what kind of operation we need to perform until the very end. So, handler class contains all fields simultaneously, then during "finalization" it constructs CG object, that represents specific operation, passing fields that are required only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcl_1_1sycl_1_1queue.html" title="Encapsulates a single SYCL queue which schedules kernels on a SYCL device.">queue</a> </dd>
<dd>
program </dd>
<dd>
<a class="el" href="classcl_1_1sycl_1_1kernel.html" title="Provides an abstraction of a SYCL kernel.">kernel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l00361">361</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6d1ff6744816686a4abffc42f4276610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1ff6744816686a4abffc42f4276610">&#9670;&nbsp;</a></span>is_same_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1handler.html#a6d1ff6744816686a4abffc42f4276610">cl::sycl::handler::is_same_type</a> =  std::is_same&lt;<a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">remove_cv_ref_t</a>&lt;U&gt;, <a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">remove_cv_ref_t</a>&lt;<a class="el" href="classT.html">T</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01386">1386</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aaefeb39ac45bff2a7e4e40308ffc2ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefeb39ac45bff2a7e4e40308ffc2ffc">&#9670;&nbsp;</a></span>remove_cv_ref_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1handler.html#aaefeb39ac45bff2a7e4e40308ffc2ffc">cl::sycl::handler::remove_cv_ref_t</a> =  typename <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a374ddfe6f1bd73a40de7fc63f3870800">detail::remove_cv_t</a>&lt;<a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt;<a class="el" href="classT.html">T</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01383">1383</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aab6e38c9f1c74a6353d9328a2a6950d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6e38c9f1c74a6353d9328a2a6950d6">&#9670;&nbsp;</a></span>handler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87d56a475a807c51c9f750bb6c8ee15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d56a475a807c51c9f750bb6c8ee15e">&#9670;&nbsp;</a></span>handler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a075114560e9ff5d9436b15b976196ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075114560e9ff5d9436b15b976196ec3">&#9670;&nbsp;</a></span>__SYCL_DEPRECATED() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::__SYCL_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;interop_task() is&#160;</td>
          <td class="paramname"><em>deprecated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">use <a class="el" href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">host_task</a>() <a class="el" href="namespacecl_1_1sycl.html#a44f4f8651c501bc92fd763973a52e9de">instead</a>&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a lambda on the host. </p>
<p>Dependencies are satisfied on the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Func</td><td>is a lambda that is executed on the host </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02070">2070</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a872858163218e46e1e387e77a740db1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872858163218e46e1e387e77a740db1c">&#9670;&nbsp;</a></span>__SYCL_DEPRECATED() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::handler::__SYCL_DEPRECATED </td>
          <td>(</td>
          <td class="paramtype">&quot;run_on_host_intel() is&#160;</td>
          <td class="paramname"><em>deprecated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">use <a class="el" href="classcl_1_1sycl_1_1handler.html#ad82560520adb4928d72d273bc58ab23e">host_task</a>() <a class="el" href="namespacecl_1_1sycl.html#a44f4f8651c501bc92fd763973a52e9de">instead</a>&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel on host device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Func</td><td>is a SYCL kernel function defined by lambda function or a named function object type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01489">1489</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="aa263b98900a3e67d195b5bc591c50ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa263b98900a3e67d195b5bc591c50ef3">&#9670;&nbsp;</a></span>barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02549">2549</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ac47e84a26e37471055033a37e7fd285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47e84a26e37471055033a37e7fd285f">&#9670;&nbsp;</a></span>barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>WaitList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then the barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00709">709</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02540">ext_oneapi_barrier()</a>.</p>

</div>
</div>
<a id="af1ac55c7343044b1280e3f650842b2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ac55c7343044b1280e3f650842b2fa">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T_Dst &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src into the memory pointed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a smart pointer to destination memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02284">2284</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01430">cl::sycl::ext::oneapi::detail::reduSaveFinalResultToUserMem()</a>, and <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01955">cl::sycl::ext::oneapi::detail::reduSaveFinalResultToUserMemHelper()</a>.</p>

</div>
</div>
<a id="af3ef5dbc3cd1700248581e59a1225b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ef5dbc3cd1700248581e59a1225b21">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_Dst *&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src into the memory pointed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a pointer to destination memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02333">2333</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="adfccda42f0d1957d65c2ca1e9e2d5097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfccda42f0d1957d65c2ca1e9e2d5097">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , int Dims_Src, access::mode AccessMode_Src, access::target AccessTarget_Src, typename T_Dst , int Dims_Dst, access::mode AccessMode_Dst, access::target AccessTarget_Dst, access::placeholder IsPlaceholder_Src = access::placeholder::false_t, access::placeholder IsPlaceholder_Dst = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Src, Dims_Src, AccessMode_Src, AccessTarget_Src, IsPlaceholder_Src &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims_Dst, AccessMode_Dst, AccessTarget_Dst, IsPlaceholder_Dst &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory object accessed by Src to the memory object accessed by Dst. </p>
<p>Dst must have at least as many bytes as the range accessed by Src.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a source SYCL accessor. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02413">2413</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor_8hpp_source.html#l01686">cl::sycl::accessor&lt; DataT, Dimensions, AccessMode, AccessTarget, IsPlaceholder, PropertyListT &gt;::get_size()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a852354ad3880f3ffdd5c1c9884bdc8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852354ad3880f3ffdd5c1c9884bdc8f3">&#9670;&nbsp;</a></span>copy() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type <a class="el" href="classT.html">T</a> to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02588">2588</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacecl_1_1sycl_1_1detail.html#ade8963b9bb134c88a5801797d4f6afd9">cl::sycl::detail::memcpy()</a>.</p>

</div>
</div>
<a id="a29d402737cbdce196b0278d6b3e6de84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d402737cbdce196b0278d6b3e6de84">&#9670;&nbsp;</a></span>copy() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype">const T_Src *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory pointed by Src into the memory object accessed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a pointer to source memory. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02372">2372</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a5f29616b3b3476b8a936320825b6d143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f29616b3b3476b8a936320825b6d143">&#9670;&nbsp;</a></span>copy() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_Src , typename T_Dst , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::copy </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T_Src &gt;&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T_Dst, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of memory pointed by Src into the memory object accessed by Dst. </p>
<p>Source must have at least as many bytes as the range accessed by Dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Src</td><td>is a smart pointer to source memory. </td></tr>
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02309">2309</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ac9452505fe71cac26fc00aa9f9438036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9452505fe71cac26fc00aa9f9438036">&#9670;&nbsp;</a></span>depends_on() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers event dependencies on this command group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Events</td><td>is a vector of valid SYCL events to wait on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00805">805</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>, <a class="el" href="namespacecl_1_1sycl.html#a96f353c1d5d9d8192ef124ea43b68dc8afedb2d84cafe20862cb4399751a8a7e3">cl::sycl::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00121">cl::sycl::make_error_code()</a>.</p>

</div>
</div>
<a id="ad5a22feb8adda7a95632c517f5d27fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a22feb8adda7a95632c517f5d27fb7">&#9670;&nbsp;</a></span>depends_on() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::depends_on </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>Event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers event dependencies on this command group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Event</td><td>is a valid SYCL event to wait on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00796">796</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>, <a class="el" href="namespacecl_1_1sycl.html#a96f353c1d5d9d8192ef124ea43b68dc8afedb2d84cafe20862cb4399751a8a7e3">cl::sycl::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00121">cl::sycl::make_error_code()</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l00451">cl::sycl::queue::fill()</a>, <a class="el" href="queue_8hpp_source.html#l00916">cl::sycl::queue::parallel_for()</a>, <a class="el" href="queue_8hpp_source.html#l00660">cl::sycl::queue::prefetch()</a>, <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01955">cl::sycl::ext::oneapi::detail::reduSaveFinalResultToUserMemHelper()</a>, and <a class="el" href="queue_8hpp_source.html#l00711">cl::sycl::queue::single_task()</a>.</p>

</div>
</div>
<a id="a9bcb8db7997ed35447d3850c88986839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcb8db7997ed35447d3850c88986839">&#9670;&nbsp;</a></span>ext_oneapi_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::ext_oneapi_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02540">2540</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="handler_8cpp_source.html#l00709">barrier()</a>, and <a class="el" href="queue_8hpp_source.html#l00333">cl::sycl::queue::ext_oneapi_submit_barrier()</a>.</p>

</div>
</div>
<a id="a907da4602b971c8c03c31efddc6a5c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907da4602b971c8c03c31efddc6a5c68">&#9670;&nbsp;</a></span>ext_oneapi_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::ext_oneapi_barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>WaitList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then the barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00699">699</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00163">cl::sycl::detail::CG::BarrierWaitlist</a>.</p>

</div>
</div>
<a id="a2211d108eb3b208b1a2b73da1161e79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2211d108eb3b208b1a2b73da1161e79b">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t, typename PropertyListT  = property_list&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; <a class="el" href="classT.html">T</a>, Dims, AccessMode, AccessTarget, IsPlaceholder, PropertyListT &gt;&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills memory pointed by accessor with the pattern given. </p>
<p>If the operation is submitted to queue associated with OpenCL device and accessor points to one dimensional memory object then use special type for filling. Otherwise fill using regular kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Dst</td><td>is a destination SYCL accessor. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is a value to be used to fill the memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02488">2488</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor_8hpp_source.html#l01693">cl::sycl::accessor&lt; DataT, Dimensions, AccessMode, AccessTarget, IsPlaceholder, PropertyListT &gt;::get_range()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l00438">cl::sycl::queue::fill()</a>.</p>

</div>
</div>
<a id="ae77b0cbec35d932eba1bd1a022673d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77b0cbec35d932eba1bd1a022673d21">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. <a class="el" href="classT.html">T</a> should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02527">2527</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad82560520adb4928d72d273bc58ab23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82560520adb4928d72d273bc58ab23e">&#9670;&nbsp;</a></span>host_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FuncT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt; <a class="el" href="structcl_1_1sycl_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt;<a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt;FuncT&gt;, void()&gt;::value || <a class="el" href="structcl_1_1sycl_1_1detail_1_1check__fn__signature.html">detail::check_fn_signature</a>&lt;<a class="el" href="namespacecl_1_1sycl_1_1detail.html#a0a16b917d121cb9ae8f53c93569594d9">detail::remove_reference_t</a>&lt;FuncT&gt;, void(<a class="el" href="classcl_1_1sycl_1_1interop__handle.html">interop_handle</a>)&gt;::value&gt; cl::sycl::handler::host_task </td>
          <td>(</td>
          <td class="paramtype">FuncT &amp;&amp;&#160;</td>
          <td class="paramname"><em>Func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a command to the SYCL runtime to invoke <code>Func</code> once. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01509">1509</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae7f3927ea447ace567f102c608d8b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f3927ea447ace567f102c608d8b358">&#9670;&nbsp;</a></span>mem_advise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00751">751</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00172">cl::sycl::detail::CG::AdviseUSM</a>, <a class="el" href="cg_8hpp_source.html#l00113">cl::sycl::detail::convertToExtendedMembers()</a>, <a class="el" href="namespacecl_1_1sycl_1_1detail.html#aae0b2cf58081e898ab5b4bc4fe0abb81a5403135845d4b93afdfe8dc859c554ef">cl::sycl::detail::HANDLER_MEM_ADVICE</a>, and <a class="el" href="global__handler_8cpp_source.html#l00035">cl::sycl::detail::GlobalHandler::instance()</a>.</p>

</div>
</div>
<a id="a110067774f86c17741d3dbcaba51de0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110067774f86c17741d3dbcaba51de0c">&#9670;&nbsp;</a></span>memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00728">728</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00167">cl::sycl::detail::CG::CopyUSM</a>.</p>

</div>
</div>
<a id="abacc9b24930b0343613e9746734ec540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc9b24930b0343613e9746734ec540">&#9670;&nbsp;</a></span>memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Dest</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Dest</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00736">736</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00168">cl::sycl::detail::CG::FillUSM</a>.</p>

</div>
</div>
<a id="a386591bd9bd6a952393ce61d8d48ce5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386591bd9bd6a952393ce61d8d48ce5c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a>&amp; cl::sycl::handler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a234cd372ff6a74e0721838d17c4adf8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234cd372ff6a74e0721838d17c4adf8b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a>&amp; cl::sycl::handler::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7f75fd1a8f3fd3e55228873ae739101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f75fd1a8f3fd3e55228873ae739101">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NDRange</td><td>is a ND-range defining global and local sizes as well as offset. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02162">2162</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a27950d7477807980f668aec8df17f5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27950d7477807980f668aec8df17f5d0">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02086">2086</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a1bf95dcc744853e18aa81de7c44d1462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf95dcc744853e18aa81de7c44d1462">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02124">2124</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="af8d12e14c96f7fb5fad4897694aa8e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d12e14c96f7fb5fad4897694aa8e6b">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>ExecutionRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>. </p>
<p>The SYCL kernel function is defined as a lambda function or a named function object type and given an id or item for indexing in the indexing space defined by range. If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExecutionRange</td><td>is a ND-range defining global and local sizes as well as offset. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01569">1569</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a710a56f0785983f0e4f3943679e0f3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710a56f0785983f0e4f3943679e0f3a7">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NDRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<p>The SYCL kernel function is defined as SYCL kernel object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NDRange</td><td>is a ND-range defining global and local sizes as well as offset. </td></tr>
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02023">2023</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ab57969f51b93ad25e9236e553160331f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57969f51b93ad25e9236e553160331f">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;Reduction::has_fast_atomics&gt; cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for()</a> accepting <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> <code>Range</code> and one reduction object. </p>
<p>This version uses fast sycl::atomic operations to update reduction variable at the end of each work-group work. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01653">1653</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a1bb1a573c60c8171eb18d29742d8dc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb1a573c60c8171eb18d29742d8dc79">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;Reduction::has_atomic_add_float64&gt; cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for()</a> accepting <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> <code>Range</code> and one reduction object. </p>
<p>This version is a specialization for the add operator. It performs runtime checks for device aspect "atomic64"; if found, fast <a class="el" href="classcl_1_1sycl_1_1atomic__ref.html">sycl::atomic_ref</a> operations are used to update the reduction at the end of each work-group work. Otherwise the default implementation is used. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01687">1687</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="accessor_8cpp_source.html#l00015">cl::sycl::detail::getDeviceFromHandler()</a>, and <a class="el" href="device_8cpp_source.html#l00163">cl::sycl::device::has()</a>.</p>

</div>
</div>
<a id="ad363b659305da790fe9308469d808ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad363b659305da790fe9308469d808ec6">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;!Reduction::has_fast_atomics &amp;&amp; !Reduction::has_atomic_add_float64&gt; cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>. </p>
<p>Performs reduction operation specified in <code>Redu</code>.</p>
<p>The SYCL kernel function is defined as a lambda function or a named function object type and given an id or item for indexing in the indexing space defined by <code>Range</code>. If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<p>TODO: Support HOST. The kernels called by this <a class="el" href="classcl_1_1sycl_1_1handler.html#a534a4723975d044713a59904347f6587">parallel_for()</a> may use some functionality that is not yet supported on HOST such as: <a class="el" href="classcl_1_1sycl_1_1handler.html#aa263b98900a3e67d195b5bc591c50ef3" title="Prevents any commands submitted afterward to this queue from executing until all commands previously ...">barrier()</a>, and ext::oneapi::reduce() that also may be used in more optimized implementations waiting for their turn of code-review. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01729">1729</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a1f5fea4c270885d5070acb47b9f12537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5fea4c270885d5070acb47b9f12537">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, int Dims, typename... RestT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; (sizeof...(RestT) &gt;= 3 &amp;&amp; <a class="el" href="structcl_1_1sycl_1_1ext_1_1oneapi_1_1detail_1_1AreAllButLastReductions.html">ext::oneapi::detail::AreAllButLastReductions</a>&lt;RestT...&gt;::value)&gt; cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RestT...&#160;</td>
          <td class="paramname"><em>Rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01851">1851</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="tuple_8hpp_source.html#l00199">std::get()</a>, <a class="el" href="nd__range_8hpp_source.html#l00044">cl::sycl::nd_range&lt; dimensions &gt;::get_group_range()</a>, <a class="el" href="nd__range_8hpp_source.html#l00042">cl::sycl::nd_range&lt; dimensions &gt;::get_local_range()</a>, <a class="el" href="pi_8h_source.html#l00105">PI_INVALID_WORK_GROUP_SIZE</a>, <a class="el" href="namespacecl_1_1sycl_1_1ext_1_1oneapi_1_1detail.html#aa9646851619b0962872dfd49da602047">cl::sycl::ext::oneapi::detail::reduGetMaxWGSize()</a>, <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l02000">cl::sycl::ext::oneapi::detail::reduGetMemPerWorkItem()</a>, <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01978">cl::sycl::ext::oneapi::detail::reduSaveFinalResultToUserMem()</a>, and <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l02009">cl::sycl::ext::oneapi::detail::tuple_select_elements()</a>.</p>

</div>
</div>
<a id="a5c87396f2312a10cd760c8eb132cf197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c87396f2312a10cd760c8eb132cf197">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01981">1981</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a534a4723975d044713a59904347f6587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534a4723975d044713a59904347f6587">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelType&#160;</td>
          <td class="paramname"><em>KernelFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01459">1459</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01300">cl::sycl::ext::oneapi::detail::reduAuxCGFuncImpl()</a>, <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l00848">cl::sycl::ext::oneapi::detail::reduCGFuncImpl()</a>, and <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01787">cl::sycl::ext::oneapi::detail::reduCGFuncImplAtomic64()</a>.</p>

</div>
</div>
<a id="a8b4924bfca94f90fc3a158bf6992a24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4924bfca94f90fc3a158bf6992a24c">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01985">1985</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="addbbab5eb387f10ff4b033122df43a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbbab5eb387f10ff4b033122df43a90">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelType&#160;</td>
          <td class="paramname"><em>KernelFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01468">1468</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a1286d152a25c9e362b1c6a8ab16f37bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1286d152a25c9e362b1c6a8ab16f37bc">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01989">1989</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a629a69df01bd0b2886a06e54bb7c72f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629a69df01bd0b2886a06e54bb7c72f9">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelType&#160;</td>
          <td class="paramname"><em>KernelFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01477">1477</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae74e7320265eb2b5518a6b7574c0efc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74e7320265eb2b5518a6b7574c0efc4">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offset. </p>
<p>The SYCL kernel function is defined as a lambda function or a named function object type and given an id or item for indexing in the indexing space defined by range. If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01537">1537</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a671be44200e47260093598af1d201d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671be44200e47260093598af1d201d09">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified range and offsets. </p>
<p>The SYCL kernel function is defined as SYCL kernel object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range defining indexing space. </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>is an offset to be applied to each work item index. </td></tr>
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02003">2003</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ad4be5cd0b5253a4043f5b31fabdf0282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4be5cd0b5253a4043f5b31fabdf0282">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function for the specified <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a>. </p>
<p>The SYCL kernel function is defined as a lambda function or a named function object type and given an id for indexing in the indexing space defined by range <code>Range</code>. The parameter <code>Redu</code> contains the object creted by the <a class="el" href="namespacecl_1_1sycl.html#ac1cd6dca1b34dab5fc370b3cd509d6ff" title="Constructs a reduction object using the given buffer Var, handler CGH, reduction operation Combiner,...">reduction()</a> function and defines the type and operation used in the corresponding argument of 'reducer' type passed to lambda/functor function. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01602">1602</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacecl_1_1sycl_1_1ext_1_1oneapi_1_1detail.html#a51b87bd8fd203fd192bc57a48fe116ee">cl::sycl::ext::oneapi::detail::reduGetMaxNumConcurrentWorkGroups()</a>, and <a class="el" href="namespacecl_1_1sycl_1_1ext_1_1oneapi_1_1detail.html#aa9646851619b0962872dfd49da602047">cl::sycl::ext::oneapi::detail::reduGetMaxWGSize()</a>.</p>

</div>
</div>
<a id="a7583d35f90314ba18fa1d82228d848b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7583d35f90314ba18fa1d82228d848b2">&#9670;&nbsp;</a></span>parallel_for_Impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;!Reduction::has_fast_atomics&gt; cl::sycl::handler::parallel_for_Impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>Range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelType&#160;</td>
          <td class="paramname"><em>KernelFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01738">1738</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="nd__range_8hpp_source.html#l00044">cl::sycl::nd_range&lt; dimensions &gt;::get_group_range()</a>, <a class="el" href="nd__range_8hpp_source.html#l00042">cl::sycl::nd_range&lt; dimensions &gt;::get_local_range()</a>, <a class="el" href="pi_8h_source.html#l00105">PI_INVALID_WORK_GROUP_SIZE</a>, and <a class="el" href="namespacecl_1_1sycl_1_1ext_1_1oneapi_1_1detail.html#aa9646851619b0962872dfd49da602047">cl::sycl::ext::oneapi::detail::reduGetMaxWGSize()</a>.</p>

</div>
</div>
<a id="a030fa979a9d4dc26c340cdd6028f051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030fa979a9d4dc26c340cdd6028f051a">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel. </p>
<p>This version of <code>parallel_for_work_group</code> takes two parameters representing the same kernel. The first one - <code>Kernel</code> - is a compiled form of the second one - <code>kernelFunc</code>, which is the source form of the kernel. The same source kernel can be compiled multiple times yielding multiple kernel class objects accessible via the <code>program</code> class interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a compiled SYCL kernel. </td></tr>
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02204">2204</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a959728223dda817d3593c6e3e104b0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959728223dda817d3593c6e3e104b0ff">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkGroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel. </p>
<p>This version of <code>parallel_for_work_group</code> takes two parameters representing the same kernel. The first one - <code>Kernel</code> - is a compiled form of the second one - <code>kernelFunc</code>, which is the source form of the kernel. The same source kernel can be compiled multiple times yielding multiple kernel class objects accessible via the <code>program</code> class interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a compiled SYCL kernel. </td></tr>
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">WorkGroupSize</td><td>is a range describing the size of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02243">2243</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="aec30a7bedd1f4c22f79eab95b7332d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec30a7bedd1f4c22f79eab95b7332d50">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch. </p>
<p>Lambda may contain multiple calls to parallel_for_work_item(...) methods representing the execution on each work-item. Launches NumWorkGroups work-groups of runtime-defined size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01907">1907</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a3df44e513e2361d48bba3415378e53e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df44e513e2361d48bba3415378e53e1">&#9670;&nbsp;</a></span>parallel_for_work_group() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkGroupSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hierarchical kernel invocation method of a kernel defined as a lambda encoding the body of each work-group to launch. </p>
<p>Lambda may contain multiple calls to parallel_for_work_item(...) methods representing the execution on each work-item. Launches NumWorkGroups work-groups of WorkGroupSize size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkGroups</td><td>is a range describing the number of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">WorkGroupSize</td><td>is a range describing the size of work-groups in each dimension. </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda representing kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01939">1939</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a2e350f915111b129b22eba2989382863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e350f915111b129b22eba2989382863">&#9670;&nbsp;</a></span>prefetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00744">744</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="cg_8hpp_source.html#l00169">cl::sycl::detail::CG::PrefetchUSM</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l00648">cl::sycl::queue::prefetch()</a>.</p>

</div>
</div>
<a id="ae15174598d704c69779e60fdb86da80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15174598d704c69779e60fdb86da80e">&#9670;&nbsp;</a></span>require()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::require </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccMode, AccTarget, <a class="el" href="namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt;&#160;</td>
          <td class="paramname"><em>Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requires access to the memory object associated with the placeholder accessor. </p>
<p>The command group has a requirement to gain access to the given memory object before executing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Acc</td><td>is a SYCL accessor describing required memory region. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01362">1362</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler__proxy_8cpp_source.html#l00017">cl::sycl::detail::associateWithHandler()</a>.</p>

</div>
</div>
<a id="aebd7ddca219b45fd8eebbf768f4abff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd7ddca219b45fd8eebbf768f4abff0">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; DataT, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01415">1415</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a93f8f35825802c6e026f2dcd343bb093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f8f35825802c6e026f2dcd343bb093">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl_1_1detail.html#af45cb3f9724853d5ea66e37de686a383">detail::enable_if_t</a>&lt;<a class="el" href="structcl_1_1sycl_1_1handler_1_1ShouldEnableSetArg.html">ShouldEnableSetArg</a>&lt;<a class="el" href="classT.html">T</a>&gt;::value, void&gt; cl::sycl::handler::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ArgIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets argument for OpenCL interoperability kernels. </p>
<p>Registers Arg passed as argument # ArgIndex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ArgIndex</td><td>is a positional number of argument to be set. </td></tr>
    <tr><td class="paramname">Arg</td><td>is an argument value to be set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01408">1408</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="abc24e638930b88ddd619cf6759183892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc24e638930b88ddd619cf6759183892">&#9670;&nbsp;</a></span>set_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::set_args </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>Args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets arguments for OpenCL interoperability kernels. </p>
<p>Registers pack of arguments(Args) with indexes starting from 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Args</td><td>are argument values to be set. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01425">1425</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a20c00c28d8158a7b69b4c7ad726614f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c00c28d8158a7b69b4c7ad726614f4">&#9670;&nbsp;</a></span>single_task() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a SYCL kernel. </p>
<p>Executes exactly once. The kernel invocation method has no functors and cannot be called on host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01967">1967</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="aa68d8445ce652ee6f2df4ce661513a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68d8445ce652ee6f2df4ce661513a81">&#9670;&nbsp;</a></span>single_task() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1kernel.html">kernel</a>&#160;</td>
          <td class="paramname"><em>Kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Kernel</td><td>is a SYCL kernel that is executed on a SYCL device (except for the host device). </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is a lambda that is used if device, queue is bound to, is a host device. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02041">2041</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="kernel_8cpp_source.html#l00036">cl::sycl::kernel::get_kernel_bundle()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="a725e255af60b5545d5af97e1420856b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725e255af60b5545d5af97e1420856b0">&#9670;&nbsp;</a></span>single_task() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::single_task </td>
          <td>(</td>
          <td class="paramtype">KernelType&#160;</td>
          <td class="paramname"><em>KernelFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines and invokes a SYCL kernel function as a function object type. </p>
<p>If it is a named function object and the function object type is globally visible, there is no need for the developer to provide a kernel name for it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KernelFunc</td><td>is a SYCL kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l01438">1438</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sycl_2ext_2oneapi_2reduction_8hpp_source.html#l01446">cl::sycl::ext::oneapi::detail::reduSaveFinalResultToUserMem()</a>.</p>

</div>
</div>
<a id="a2e0250574969ee1bf7743596662c847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0250574969ee1bf7743596662c847e">&#9670;&nbsp;</a></span>update_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dims, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder = access::placeholder::false_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::update_host </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; <a class="el" href="classT.html">T</a>, Dims, AccessMode, AccessTarget, IsPlaceholder &gt;&#160;</td>
          <td class="paramname"><em>Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides guarantees that the memory object accessed via Acc is updated on the host after command group object execution is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Acc</td><td>is a SYCL accessor that needs to be updated on host. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02461">2461</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="afd4e8ab1956f2f591030f1d5fe24ba6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4e8ab1956f2f591030f1d5fe24ba6c">&#9670;&nbsp;</a></span>use_kernel_bundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::handler::use_kernel_bundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1kernel__bundle.html">kernel_bundle</a>&lt; <a class="el" href="namespacecl_1_1sycl.html#a2704d20220e08bb580fed24428b051d0aee7004c7949d83f130592f15d98ca343">bundle_state::executable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ExecBundle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8cpp_source.html#l00772">772</a> of file <a class="el" href="handler_8cpp_source.html">handler.cpp</a>.</p>

<p class="reference">References <a class="el" href="kernel__bundle_8hpp_source.html#l00212">cl::sycl::kernel_bundle&lt; State &gt;::get_context()</a>, <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>, <a class="el" href="namespacecl_1_1sycl.html#a96f353c1d5d9d8192ef124ea43b68dc8afedb2d84cafe20862cb4399751a8a7e3">cl::sycl::invalid</a>, and <a class="el" href="exception_8cpp_source.html#l00121">cl::sycl::make_error_code()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaabb994ca2bdbf38e10d7742a7e97f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabb994ca2bdbf38e10d7742a7e97f8f">&#9670;&nbsp;</a></span>::MockHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::MockHandler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02705">2705</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a4fe93ea8d613a9b7224780404781c279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe93ea8d613a9b7224780404781c279">&#9670;&nbsp;</a></span>accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dims, access::mode AccMode, access::target AccTarget, access::placeholder isPlaceholder, typename PropertyListT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcl_1_1sycl_1_1accessor.html">accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02679">2679</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ae548b3b019349fdb34b6be5d88d2165a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae548b3b019349fdb34b6be5d88d2165a">&#9670;&nbsp;</a></span>detail::associateWithHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a8d5e397ffe5aede6b455150254459c91">detail::associateWithHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1detail_1_1AccessorBaseHost.html">detail::AccessorBaseHost</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598">access::target</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa46bc683d37b6005434a0bceb5389f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46bc683d37b6005434a0bceb5389f8c">&#9670;&nbsp;</a></span>detail::getDeviceFromHandler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1device.html">device</a> <a class="el" href="namespacecl_1_1sycl_1_1detail.html#a4679ea98c7f73f344135382c7b7ab13d">detail::getDeviceFromHandler</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbb498cc698f57626f0746b3365a880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb498cc698f57626f0746b3365a880e">&#9670;&nbsp;</a></span>detail::image_accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataT , int Dimensions, access::mode AccessMode, access::target AccessTarget, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcl_1_1sycl_1_1detail_1_1image__accessor.html">detail::image_accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02684">2684</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad7cdb542aa2a076f6714e683ee827d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cdb542aa2a076f6714e683ee827d4e">&#9670;&nbsp;</a></span>detail::queue_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1detail_1_1queue__impl.html">detail::queue_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02674">2674</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a5fca0ca308f0eac9343990d58cd54374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fca0ca308f0eac9343990d58cd54374">&#9670;&nbsp;</a></span>detail::stream_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcl_1_1sycl_1_1detail_1_1stream__impl.html">detail::stream_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02687">2687</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="a57dcba71eada00c9cca712c46e86ceb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dcba71eada00c9cca712c46e86ceb4">&#9670;&nbsp;</a></span>ext::oneapi::detail::reduction_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class BinaryOperation , int Dims, bool IsUSM, access::placeholder IsPlaceholder&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcl_1_1sycl_1_1ext_1_1oneapi_1_1detail_1_1reduction__impl.html">ext::oneapi::detail::reduction_impl</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02692">2692</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<a id="ad6cdd83c821525ef93cdeb8332fd7de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cdd83c821525ef93cdeb8332fd7de8">&#9670;&nbsp;</a></span>stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcl_1_1sycl_1_1stream.html">stream</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l02686">2686</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/CL/sycl/<a class="el" href="handler_8hpp_source.html">handler.hpp</a></li>
<li>source/<a class="el" href="handler_8cpp_source.html">handler.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclasscl_1_1sycl_1_1queue_html_a74cfc07a129881fbb0782cfc8092c150"><div class="ttname"><a href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">cl::sycl::queue::submit</a></div><div class="ttdeci">event submit(T CGF _CODELOCPARAM(&amp;CodeLoc))</div><div class="ttdoc">Submits a command group function object to the queue, in order to be scheduled for execution on the d...</div><div class="ttdef"><b>Definition:</b> <a href="queue_8hpp_source.html#l00252">queue.hpp:252</a></div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1handler.html">handler</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
