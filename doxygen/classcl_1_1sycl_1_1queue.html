<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: cl::sycl::queue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI Data Parallel C++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcl_1_1sycl_1_1queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcl_1_1sycl_1_1queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::queue Class Reference<div class="ingroups"><a class="el" href="group__sycl__api.html">DPC++ User API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a single SYCL queue which schedules kernels on a SYCL device.  
 <a href="classcl_1_1sycl_1_1queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="queue_8hpp_source.html">CL/sycl/queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c458b2a33f18ab0e30ecce113c6defe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a5c458b2a33f18ab0e30ecce113c6defe">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:a5c458b2a33f18ab0e30ecce113c6defe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device returned by an instance of <a class="el" href="classcl_1_1sycl_1_1default__selector.html" title="The default selector chooses the first available SYCL device.">default_selector</a>.  <a href="classcl_1_1sycl_1_1queue.html#a5c458b2a33f18ab0e30ecce113c6defe">More...</a><br /></td></tr>
<tr class="separator:a5c458b2a33f18ab0e30ecce113c6defe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f219dac1e09e6173fd491df629dc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ab60f219dac1e09e6173fd491df629dc3">queue</a> (const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;AsyncHandler, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:ab60f219dac1e09e6173fd491df629dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler using the device returned by an instance of <a class="el" href="classcl_1_1sycl_1_1default__selector.html" title="The default selector chooses the first available SYCL device.">default_selector</a>.  <a href="classcl_1_1sycl_1_1queue.html#ab60f219dac1e09e6173fd491df629dc3">More...</a><br /></td></tr>
<tr class="separator:ab60f219dac1e09e6173fd491df629dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc295e6b1df3c1f9ad860ae339b425a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#acc295e6b1df3c1f9ad860ae339b425a6">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;DeviceSelector, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:acc295e6b1df3c1f9ad860ae339b425a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device returned by the DeviceSelector provided.  <a href="classcl_1_1sycl_1_1queue.html#acc295e6b1df3c1f9ad860ae339b425a6">More...</a><br /></td></tr>
<tr class="separator:acc295e6b1df3c1f9ad860ae339b425a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e01befca48b3eafda1cea81f515fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a8c0e01befca48b3eafda1cea81f515fc">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;DeviceSelector, const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;AsyncHandler, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:a8c0e01befca48b3eafda1cea81f515fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler using the device returned by the DeviceSelector provided.  <a href="classcl_1_1sycl_1_1queue.html#a8c0e01befca48b3eafda1cea81f515fc">More...</a><br /></td></tr>
<tr class="separator:a8c0e01befca48b3eafda1cea81f515fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcadc782fa728a919189ac213aafc792"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#abcadc782fa728a919189ac213aafc792">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:abcadc782fa728a919189ac213aafc792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance using the device provided.  <a href="classcl_1_1sycl_1_1queue.html#abcadc782fa728a919189ac213aafc792">More...</a><br /></td></tr>
<tr class="separator:abcadc782fa728a919189ac213aafc792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef0b518923e220bf19b37e9e0ccf562"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#adef0b518923e220bf19b37e9e0ccf562">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;AsyncHandler, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:adef0b518923e220bf19b37e9e0ccf562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler using the device provided.  <a href="classcl_1_1sycl_1_1queue.html#adef0b518923e220bf19b37e9e0ccf562">More...</a><br /></td></tr>
<tr class="separator:adef0b518923e220bf19b37e9e0ccf562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e7582f72008b3586a6c74405e36a65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ae3e7582f72008b3586a6c74405e36a65">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;DeviceSelector, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:ae3e7582f72008b3586a6c74405e36a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance that is associated with the context provided, using the device returned by the device selector.  <a href="classcl_1_1sycl_1_1queue.html#ae3e7582f72008b3586a6c74405e36a65">More...</a><br /></td></tr>
<tr class="separator:ae3e7582f72008b3586a6c74405e36a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaac4845e98e5b3a1cfb32580a820be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#adfaac4845e98e5b3a1cfb32580a820be">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;DeviceSelector, const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;AsyncHandler, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:adfaac4845e98e5b3a1cfb32580a820be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue instance with an async_handler that is associated with the context provided, using the device returned by the device selector.  <a href="classcl_1_1sycl_1_1queue.html#adfaac4845e98e5b3a1cfb32580a820be">More...</a><br /></td></tr>
<tr class="separator:adfaac4845e98e5b3a1cfb32580a820be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab117f911d1e7b44466a834ea780b5a3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ab117f911d1e7b44466a834ea780b5a3e">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:ab117f911d1e7b44466a834ea780b5a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue associated with the given context, device and optional properties list.  <a href="classcl_1_1sycl_1_1queue.html#ab117f911d1e7b44466a834ea780b5a3e">More...</a><br /></td></tr>
<tr class="separator:ab117f911d1e7b44466a834ea780b5a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fe5802e275e487a80a0cd677b5315c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ac1fe5802e275e487a80a0cd677b5315c">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;SyclContext, const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;SyclDevice, const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;AsyncHandler, const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;PropList={})</td></tr>
<tr class="memdesc:ac1fe5802e275e487a80a0cd677b5315c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue associated with the given context, device, asynchronous exception handler and optional properties list.  <a href="classcl_1_1sycl_1_1queue.html#ac1fe5802e275e487a80a0cd677b5315c">More...</a><br /></td></tr>
<tr class="separator:ac1fe5802e275e487a80a0cd677b5315c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2845668f9066c6f34926488374deda3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ac2845668f9066c6f34926488374deda3">queue</a> (const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;RHS)=default</td></tr>
<tr class="memdesc:ac2845668f9066c6f34926488374deda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a SYCL queue with an optional async_handler from an OpenCL cl_command_queue.  <a href="classcl_1_1sycl_1_1queue.html#ac2845668f9066c6f34926488374deda3">More...</a><br /></td></tr>
<tr class="separator:ac2845668f9066c6f34926488374deda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcb9e750fefa241890d191546cdc67a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a8dcb9e750fefa241890d191546cdc67a">queue</a> (<a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&amp;RHS)=default</td></tr>
<tr class="separator:a8dcb9e750fefa241890d191546cdc67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6213fd30826aec4dfa580c5ec7e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a01d6213fd30826aec4dfa580c5ec7e66">operator=</a> (const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;RHS)=default</td></tr>
<tr class="separator:a01d6213fd30826aec4dfa580c5ec7e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f2545f918fa3745bde9e80f21a6048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ab4f2545f918fa3745bde9e80f21a6048">operator=</a> (<a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&amp;RHS)=default</td></tr>
<tr class="separator:ab4f2545f918fa3745bde9e80f21a6048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6bd404213c1c28d9193fe1d18c15ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#adc6bd404213c1c28d9193fe1d18c15ec">operator==</a> (const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;RHS) const</td></tr>
<tr class="separator:adc6bd404213c1c28d9193fe1d18c15ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f12abfa503b0d395333e32381bfc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aa26f12abfa503b0d395333e32381bfc9">operator!=</a> (const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;RHS) const</td></tr>
<tr class="separator:aa26f12abfa503b0d395333e32381bfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca23a41f6aa537c7038be5bf7ae135e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1context.html">context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aca23a41f6aa537c7038be5bf7ae135e3">get_context</a> () const</td></tr>
<tr class="separator:aca23a41f6aa537c7038be5bf7ae135e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f991915c57bfb1d73992fde421d56c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1device.html">device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a2f991915c57bfb1d73992fde421d56c8">get_device</a> () const</td></tr>
<tr class="separator:a2f991915c57bfb1d73992fde421d56c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbbd03cb8e3021fab6835538ff72a65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#adfbbd03cb8e3021fab6835538ff72a65">is_host</a> () const</td></tr>
<tr class="separator:adfbbd03cb8e3021fab6835538ff72a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae877ebb3989aa206124871b849b04813"><td class="memTemplParams" colspan="2">template&lt;info::queue param&gt; </td></tr>
<tr class="memitem:ae877ebb3989aa206124871b849b04813"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1info_1_1param__traits.html">info::param_traits</a>&lt; <a class="el" href="namespacecl_1_1sycl_1_1info.html#a298d56c26b4eec2a4d4fb1649e2d1063">info::queue</a>, param &gt;::return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ae877ebb3989aa206124871b849b04813">get_info</a> () const</td></tr>
<tr class="memdesc:ae877ebb3989aa206124871b849b04813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries SYCL queue for information.  <a href="classcl_1_1sycl_1_1queue.html#ae877ebb3989aa206124871b849b04813">More...</a><br /></td></tr>
<tr class="separator:ae877ebb3989aa206124871b849b04813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cfc07a129881fbb0782cfc8092c150"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74cfc07a129881fbb0782cfc8092c150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">submit</a> (<a class="el" href="classT.html">T</a> CGF <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a74cfc07a129881fbb0782cfc8092c150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command group function object to the queue, in order to be scheduled for execution on the device.  <a href="classcl_1_1sycl_1_1queue.html#a74cfc07a129881fbb0782cfc8092c150">More...</a><br /></td></tr>
<tr class="separator:a74cfc07a129881fbb0782cfc8092c150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403befa777925c4d2629234e38a73fd2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a403befa777925c4d2629234e38a73fd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a403befa777925c4d2629234e38a73fd2">submit</a> (<a class="el" href="classT.html">T</a> CGF, <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;SecondaryQueue <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a403befa777925c4d2629234e38a73fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a command group function object to the queue, in order to be scheduled for execution on the device.  <a href="classcl_1_1sycl_1_1queue.html#a403befa777925c4d2629234e38a73fd2">More...</a><br /></td></tr>
<tr class="separator:a403befa777925c4d2629234e38a73fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d34aeaa32efc0f5942a63fb6afdd9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a8d34aeaa32efc0f5942a63fb6afdd9fb">ext_oneapi_submit_barrier</a> (<a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a8d34aeaa32efc0f5942a63fb6afdd9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classcl_1_1sycl_1_1queue.html#a8d34aeaa32efc0f5942a63fb6afdd9fb">More...</a><br /></td></tr>
<tr class="separator:a8d34aeaa32efc0f5942a63fb6afdd9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fd5166ecf040891c2e1c2eb8210d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a03fd5166ecf040891c2e1c2eb8210d94">submit_barrier</a> (<a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a03fd5166ecf040891c2e1c2eb8210d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state.  <a href="classcl_1_1sycl_1_1queue.html#a03fd5166ecf040891c2e1c2eb8210d94">More...</a><br /></td></tr>
<tr class="separator:a03fd5166ecf040891c2e1c2eb8210d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e08338877f6e3f19684dfad383823d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ad7e08338877f6e3f19684dfad383823d">ext_oneapi_submit_barrier</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:ad7e08338877f6e3f19684dfad383823d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classcl_1_1sycl_1_1queue.html#ad7e08338877f6e3f19684dfad383823d">More...</a><br /></td></tr>
<tr class="separator:ad7e08338877f6e3f19684dfad383823d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a1938f7ebd34b9b7389189b370f597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a99a1938f7ebd34b9b7389189b370f597">submit_barrier</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a99a1938f7ebd34b9b7389189b370f597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state.  <a href="classcl_1_1sycl_1_1queue.html#a99a1938f7ebd34b9b7389189b370f597">More...</a><br /></td></tr>
<tr class="separator:a99a1938f7ebd34b9b7389189b370f597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88a60a32d5695334a6a20246acf5ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ae88a60a32d5695334a6a20246acf5ee3">wait</a> (<a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:ae88a60a32d5695334a6a20246acf5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking wait for the completion of all enqueued tasks in the queue.  <a href="classcl_1_1sycl_1_1queue.html#ae88a60a32d5695334a6a20246acf5ee3">More...</a><br /></td></tr>
<tr class="separator:ae88a60a32d5695334a6a20246acf5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7304541935e8bec0c65b1490e05edc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a7304541935e8bec0c65b1490e05edc2f">wait_and_throw</a> (<a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a7304541935e8bec0c65b1490e05edc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a blocking wait for the completion of all enqueued tasks in the queue.  <a href="classcl_1_1sycl_1_1queue.html#a7304541935e8bec0c65b1490e05edc2f">More...</a><br /></td></tr>
<tr class="separator:a7304541935e8bec0c65b1490e05edc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8abb9c998a175a7e115b0b475cdc76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a0d8abb9c998a175a7e115b0b475cdc76">wait_proxy</a> (const <a class="el" href="structcl_1_1sycl_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc)</td></tr>
<tr class="memdesc:a0d8abb9c998a175a7e115b0b475cdc76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy method for wait to forward the code location information to the implementation.  <a href="classcl_1_1sycl_1_1queue.html#a0d8abb9c998a175a7e115b0b475cdc76">More...</a><br /></td></tr>
<tr class="separator:a0d8abb9c998a175a7e115b0b475cdc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967e0150616bc53f07da9d949dffe431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a967e0150616bc53f07da9d949dffe431">wait_and_throw_proxy</a> (const <a class="el" href="structcl_1_1sycl_1_1detail_1_1code__location.html">detail::code_location</a> &amp;CodeLoc)</td></tr>
<tr class="memdesc:a967e0150616bc53f07da9d949dffe431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy method for wait_and_throw to forward the code location information to the implementation.  <a href="classcl_1_1sycl_1_1queue.html#a967e0150616bc53f07da9d949dffe431">More...</a><br /></td></tr>
<tr class="separator:a967e0150616bc53f07da9d949dffe431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c39ed682422e4e525fe0a01e8b7ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ae5c39ed682422e4e525fe0a01e8b7ad9">throw_asynchronous</a> ()</td></tr>
<tr class="memdesc:ae5c39ed682422e4e525fe0a01e8b7ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any asynchronous errors have been produced by the queue and if so reports them to the async_handler passed on the queue construction.  <a href="classcl_1_1sycl_1_1queue.html#ae5c39ed682422e4e525fe0a01e8b7ad9">More...</a><br /></td></tr>
<tr class="separator:ae5c39ed682422e4e525fe0a01e8b7ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24e060ff8995d3194bc5ead4d2abb3c"><td class="memTemplParams" colspan="2">template&lt;typename PropertyT &gt; </td></tr>
<tr class="memitem:ab24e060ff8995d3194bc5ead4d2abb3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ab24e060ff8995d3194bc5ead4d2abb3c">has_property</a> () const</td></tr>
<tr class="separator:ab24e060ff8995d3194bc5ead4d2abb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddf14c63128569224aad4967408ecf1"><td class="memTemplParams" colspan="2">template&lt;typename PropertyT &gt; </td></tr>
<tr class="memitem:adddf14c63128569224aad4967408ecf1"><td class="memTemplItemLeft" align="right" valign="top">PropertyT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#adddf14c63128569224aad4967408ecf1">get_property</a> () const</td></tr>
<tr class="separator:adddf14c63128569224aad4967408ecf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885877f9ae12cb55d61a24d2a179dbba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a885877f9ae12cb55d61a24d2a179dbba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a885877f9ae12cb55d61a24d2a179dbba">fill</a> (void *Ptr, const <a class="el" href="classT.html">T</a> &amp;Pattern, size_t Count)</td></tr>
<tr class="memdesc:a885877f9ae12cb55d61a24d2a179dbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classcl_1_1sycl_1_1queue.html#a885877f9ae12cb55d61a24d2a179dbba">More...</a><br /></td></tr>
<tr class="separator:a885877f9ae12cb55d61a24d2a179dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1974405138a5c4791a55aa3cc596c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb1974405138a5c4791a55aa3cc596c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aeb1974405138a5c4791a55aa3cc596c0">fill</a> (void *Ptr, const <a class="el" href="classT.html">T</a> &amp;Pattern, size_t Count, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:aeb1974405138a5c4791a55aa3cc596c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classcl_1_1sycl_1_1queue.html#aeb1974405138a5c4791a55aa3cc596c0">More...</a><br /></td></tr>
<tr class="separator:aeb1974405138a5c4791a55aa3cc596c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5446e07f9e23961503514d949a31fd67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5446e07f9e23961503514d949a31fd67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a5446e07f9e23961503514d949a31fd67">fill</a> (void *Ptr, const <a class="el" href="classT.html">T</a> &amp;Pattern, size_t Count, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:a5446e07f9e23961503514d949a31fd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the specified memory with the specified pattern.  <a href="classcl_1_1sycl_1_1queue.html#a5446e07f9e23961503514d949a31fd67">More...</a><br /></td></tr>
<tr class="separator:a5446e07f9e23961503514d949a31fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd93967ba2484d50786c22b4148cb67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#afcd93967ba2484d50786c22b4148cb67">memset</a> (void *Ptr, int Value, size_t Count)</td></tr>
<tr class="memdesc:afcd93967ba2484d50786c22b4148cb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classcl_1_1sycl_1_1queue.html#afcd93967ba2484d50786c22b4148cb67">More...</a><br /></td></tr>
<tr class="separator:afcd93967ba2484d50786c22b4148cb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4891f4e76fc65ac03e0298ed11462814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a4891f4e76fc65ac03e0298ed11462814">memset</a> (void *Ptr, int Value, size_t Count, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:a4891f4e76fc65ac03e0298ed11462814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classcl_1_1sycl_1_1queue.html#a4891f4e76fc65ac03e0298ed11462814">More...</a><br /></td></tr>
<tr class="separator:a4891f4e76fc65ac03e0298ed11462814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c009de8f034e70aacf59ec6c137de24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a5c009de8f034e70aacf59ec6c137de24">memset</a> (void *Ptr, int Value, size_t Count, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:a5c009de8f034e70aacf59ec6c137de24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the memory pointed by a USM pointer with the value specified.  <a href="classcl_1_1sycl_1_1queue.html#a5c009de8f034e70aacf59ec6c137de24">More...</a><br /></td></tr>
<tr class="separator:a5c009de8f034e70aacf59ec6c137de24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc6a510e5e9abcbf1ee904d4b86edbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a6bc6a510e5e9abcbf1ee904d4b86edbf">memcpy</a> (void *Dest, const void *Src, size_t Count)</td></tr>
<tr class="memdesc:a6bc6a510e5e9abcbf1ee904d4b86edbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#a6bc6a510e5e9abcbf1ee904d4b86edbf">More...</a><br /></td></tr>
<tr class="separator:a6bc6a510e5e9abcbf1ee904d4b86edbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd44ca8026ba7e4e7c585496dfa870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a82dd44ca8026ba7e4e7c585496dfa870">memcpy</a> (void *Dest, const void *Src, size_t Count, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:a82dd44ca8026ba7e4e7c585496dfa870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#a82dd44ca8026ba7e4e7c585496dfa870">More...</a><br /></td></tr>
<tr class="separator:a82dd44ca8026ba7e4e7c585496dfa870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebba5b554a60ee51faac4214a1b5074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aeebba5b554a60ee51faac4214a1b5074">memcpy</a> (void *Dest, const void *Src, size_t Count, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:aeebba5b554a60ee51faac4214a1b5074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#aeebba5b554a60ee51faac4214a1b5074">More...</a><br /></td></tr>
<tr class="separator:aeebba5b554a60ee51faac4214a1b5074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e7a90764212f61d5eb70b545f15855"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9e7a90764212f61d5eb70b545f15855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aa9e7a90764212f61d5eb70b545f15855">copy</a> (const <a class="el" href="classT.html">T</a> *Src, <a class="el" href="classT.html">T</a> *Dest, size_t Count)</td></tr>
<tr class="memdesc:aa9e7a90764212f61d5eb70b545f15855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#aa9e7a90764212f61d5eb70b545f15855">More...</a><br /></td></tr>
<tr class="separator:aa9e7a90764212f61d5eb70b545f15855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d5116533678fca51a6152049e346b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97d5116533678fca51a6152049e346b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a97d5116533678fca51a6152049e346b8">copy</a> (const <a class="el" href="classT.html">T</a> *Src, <a class="el" href="classT.html">T</a> *Dest, size_t Count, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:a97d5116533678fca51a6152049e346b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#a97d5116533678fca51a6152049e346b8">More...</a><br /></td></tr>
<tr class="separator:a97d5116533678fca51a6152049e346b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8a24441e36d9d96c61d952f4a39265"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f8a24441e36d9d96c61d952f4a39265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a2f8a24441e36d9d96c61d952f4a39265">copy</a> (const <a class="el" href="classT.html">T</a> *Src, <a class="el" href="classT.html">T</a> *Dest, size_t Count, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:a2f8a24441e36d9d96c61d952f4a39265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from one memory region to another, both pointed by USM pointers.  <a href="classcl_1_1sycl_1_1queue.html#a2f8a24441e36d9d96c61d952f4a39265">More...</a><br /></td></tr>
<tr class="separator:a2f8a24441e36d9d96c61d952f4a39265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf855d45f7c048c839e283c036a05cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#acdf855d45f7c048c839e283c036a05cb">mem_advise</a> (const void *Ptr, size_t Length, <a class="el" href="pi_8h.html#a286bf19d79f0e65f8137d269f037798b">pi_mem_advice</a> Advice)</td></tr>
<tr class="memdesc:acdf855d45f7c048c839e283c036a05cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classcl_1_1sycl_1_1queue.html#acdf855d45f7c048c839e283c036a05cb">More...</a><br /></td></tr>
<tr class="separator:acdf855d45f7c048c839e283c036a05cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a9b32cd6237e4b6573d816dd299f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a4d2a9b32cd6237e4b6573d816dd299f9">mem_advise</a> (const void *Ptr, size_t Length, int Advice)</td></tr>
<tr class="memdesc:a4d2a9b32cd6237e4b6573d816dd299f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classcl_1_1sycl_1_1queue.html#a4d2a9b32cd6237e4b6573d816dd299f9">More...</a><br /></td></tr>
<tr class="separator:a4d2a9b32cd6237e4b6573d816dd299f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70703277950f9b47866c517a9d4e969c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a70703277950f9b47866c517a9d4e969c">mem_advise</a> (const void *Ptr, size_t Length, int Advice, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:a70703277950f9b47866c517a9d4e969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classcl_1_1sycl_1_1queue.html#a70703277950f9b47866c517a9d4e969c">More...</a><br /></td></tr>
<tr class="separator:a70703277950f9b47866c517a9d4e969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed90f84a4ed2e9c62828bd9fee09d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a0ed90f84a4ed2e9c62828bd9fee09d64">mem_advise</a> (const void *Ptr, size_t Length, int Advice, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:a0ed90f84a4ed2e9c62828bd9fee09d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides additional information to the underlying runtime about how different allocations are used.  <a href="classcl_1_1sycl_1_1queue.html#a0ed90f84a4ed2e9c62828bd9fee09d64">More...</a><br /></td></tr>
<tr class="separator:a0ed90f84a4ed2e9c62828bd9fee09d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5516a9023e6a5c2def87689808eee11c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a5516a9023e6a5c2def87689808eee11c">prefetch</a> (const void *Ptr, size_t Count)</td></tr>
<tr class="memdesc:a5516a9023e6a5c2def87689808eee11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classcl_1_1sycl_1_1queue.html#a5516a9023e6a5c2def87689808eee11c">More...</a><br /></td></tr>
<tr class="separator:a5516a9023e6a5c2def87689808eee11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc938e9e2e814ebcaa49bf496b3d0878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#abc938e9e2e814ebcaa49bf496b3d0878">prefetch</a> (const void *Ptr, size_t Count, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent)</td></tr>
<tr class="memdesc:abc938e9e2e814ebcaa49bf496b3d0878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classcl_1_1sycl_1_1queue.html#abc938e9e2e814ebcaa49bf496b3d0878">More...</a><br /></td></tr>
<tr class="separator:abc938e9e2e814ebcaa49bf496b3d0878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efd060dd53829ccf8d9649b7b73150c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a1efd060dd53829ccf8d9649b7b73150c">prefetch</a> (const void *Ptr, size_t Count, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents)</td></tr>
<tr class="memdesc:a1efd060dd53829ccf8d9649b7b73150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available.  <a href="classcl_1_1sycl_1_1queue.html#a1efd060dd53829ccf8d9649b7b73150c">More...</a><br /></td></tr>
<tr class="separator:a1efd060dd53829ccf8d9649b7b73150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e62095771bd8eafd97298291e1acd65"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a4e62095771bd8eafd97298291e1acd65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a4e62095771bd8eafd97298291e1acd65">single_task</a> (<a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a4e62095771bd8eafd97298291e1acd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classcl_1_1sycl_1_1queue.html#a4e62095771bd8eafd97298291e1acd65">More...</a><br /></td></tr>
<tr class="separator:a4e62095771bd8eafd97298291e1acd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f99bcfefc29069a31b3bf82b990f09e"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a8f99bcfefc29069a31b3bf82b990f09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a8f99bcfefc29069a31b3bf82b990f09e">single_task</a> (<a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a8f99bcfefc29069a31b3bf82b990f09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classcl_1_1sycl_1_1queue.html#a8f99bcfefc29069a31b3bf82b990f09e">More...</a><br /></td></tr>
<tr class="separator:a8f99bcfefc29069a31b3bf82b990f09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955b207732047cc19bb5d01026969892"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a955b207732047cc19bb5d01026969892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a955b207732047cc19bb5d01026969892">single_task</a> (const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a955b207732047cc19bb5d01026969892"><td class="mdescLeft">&#160;</td><td class="mdescRight">single_task version with a kernel represented as a lambda.  <a href="classcl_1_1sycl_1_1queue.html#a955b207732047cc19bb5d01026969892">More...</a><br /></td></tr>
<tr class="separator:a955b207732047cc19bb5d01026969892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb27ee1c41ae8ff975e7e322253fe917"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:acb27ee1c41ae8ff975e7e322253fe917"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#acb27ee1c41ae8ff975e7e322253fe917">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:acb27ee1c41ae8ff975e7e322253fe917"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#acb27ee1c41ae8ff975e7e322253fe917">More...</a><br /></td></tr>
<tr class="separator:acb27ee1c41ae8ff975e7e322253fe917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fae91746e12707b246235c0094a96b"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:ab0fae91746e12707b246235c0094a96b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ab0fae91746e12707b246235c0094a96b">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:ab0fae91746e12707b246235c0094a96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#ab0fae91746e12707b246235c0094a96b">More...</a><br /></td></tr>
<tr class="separator:ab0fae91746e12707b246235c0094a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a03639455a508296a2f464a8cc6c9d"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:aa0a03639455a508296a2f464a8cc6c9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#aa0a03639455a508296a2f464a8cc6c9d">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:aa0a03639455a508296a2f464a8cc6c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#aa0a03639455a508296a2f464a8cc6c9d">More...</a><br /></td></tr>
<tr class="separator:aa0a03639455a508296a2f464a8cc6c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5639955ac2cac52b0469838ad32db"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a85c5639955ac2cac52b0469838ad32db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a85c5639955ac2cac52b0469838ad32db">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a85c5639955ac2cac52b0469838ad32db"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#a85c5639955ac2cac52b0469838ad32db">More...</a><br /></td></tr>
<tr class="separator:a85c5639955ac2cac52b0469838ad32db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868009a8248b56b1ba0c444c374af456"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a868009a8248b56b1ba0c444c374af456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a868009a8248b56b1ba0c444c374af456">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a868009a8248b56b1ba0c444c374af456"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#a868009a8248b56b1ba0c444c374af456">More...</a><br /></td></tr>
<tr class="separator:a868009a8248b56b1ba0c444c374af456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352a66cbfe7bb8caade69091ab19cf42"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a352a66cbfe7bb8caade69091ab19cf42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a352a66cbfe7bb8caade69091ab19cf42">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a352a66cbfe7bb8caade69091ab19cf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#a352a66cbfe7bb8caade69091ab19cf42">More...</a><br /></td></tr>
<tr class="separator:a352a66cbfe7bb8caade69091ab19cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d2905826b71870ecc8ea00906cb882"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a66d2905826b71870ecc8ea00906cb882"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a66d2905826b71870ecc8ea00906cb882">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt; NumWorkItems, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a66d2905826b71870ecc8ea00906cb882"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#a66d2905826b71870ecc8ea00906cb882">More...</a><br /></td></tr>
<tr class="separator:a66d2905826b71870ecc8ea00906cb882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebfa7934ec12e9cb08c87a111b75ff"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:a07ebfa7934ec12e9cb08c87a111b75ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a07ebfa7934ec12e9cb08c87a111b75ff">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt; NumWorkItems, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a07ebfa7934ec12e9cb08c87a111b75ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#a07ebfa7934ec12e9cb08c87a111b75ff">More...</a><br /></td></tr>
<tr class="separator:a07ebfa7934ec12e9cb08c87a111b75ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa699830b8c540a01fc8d559a6ce8c0"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </td></tr>
<tr class="memitem:acfa699830b8c540a01fc8d559a6ce8c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#acfa699830b8c540a01fc8d559a6ce8c0">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt; NumWorkItems, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:acfa699830b8c540a01fc8d559a6ce8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range that specifies global size only.  <a href="classcl_1_1sycl_1_1queue.html#acfa699830b8c540a01fc8d559a6ce8c0">More...</a><br /></td></tr>
<tr class="separator:acfa699830b8c540a01fc8d559a6ce8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4d18382d95b5de4509581f76af298"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a1ce4d18382d95b5de4509581f76af298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a1ce4d18382d95b5de4509581f76af298">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a1ce4d18382d95b5de4509581f76af298"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classcl_1_1sycl_1_1queue.html#a1ce4d18382d95b5de4509581f76af298">More...</a><br /></td></tr>
<tr class="separator:a1ce4d18382d95b5de4509581f76af298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82473f85af862ebd751afabc266a36d1"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a82473f85af862ebd751afabc266a36d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a82473f85af862ebd751afabc266a36d1">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a82473f85af862ebd751afabc266a36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classcl_1_1sycl_1_1queue.html#a82473f85af862ebd751afabc266a36d1">More...</a><br /></td></tr>
<tr class="separator:a82473f85af862ebd751afabc266a36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aab50a1ad65bae769aa142c404a121e"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a3aab50a1ad65bae769aa142c404a121e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a3aab50a1ad65bae769aa142c404a121e">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt; NumWorkItems, <a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt; WorkItemOffset, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a3aab50a1ad65bae769aa142c404a121e"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly.  <a href="classcl_1_1sycl_1_1queue.html#a3aab50a1ad65bae769aa142c404a121e">More...</a><br /></td></tr>
<tr class="separator:a3aab50a1ad65bae769aa142c404a121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e6845be9c7ce965fce626b14f1c0ac"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:ad1e6845be9c7ce965fce626b14f1c0ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#ad1e6845be9c7ce965fce626b14f1c0ac">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; ExecutionRange, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:ad1e6845be9c7ce965fce626b14f1c0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classcl_1_1sycl_1_1queue.html#ad1e6845be9c7ce965fce626b14f1c0ac">More...</a><br /></td></tr>
<tr class="separator:ad1e6845be9c7ce965fce626b14f1c0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089901a695ed39ad3fcecd523ecef3dd"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:a089901a695ed39ad3fcecd523ecef3dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a089901a695ed39ad3fcecd523ecef3dd">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; ExecutionRange, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> DepEvent, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:a089901a695ed39ad3fcecd523ecef3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classcl_1_1sycl_1_1queue.html#a089901a695ed39ad3fcecd523ecef3dd">More...</a><br /></td></tr>
<tr class="separator:a089901a695ed39ad3fcecd523ecef3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ef2f7ba7b48430719139c9bef971df"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </td></tr>
<tr class="memitem:af2ef2f7ba7b48430719139c9bef971df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#af2ef2f7ba7b48430719139c9bef971df">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; ExecutionRange, const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;DepEvents, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:af2ef2f7ba7b48430719139c9bef971df"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classcl_1_1sycl_1_1queue.html#af2ef2f7ba7b48430719139c9bef971df">More...</a><br /></td></tr>
<tr class="separator:af2ef2f7ba7b48430719139c9bef971df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec39afb79e7005e9b09ae7a1c48a08c"><td class="memTemplParams" colspan="2">template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </td></tr>
<tr class="memitem:acec39afb79e7005e9b09ae7a1c48a08c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#acec39afb79e7005e9b09ae7a1c48a08c">parallel_for</a> (<a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt; ExecutionRange, Reduction Redu, <a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a>(&amp;CodeLoc))</td></tr>
<tr class="memdesc:acec39afb79e7005e9b09ae7a1c48a08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset.  <a href="classcl_1_1sycl_1_1queue.html#acec39afb79e7005e9b09ae7a1c48a08c">More...</a><br /></td></tr>
<tr class="separator:acec39afb79e7005e9b09ae7a1c48a08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8244d40020d5524492549a66cf4396e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#af8244d40020d5524492549a66cf4396e">is_in_order</a> () const</td></tr>
<tr class="memdesc:af8244d40020d5524492549a66cf4396e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the queue is in order or OoO.  <a href="classcl_1_1sycl_1_1queue.html#af8244d40020d5524492549a66cf4396e">More...</a><br /></td></tr>
<tr class="separator:af8244d40020d5524492549a66cf4396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e63e95af49ba50358e68b2eab6962ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#ac67af1b2ee223fc75f90287790459336">backend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a5e63e95af49ba50358e68b2eab6962ea">get_backend</a> () const noexcept</td></tr>
<tr class="memdesc:a5e63e95af49ba50358e68b2eab6962ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the backend associated with this queue.  <a href="classcl_1_1sycl_1_1queue.html#a5e63e95af49ba50358e68b2eab6962ea">More...</a><br /></td></tr>
<tr class="separator:a5e63e95af49ba50358e68b2eab6962ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38ca19d393ca3185991db28dabab83"><td class="memTemplParams" colspan="2">template&lt;backend Backend&gt; </td></tr>
<tr class="memitem:a6f38ca19d393ca3185991db28dabab83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecl_1_1sycl.html#a26f419bb807dc7762b3fdb499790e133">backend_return_t</a>&lt; Backend, <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a6f38ca19d393ca3185991db28dabab83">get_native</a> () const</td></tr>
<tr class="memdesc:a6f38ca19d393ca3185991db28dabab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the native handle of the SYCL queue.  <a href="classcl_1_1sycl_1_1queue.html#a6f38ca19d393ca3185991db28dabab83">More...</a><br /></td></tr>
<tr class="separator:a6f38ca19d393ca3185991db28dabab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a71492293d0386f542d120a1fc3dfbb55"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a71492293d0386f542d120a1fc3dfbb55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classT.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1queue.html#a71492293d0386f542d120a1fc3dfbb55">detail::createSyclObjFromImpl</a> (decltype(T::impl) ImplObj)</td></tr>
<tr class="separator:a71492293d0386f542d120a1fc3dfbb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a single SYCL queue which schedules kernels on a SYCL device. </p>
<p>A SYCL queue can be used to submit command groups to be executed by the SYCL runtime.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcl_1_1sycl_1_1device.html" title="The SYCL device class encapsulates a single SYCL device on which kernels may be executed.">device</a> </dd>
<dd>
<a class="el" href="classcl_1_1sycl_1_1handler.html" title="Command group handler class.">handler</a> </dd>
<dd>
<a class="el" href="classcl_1_1sycl_1_1event.html" title="An event object can be used to synchronize memory transfers, enqueues of kernels and signaling barrie...">event</a> </dd>
<dd>
<a class="el" href="classcl_1_1sycl_1_1kernel.html" title="Provides an abstraction of a SYCL kernel.">kernel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00103">103</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5c458b2a33f18ab0e30ecce113c6defe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c458b2a33f18ab0e30ecce113c6defe">&#9670;&nbsp;</a></span>queue() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device returned by an instance of <a class="el" href="classcl_1_1sycl_1_1default__selector.html" title="The default selector chooses the first available SYCL device.">default_selector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00109">109</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ab60f219dac1e09e6173fd491df629dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f219dac1e09e6173fd491df629dc3">&#9670;&nbsp;</a></span>queue() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler using the device returned by an instance of <a class="el" href="classcl_1_1sycl_1_1default__selector.html" title="The default selector chooses the first available SYCL device.">default_selector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00117">117</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="acc295e6b1df3c1f9ad860ae339b425a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc295e6b1df3c1f9ad860ae339b425a6">&#9670;&nbsp;</a></span>queue() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device returned by the DeviceSelector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00125">125</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a8c0e01befca48b3eafda1cea81f515fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0e01befca48b3eafda1cea81f515fc">&#9670;&nbsp;</a></span>queue() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler using the device returned by the DeviceSelector provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00135">135</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="abcadc782fa728a919189ac213aafc792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcadc782fa728a919189ac213aafc792">&#9670;&nbsp;</a></span>queue() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance using the device provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00143">143</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="adef0b518923e220bf19b37e9e0ccf562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef0b518923e220bf19b37e9e0ccf562">&#9670;&nbsp;</a></span>queue() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler using the device provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00046">46</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ae3e7582f72008b3586a6c74405e36a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7582f72008b3586a6c74405e36a65">&#9670;&nbsp;</a></span>queue() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance that is associated with the context provided, using the device returned by the device selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00059">59</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="adfaac4845e98e5b3a1cfb32580a820be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaac4845e98e5b3a1cfb32580a820be">&#9670;&nbsp;</a></span>queue() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device__selector.html">device_selector</a> &amp;&#160;</td>
          <td class="paramname"><em>DeviceSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue instance with an async_handler that is associated with the context provided, using the device returned by the device selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">DeviceSelector</td><td>is an instance of SYCL device selector. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00023">23</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="context_8cpp_source.html#l00127">cl::sycl::context::get_devices()</a>, and <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ab117f911d1e7b44466a834ea780b5a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab117f911d1e7b44466a834ea780b5a3e">&#9670;&nbsp;</a></span>queue() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue associated with the given context, device and optional properties list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00065">65</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ac1fe5802e275e487a80a0cd677b5315c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fe5802e275e487a80a0cd677b5315c">&#9670;&nbsp;</a></span>queue() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1device.html">device</a> &amp;&#160;</td>
          <td class="paramname"><em>SyclDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecl_1_1sycl.html#a188564f925b1631d80a119dc0eb70817">async_handler</a> &amp;&#160;</td>
          <td class="paramname"><em>AsyncHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1property__list.html">property_list</a> &amp;&#160;</td>
          <td class="paramname"><em>PropList</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a SYCL queue associated with the given context, device, asynchronous exception handler and optional properties list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SyclContext</td><td>is an instance of SYCL context. </td></tr>
    <tr><td class="paramname">SyclDevice</td><td>is an instance of SYCL device. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
    <tr><td class="paramname">PropList</td><td>is a list of properties for queue construction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00039">39</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="CL_2sycl_2detail_2common_8hpp_source.html#l00198">cl::sycl::detail::getSyclObjImpl()</a>.</p>

</div>
</div>
<a id="ac2845668f9066c6f34926488374deda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2845668f9066c6f34926488374deda3">&#9670;&nbsp;</a></span>queue() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a SYCL queue with an optional async_handler from an OpenCL cl_command_queue. </p>
<p>The instance of cl_command_queue is retained on construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ClQueue</td><td>is a valid instance of OpenCL queue. </td></tr>
    <tr><td class="paramname">SyclContext</td><td>is a valid SYCL context. </td></tr>
    <tr><td class="paramname">AsyncHandler</td><td>is a SYCL asynchronous exception handler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dcb9e750fefa241890d191546cdc67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcb9e750fefa241890d191546cdc67a">&#9670;&nbsp;</a></span>queue() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::sycl::queue::queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa9e7a90764212f61d5eb70b545f15855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e7a90764212f61d5eb70b545f15855">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type <a class="el" href="classT.html">T</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00563">563</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacecl_1_1sycl_1_1detail.html#ade8963b9bb134c88a5801797d4f6afd9">cl::sycl::detail::memcpy()</a>.</p>

</div>
</div>
<a id="a2f8a24441e36d9d96c61d952f4a39265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8a24441e36d9d96c61d952f4a39265">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type <a class="el" href="classT.html">T</a> to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00595">595</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacecl_1_1sycl_1_1detail.html#ade8963b9bb134c88a5801797d4f6afd9">cl::sycl::detail::memcpy()</a>.</p>

</div>
</div>
<a id="a97d5116533678fca51a6152049e346b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d5116533678fca51a6152049e346b8">&#9670;&nbsp;</a></span>copy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of elements of type <a class="el" href="classT.html">T</a> to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00579">579</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespacecl_1_1sycl_1_1detail.html#ade8963b9bb134c88a5801797d4f6afd9">cl::sycl::detail::memcpy()</a>.</p>

</div>
</div>
<a id="a8d34aeaa32efc0f5942a63fb6afdd9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d34aeaa32efc0f5942a63fb6afdd9fb">&#9670;&nbsp;</a></span>ext_oneapi_submit_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::ext_oneapi_submit_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00333">333</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00051">_CODELOCFW</a>, and <a class="el" href="handler_8hpp_source.html#l02540">cl::sycl::handler::ext_oneapi_barrier()</a>.</p>

</div>
</div>
<a id="ad7e08338877f6e3f19684dfad383823d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e08338877f6e3f19684dfad383823d">&#9670;&nbsp;</a></span>ext_oneapi_submit_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::ext_oneapi_submit_barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then ext_oneapi_submit_barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00360">360</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00051">_CODELOCFW</a>, and <a class="el" href="handler_8hpp_source.html#l02540">cl::sycl::handler::ext_oneapi_barrier()</a>.</p>

</div>
</div>
<a id="a885877f9ae12cb55d61a24d2a179dbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885877f9ae12cb55d61a24d2a179dbba">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. <a class="el" href="classT.html">T</a> should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00438">438</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l02488">cl::sycl::handler::fill()</a>.</p>

</div>
</div>
<a id="a5446e07f9e23961503514d949a31fd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5446e07f9e23961503514d949a31fd67">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. <a class="el" href="classT.html">T</a> should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00468">468</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>, and <a class="el" href="handler_8hpp_source.html#l02488">cl::sycl::handler::fill()</a>.</p>

</div>
</div>
<a id="aeb1974405138a5c4791a55aa3cc596c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1974405138a5c4791a55aa3cc596c0">&#9670;&nbsp;</a></span>fill() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classT.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>Pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the specified memory with the specified pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is the pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Pattern</td><td>is the pattern to fill into the memory. <a class="el" href="classT.html">T</a> should be trivially copyable. </td></tr>
    <tr><td class="paramname">Count</td><td>is the number of times to fill Pattern into Ptr. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00451">451</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>, and <a class="el" href="handler_8hpp_source.html#l02488">cl::sycl::handler::fill()</a>.</p>

</div>
</div>
<a id="a5e63e95af49ba50358e68b2eab6962ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e63e95af49ba50358e68b2eab6962ea">&#9670;&nbsp;</a></span>get_backend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#ac67af1b2ee223fc75f90287790459336">backend</a> cl::sycl::queue::get_backend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the backend associated with this queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the backend associated with this queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00202">202</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">References <a class="el" href="backend__impl_8hpp_source.html#l00016">cl::sycl::detail::getImplBackend()</a>.</p>

</div>
</div>
<a id="aca23a41f6aa537c7038be5bf7ae135e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca23a41f6aa537c7038be5bf7ae135e3">&#9670;&nbsp;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1context.html">context</a> cl::sycl::queue::get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a valid instance of OpenCL queue, which is retained before being returned.</dd>
<dd>
an associated SYCL context. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00073">73</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="usm__impl_8cpp_source.html#l00416">cl::sycl::aligned_alloc()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00252">cl::sycl::aligned_alloc_device()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00328">cl::sycl::aligned_alloc_host()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00353">cl::sycl::aligned_alloc_shared()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00269">cl::sycl::free()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00386">cl::sycl::malloc()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00229">cl::sycl::malloc_device()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00286">cl::sycl::malloc_host()</a>, and <a class="el" href="usm__impl_8cpp_source.html#l00307">cl::sycl::malloc_shared()</a>.</p>

</div>
</div>
<a id="a2f991915c57bfb1d73992fde421d56c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f991915c57bfb1d73992fde421d56c8">&#9670;&nbsp;</a></span>get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1device.html">device</a> cl::sycl::queue::get_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>SYCL device this queue was constructed with. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00075">75</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="usm__impl_8cpp_source.html#l00416">cl::sycl::aligned_alloc()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00252">cl::sycl::aligned_alloc_device()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00353">cl::sycl::aligned_alloc_shared()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00386">cl::sycl::malloc()</a>, <a class="el" href="usm__impl_8cpp_source.html#l00229">cl::sycl::malloc_device()</a>, and <a class="el" href="usm__impl_8cpp_source.html#l00307">cl::sycl::malloc_shared()</a>.</p>

</div>
</div>
<a id="ae877ebb3989aa206124871b849b04813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae877ebb3989aa206124871b849b04813">&#9670;&nbsp;</a></span>get_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;info::queue Param&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1info_1_1param__traits.html">info::param_traits</a>&lt; <a class="el" href="namespacecl_1_1sycl_1_1info.html#a298d56c26b4eec2a4d4fb1649e2d1063">info::queue</a>, Param &gt;::return_type cl::sycl::queue::get_info</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries SYCL queue for information. </p>
<p>The return type depends on information being queried. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00168">168</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a6f38ca19d393ca3185991db28dabab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f38ca19d393ca3185991db28dabab83">&#9670;&nbsp;</a></span>get_native()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;backend Backend&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecl_1_1sycl.html#a26f419bb807dc7762b3fdb499790e133">backend_return_t</a>&lt;Backend, <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a>&gt; cl::sycl::queue::get_native </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the native handle of the SYCL queue. </p>
<dl class="section return"><dt>Returns</dt><dd>a native handle, the type of which defined by the backend. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01062">1062</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="adddf14c63128569224aad4967408ecf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddf14c63128569224aad4967408ecf1">&#9670;&nbsp;</a></span>get_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertyT cl::sycl::queue::get_property</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a copy of the property of type PropertyT that the queue was constructed with. If the queue was not constructed with the PropertyT property, an invalid_object_error SYCL exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00184">184</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ab24e060ff8995d3194bc5ead4d2abb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24e060ff8995d3194bc5ead4d2abb3c">&#9670;&nbsp;</a></span>has_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cl::sycl::queue::has_property</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the queue was constructed with property specified by PropertyT. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00180">180</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="adfbbd03cb8e3021fab6835538ff72a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbbd03cb8e3021fab6835538ff72a65">&#9670;&nbsp;</a></span>is_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cl::sycl::queue::is_host </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this queue is a SYCL host queue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00077">77</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue_8hpp_source.html#l00292">submit()</a>.</p>

</div>
</div>
<a id="af8244d40020d5524492549a66cf4396e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8244d40020d5524492549a66cf4396e">&#9670;&nbsp;</a></span>is_in_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cl::sycl::queue::is_in_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the queue is in order or OoO. </p>
<p>Equivalent to <a class="el" href="classcl_1_1sycl_1_1queue.html#ab24e060ff8995d3194bc5ead4d2abb3c">has_property&lt;property::queue::in_order&gt;()</a> </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00198">198</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a4d2a9b32cd6237e4b6573d816dd299f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2a9b32cd6237e4b6573d816dd299f9">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00112">112</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a0ed90f84a4ed2e9c62828bd9fee09d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed90f84a4ed2e9c62828bd9fee09d64">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00121">121</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a70703277950f9b47866c517a9d4e969c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70703277950f9b47866c517a9d4e969c">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Advice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00116">116</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="acdf855d45f7c048c839e283c036a05cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf855d45f7c048c839e283c036a05cb">&#9670;&nbsp;</a></span>mem_advise() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::mem_advise </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pi_8h.html#a286bf19d79f0e65f8137d269f037798b">pi_mem_advice</a>&#160;</td>
          <td class="paramname"><em>Advice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides additional information to the underlying runtime about how different allocations are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the allocation. </td></tr>
    <tr><td class="paramname">Length</td><td>is a number of bytes in the allocation. </td></tr>
    <tr><td class="paramname">Advice</td><td>is a device-defined advice for the specified allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing advice operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00108">108</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a6bc6a510e5e9abcbf1ee904d4b86edbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc6a510e5e9abcbf1ee904d4b86edbf">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00095">95</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aeebba5b554a60ee51faac4214a1b5074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebba5b554a60ee51faac4214a1b5074">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00103">103</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a82dd44ca8026ba7e4e7c585496dfa870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dd44ca8026ba7e4e7c585496dfa870">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from one memory region to another, both pointed by USM pointers. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if either</td></tr>
    <tr><td class="paramname">Dest</td><td>or</td></tr>
    <tr><td class="paramname">Src</td><td>is nullptr. The behavior is undefined if any of the pointer parameters is invalid.</td></tr>
    <tr><td class="paramname">Dest</td><td>is a USM pointer to the destination memory. </td></tr>
    <tr><td class="paramname">Src</td><td>is a USM pointer to the source memory. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to copy. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing copy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00099">99</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="afcd93967ba2484d50786c22b4148cb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd93967ba2484d50786c22b4148cb67">&#9670;&nbsp;</a></span>memset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00082">82</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a5c009de8f034e70aacf59ec6c137de24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c009de8f034e70aacf59ec6c137de24">&#9670;&nbsp;</a></span>memset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00090">90</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a4891f4e76fc65ac03e0298ed11462814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4891f4e76fc65ac03e0298ed11462814">&#9670;&nbsp;</a></span>memset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the memory pointed by a USM pointer with the value specified. </p>
<p>No operations is done if</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Count</td><td>is zero. An exception is thrown if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is nullptr. The behavior is undefined if</td></tr>
    <tr><td class="paramname">Ptr</td><td>is invalid.</td></tr>
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to fill. </td></tr>
    <tr><td class="paramname">Value</td><td>is a value to be set. Value is cast as an unsigned char. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to fill. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00086">86</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="aa26f12abfa503b0d395333e32381bfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26f12abfa503b0d395333e32381bfc9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cl::sycl::queue::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00217">217</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="a01d6213fd30826aec4dfa580c5ec7e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d6213fd30826aec4dfa580c5ec7e66">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a>&amp; cl::sycl::queue::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4f2545f918fa3745bde9e80f21a6048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f2545f918fa3745bde9e80f21a6048">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a>&amp; cl::sycl::queue::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc6bd404213c1c28d9193fe1d18c15ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6bd404213c1c28d9193fe1d18c15ec">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cl::sycl::queue::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00215">215</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

</div>
</div>
<a id="ad1e6845be9c7ce965fce626b14f1c0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e6845be9c7ce965fce626b14f1c0ac">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>ExecutionRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExecutionRange</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00962">962</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="af2ef2f7ba7b48430719139c9bef971df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ef2f7ba7b48430719139c9bef971df">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>ExecutionRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExecutionRange</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01006">1006</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="a089901a695ed39ad3fcecd523ecef3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089901a695ed39ad3fcecd523ecef3dd">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>ExecutionRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExecutionRange</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00983">983</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="acec39afb79e7005e9b09ae7a1c48a08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec39afb79e7005e9b09ae7a1c48a08c">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims, typename Reduction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>ExecutionRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reduction&#160;</td>
          <td class="paramname"><em>Redu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + <a class="el" href="classcl_1_1sycl_1_1nd__range.html" title="Defines the iteration domain of both the work-groups and the overall dispatch.">nd_range</a> that specifies global, local sizes and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ExecutionRange</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">Redu</td><td>is a reduction operation </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l01029">1029</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="acb27ee1c41ae8ff975e7e322253fe917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb27ee1c41ae8ff975e7e322253fe917">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00761">761</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a66d2905826b71870ecc8ea00906cb882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d2905826b71870ecc8ea00906cb882">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00847">847</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a85c5639955ac2cac52b0469838ad32db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c5639955ac2cac52b0469838ad32db">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00801">801</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="ab0fae91746e12707b246235c0094a96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fae91746e12707b246235c0094a96b">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00774">774</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a07ebfa7934ec12e9cb08c87a111b75ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ebfa7934ec12e9cb08c87a111b75ff">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00863">863</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a868009a8248b56b1ba0c444c374af456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868009a8248b56b1ba0c444c374af456">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 2 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00816">816</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="aa0a03639455a508296a2f464a8cc6c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a03639455a508296a2f464a8cc6c9d">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00787">787</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="acfa699830b8c540a01fc8d559a6ce8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa699830b8c540a01fc8d559a6ce8c0">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00879">879</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a352a66cbfe7bb8caade69091ab19cf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352a66cbfe7bb8caade69091ab19cf42">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range that specifies global size only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00831">831</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a1ce4d18382d95b5de4509581f76af298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce4d18382d95b5de4509581f76af298">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00895">895</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a3aab50a1ad65bae769aa142c404a121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aab50a1ad65bae769aa142c404a121e">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00940">940</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="a82473f85af862ebd751afabc266a36d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82473f85af862ebd751afabc266a36d1">&#9670;&nbsp;</a></span>parallel_for() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType , int Dims&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::parallel_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1range.html">range</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>NumWorkItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1id.html">id</a>&lt; Dims &gt;&#160;</td>
          <td class="paramname"><em>WorkItemOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parallel_for version with a kernel represented as a lambda + range and offset that specify global size and global offset correspondingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWorkItems</td><td>is a range that specifies the work space of the kernel </td></tr>
    <tr><td class="paramname">WorkItemOffset</td><td>specifies the offset for each work item id </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00916">916</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="a5516a9023e6a5c2def87689808eee11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5516a9023e6a5c2def87689808eee11c">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00648">648</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00744">cl::sycl::handler::prefetch()</a>.</p>

</div>
</div>
<a id="a1efd060dd53829ccf8d9649b7b73150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efd060dd53829ccf8d9649b7b73150c">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00676">676</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>, and <a class="el" href="handler_8cpp_source.html#l00744">cl::sycl::handler::prefetch()</a>.</p>

</div>
</div>
<a id="abc938e9e2e814ebcaa49bf496b3d0878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc938e9e2e814ebcaa49bf496b3d0878">&#9670;&nbsp;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::prefetch </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides hints to the runtime library that data should be made available on a device earlier than Unified Shared Memory would normally require it to be available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ptr</td><td>is a USM pointer to the memory to be prefetched to the device. </td></tr>
    <tr><td class="paramname">Count</td><td>is a number of bytes to be prefetched. </td></tr>
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an event representing prefetch operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00660">660</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>, and <a class="el" href="handler_8cpp_source.html#l00744">cl::sycl::handler::prefetch()</a>.</p>

</div>
</div>
<a id="a4e62095771bd8eafd97298291e1acd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e62095771bd8eafd97298291e1acd65">&#9670;&nbsp;</a></span>single_task() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00689">689</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a955b207732047cc19bb5d01026969892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955b207732047cc19bb5d01026969892">&#9670;&nbsp;</a></span>single_task() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::single_task </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>DepEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvents</td><td>is a vector of events that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00736">736</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="a8f99bcfefc29069a31b3bf82b990f09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f99bcfefc29069a31b3bf82b990f09e">&#9670;&nbsp;</a></span>single_task() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName  = detail::auto_name, typename KernelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::single_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>DepEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#ad45daf4b7f11d72fd70ca81b5cd7d6e1">_KERNELFUNCPARAM</a>(<a class="el" href="pi__esimd__emulator_8cpp.html#a9903e50fda5881be885f6e5131ab5bdf">KernelFunc</a>) <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>single_task version with a kernel represented as a lambda. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DepEvent</td><td>is an event that specifies the kernel dependencies </td></tr>
    <tr><td class="paramname">KernelFunc</td><td>is the Kernel functor or lambda </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>contains the code location of user code </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00711">711</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="handler_8cpp_source.html#l00796">cl::sycl::handler::depends_on()</a>.</p>

</div>
</div>
<a id="a74cfc07a129881fbb0782cfc8092c150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cfc07a129881fbb0782cfc8092c150">&#9670;&nbsp;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classT.html">T</a> CGF <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a command group function object to the queue, in order to be scheduled for execution on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CGF</td><td>is a function object containing command group. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object for the submitted command group. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00252">252</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a403befa777925c4d2629234e38a73fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403befa777925c4d2629234e38a73fd2">&#9670;&nbsp;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classT.html">T</a>&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a> &amp;SecondaryQueue <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits a command group function object to the queue, in order to be scheduled for execution on the device. </p>
<p>On a kernel error, this command group function object is then scheduled for execution on a secondary queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CGF</td><td>is a function object containing command group. </td></tr>
    <tr><td class="paramname">SecondaryQueue</td><td>is a fallback SYCL queue. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00292">292</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>, and <a class="el" href="queue_8cpp_source.html#l00077">is_host()</a>.</p>

</div>
</div>
<a id="a03fd5166ecf040891c2e1c2eb8210d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fd5166ecf040891c2e1c2eb8210d94">&#9670;&nbsp;</a></span>submit_barrier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::submit_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all commands previously submitted to this queue have entered the complete state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00346">346</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a99a1938f7ebd34b9b7389189b370f597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a1938f7ebd34b9b7389189b370f597">&#9670;&nbsp;</a></span>submit_barrier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a> cl::sycl::queue::submit_barrier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> &gt; &amp;WaitList <a class="el" href="queue_8hpp.html#a67e15f570b199ff3280ea8c1cdc3e644">_CODELOCPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prevents any commands submitted afterward to this queue from executing until all events in WaitList have entered the complete state. </p>
<p>If WaitList is empty, then submit_barrier has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">WaitList</td><td>is a vector of valid SYCL events that need to complete before barrier command can be executed. </td></tr>
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SYCL event object, which corresponds to the queue the command group is being enqueued on. </dd></dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00378">378</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="ae5c39ed682422e4e525fe0a01e8b7ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c39ed682422e4e525fe0a01e8b7ad9">&#9670;&nbsp;</a></span>throw_asynchronous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::queue::throw_asynchronous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any asynchronous errors have been produced by the queue and if so reports them to the async_handler passed on the queue construction. </p>
<p>If no async_handler was provided then asynchronous exceptions will be lost. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00080">80</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="ae88a60a32d5695334a6a20246acf5ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88a60a32d5695334a6a20246acf5ee3">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::queue::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a blocking wait for the completion of all enqueued tasks in the queue. </p>
<p>Synchronous errors will be reported through SYCL exceptions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00388">388</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a7304541935e8bec0c65b1490e05edc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7304541935e8bec0c65b1490e05edc2f">&#9670;&nbsp;</a></span>wait_and_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::queue::wait_and_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="queue_8hpp.html#af26913b7095fdf2aa00d51f4e1b5bdf7">_CODELOCONLYPARAM</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a blocking wait for the completion of all enqueued tasks in the queue. </p>
<p>Synchronous errors will be reported through SYCL exceptions. Asynchronous errors will be passed to the async_handler passed to the queue on construction. If no async_handler was provided then asynchronous exceptions will be lost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CodeLoc</td><td>is the code location of the submit call (default argument) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="queue_8hpp_source.html#l00402">402</a> of file <a class="el" href="queue_8hpp_source.html">queue.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8hpp_source.html#l00050">_CODELOCARG</a>.</p>

</div>
</div>
<a id="a967e0150616bc53f07da9d949dffe431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967e0150616bc53f07da9d949dffe431">&#9670;&nbsp;</a></span>wait_and_throw_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::queue::wait_and_throw_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcl_1_1sycl_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxy method for wait_and_throw to forward the code location information to the implementation. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00162">162</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<a id="a0d8abb9c998a175a7e115b0b475cdc76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8abb9c998a175a7e115b0b475cdc76">&#9670;&nbsp;</a></span>wait_proxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cl::sycl::queue::wait_proxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcl_1_1sycl_1_1detail_1_1code__location.html">detail::code_location</a> &amp;&#160;</td>
          <td class="paramname"><em>CodeLoc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxy method for wait to forward the code location information to the implementation. </p>

<p class="definition">Definition at line <a class="el" href="queue_8cpp_source.html#l00158">158</a> of file <a class="el" href="queue_8cpp_source.html">queue.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a71492293d0386f542d120a1fc3dfbb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71492293d0386f542d120a1fc3dfbb55">&#9670;&nbsp;</a></span>detail::createSyclObjFromImpl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classT.html">T</a> <a class="el" href="namespacecl_1_1sycl_1_1detail.html#abf270973bb66a47f8e8aebddd06ac8aa">detail::createSyclObjFromImpl</a> </td>
          <td>(</td>
          <td class="paramtype">decltype(T::impl)&#160;</td>
          <td class="paramname"><em>ImplObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/CL/sycl/<a class="el" href="queue_8hpp_source.html">queue.hpp</a></li>
<li>source/<a class="el" href="queue_8cpp_source.html">queue.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1queue.html">queue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
