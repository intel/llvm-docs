<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: syclcompat Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacesyclcompat.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">syclcompat Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesyclcompat_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacesyclcompat_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic extension to implement standard APIs in std::atomic. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1experimental"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1experimental.html">experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1global__id"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1global__id.html">global_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1global__range"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1global__range.html">global_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1local__id"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1local__id.html">local_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1local__range"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1local__range.html">local_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1work__group__id"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1work__group__id.html">work_group_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesyclcompat_1_1work__group__range"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat_1_1work__group__range.html">work_group_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1atomic.html">atomic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1device__info.html">device_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">device extension  <a href="classsyclcompat_1_1device__ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1kernel__function__info.html">kernel_function_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1kernel__function.html">kernel_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1abs.html">abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::abs wrapper functors.  <a href="structsyclcompat_1_1abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1abs__diff.html">abs_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#aa9236143fabea8fadb52dd9c796b47a8">sycl::abs_diff</a> wrapper functors.  <a href="structsyclcompat_1_1abs__diff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1add__sat.html">add_sat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::add_sat wrapper functors.  <a href="structsyclcompat_1_1add__sat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1rhadd.html">rhadd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::rhadd wrapper functors.  <a href="structsyclcompat_1_1rhadd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1hadd.html">hadd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#a5575957639958adc1535884f2440fdc9">sycl::hadd</a> wrapper functors.  <a href="structsyclcompat_1_1hadd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1maximum.html">maximum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#ac1ccdc393a3b0aaeb3f37b6b41c691f8">sycl::max</a> wrapper functors.  <a href="structsyclcompat_1_1maximum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1minimum.html">minimum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespacesycl_1_1__V1.html#a4072af1569b9ea628fd1222a82ea624a">sycl::min</a> wrapper functors.  <a href="structsyclcompat_1_1minimum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1sub__sat.html">sub_sat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sycl::sub_sat wrapper functors.  <a href="structsyclcompat_1_1sub__sat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pitched 2D/3D memory data.  <a href="classsyclcompat_1_1pitched__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1accessor.html">accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">accessor used as device function parameter.  <a href="classsyclcompat_1_1accessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1accessor_3_01T_00_01Memory_00_013_01_4.html">accessor&lt; T, Memory, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1accessor_3_01T_00_01Memory_00_012_01_4.html">accessor&lt; T, Memory, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device variable with address space of shared or global.  <a href="classsyclcompat_1_1device__memory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1device__memory_3_01T_00_01Memory_00_010_01_4.html">device_memory&lt; T, Memory, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1pointer__attributes.html">pointer_attributes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1type__identity.html">type_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsyclcompat_1_1arith.html">arith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1args__selector.html">args_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyclcompat_1_1args__selector_3_01n__nondefault__params_00_01n__default__params_00_01R_07Ts_8_8_8_08_4.html">args_selector&lt; n_nondefault_params, n_default_params, R(Ts...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsyclcompat_1_1args__selector.html">args_selector</a> is a helper class for extracting arguments from an array of pointers to arguments or buffer of arguments to pass to a kernel function.  <a href="classsyclcompat_1_1args__selector_3_01n__nondefault__params_00_01n__default__params_00_01R_07Ts_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4570dc377234b5e434c0acfc4c5d01da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4570dc377234b5e434c0acfc4c5d01da">event_ptr</a> = <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> *</td></tr>
<tr class="separator:a4570dc377234b5e434c0acfc4c5d01da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6e9f8a69c836759d611d115bf0a6f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4d6e9f8a69c836759d611d115bf0a6f7">queue_ptr</a> = <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> *</td></tr>
<tr class="separator:a4d6e9f8a69c836759d611d115bf0a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c51cceeff1ab9a650f1a5022ea75cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#af5c51cceeff1ab9a650f1a5022ea75cf">device_ptr</a> = char *</td></tr>
<tr class="separator:af5c51cceeff1ab9a650f1a5022ea75cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e80f614a873f90786e7c52680708cc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a36e80f614a873f90786e7c52680708cc">kernel_functor</a>) (<a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;, const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; 3 &gt; &amp;, unsigned int, void **, void **)</td></tr>
<tr class="separator:a36e80f614a873f90786e7c52680708cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d334cfc720dcdf7c959caa4da33343"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a20d334cfc720dcdf7c959caa4da33343">byte_t</a> = uint8_t</td></tr>
<tr class="separator:a20d334cfc720dcdf7c959caa4da33343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f379ff028549b1c4312a23c39753e43"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Dimension&gt; </td></tr>
<tr class="memitem:a8f379ff028549b1c4312a23c39753e43"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8f379ff028549b1c4312a23c39753e43">global_memory</a> = <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt; T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea9c70933aff6b2a6d08c687a6cbb6b765">memory_region::global</a>, Dimension &gt;</td></tr>
<tr class="separator:a8f379ff028549b1c4312a23c39753e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7404b0ace19666b93b631cfeb643e41d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Dimension&gt; </td></tr>
<tr class="memitem:a7404b0ace19666b93b631cfeb643e41d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7404b0ace19666b93b631cfeb643e41d">constant_memory</a> = <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt; T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea617ac08757d38a5a7ed91c224f0e90a0">memory_region::constant</a>, Dimension &gt;</td></tr>
<tr class="separator:a7404b0ace19666b93b631cfeb643e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299845541af5f774b44ba0e522721774"><td class="memTemplParams" colspan="2">template&lt;class T , size_t Dimension&gt; </td></tr>
<tr class="memitem:a299845541af5f774b44ba0e522721774"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a299845541af5f774b44ba0e522721774">shared_memory</a> = <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt; T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7eaef16beba4bcd6c1de447a651f054be05">memory_region::usm_shared</a>, Dimension &gt;</td></tr>
<tr class="separator:a299845541af5f774b44ba0e522721774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b19671aff0ceba14c1a3f5f1615e7e8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7b19671aff0ceba14c1a3f5f1615e7e8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a> = typename <a class="el" href="structsyclcompat_1_1type__identity.html">type_identity</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a7b19671aff0ceba14c1a3f5f1615e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cc02af8f079b9ed7c68a35a2119d3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3cc02af8f079b9ed7c68a35a2119d3f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">arith_t</a> = typename <a class="el" href="structsyclcompat_1_1arith.html">arith</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ad3cc02af8f079b9ed7c68a35a2119d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12db87a8e1dcae8108de2263e2a9150"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad12db87a8e1dcae8108de2263e2a9150">err0</a> = <a class="el" href="classsyclcompat_1_1detail_1_1generic__error__type.html">detail::generic_error_type</a>&lt; struct err0_tag, int &gt;</td></tr>
<tr class="separator:ad12db87a8e1dcae8108de2263e2a9150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9b4ad277d57da5476387507f0576a0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#adf9b4ad277d57da5476387507f0576a0">err1</a> = <a class="el" href="classsyclcompat_1_1detail_1_1generic__error__type.html">detail::generic_error_type</a>&lt; struct err1_tag, int &gt;</td></tr>
<tr class="separator:adf9b4ad277d57da5476387507f0576a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac9df5b0e17a975d2fd8feef36f0ce4ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac9df5b0e17a975d2fd8feef36f0ce4ba">error_code</a> { <a class="el" href="namespacesyclcompat.html#ac9df5b0e17a975d2fd8feef36f0ce4baaf12697db8c07bf0ca36f6ab817a291f3">SUCCESS</a> = 0
, <a class="el" href="namespacesyclcompat.html#ac9df5b0e17a975d2fd8feef36f0ce4baa761fb0a1e381b9c67dd17e512126df78">BACKEND_ERROR</a> = 1
, <a class="el" href="namespacesyclcompat.html#ac9df5b0e17a975d2fd8feef36f0ce4baa1020859b0b70472d8b2eebfbbd7035ed">DEFAULT_ERROR</a> = 999
 }</td></tr>
<tr class="separator:ac9df5b0e17a975d2fd8feef36f0ce4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565b2d3d3c1d6ba009f9e62129cb5c7e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7e">memory_region</a> { <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea9c70933aff6b2a6d08c687a6cbb6b765">global</a> = 0
, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea617ac08757d38a5a7ed91c224f0e90a0">constant</a>
, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7eaf5ddaf0ca7929578b408c909429f68f2">local</a>
, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7eaef16beba4bcd6c1de447a651f054be05">usm_shared</a>
 }</td></tr>
<tr class="separator:a565b2d3d3c1d6ba009f9e62129cb5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81aef3206734209057e7fa5429b849c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad81aef3206734209057e7fa5429b849c">target</a> { <a class="el" href="namespacesyclcompat.html#ad81aef3206734209057e7fa5429b849ca913f9c49dcb544e2087cee284f4a00b7">device</a>
, <a class="el" href="namespacesyclcompat.html#ad81aef3206734209057e7fa5429b849caf5ddaf0ca7929578b408c909429f68f2">local</a>
 }</td></tr>
<tr class="separator:ad81aef3206734209057e7fa5429b849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:affd5fb03de12340076f5de7ce46b9827"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:affd5fb03de12340076f5de7ce46b9827"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#affd5fb03de12340076f5de7ce46b9827">atomic_fetch_add</a> (T *addr, <a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">arith_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:affd5fb03de12340076f5de7ce46b9827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add the value operand to the value at the addr and assign the result to the value at addr.  <a href="namespacesyclcompat.html#affd5fb03de12340076f5de7ce46b9827">More...</a><br /></td></tr>
<tr class="separator:affd5fb03de12340076f5de7ce46b9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b4ddb817c99930c23a03f51891b44"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:a746b4ddb817c99930c23a03f51891b44"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a746b4ddb817c99930c23a03f51891b44">atomic_fetch_sub</a> (T *addr, <a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">arith_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:a746b4ddb817c99930c23a03f51891b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtract the value operand from the value at the addr and assign the result to the value at addr.  <a href="namespacesyclcompat.html#a746b4ddb817c99930c23a03f51891b44">More...</a><br /></td></tr>
<tr class="separator:a746b4ddb817c99930c23a03f51891b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0a22ac7643dfaeb1b9cb98bfda2e00"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:a4e0a22ac7643dfaeb1b9cb98bfda2e00"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4e0a22ac7643dfaeb1b9cb98bfda2e00">atomic_fetch_and</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:a4e0a22ac7643dfaeb1b9cb98bfda2e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically perform a bitwise AND between the value operand and the value at the addr and assign the result to the value at addr.  <a href="namespacesyclcompat.html#a4e0a22ac7643dfaeb1b9cb98bfda2e00">More...</a><br /></td></tr>
<tr class="separator:a4e0a22ac7643dfaeb1b9cb98bfda2e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06163f1b6ca4a73c7f75ea38cbb7b18"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:ae06163f1b6ca4a73c7f75ea38cbb7b18"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae06163f1b6ca4a73c7f75ea38cbb7b18">atomic_fetch_or</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:ae06163f1b6ca4a73c7f75ea38cbb7b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically or the value at the addr with the value operand, and assign the result to the value at addr.  <a href="namespacesyclcompat.html#ae06163f1b6ca4a73c7f75ea38cbb7b18">More...</a><br /></td></tr>
<tr class="separator:ae06163f1b6ca4a73c7f75ea38cbb7b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a04a345069fdf52c36403238b0d345"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:ab0a04a345069fdf52c36403238b0d345"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab0a04a345069fdf52c36403238b0d345">atomic_fetch_xor</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:ab0a04a345069fdf52c36403238b0d345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically xor the value at the addr with the value operand, and assign the result to the value at addr.  <a href="namespacesyclcompat.html#ab0a04a345069fdf52c36403238b0d345">More...</a><br /></td></tr>
<tr class="separator:ab0a04a345069fdf52c36403238b0d345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa744bf05c50d2f850c04b23097450b36"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:aa744bf05c50d2f850c04b23097450b36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa744bf05c50d2f850c04b23097450b36">atomic_fetch_min</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:aa744bf05c50d2f850c04b23097450b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically calculate the minimum of the value at addr and the value operand and assign the result to the value at addr.  <a href="namespacesyclcompat.html#aa744bf05c50d2f850c04b23097450b36">More...</a><br /></td></tr>
<tr class="separator:aa744bf05c50d2f850c04b23097450b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1c0fa55fcb68c778eb14288d33b7c4"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:a8f1c0fa55fcb68c778eb14288d33b7c4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8f1c0fa55fcb68c778eb14288d33b7c4">atomic_fetch_max</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:a8f1c0fa55fcb68c778eb14288d33b7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically calculate the maximum of the value at addr and the value operand and assign the result to the value at addr.  <a href="namespacesyclcompat.html#a8f1c0fa55fcb68c778eb14288d33b7c4">More...</a><br /></td></tr>
<tr class="separator:a8f1c0fa55fcb68c778eb14288d33b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2bb67d94f0e525c9c768646b30f80"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device&gt; </td></tr>
<tr class="memitem:abad2bb67d94f0e525c9c768646b30f80"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#abad2bb67d94f0e525c9c768646b30f80">atomic_fetch_compare_dec</a> (unsigned int *addr, unsigned int operand)</td></tr>
<tr class="memdesc:abad2bb67d94f0e525c9c768646b30f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically set <code>operand</code> to the value stored in <code>addr</code>, if old value stored in <code>addr</code> is equal to zero or greater than <code>operand</code>, else decrease the value stored in <code>addr</code>.  <a href="namespacesyclcompat.html#abad2bb67d94f0e525c9c768646b30f80">More...</a><br /></td></tr>
<tr class="separator:abad2bb67d94f0e525c9c768646b30f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd2aa5acc6e278fbfeab1d80afd7739"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device&gt; </td></tr>
<tr class="memitem:a6fd2aa5acc6e278fbfeab1d80afd7739"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6fd2aa5acc6e278fbfeab1d80afd7739">atomic_fetch_compare_inc</a> (unsigned int *addr, unsigned int operand)</td></tr>
<tr class="memdesc:a6fd2aa5acc6e278fbfeab1d80afd7739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment the value stored in <code>addr</code> if old value stored in <code>addr</code> is less than <code>operand</code>, else set 0 to the value stored in <code>addr</code>.  <a href="namespacesyclcompat.html#a6fd2aa5acc6e278fbfeab1d80afd7739">More...</a><br /></td></tr>
<tr class="separator:a6fd2aa5acc6e278fbfeab1d80afd7739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435aa9b16d17415acbdda668d97a82a"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:af435aa9b16d17415acbdda668d97a82a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#af435aa9b16d17415acbdda668d97a82a">atomic_exchange</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; operand)</td></tr>
<tr class="memdesc:af435aa9b16d17415acbdda668d97a82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchange the value at the address addr with the value operand.  <a href="namespacesyclcompat.html#af435aa9b16d17415acbdda668d97a82a">More...</a><br /></td></tr>
<tr class="separator:af435aa9b16d17415acbdda668d97a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c77d82466c5c8bdc7aab25c6a6ff5e0"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:a5c77d82466c5c8bdc7aab25c6a6ff5e0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a5c77d82466c5c8bdc7aab25c6a6ff5e0">atomic_compare_exchange_strong</a> (<a class="el" href="classsycl_1_1__V1_1_1multi__ptr.html">sycl::multi_ptr</a>&lt; T, sycl::access::address_space::generic_space &gt; addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; expected, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; desired, <a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a> success=sycl::memory_order::relaxed, <a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a> fail=sycl::memory_order::relaxed)</td></tr>
<tr class="memdesc:a5c77d82466c5c8bdc7aab25c6a6ff5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compare the value at <code>addr</code> to the value expected and exchange with the value desired if the value at <code>addr</code> is equal to the value expected.  <a href="namespacesyclcompat.html#a5c77d82466c5c8bdc7aab25c6a6ff5e0">More...</a><br /></td></tr>
<tr class="separator:a5c77d82466c5c8bdc7aab25c6a6ff5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37ed7afef52f6347ecb606cf3397461"><td class="memTemplParams" colspan="2">template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </td></tr>
<tr class="memitem:ac37ed7afef52f6347ecb606cf3397461"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac37ed7afef52f6347ecb606cf3397461">atomic_compare_exchange_strong</a> (T *addr, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; expected, <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; desired, <a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a> success=sycl::memory_order::relaxed, <a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a> fail=sycl::memory_order::relaxed)</td></tr>
<tr class="memdesc:ac37ed7afef52f6347ecb606cf3397461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compare the value at <code>addr</code> to the value expected and exchange with the value desired if the value at <code>addr</code> is equal to the value expected.  <a href="namespacesyclcompat.html#ac37ed7afef52f6347ecb606cf3397461">More...</a><br /></td></tr>
<tr class="separator:ac37ed7afef52f6347ecb606cf3397461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32b20f10c68bdb00e5d72b865c0eb1e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa32b20f10c68bdb00e5d72b865c0eb1e">destroy_event</a> (<a class="el" href="namespacesyclcompat.html#a4570dc377234b5e434c0acfc4c5d01da">event_ptr</a> event)</td></tr>
<tr class="memdesc:aa32b20f10c68bdb00e5d72b865c0eb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy <code>event</code> pointed memory.  <a href="namespacesyclcompat.html#aa32b20f10c68bdb00e5d72b865c0eb1e">More...</a><br /></td></tr>
<tr class="separator:aa32b20f10c68bdb00e5d72b865c0eb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110c1e925095492f2b25c879141ab136"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a110c1e925095492f2b25c879141ab136">create_queue</a> (bool print_on_async_exceptions=false, bool in_order=true)</td></tr>
<tr class="separator:a110c1e925095492f2b25c879141ab136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7fd6490005df50af1a36cf808035b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a> ()</td></tr>
<tr class="memdesc:a38b7fd6490005df50af1a36cf808035b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get the default queue of current device in device manager.  <a href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">More...</a><br /></td></tr>
<tr class="separator:a38b7fd6490005df50af1a36cf808035b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3223fe4dfc1766754816ae2755765a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab3223fe4dfc1766754816ae2755765a2">set_default_queue</a> (const <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;q)</td></tr>
<tr class="memdesc:ab3223fe4dfc1766754816ae2755765a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to change the default queue of the current device in the device manager If the device extension saved queue is the default queue, the previous saved queue will be overwritten as well.  <a href="namespacesyclcompat.html#ab3223fe4dfc1766754816ae2755765a2">More...</a><br /></td></tr>
<tr class="separator:ab3223fe4dfc1766754816ae2755765a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea882bd7bed0d3038f4692b004c5d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a58ea882bd7bed0d3038f4692b004c5d5">wait</a> (<a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="separator:a58ea882bd7bed0d3038f4692b004c5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93cf9b8fbc72c4f86eaf47ca2742c72"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad93cf9b8fbc72c4f86eaf47ca2742c72">wait_and_throw</a> (<a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="separator:ad93cf9b8fbc72c4f86eaf47ca2742c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74920a687e04d5ecb59233c777f13416"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a74920a687e04d5ecb59233c777f13416">get_current_device_id</a> ()</td></tr>
<tr class="memdesc:a74920a687e04d5ecb59233c777f13416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get the id of current device in device manager.  <a href="namespacesyclcompat.html#a74920a687e04d5ecb59233c777f13416">More...</a><br /></td></tr>
<tr class="separator:a74920a687e04d5ecb59233c777f13416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b3ae5459d3498b3888b2688acefab4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a59b3ae5459d3498b3888b2688acefab4">get_current_device</a> ()</td></tr>
<tr class="memdesc:a59b3ae5459d3498b3888b2688acefab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get the current device.  <a href="namespacesyclcompat.html#a59b3ae5459d3498b3888b2688acefab4">More...</a><br /></td></tr>
<tr class="separator:a59b3ae5459d3498b3888b2688acefab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc62347d3a31e511868a76c15de26829"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acc62347d3a31e511868a76c15de26829">get_device</a> (unsigned int id)</td></tr>
<tr class="memdesc:acc62347d3a31e511868a76c15de26829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get a device by id.  <a href="namespacesyclcompat.html#acc62347d3a31e511868a76c15de26829">More...</a><br /></td></tr>
<tr class="separator:acc62347d3a31e511868a76c15de26829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee26fe4fe6f4ca9d1cf164999a65139"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1context.html">sycl::context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acee26fe4fe6f4ca9d1cf164999a65139">get_default_context</a> ()</td></tr>
<tr class="memdesc:acee26fe4fe6f4ca9d1cf164999a65139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get the context of the default queue of current device in device manager.  <a href="namespacesyclcompat.html#acee26fe4fe6f4ca9d1cf164999a65139">More...</a><br /></td></tr>
<tr class="separator:acee26fe4fe6f4ca9d1cf164999a65139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c887b868bc53711bbaf533385e2975c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9c887b868bc53711bbaf533385e2975c">cpu_device</a> ()</td></tr>
<tr class="memdesc:a9c887b868bc53711bbaf533385e2975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Util function to get a CPU device.  <a href="namespacesyclcompat.html#a9c887b868bc53711bbaf533385e2975c">More...</a><br /></td></tr>
<tr class="separator:a9c887b868bc53711bbaf533385e2975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd95977e9335b81802f7d6b5e2b553b3"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afd95977e9335b81802f7d6b5e2b553b3">select_device</a> (unsigned int id)</td></tr>
<tr class="separator:afd95977e9335b81802f7d6b5e2b553b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec6e3777ccafd2c25a065e8caf39032"><td class="memTemplParams" colspan="2">template&lt;class DeviceSelector &gt; </td></tr>
<tr class="memitem:a6ec6e3777ccafd2c25a065e8caf39032"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::is_invocable_r_v&lt; int, DeviceSelector, const <a class="el" href="classsycl_1_1__V1_1_1device.html">sycl::device</a> &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6ec6e3777ccafd2c25a065e8caf39032">select_device</a> (const DeviceSelector &amp;selector=<a class="el" href="namespacesycl_1_1__V1.html#ac52b02260b49dbe11483b0541c5c6c42">sycl::gpu_selector_v</a>)</td></tr>
<tr class="separator:a6ec6e3777ccafd2c25a065e8caf39032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa24f1a604f305d6e80695fd69a113"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#af8aa24f1a604f305d6e80695fd69a113">get_device_id</a> (const <a class="el" href="classsycl_1_1__V1_1_1device.html">sycl::device</a> &amp;dev)</td></tr>
<tr class="separator:af8aa24f1a604f305d6e80695fd69a113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cad58f2f1bb826c12486954426d77d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a31cad58f2f1bb826c12486954426d77d">operator*</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;a, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;b)</td></tr>
<tr class="separator:a31cad58f2f1bb826c12486954426d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf990595e06de0c2521ba6fcfd31d61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2bf990595e06de0c2521ba6fcfd31d61">operator+</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;a, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;b)</td></tr>
<tr class="separator:a2bf990595e06de0c2521ba6fcfd31d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a51112cd8fe4185985d016b6975ac52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1a51112cd8fe4185985d016b6975ac52">operator-</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;a, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;b)</td></tr>
<tr class="separator:a1a51112cd8fe4185985d016b6975ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b459bf5b9e64550f3ae84ddc7b17255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a0b459bf5b9e64550f3ae84ddc7b17255">wg_barrier</a> ()</td></tr>
<tr class="separator:a0b459bf5b9e64550f3ae84ddc7b17255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6614efebb83103f9e84ace3101683ab1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6614efebb83103f9e84ace3101683ab1">get_kernel_function_info</a> (<a class="el" href="structsyclcompat_1_1kernel__function__info.html">kernel_function_info</a> *kernel_info, const void *function)</td></tr>
<tr class="separator:a6614efebb83103f9e84ace3101683ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab53397f91801cdf59722857305e5fc6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structsyclcompat_1_1kernel__function__info.html">kernel_function_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aab53397f91801cdf59722857305e5fc6">get_kernel_function_info</a> (const void *function)</td></tr>
<tr class="separator:aab53397f91801cdf59722857305e5fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585befc6125c977ceb4eab60f4892d04"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a585befc6125c977ceb4eab60f4892d04">load_kernel_library</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a585befc6125c977ceb4eab60f4892d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load kernel library and return a handle to use the library.  <a href="namespacesyclcompat.html#a585befc6125c977ceb4eab60f4892d04">More...</a><br /></td></tr>
<tr class="separator:a585befc6125c977ceb4eab60f4892d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab4ddfee87793003a6bbb57d49fd2a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9ab4ddfee87793003a6bbb57d49fd2a6">load_kernel_library_mem</a> (char const *const image)</td></tr>
<tr class="memdesc:a9ab4ddfee87793003a6bbb57d49fd2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load kernel library whose image is alreay in memory and return a handle to use the library.  <a href="namespacesyclcompat.html#a9ab4ddfee87793003a6bbb57d49fd2a6">More...</a><br /></td></tr>
<tr class="separator:a9ab4ddfee87793003a6bbb57d49fd2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5935ac7b9837629595ab0a2e0a17638"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#af5935ac7b9837629595ab0a2e0a17638">unload_kernel_library</a> (const <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> &amp;library)</td></tr>
<tr class="memdesc:af5935ac7b9837629595ab0a2e0a17638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload kernel library.  <a href="namespacesyclcompat.html#af5935ac7b9837629595ab0a2e0a17638">More...</a><br /></td></tr>
<tr class="separator:af5935ac7b9837629595ab0a2e0a17638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dcfdd1fa0f22fb45aeaefdd62c087f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1kernel__function.html">kernel_function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a38dcfdd1fa0f22fb45aeaefdd62c087f">get_kernel_function</a> (<a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> &amp;library, const std::string &amp;name)</td></tr>
<tr class="memdesc:a38dcfdd1fa0f22fb45aeaefdd62c087f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find kernel function in a kernel library and return its address.  <a href="namespacesyclcompat.html#a38dcfdd1fa0f22fb45aeaefdd62c087f">More...</a><br /></td></tr>
<tr class="separator:a38dcfdd1fa0f22fb45aeaefdd62c087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a5f735a7d83ed624e8a4c46ae3de99"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa2a5f735a7d83ed624e8a4c46ae3de99">invoke_kernel_function</a> (<a class="el" href="classsyclcompat_1_1kernel__function.html">kernel_function</a> &amp;function, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;queue, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; group_range, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; local_range, unsigned int local_mem_size, void **kernel_params, void **extra)</td></tr>
<tr class="memdesc:aa2a5f735a7d83ed624e8a4c46ae3de99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a kernel function.  <a href="namespacesyclcompat.html#aa2a5f735a7d83ed624e8a4c46ae3de99">More...</a><br /></td></tr>
<tr class="separator:aa2a5f735a7d83ed624e8a4c46ae3de99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646c5288e3a8968d2d0182ea79ee8a3e"><td class="memTemplParams" colspan="2">template&lt;int Dim&gt; </td></tr>
<tr class="memitem:a646c5288e3a8968d2d0182ea79ee8a3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a646c5288e3a8968d2d0182ea79ee8a3e">compute_nd_range</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; Dim &gt; global_size_in, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; Dim &gt; work_group_size)</td></tr>
<tr class="separator:a646c5288e3a8968d2d0182ea79ee8a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059609bb8b030e02033312593fe5047a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a059609bb8b030e02033312593fe5047a">compute_nd_range</a> (int global_size_in, int work_group_size)</td></tr>
<tr class="separator:a059609bb8b030e02033312593fe5047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeafdaba8af089ffb199a179591470f8"><td class="memTemplParams" colspan="2">template&lt;auto F, int Dim, typename... Args&gt; </td></tr>
<tr class="memitem:abeafdaba8af089ffb199a179591470f8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; decltype(F), Args... &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#abeafdaba8af089ffb199a179591470f8">launch</a> (const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;range, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q, Args... args)</td></tr>
<tr class="separator:abeafdaba8af089ffb199a179591470f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e14af63b7aa04b211d76c8c138df1c1"><td class="memTemplParams" colspan="2">template&lt;auto F, int Dim, typename... Args&gt; </td></tr>
<tr class="memitem:a0e14af63b7aa04b211d76c8c138df1c1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; decltype(F), Args... &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a0e14af63b7aa04b211d76c8c138df1c1">launch</a> (const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;range, Args... args)</td></tr>
<tr class="separator:a0e14af63b7aa04b211d76c8c138df1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741d1f0be2ea198c33fdbdb335373830"><td class="memTemplParams" colspan="2">template&lt;auto F, typename... Args&gt; </td></tr>
<tr class="memitem:a741d1f0be2ea198c33fdbdb335373830"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; decltype(F), Args... &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a741d1f0be2ea198c33fdbdb335373830">launch</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;grid, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;threads, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q, Args... args)</td></tr>
<tr class="separator:a741d1f0be2ea198c33fdbdb335373830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087d2c6930b8d056ee4824ef599deeae"><td class="memTemplParams" colspan="2">template&lt;auto F, typename... Args&gt; </td></tr>
<tr class="memitem:a087d2c6930b8d056ee4824ef599deeae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_invocable_v&lt; decltype(F), Args... &gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a087d2c6930b8d056ee4824ef599deeae">launch</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;grid, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;threads, Args... args)</td></tr>
<tr class="separator:a087d2c6930b8d056ee4824ef599deeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978d583d934306a78f6bf778cdb24cd9"><td class="memTemplParams" colspan="2">template&lt;auto F, int Dim, typename... Args&gt; </td></tr>
<tr class="memitem:a978d583d934306a78f6bf778cdb24cd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a978d583d934306a78f6bf778cdb24cd9">launch</a> (const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;range, size_t mem_size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q, Args... args)</td></tr>
<tr class="memdesc:a978d583d934306a78f6bf778cdb24cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches a kernel with the templated F param and arguments on a device specified by the given nd_range and SYCL queue.  <a href="namespacesyclcompat.html#a978d583d934306a78f6bf778cdb24cd9">More...</a><br /></td></tr>
<tr class="separator:a978d583d934306a78f6bf778cdb24cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91edb2e1a17f68148a30f1aae1b7f9e"><td class="memTemplParams" colspan="2">template&lt;auto F, int Dim, typename... Args&gt; </td></tr>
<tr class="memitem:ad91edb2e1a17f68148a30f1aae1b7f9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad91edb2e1a17f68148a30f1aae1b7f9e">launch</a> (const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;range, size_t mem_size, Args... args)</td></tr>
<tr class="memdesc:ad91edb2e1a17f68148a30f1aae1b7f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches a kernel with the templated F param and arguments on a device specified by the given nd_range using theSYCL default queue.  <a href="namespacesyclcompat.html#ad91edb2e1a17f68148a30f1aae1b7f9e">More...</a><br /></td></tr>
<tr class="separator:ad91edb2e1a17f68148a30f1aae1b7f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c89d4f603e97db00587f482df7ca2c"><td class="memTemplParams" colspan="2">template&lt;auto F, typename... Args&gt; </td></tr>
<tr class="memitem:ac5c89d4f603e97db00587f482df7ca2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac5c89d4f603e97db00587f482df7ca2c">launch</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;grid, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;threads, size_t mem_size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q, Args... args)</td></tr>
<tr class="memdesc:ac5c89d4f603e97db00587f482df7ca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches a kernel with the templated F param and arguments on a device with a user-specified grid and block dimensions following the standard of other programming models using a user-defined SYCL queue.  <a href="namespacesyclcompat.html#ac5c89d4f603e97db00587f482df7ca2c">More...</a><br /></td></tr>
<tr class="separator:ac5c89d4f603e97db00587f482df7ca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee94da5b4aecfdd193f75f17d52b858"><td class="memTemplParams" colspan="2">template&lt;auto F, typename... Args&gt; </td></tr>
<tr class="memitem:aeee94da5b4aecfdd193f75f17d52b858"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aeee94da5b4aecfdd193f75f17d52b858">launch</a> (const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;grid, const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;threads, size_t mem_size, Args... args)</td></tr>
<tr class="memdesc:aeee94da5b4aecfdd193f75f17d52b858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches a kernel with the templated F param and arguments on a device with a user-specified grid and block dimensions following the standard of other programming models using the default SYCL queue.  <a href="namespacesyclcompat.html#aeee94da5b4aecfdd193f75f17d52b858">More...</a><br /></td></tr>
<tr class="separator:aeee94da5b4aecfdd193f75f17d52b858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3ae74a23f7ffa7b31650daee0412f2b8">fast_length</a> (const float *a, int len)</td></tr>
<tr class="memdesc:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute fast_length for variable-length array.  <a href="namespacesyclcompat.html#a3ae74a23f7ffa7b31650daee0412f2b8">More...</a><br /></td></tr>
<tr class="separator:a3ae74a23f7ffa7b31650daee0412f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5204b4194f5c613a63ff91f28d31a44"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ac5204b4194f5c613a63ff91f28d31a44"><td class="memTemplItemLeft" align="right" valign="top">ValueT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac5204b4194f5c613a63ff91f28d31a44">length</a> (const ValueT *a, const int len)</td></tr>
<tr class="memdesc:ac5204b4194f5c613a63ff91f28d31a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the square root of the input array.  <a href="namespacesyclcompat.html#ac5204b4194f5c613a63ff91f28d31a44">More...</a><br /></td></tr>
<tr class="separator:ac5204b4194f5c613a63ff91f28d31a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a123aec0583990a7a4a44531e407e7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a33a123aec0583990a7a4a44531e407e7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; BinaryOperation, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a33a123aec0583990a7a4a44531e407e7">compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a33a123aec0583990a7a4a44531e407e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs comparison.  <a href="namespacesyclcompat.html#a33a123aec0583990a7a4a44531e407e7">More...</a><br /></td></tr>
<tr class="separator:a33a123aec0583990a7a4a44531e407e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a07bd08286d8161d4f99e34e89c01c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a40a07bd08286d8161d4f99e34e89c01c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; std::not_equal_to&lt;&gt;, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a40a07bd08286d8161d4f99e34e89c01c">compare</a> (const ValueT a, const ValueT b, const std::not_equal_to&lt;&gt; binary_op)</td></tr>
<tr class="separator:a40a07bd08286d8161d4f99e34e89c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df4167f117b91719debbcd1f8d954c4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a1df4167f117b91719debbcd1f8d954c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1df4167f117b91719debbcd1f8d954c4">compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a1df4167f117b91719debbcd1f8d954c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element comparison.  <a href="namespacesyclcompat.html#a1df4167f117b91719debbcd1f8d954c4">More...</a><br /></td></tr>
<tr class="separator:a1df4167f117b91719debbcd1f8d954c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded00838c044c56640295819e6509c29"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:aded00838c044c56640295819e6509c29"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; std::invoke_result_t&lt; BinaryOperation, ValueT, ValueT &gt;, bool &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aded00838c044c56640295819e6509c29">unordered_compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:aded00838c044c56640295819e6509c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unordered comparison.  <a href="namespacesyclcompat.html#aded00838c044c56640295819e6509c29">More...</a><br /></td></tr>
<tr class="separator:aded00838c044c56640295819e6509c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a24a0dd3d4869a23e8acd0000eff243a2">unordered_compare</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a24a0dd3d4869a23e8acd0000eff243a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element unordered comparison.  <a href="namespacesyclcompat.html#a24a0dd3d4869a23e8acd0000eff243a2">More...</a><br /></td></tr>
<tr class="separator:a24a0dd3d4869a23e8acd0000eff243a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac829511f38fb4f876d37b587190d00b8"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac829511f38fb4f876d37b587190d00b8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac829511f38fb4f876d37b587190d00b8">compare_both</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac829511f38fb4f876d37b587190d00b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element comparison and return true if both results are true.  <a href="namespacesyclcompat.html#ac829511f38fb4f876d37b587190d00b8">More...</a><br /></td></tr>
<tr class="separator:ac829511f38fb4f876d37b587190d00b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89163075cb3b34a386d4e020c51ef77a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:a89163075cb3b34a386d4e020c51ef77a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a89163075cb3b34a386d4e020c51ef77a">unordered_compare_both</a> (const ValueT a, const ValueT b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:a89163075cb3b34a386d4e020c51ef77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 element unordered comparison and return true if both results are true.  <a href="namespacesyclcompat.html#a89163075cb3b34a386d4e020c51ef77a">More...</a><br /></td></tr>
<tr class="separator:a89163075cb3b34a386d4e020c51ef77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac29a2946cfc8b1e5053f1d11a3f81a55">compare_mask</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements.  <a href="namespacesyclcompat.html#ac29a2946cfc8b1e5053f1d11a3f81a55">More...</a><br /></td></tr>
<tr class="separator:ac29a2946cfc8b1e5053f1d11a3f81a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac54f0e6926d1e17b28d01849ba1969e2">unordered_compare_mask</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ac54f0e6926d1e17b28d01849ba1969e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements unordered comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements.  <a href="namespacesyclcompat.html#ac54f0e6926d1e17b28d01849ba1969e2">More...</a><br /></td></tr>
<tr class="separator:ac54f0e6926d1e17b28d01849ba1969e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a31a2a3d5e07d4bb8b20f2309f2827105">vectorized_max</a> (T a, T b)</td></tr>
<tr class="memdesc:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized max for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#a31a2a3d5e07d4bb8b20f2309f2827105">More...</a><br /></td></tr>
<tr class="separator:a31a2a3d5e07d4bb8b20f2309f2827105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf81d995e76936eb645775f69ba31e"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a9cbf81d995e76936eb645775f69ba31e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9cbf81d995e76936eb645775f69ba31e">vectorized_min</a> (T a, T b)</td></tr>
<tr class="memdesc:a9cbf81d995e76936eb645775f69ba31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized min for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#a9cbf81d995e76936eb645775f69ba31e">More...</a><br /></td></tr>
<tr class="separator:a9cbf81d995e76936eb645775f69ba31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b88222d07913e646022d54682371d"><td class="memTemplParams" colspan="2">template&lt;typename VecT , class UnaryOperation &gt; </td></tr>
<tr class="memitem:ad16b88222d07913e646022d54682371d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad16b88222d07913e646022d54682371d">vectorized_unary</a> (unsigned a, const UnaryOperation unary_op)</td></tr>
<tr class="memdesc:ad16b88222d07913e646022d54682371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized unary operation for a value, with the value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ad16b88222d07913e646022d54682371d">More...</a><br /></td></tr>
<tr class="separator:ad16b88222d07913e646022d54682371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memTemplParams" colspan="2">template&lt;typename VecT &gt; </td></tr>
<tr class="memitem:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae5c6ea6f042442a0e6b83406d3be7f47">vectorized_sum_abs_diff</a> (unsigned a, unsigned b)</td></tr>
<tr class="memdesc:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized absolute difference for two values without modulo overflow, with each value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ae5c6ea6f042442a0e6b83406d3be7f47">More...</a><br /></td></tr>
<tr class="separator:ae5c6ea6f042442a0e6b83406d3be7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfca16dc6307a92959d4d7ef76337cc"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:aecfca16dc6307a92959d4d7ef76337cc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aecfca16dc6307a92959d4d7ef76337cc">vectorized_isgreater</a> (T a, T b)</td></tr>
<tr class="memdesc:aecfca16dc6307a92959d4d7ef76337cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized isgreater for two values, with each value treated as a vector type <code>S</code>.  <a href="namespacesyclcompat.html#aecfca16dc6307a92959d4d7ef76337cc">More...</a><br /></td></tr>
<tr class="separator:aecfca16dc6307a92959d4d7ef76337cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c669031ba0dc847fe933f8640fe81"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a801c669031ba0dc847fe933f8640fe81"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a801c669031ba0dc847fe933f8640fe81">vectorized_isgreater&lt; sycl::ushort2, unsigned &gt;</a> (unsigned a, unsigned b)</td></tr>
<tr class="memdesc:a801c669031ba0dc847fe933f8640fe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized isgreater for two unsigned int values, with each value treated as a vector of two unsigned short.  <a href="namespacesyclcompat.html#a801c669031ba0dc847fe933f8640fe81">More...</a><br /></td></tr>
<tr class="separator:a801c669031ba0dc847fe933f8640fe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memTemplItemLeft" align="right" valign="top">ValueT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab9be2b3ef2fed36c10d60ac4eb130f5c">clamp</a> (ValueT val, ValueT min_val, ValueT max_val)</td></tr>
<tr class="memdesc:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min(max(val, min_val), max_val)  <a href="namespacesyclcompat.html#ab9be2b3ef2fed36c10d60ac4eb130f5c">More...</a><br /></td></tr>
<tr class="separator:ab9be2b3ef2fed36c10d60ac4eb130f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad717ffed265f37aad2378786fd6d89f4"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ad717ffed265f37aad2378786fd6d89f4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; ValueT::size()==2, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad717ffed265f37aad2378786fd6d89f4">isnan</a> (const ValueT a)</td></tr>
<tr class="memdesc:ad717ffed265f37aad2378786fd6d89f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether 2 element value is NaN.  <a href="namespacesyclcompat.html#ad717ffed265f37aad2378786fd6d89f4">More...</a><br /></td></tr>
<tr class="separator:ad717ffed265f37aad2378786fd6d89f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba95047e6b327a88374d0ad3a595b7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a8cba95047e6b327a88374d0ad3a595b7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8cba95047e6b327a88374d0ad3a595b7">cbrt</a> (ValueT val)</td></tr>
<tr class="memdesc:a8cba95047e6b327a88374d0ad3a595b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">cbrt function wrapper.  <a href="namespacesyclcompat.html#a8cba95047e6b327a88374d0ad3a595b7">More...</a><br /></td></tr>
<tr class="separator:a8cba95047e6b327a88374d0ad3a595b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; ValueT &gt; &amp;&amp;std::is_integral_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7ca23d990971b4698e3c3e5c6a7c6a6a">min</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a7ca23d990971b4698e3c3e5c6a7c6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fd37967c8d72eaea54a9305713b68b"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:aa3fd37967c8d72eaea54a9305713b68b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt; &amp;&amp;std::is_floating_point_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa3fd37967c8d72eaea54a9305713b68b">min</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:aa3fd37967c8d72eaea54a9305713b68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b268e654edb59f11023407d89dc1e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a22b268e654edb59f11023407d89dc1e2">min</a> (<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> a, <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> b)</td></tr>
<tr class="separator:a22b268e654edb59f11023407d89dc1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531bbe21767e8f4072bfcdff20f498f7"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a531bbe21767e8f4072bfcdff20f498f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; ValueT &gt; &amp;&amp;std::is_integral_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a531bbe21767e8f4072bfcdff20f498f7">max</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a531bbe21767e8f4072bfcdff20f498f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a7811f8997faff9f040545e94eb578"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a85a7811f8997faff9f040545e94eb578"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt; &amp;&amp;std::is_floating_point_v&lt; ValueU &gt;, std::common_type_t&lt; ValueT, ValueU &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a85a7811f8997faff9f040545e94eb578">max</a> (ValueT a, ValueU b)</td></tr>
<tr class="separator:a85a7811f8997faff9f040545e94eb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49771fa421f438b08a8a9fd641cbc9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a49771fa421f438b08a8a9fd641cbc9fb">max</a> (<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> a, <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> b)</td></tr>
<tr class="separator:a49771fa421f438b08a8a9fd641cbc9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memTemplItemLeft" align="right" valign="top">std::common_type_t&lt; ValueT, ValueU &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a615ce353b7e9f28276758fe1eacf4aaf">fmax_nan</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="memdesc:a615ce353b7e9f28276758fe1eacf4aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison and returns the bigger one.  <a href="namespacesyclcompat.html#a615ce353b7e9f28276758fe1eacf4aaf">More...</a><br /></td></tr>
<tr class="separator:a615ce353b7e9f28276758fe1eacf4aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56980b5d12a81c3e1316d788f7730a24"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a56980b5d12a81c3e1316d788f7730a24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; std::common_type_t&lt; ValueT, ValueU &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a56980b5d12a81c3e1316d788f7730a24">fmax_nan</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt; b)</td></tr>
<tr class="separator:a56980b5d12a81c3e1316d788f7730a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e292b332c72f1e012dfff1543122ad"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:aa6e292b332c72f1e012dfff1543122ad"><td class="memTemplItemLeft" align="right" valign="top">std::common_type_t&lt; ValueT, ValueU &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa6e292b332c72f1e012dfff1543122ad">fmin_nan</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="memdesc:aa6e292b332c72f1e012dfff1543122ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs 2 elements comparison and returns the smaller one.  <a href="namespacesyclcompat.html#aa6e292b332c72f1e012dfff1543122ad">More...</a><br /></td></tr>
<tr class="separator:aa6e292b332c72f1e012dfff1543122ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f095a3499a1a403aa3a5c523af0f445"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:a6f095a3499a1a403aa3a5c523af0f445"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; std::common_type_t&lt; ValueT, ValueU &gt;, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6f095a3499a1a403aa3a5c523af0f445">fmin_nan</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt; b)</td></tr>
<tr class="separator:a6f095a3499a1a403aa3a5c523af0f445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018900fdf8d4f949fd973c9d96765320"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a018900fdf8d4f949fd973c9d96765320">pow</a> (const float a, const int b)</td></tr>
<tr class="separator:a018900fdf8d4f949fd973c9d96765320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783139834d0eb876b11b4f5af0358e6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a783139834d0eb876b11b4f5af0358e6b">pow</a> (const double a, const int b)</td></tr>
<tr class="separator:a783139834d0eb876b11b4f5af0358e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4389d66219fa53171d7a8779fd7cc2"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:ace4389d66219fa53171d7a8779fd7cc2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ace4389d66219fa53171d7a8779fd7cc2">pow</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="separator:ace4389d66219fa53171d7a8779fd7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueU &gt; </td></tr>
<tr class="memitem:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_floating_point_v&lt; ValueT &gt;, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae16d49807b1bd0c2ba162b8b041e6328">pow</a> (const ValueT a, const ValueU b)</td></tr>
<tr class="separator:ae16d49807b1bd0c2ba162b8b041e6328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883b7f69405f6f7dc164912b6dd25866"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a883b7f69405f6f7dc164912b6dd25866"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a883b7f69405f6f7dc164912b6dd25866">relu</a> (const ValueT a)</td></tr>
<tr class="memdesc:a883b7f69405f6f7dc164912b6dd25866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs relu saturation.  <a href="namespacesyclcompat.html#a883b7f69405f6f7dc164912b6dd25866">More...</a><br /></td></tr>
<tr class="separator:a883b7f69405f6f7dc164912b6dd25866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cefc15668bad433ae4dd61991eed446"><td class="memTemplParams" colspan="2">template&lt;class ValueT &gt; </td></tr>
<tr class="memitem:a9cefc15668bad433ae4dd61991eed446"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9cefc15668bad433ae4dd61991eed446">relu</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a)</td></tr>
<tr class="separator:a9cefc15668bad433ae4dd61991eed446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memTemplParams" colspan="2">template&lt;class ValueT &gt; </td></tr>
<tr class="memitem:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; ValueT &gt;||std::is_same_v&lt; <a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT &gt;, <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae5ef6bf54a8af27e5a21365dd387ea6b">relu</a> (const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; a)</td></tr>
<tr class="separator:ae5ef6bf54a8af27e5a21365dd387ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedacf06b344702068bd0e09261dda844"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedacf06b344702068bd0e09261dda844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aedacf06b344702068bd0e09261dda844">cmul</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; y)</td></tr>
<tr class="memdesc:aedacf06b344702068bd0e09261dda844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multiplication of two complex numbers.  <a href="namespacesyclcompat.html#aedacf06b344702068bd0e09261dda844">More...</a><br /></td></tr>
<tr class="separator:aedacf06b344702068bd0e09261dda844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a98ca4eb5a166e3a49c085c9445fef3c3">cdiv</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; y)</td></tr>
<tr class="memdesc:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the division of two complex numbers.  <a href="namespacesyclcompat.html#a98ca4eb5a166e3a49c085c9445fef3c3">More...</a><br /></td></tr>
<tr class="separator:a98ca4eb5a166e3a49c085c9445fef3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3c10c27d44679e0ae2829cb48ab76d14">cabs</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x)</td></tr>
<tr class="memdesc:a3c10c27d44679e0ae2829cb48ab76d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the magnitude of a complex number.  <a href="namespacesyclcompat.html#a3c10c27d44679e0ae2829cb48ab76d14">More...</a><br /></td></tr>
<tr class="separator:a3c10c27d44679e0ae2829cb48ab76d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bdeb6e393e3bb3493787eafef19dca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74bdeb6e393e3bb3493787eafef19dca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a74bdeb6e393e3bb3493787eafef19dca">conj</a> (<a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt; x)</td></tr>
<tr class="memdesc:a74bdeb6e393e3bb3493787eafef19dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the complex conjugate of a complex number.  <a href="namespacesyclcompat.html#a74bdeb6e393e3bb3493787eafef19dca">More...</a><br /></td></tr>
<tr class="separator:a74bdeb6e393e3bb3493787eafef19dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11b7d2b288bb226ea5209062146ec63"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:ab11b7d2b288bb226ea5209062146ec63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab11b7d2b288bb226ea5209062146ec63">cmul_add</a> (const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; b, const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt; c)</td></tr>
<tr class="memdesc:ab11b7d2b288bb226ea5209062146ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs complex number multiply addition.  <a href="namespacesyclcompat.html#ab11b7d2b288bb226ea5209062146ec63">More...</a><br /></td></tr>
<tr class="separator:ab11b7d2b288bb226ea5209062146ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4415353f91d200fc2fbea022e53e336e"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:a4415353f91d200fc2fbea022e53e336e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4415353f91d200fc2fbea022e53e336e">cmul_add</a> (const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; a, const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; b, const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt; c)</td></tr>
<tr class="separator:a4415353f91d200fc2fbea022e53e336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f7af0ba11c7e398732af5088e033f1"><td class="memTemplParams" colspan="2">template&lt;typename VecT , class BinaryOperation &gt; </td></tr>
<tr class="memitem:ad2f7af0ba11c7e398732af5088e033f1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad2f7af0ba11c7e398732af5088e033f1">vectorized_binary</a> (unsigned a, unsigned b, const BinaryOperation binary_op)</td></tr>
<tr class="memdesc:ad2f7af0ba11c7e398732af5088e033f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vectorized binary operation value for two values, with each value treated as a vector type <code>VecT</code>.  <a href="namespacesyclcompat.html#ad2f7af0ba11c7e398732af5088e033f1">More...</a><br /></td></tr>
<tr class="separator:ad2f7af0ba11c7e398732af5088e033f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2322aed08cbe875a97da83f7dcc8a61f">extend_add</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a2322aed08cbe875a97da83f7dcc8a61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and add them.  <a href="namespacesyclcompat.html#a2322aed08cbe875a97da83f7dcc8a61f">More...</a><br /></td></tr>
<tr class="separator:a2322aed08cbe875a97da83f7dcc8a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acebd1383b7ad2eeba4f7749eb99e0bc0">extend_add</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, add <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#acebd1383b7ad2eeba4f7749eb99e0bc0">More...</a><br /></td></tr>
<tr class="separator:acebd1383b7ad2eeba4f7749eb99e0bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b249ad38d46680197b4252ba0a36a60"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a3b249ad38d46680197b4252ba0a36a60"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3b249ad38d46680197b4252ba0a36a60">extend_add_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a3b249ad38d46680197b4252ba0a36a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and add them with saturation.  <a href="namespacesyclcompat.html#a3b249ad38d46680197b4252ba0a36a60">More...</a><br /></td></tr>
<tr class="separator:a3b249ad38d46680197b4252ba0a36a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8160bb0989abca1627abc8848d3e5d45"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a8160bb0989abca1627abc8848d3e5d45"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a8160bb0989abca1627abc8848d3e5d45">extend_add_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a8160bb0989abca1627abc8848d3e5d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, add <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a8160bb0989abca1627abc8848d3e5d45">More...</a><br /></td></tr>
<tr class="separator:a8160bb0989abca1627abc8848d3e5d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340a282cecb3084c18e11203262ef7d0"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a340a282cecb3084c18e11203262ef7d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a340a282cecb3084c18e11203262ef7d0">extend_sub</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a340a282cecb3084c18e11203262ef7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and minus them.  <a href="namespacesyclcompat.html#a340a282cecb3084c18e11203262ef7d0">More...</a><br /></td></tr>
<tr class="separator:a340a282cecb3084c18e11203262ef7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24d3ca4111c0870bce355c7283b2588"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:ad24d3ca4111c0870bce355c7283b2588"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad24d3ca4111c0870bce355c7283b2588">extend_sub</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:ad24d3ca4111c0870bce355c7283b2588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#ad24d3ca4111c0870bce355c7283b2588">More...</a><br /></td></tr>
<tr class="separator:ad24d3ca4111c0870bce355c7283b2588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab537af4548527320497820dbe606d5fa"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:ab537af4548527320497820dbe606d5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab537af4548527320497820dbe606d5fa">extend_sub_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:ab537af4548527320497820dbe606d5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and minus them with saturation.  <a href="namespacesyclcompat.html#ab537af4548527320497820dbe606d5fa">More...</a><br /></td></tr>
<tr class="separator:ab537af4548527320497820dbe606d5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095a7e145440a9bee06ed5f885bcee62"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a095a7e145440a9bee06ed5f885bcee62"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a095a7e145440a9bee06ed5f885bcee62">extend_sub_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a095a7e145440a9bee06ed5f885bcee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a095a7e145440a9bee06ed5f885bcee62">More...</a><br /></td></tr>
<tr class="separator:a095a7e145440a9bee06ed5f885bcee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67762a6b2faa454a541b765c35164af4"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a67762a6b2faa454a541b765c35164af4"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a67762a6b2faa454a541b765c35164af4">extend_absdiff</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a67762a6b2faa454a541b765c35164af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a>.  <a href="namespacesyclcompat.html#a67762a6b2faa454a541b765c35164af4">More...</a><br /></td></tr>
<tr class="separator:a67762a6b2faa454a541b765c35164af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340c344b03eef89ef8abc09cdafd03ea"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a340c344b03eef89ef8abc09cdafd03ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a340c344b03eef89ef8abc09cdafd03ea">extend_absdiff</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a340c344b03eef89ef8abc09cdafd03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a340c344b03eef89ef8abc09cdafd03ea">More...</a><br /></td></tr>
<tr class="separator:a340c344b03eef89ef8abc09cdafd03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10430015596393bf2dce1e007dfcca07"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a10430015596393bf2dce1e007dfcca07"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a10430015596393bf2dce1e007dfcca07">extend_absdiff_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a10430015596393bf2dce1e007dfcca07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> with saturation.  <a href="namespacesyclcompat.html#a10430015596393bf2dce1e007dfcca07">More...</a><br /></td></tr>
<tr class="separator:a10430015596393bf2dce1e007dfcca07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf831fb5b0e0779bb550851b73af89b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a3cf831fb5b0e0779bb550851b73af89b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a3cf831fb5b0e0779bb550851b73af89b">extend_absdiff_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a3cf831fb5b0e0779bb550851b73af89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a3cf831fb5b0e0779bb550851b73af89b">More...</a><br /></td></tr>
<tr class="separator:a3cf831fb5b0e0779bb550851b73af89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513cddbc8845e942c38c04484ddb359b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a513cddbc8845e942c38c04484ddb359b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a513cddbc8845e942c38c04484ddb359b">extend_min</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a513cddbc8845e942c38c04484ddb359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one.  <a href="namespacesyclcompat.html#a513cddbc8845e942c38c04484ddb359b">More...</a><br /></td></tr>
<tr class="separator:a513cddbc8845e942c38c04484ddb359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a77de29a1c643284782b3c83fba3d69"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a4a77de29a1c643284782b3c83fba3d69"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a4a77de29a1c643284782b3c83fba3d69">extend_min</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a4a77de29a1c643284782b3c83fba3d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a4a77de29a1c643284782b3c83fba3d69">More...</a><br /></td></tr>
<tr class="separator:a4a77de29a1c643284782b3c83fba3d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a696a528e5d9dbe5944898a5a5ed7bf6b">extend_min_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one with saturation.  <a href="namespacesyclcompat.html#a696a528e5d9dbe5944898a5a5ed7bf6b">More...</a><br /></td></tr>
<tr class="separator:a696a528e5d9dbe5944898a5a5ed7bf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcaf721a651b4656ca9f024818537215"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:afcaf721a651b4656ca9f024818537215"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afcaf721a651b4656ca9f024818537215">extend_min_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:afcaf721a651b4656ca9f024818537215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#afcaf721a651b4656ca9f024818537215">More...</a><br /></td></tr>
<tr class="separator:afcaf721a651b4656ca9f024818537215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a533cffd30b30a7a51f6e51283f6ad0fc">extend_max</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one.  <a href="namespacesyclcompat.html#a533cffd30b30a7a51f6e51283f6ad0fc">More...</a><br /></td></tr>
<tr class="separator:a533cffd30b30a7a51f6e51283f6ad0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8ec078f14bae384ecab4c45801b117"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:aba8ec078f14bae384ecab4c45801b117"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aba8ec078f14bae384ecab4c45801b117">extend_max</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:aba8ec078f14bae384ecab4c45801b117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#aba8ec078f14bae384ecab4c45801b117">More...</a><br /></td></tr>
<tr class="separator:aba8ec078f14bae384ecab4c45801b117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d428f4281cef11e44e37b69d62876d"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT &gt; </td></tr>
<tr class="memitem:a36d428f4281cef11e44e37b69d62876d"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a36d428f4281cef11e44e37b69d62876d">extend_max_sat</a> (AT a, BT b)</td></tr>
<tr class="memdesc:a36d428f4281cef11e44e37b69d62876d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one with saturation.  <a href="namespacesyclcompat.html#a36d428f4281cef11e44e37b69d62876d">More...</a><br /></td></tr>
<tr class="separator:a36d428f4281cef11e44e37b69d62876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b890c4272f2b5c60e2205f90b422f2"><td class="memTemplParams" colspan="2">template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </td></tr>
<tr class="memitem:a60b890c4272f2b5c60e2205f90b422f2"><td class="memTemplItemLeft" align="right" valign="top">constexpr RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a60b890c4272f2b5c60e2205f90b422f2">extend_max_sat</a> (AT a, BT b, CT c, BinaryOperation second_op)</td></tr>
<tr class="memdesc:a60b890c4272f2b5c60e2205f90b422f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>.  <a href="namespacesyclcompat.html#a60b890c4272f2b5c60e2205f90b422f2">More...</a><br /></td></tr>
<tr class="separator:a60b890c4272f2b5c60e2205f90b422f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb6115d3ea863770733640e0c24c13"><td class="memTemplParams" colspan="2">template&lt;typename AllocT &gt; </td></tr>
<tr class="memitem:a48cb6115d3ea863770733640e0c24c13"><td class="memTemplItemLeft" align="right" valign="top">auto *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a48cb6115d3ea863770733640e0c24c13">local_mem</a> ()</td></tr>
<tr class="separator:a48cb6115d3ea863770733640e0c24c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c54c29e7d6077d5c6deb8e90437473"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#af2c54c29e7d6077d5c6deb8e90437473">malloc</a> (size_t num_bytes, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:af2c54c29e7d6077d5c6deb8e90437473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block on the device.  <a href="namespacesyclcompat.html#af2c54c29e7d6077d5c6deb8e90437473">More...</a><br /></td></tr>
<tr class="separator:af2c54c29e7d6077d5c6deb8e90437473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7363de3a3d3fe0109c7d97ca3542c731"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7363de3a3d3fe0109c7d97ca3542c731">malloc_host</a> (size_t num_bytes, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a7363de3a3d3fe0109c7d97ca3542c731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block on the host.  <a href="namespacesyclcompat.html#a7363de3a3d3fe0109c7d97ca3542c731">More...</a><br /></td></tr>
<tr class="separator:a7363de3a3d3fe0109c7d97ca3542c731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f4a03fece6ccde023d34dc9218a2cb"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab0f4a03fece6ccde023d34dc9218a2cb">malloc_shared</a> (size_t num_bytes, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ab0f4a03fece6ccde023d34dc9218a2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block of usm_shared memory.  <a href="namespacesyclcompat.html#ab0f4a03fece6ccde023d34dc9218a2cb">More...</a><br /></td></tr>
<tr class="separator:ab0f4a03fece6ccde023d34dc9218a2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6982731137d57e7e35d42d4f6b213e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1f6982731137d57e7e35d42d4f6b213e">malloc</a> (<a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a1f6982731137d57e7e35d42d4f6b213e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block for 3D array on the device.  <a href="namespacesyclcompat.html#a1f6982731137d57e7e35d42d4f6b213e">More...</a><br /></td></tr>
<tr class="separator:a1f6982731137d57e7e35d42d4f6b213e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccc3b0bbff2728c7a2f2afc18744ca0"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acccc3b0bbff2728c7a2f2afc18744ca0">malloc</a> (size_t &amp;pitch, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:acccc3b0bbff2728c7a2f2afc18744ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block for 2D array on the device.  <a href="namespacesyclcompat.html#acccc3b0bbff2728c7a2f2afc18744ca0">More...</a><br /></td></tr>
<tr class="separator:acccc3b0bbff2728c7a2f2afc18744ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405e7e737482cc13809fb2260cd7cc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2405e7e737482cc13809fb2260cd7cc7">free</a> (void *ptr, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a2405e7e737482cc13809fb2260cd7cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">free  <a href="namespacesyclcompat.html#a2405e7e737482cc13809fb2260cd7cc7">More...</a><br /></td></tr>
<tr class="separator:a2405e7e737482cc13809fb2260cd7cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c4f6e0b0f5ffcd40e4ea17e97e17dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac3c4f6e0b0f5ffcd40e4ea17e97e17dd">free_async</a> (const std::vector&lt; void * &gt; &amp;pointers, const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt; &amp;events, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ac3c4f6e0b0f5ffcd40e4ea17e97e17dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the device memory pointed by a batch of pointers in <code>pointers</code> which are related to <code>q</code> after <code>events</code> completed.  <a href="namespacesyclcompat.html#ac3c4f6e0b0f5ffcd40e4ea17e97e17dd">More...</a><br /></td></tr>
<tr class="separator:ac3c4f6e0b0f5ffcd40e4ea17e97e17dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c931cec177ad23a31a11f51a01c75f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a0c931cec177ad23a31a11f51a01c75f5">memcpy</a> (void *to_ptr, const void *from_ptr, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a0c931cec177ad23a31a11f51a01c75f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously copies <code>size</code> bytes from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>.  <a href="namespacesyclcompat.html#a0c931cec177ad23a31a11f51a01c75f5">More...</a><br /></td></tr>
<tr class="separator:a0c931cec177ad23a31a11f51a01c75f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf0cecf244c39b3c1b09b104fab7271"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7bf0cecf244c39b3c1b09b104fab7271">memcpy_async</a> (void *to_ptr, const void *from_ptr, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a7bf0cecf244c39b3c1b09b104fab7271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously copies <code>size</code> bytes from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>.  <a href="namespacesyclcompat.html#a7bf0cecf244c39b3c1b09b104fab7271">More...</a><br /></td></tr>
<tr class="separator:a7bf0cecf244c39b3c1b09b104fab7271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab75cf8f287e10bb6abf942a65e94cc2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab75cf8f287e10bb6abf942a65e94cc2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aab75cf8f287e10bb6abf942a65e94cc2">memcpy_async</a> (<a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *to_ptr, const <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *from_ptr, size_t count, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:aab75cf8f287e10bb6abf942a65e94cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously copies <code>count</code> T's from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>.  <a href="namespacesyclcompat.html#aab75cf8f287e10bb6abf942a65e94cc2">More...</a><br /></td></tr>
<tr class="separator:aab75cf8f287e10bb6abf942a65e94cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13c96026b426484d776c34ff5cfd791"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae13c96026b426484d776c34ff5cfd791"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae13c96026b426484d776c34ff5cfd791">memcpy</a> (<a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *to_ptr, const <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *from_ptr, size_t count, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ae13c96026b426484d776c34ff5cfd791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously copies <code>count</code> T's from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>.  <a href="namespacesyclcompat.html#ae13c96026b426484d776c34ff5cfd791">More...</a><br /></td></tr>
<tr class="separator:ae13c96026b426484d776c34ff5cfd791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347c9efef0dac49b9b8d11d35300e71"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac347c9efef0dac49b9b8d11d35300e71">memcpy</a> (void *to_ptr, size_t to_pitch, const void *from_ptr, size_t from_pitch, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ac347c9efef0dac49b9b8d11d35300e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously copies 2D matrix specified by <code>x</code> and <code>y</code> from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>, while <code>from_pitch</code> and <code>to_pitch</code> are the range of dim x in bytes of the matrix specified by <code>from_ptr</code> and <code>to_ptr</code>.  <a href="namespacesyclcompat.html#ac347c9efef0dac49b9b8d11d35300e71">More...</a><br /></td></tr>
<tr class="separator:ac347c9efef0dac49b9b8d11d35300e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc8e53b9ec360517c25b151e2fc0312"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#adbc8e53b9ec360517c25b151e2fc0312">memcpy_async</a> (void *to_ptr, size_t to_pitch, const void *from_ptr, size_t from_pitch, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:adbc8e53b9ec360517c25b151e2fc0312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously copies 2D matrix specified by <code>x</code> and <code>y</code> from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>, while <code><code>from_pitch</code> and</code> <code>to_pitch</code> are the range of dim x in bytes of the matrix specified by <code>from_ptr</code> and <code>to_ptr</code>.  <a href="namespacesyclcompat.html#adbc8e53b9ec360517c25b151e2fc0312">More...</a><br /></td></tr>
<tr class="separator:adbc8e53b9ec360517c25b151e2fc0312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23a63f32d830f9064135d882557fded"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad23a63f32d830f9064135d882557fded">memcpy</a> (<a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> to, <a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt; to_pos, <a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> from, <a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt; from_pos, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ad23a63f32d830f9064135d882557fded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously copies a subset of a 3D matrix specified by <code>to</code> to another 3D matrix specified by <code>from</code>.  <a href="namespacesyclcompat.html#ad23a63f32d830f9064135d882557fded">More...</a><br /></td></tr>
<tr class="separator:ad23a63f32d830f9064135d882557fded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58d8e908a75bdb929bb6d0d2a78505f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ac58d8e908a75bdb929bb6d0d2a78505f">memcpy_async</a> (<a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> to, <a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt; to_pos, <a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> from, <a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt; from_pos, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ac58d8e908a75bdb929bb6d0d2a78505f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously copies a subset of a 3D matrix specified by <code>to</code> to another 3D matrix specified by <code>from</code>.  <a href="namespacesyclcompat.html#ac58d8e908a75bdb929bb6d0d2a78505f">More...</a><br /></td></tr>
<tr class="separator:ac58d8e908a75bdb929bb6d0d2a78505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa555a5c37f9422a6034503545bac2349"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa555a5c37f9422a6034503545bac2349"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aa555a5c37f9422a6034503545bac2349">fill</a> (void *dev_ptr, const T &amp;pattern, size_t count, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:aa555a5c37f9422a6034503545bac2349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously sets <code>pattern</code> to the first <code>count</code> elements starting from <code>dev_ptr</code>.  <a href="namespacesyclcompat.html#aa555a5c37f9422a6034503545bac2349">More...</a><br /></td></tr>
<tr class="separator:aa555a5c37f9422a6034503545bac2349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04308ffd19da9568264086fcf59e198"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad04308ffd19da9568264086fcf59e198"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ad04308ffd19da9568264086fcf59e198">fill_async</a> (void *dev_ptr, const T &amp;pattern, size_t count, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ad04308ffd19da9568264086fcf59e198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets <code>pattern</code> to the first <code>count</code> elements starting from <code>dev_ptr</code>.  <a href="namespacesyclcompat.html#ad04308ffd19da9568264086fcf59e198">More...</a><br /></td></tr>
<tr class="separator:ad04308ffd19da9568264086fcf59e198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9f0b7c00c63162ba76771523e6f646"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afe9f0b7c00c63162ba76771523e6f646">memset</a> (void *dev_ptr, int value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:afe9f0b7c00c63162ba76771523e6f646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously sets <code>value</code> to the first <code>size</code> bytes starting from <code>dev_ptr</code>.  <a href="namespacesyclcompat.html#afe9f0b7c00c63162ba76771523e6f646">More...</a><br /></td></tr>
<tr class="separator:afe9f0b7c00c63162ba76771523e6f646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd37b14e4b01bd2906e13ee4b9b6fca0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afd37b14e4b01bd2906e13ee4b9b6fca0">memset_d16</a> (void *dev_ptr, unsigned short value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:afd37b14e4b01bd2906e13ee4b9b6fca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 2 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> synchronously.  <a href="namespacesyclcompat.html#afd37b14e4b01bd2906e13ee4b9b6fca0">More...</a><br /></td></tr>
<tr class="separator:afd37b14e4b01bd2906e13ee4b9b6fca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d2b281f21686a0a2b611eb812c0622"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a72d2b281f21686a0a2b611eb812c0622">memset_d32</a> (void *dev_ptr, unsigned int value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a72d2b281f21686a0a2b611eb812c0622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 4 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> synchronously.  <a href="namespacesyclcompat.html#a72d2b281f21686a0a2b611eb812c0622">More...</a><br /></td></tr>
<tr class="separator:a72d2b281f21686a0a2b611eb812c0622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffae135ebd10229ab6455e91427e85d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a7ffae135ebd10229ab6455e91427e85d">memset_async</a> (void *dev_ptr, int value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a7ffae135ebd10229ab6455e91427e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 1 byte data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#a7ffae135ebd10229ab6455e91427e85d">More...</a><br /></td></tr>
<tr class="separator:a7ffae135ebd10229ab6455e91427e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a58df21e8428392811b4998ad111b11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a0a58df21e8428392811b4998ad111b11">memset_d16_async</a> (void *dev_ptr, unsigned short value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a0a58df21e8428392811b4998ad111b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 2 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#a0a58df21e8428392811b4998ad111b11">More...</a><br /></td></tr>
<tr class="separator:a0a58df21e8428392811b4998ad111b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5c4d682df42d0e8c447a107c7161b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aef5c4d682df42d0e8c447a107c7161b8">memset_d32_async</a> (void *dev_ptr, unsigned int value, size_t size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:aef5c4d682df42d0e8c447a107c7161b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 4 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#aef5c4d682df42d0e8c447a107c7161b8">More...</a><br /></td></tr>
<tr class="separator:aef5c4d682df42d0e8c447a107c7161b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfebc5a5375d64ecb0a2081ce1712477"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#acfebc5a5375d64ecb0a2081ce1712477">memset</a> (void *ptr, size_t pitch, int val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:acfebc5a5375d64ecb0a2081ce1712477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 1 byte data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> synchronously.  <a href="namespacesyclcompat.html#acfebc5a5375d64ecb0a2081ce1712477">More...</a><br /></td></tr>
<tr class="separator:acfebc5a5375d64ecb0a2081ce1712477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b41d11ec6e209fc3e1c65d3ba4feacb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a5b41d11ec6e209fc3e1c65d3ba4feacb">memset_d16</a> (void *ptr, size_t pitch, unsigned short val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a5b41d11ec6e209fc3e1c65d3ba4feacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 2 bytes data <code>val</code> to the pitched 2D memory region pointed by ptr in <code>q</code> synchronously.  <a href="namespacesyclcompat.html#a5b41d11ec6e209fc3e1c65d3ba4feacb">More...</a><br /></td></tr>
<tr class="separator:a5b41d11ec6e209fc3e1c65d3ba4feacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad304dd894c1f50688a069958077d64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#afad304dd894c1f50688a069958077d64">memset_d32</a> (void *ptr, size_t pitch, unsigned int val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:afad304dd894c1f50688a069958077d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 4 bytes data <code>val</code> to the pitched 2D memory region pointed by ptr in <code>q</code> synchronously.  <a href="namespacesyclcompat.html#afad304dd894c1f50688a069958077d64">More...</a><br /></td></tr>
<tr class="separator:afad304dd894c1f50688a069958077d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05a9b0c6fd4f75cd020bd1671aed734"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae05a9b0c6fd4f75cd020bd1671aed734">memset_async</a> (void *ptr, size_t pitch, int val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ae05a9b0c6fd4f75cd020bd1671aed734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 1 byte data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#ae05a9b0c6fd4f75cd020bd1671aed734">More...</a><br /></td></tr>
<tr class="separator:ae05a9b0c6fd4f75cd020bd1671aed734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e4cd08d9a56cb63a3f4cf90e20da4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aee9e4cd08d9a56cb63a3f4cf90e20da4">memset_d16_async</a> (void *ptr, size_t pitch, unsigned short val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:aee9e4cd08d9a56cb63a3f4cf90e20da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 2 bytes data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#aee9e4cd08d9a56cb63a3f4cf90e20da4">More...</a><br /></td></tr>
<tr class="separator:aee9e4cd08d9a56cb63a3f4cf90e20da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bb15dca317fa62ad68e77312ec1b78"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a13bb15dca317fa62ad68e77312ec1b78">memset_d32_async</a> (void *ptr, size_t pitch, unsigned int val, size_t x, size_t y, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a13bb15dca317fa62ad68e77312ec1b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 4 bytes data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously.  <a href="namespacesyclcompat.html#a13bb15dca317fa62ad68e77312ec1b78">More...</a><br /></td></tr>
<tr class="separator:a13bb15dca317fa62ad68e77312ec1b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d789b76dab62515323f57267459092f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6d789b76dab62515323f57267459092f">memset</a> (<a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> pitch, int val, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:a6d789b76dab62515323f57267459092f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>value</code> to the 3D memory region specified by <code>pitch</code> in <code>q</code>.  <a href="namespacesyclcompat.html#a6d789b76dab62515323f57267459092f">More...</a><br /></td></tr>
<tr class="separator:a6d789b76dab62515323f57267459092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5649cb5f8a57196d43977d5c362c718"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab5649cb5f8a57196d43977d5c362c718">memset_async</a> (<a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> pitch, int val, <a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt; size, <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> q=<a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>())</td></tr>
<tr class="memdesc:ab5649cb5f8a57196d43977d5c362c718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>value</code> to the 3D memory region specified by <code>pitch</code> in <code>q</code>.  <a href="namespacesyclcompat.html#ab5649cb5f8a57196d43977d5c362c718">More...</a><br /></td></tr>
<tr class="separator:ab5649cb5f8a57196d43977d5c362c718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aababf558fa90c938a0114bd3fb8669c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#aababf558fa90c938a0114bd3fb8669c9">cast_double_to_int</a> (double d, bool use_high32=true)</td></tr>
<tr class="memdesc:aababf558fa90c938a0114bd3fb8669c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the high or low 32 bits of a double to an integer.  <a href="namespacesyclcompat.html#aababf558fa90c938a0114bd3fb8669c9">More...</a><br /></td></tr>
<tr class="separator:aababf558fa90c938a0114bd3fb8669c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e7d732535672f14d851461b643428"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a070e7d732535672f14d851461b643428">cast_ints_to_double</a> (int high32, int low32)</td></tr>
<tr class="memdesc:a070e7d732535672f14d851461b643428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two integers, the first as the high 32 bits and the second as the low 32 bits, into a double.  <a href="namespacesyclcompat.html#a070e7d732535672f14d851461b643428">More...</a><br /></td></tr>
<tr class="separator:a070e7d732535672f14d851461b643428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c59145672ec00842b62b0cb219384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877c59145672ec00842b62b0cb219384"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a877c59145672ec00842b62b0cb219384">reverse_bits</a> (T a)</td></tr>
<tr class="memdesc:a877c59145672ec00842b62b0cb219384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the bit order of an unsigned integer.  <a href="namespacesyclcompat.html#a877c59145672ec00842b62b0cb219384">More...</a><br /></td></tr>
<tr class="separator:a877c59145672ec00842b62b0cb219384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee727e0bbfa694132c2767768e6a1a1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2ee727e0bbfa694132c2767768e6a1a1">byte_level_permute</a> (unsigned int a, unsigned int b, unsigned int s)</td></tr>
<tr class="separator:a2ee727e0bbfa694132c2767768e6a1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2990f26d3b8377bb41badcae9c7c7dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2990f26d3b8377bb41badcae9c7c7dd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ae2990f26d3b8377bb41badcae9c7c7dd">ffs</a> (T a)</td></tr>
<tr class="memdesc:ae2990f26d3b8377bb41badcae9c7c7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find position of first least significant set bit in an integer.  <a href="namespacesyclcompat.html#ae2990f26d3b8377bb41badcae9c7c7dd">More...</a><br /></td></tr>
<tr class="separator:ae2990f26d3b8377bb41badcae9c7c7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1117445292b8b4ab9a7273bd6332f131"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1117445292b8b4ab9a7273bd6332f131"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1117445292b8b4ab9a7273bd6332f131">select_from_sub_group</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, T x, int remote_local_id, int logical_sub_group_size=32)</td></tr>
<tr class="memdesc:a1117445292b8b4ab9a7273bd6332f131"><td class="mdescLeft">&#160;</td><td class="mdescRight">select_from_sub_group allows work-items to obtain a copy of a value held by any other work-item in the sub_group.  <a href="namespacesyclcompat.html#a1117445292b8b4ab9a7273bd6332f131">More...</a><br /></td></tr>
<tr class="separator:a1117445292b8b4ab9a7273bd6332f131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad6b02e9f18bf61179e2037e1b678f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adad6b02e9f18bf61179e2037e1b678f5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#adad6b02e9f18bf61179e2037e1b678f5">shift_sub_group_left</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, T x, unsigned int delta, int logical_sub_group_size=32)</td></tr>
<tr class="memdesc:adad6b02e9f18bf61179e2037e1b678f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">shift_sub_group_left move values held by the work-items in a sub_group directly to another work-item in the sub_group, by shifting values a fixed number of work-items to the left.  <a href="namespacesyclcompat.html#adad6b02e9f18bf61179e2037e1b678f5">More...</a><br /></td></tr>
<tr class="separator:adad6b02e9f18bf61179e2037e1b678f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8af01b4f8b92249353dcaee7cb74a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb8af01b4f8b92249353dcaee7cb74a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#abb8af01b4f8b92249353dcaee7cb74a8">shift_sub_group_right</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, T x, unsigned int delta, int logical_sub_group_size=32)</td></tr>
<tr class="memdesc:abb8af01b4f8b92249353dcaee7cb74a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">shift_sub_group_right move values held by the work-items in a sub_group directly to another work-item in the sub_group, by shifting values a fixed number of work-items to the right.  <a href="namespacesyclcompat.html#abb8af01b4f8b92249353dcaee7cb74a8">More...</a><br /></td></tr>
<tr class="separator:abb8af01b4f8b92249353dcaee7cb74a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da621ecd0a155041a1ab3babf8bbf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4da621ecd0a155041a1ab3babf8bbf3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#ab4da621ecd0a155041a1ab3babf8bbf3">permute_sub_group_by_xor</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, T x, unsigned int mask, int logical_sub_group_size=32)</td></tr>
<tr class="memdesc:ab4da621ecd0a155041a1ab3babf8bbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">permute_sub_group_by_xor permutes values by exchanging values held by pairs of work-items identified by computing the bitwise exclusive OR of the work-item id and some fixed mask.  <a href="namespacesyclcompat.html#ab4da621ecd0a155041a1ab3babf8bbf3">More...</a><br /></td></tr>
<tr class="separator:ab4da621ecd0a155041a1ab3babf8bbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c50eec86d9f7adfc9ed8fe6f787b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a9e9c50eec86d9f7adfc9ed8fe6f787b1">get_sycl_language_version</a> ()</td></tr>
<tr class="memdesc:a9e9c50eec86d9f7adfc9ed8fe6f787b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherited from the original SYCLomatic compatibility headers.  <a href="namespacesyclcompat.html#a9e9c50eec86d9f7adfc9ed8fe6f787b1">More...</a><br /></td></tr>
<tr class="separator:a9e9c50eec86d9f7adfc9ed8fe6f787b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2955af6db3cf9aae710187072b3c3757"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2955af6db3cf9aae710187072b3c3757"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a2955af6db3cf9aae710187072b3c3757">match_any_over_sub_group</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, unsigned member_mask, T value)</td></tr>
<tr class="memdesc:a2955af6db3cf9aae710187072b3c3757"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function match_any_over_sub_group conducts a comparison of values across work-items within a sub-group.  <a href="namespacesyclcompat.html#a2955af6db3cf9aae710187072b3c3757">More...</a><br /></td></tr>
<tr class="separator:a2955af6db3cf9aae710187072b3c3757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d45353c2b332863e8904775dc1ad146"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d45353c2b332863e8904775dc1ad146"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a6d45353c2b332863e8904775dc1ad146">match_all_over_sub_group</a> (<a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a> g, unsigned member_mask, T value, int *pred)</td></tr>
<tr class="memdesc:a6d45353c2b332863e8904775dc1ad146"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function match_all_over_sub_group conducts a comparison of values across work-items within a sub-group.  <a href="namespacesyclcompat.html#a6d45353c2b332863e8904775dc1ad146">More...</a><br /></td></tr>
<tr class="separator:a6d45353c2b332863e8904775dc1ad146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1385985ccfe147c96c3bd2b213fb1f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesyclcompat.html#a4d6e9f8a69c836759d611d115bf0a6f7">queue_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesyclcompat.html#a1385985ccfe147c96c3bd2b213fb1f15">int_as_queue_ptr</a> (uintptr_t x)</td></tr>
<tr class="memdesc:a1385985ccfe147c96c3bd2b213fb1f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">If x &lt;= 2, then return a pointer to the default queue; otherwise, return x reinterpreted as a queue_ptr.  <a href="namespacesyclcompat.html#a1385985ccfe147c96c3bd2b213fb1f15">More...</a><br /></td></tr>
<tr class="separator:a1385985ccfe147c96c3bd2b213fb1f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad3cc02af8f079b9ed7c68a35a2119d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cc02af8f079b9ed7c68a35a2119d3f">&#9670;&nbsp;</a></span>arith_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">syclcompat::arith_t</a> = typedef typename <a class="el" href="structsyclcompat_1_1arith.html">arith</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00042">42</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a20d334cfc720dcdf7c959caa4da33343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d334cfc720dcdf7c959caa4da33343">&#9670;&nbsp;</a></span>byte_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a20d334cfc720dcdf7c959caa4da33343">syclcompat::byte_t</a> = typedef uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00097">97</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a7404b0ace19666b93b631cfeb643e41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7404b0ace19666b93b631cfeb643e41d">&#9670;&nbsp;</a></span>constant_memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t Dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a7404b0ace19666b93b631cfeb643e41d">syclcompat::constant_memory</a> = typedef <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt;T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea617ac08757d38a5a7ed91c224f0e90a0">memory_region::constant</a>, Dimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l01159">1159</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="af5c51cceeff1ab9a650f1a5022ea75cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c51cceeff1ab9a650f1a5022ea75cf">&#9670;&nbsp;</a></span>device_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#af5c51cceeff1ab9a650f1a5022ea75cf">syclcompat::device_ptr</a> = typedef char *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00084">84</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

</div>
</div>
<a id="ad12db87a8e1dcae8108de2263e2a9150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12db87a8e1dcae8108de2263e2a9150">&#9670;&nbsp;</a></span>err0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#ad12db87a8e1dcae8108de2263e2a9150">syclcompat::err0</a> = typedef <a class="el" href="classsyclcompat_1_1detail_1_1generic__error__type.html">detail::generic_error_type</a>&lt;struct err0_tag, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00132">132</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="adf9b4ad277d57da5476387507f0576a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9b4ad277d57da5476387507f0576a0">&#9670;&nbsp;</a></span>err1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#adf9b4ad277d57da5476387507f0576a0">syclcompat::err1</a> = typedef <a class="el" href="classsyclcompat_1_1detail_1_1generic__error__type.html">detail::generic_error_type</a>&lt;struct err1_tag, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00133">133</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a4570dc377234b5e434c0acfc4c5d01da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4570dc377234b5e434c0acfc4c5d01da">&#9670;&nbsp;</a></span>event_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a4570dc377234b5e434c0acfc4c5d01da">syclcompat::event_ptr</a> = typedef <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00080">80</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

</div>
</div>
<a id="a8f379ff028549b1c4312a23c39753e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f379ff028549b1c4312a23c39753e43">&#9670;&nbsp;</a></span>global_memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t Dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a8f379ff028549b1c4312a23c39753e43">syclcompat::global_memory</a> = typedef <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt;T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7ea9c70933aff6b2a6d08c687a6cbb6b765">memory_region::global</a>, Dimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l01157">1157</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a36e80f614a873f90786e7c52680708cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e80f614a873f90786e7c52680708cc">&#9670;&nbsp;</a></span>kernel_functor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* syclcompat::kernel_functor) (<a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;, const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; 3 &gt; &amp;, unsigned int, void **, void **)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00059">59</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

</div>
</div>
<a id="a4d6e9f8a69c836759d611d115bf0a6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6e9f8a69c836759d611d115bf0a6f7">&#9670;&nbsp;</a></span>queue_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a4d6e9f8a69c836759d611d115bf0a6f7">syclcompat::queue_ptr</a> = typedef <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00082">82</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

</div>
</div>
<a id="a299845541af5f774b44ba0e522721774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299845541af5f774b44ba0e522721774">&#9670;&nbsp;</a></span>shared_memory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t Dimension&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a299845541af5f774b44ba0e522721774">syclcompat::shared_memory</a> = typedef <a class="el" href="classsyclcompat_1_1device__memory.html">device_memory</a>&lt;T, <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7eaef16beba4bcd6c1de447a651f054be05">memory_region::usm_shared</a>, Dimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l01161">1161</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a7b19671aff0ceba14c1a3f5f1615e7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b19671aff0ceba14c1a3f5f1615e7e8">&#9670;&nbsp;</a></span>type_identity_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">syclcompat::type_identity_t</a> = typedef typename <a class="el" href="structsyclcompat_1_1type__identity.html">type_identity</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00035">35</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac9df5b0e17a975d2fd8feef36f0ce4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9df5b0e17a975d2fd8feef36f0ce4ba">&#9670;&nbsp;</a></span>error_code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesyclcompat.html#ac9df5b0e17a975d2fd8feef36f0ce4ba">syclcompat::error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac9df5b0e17a975d2fd8feef36f0ce4baaf12697db8c07bf0ca36f6ab817a291f3"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac9df5b0e17a975d2fd8feef36f0ce4baa761fb0a1e381b9c67dd17e512126df78"></a>BACKEND_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac9df5b0e17a975d2fd8feef36f0ce4baa1020859b0b70472d8b2eebfbbd7035ed"></a>DEFAULT_ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="defs_8hpp_source.html#l00059">59</a> of file <a class="el" href="defs_8hpp_source.html">defs.hpp</a>.</p>

</div>
</div>
<a id="a565b2d3d3c1d6ba009f9e62129cb5c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565b2d3d3c1d6ba009f9e62129cb5c7e">&#9670;&nbsp;</a></span>memory_region</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesyclcompat.html#a565b2d3d3c1d6ba009f9e62129cb5c7e">syclcompat::memory_region</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a565b2d3d3c1d6ba009f9e62129cb5c7ea9c70933aff6b2a6d08c687a6cbb6b765"></a>global&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a565b2d3d3c1d6ba009f9e62129cb5c7ea617ac08757d38a5a7ed91c224f0e90a0"></a>constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a565b2d3d3c1d6ba009f9e62129cb5c7eaf5ddaf0ca7929578b408c909429f68f2"></a>local&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a565b2d3d3c1d6ba009f9e62129cb5c7eaef16beba4bcd6c1de447a651f054be05"></a>usm_shared&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00088">88</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ad81aef3206734209057e7fa5429b849c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81aef3206734209057e7fa5429b849c">&#9670;&nbsp;</a></span>target</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesyclcompat.html#ad81aef3206734209057e7fa5429b849c">syclcompat::target</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad81aef3206734209057e7fa5429b849ca913f9c49dcb544e2087cee284f4a00b7"></a>device&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad81aef3206734209057e7fa5429b849caf5ddaf0ca7929578b408c909429f68f2"></a>local&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00095">95</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c77d82466c5c8bdc7aab25c6a6ff5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c77d82466c5c8bdc7aab25c6a6ff5e0">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1multi__ptr.html">sycl::multi_ptr</a>&lt; T, sycl::access::address_space::generic_space &gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em> = <code>sycl::memory_order::relaxed</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a>&#160;</td>
          <td class="paramname"><em>fail</em> = <code>sycl::memory_order::relaxed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically compare the value at <code>addr</code> to the value expected and exchange with the value desired if the value at <code>addr</code> is equal to the value expected. </p>
<p>Returns the value at the <code>addr</code> before the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>Multi_ptr. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">expected</td><td>The value to compare against the value at <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">desired</td><td>The value to assign to <code>addr</code> if the value at <code>addr</code> is expected. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">success</td><td>The memory ordering used when comparison succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fail</td><td>The memory ordering used when comparison fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00253">253</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="ac37ed7afef52f6347ecb606cf3397461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37ed7afef52f6347ecb606cf3397461">&#9670;&nbsp;</a></span>atomic_compare_exchange_strong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_compare_exchange_strong </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a>&#160;</td>
          <td class="paramname"><em>success</em> = <code>sycl::memory_order::relaxed</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae1b5256f6c01d5c133ca46e1014439d4">sycl::memory_order</a>&#160;</td>
          <td class="paramname"><em>fail</em> = <code>sycl::memory_order::relaxed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically compare the value at <code>addr</code> to the value expected and exchange with the value desired if the value at <code>addr</code> is equal to the value expected. </p>
<p>Returns the value at the <code>addr</code> before the call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">expected</td><td>The value to compare against the value at <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">desired</td><td>The value to assign to <code>addr</code> if the value at <code>addr</code> is expected. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">success</td><td>The memory ordering used when comparison succeeds. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fail</td><td>The memory ordering used when comparison fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00279">279</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="af435aa9b16d17415acbdda668d97a82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af435aa9b16d17415acbdda668d97a82a">&#9670;&nbsp;</a></span>atomic_exchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_exchange </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically exchange the value at the address addr with the value operand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to be exchanged with the value pointed by <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00232">232</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="affd5fb03de12340076f5de7ce46b9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd5fb03de12340076f5de7ce46b9827">&#9670;&nbsp;</a></span>atomic_fetch_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_add </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">arith_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add the value operand to the value at the addr and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to add to the value at <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00056">56</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="a4e0a22ac7643dfaeb1b9cb98bfda2e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0a22ac7643dfaeb1b9cb98bfda2e00">&#9670;&nbsp;</a></span>atomic_fetch_and()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_and </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically perform a bitwise AND between the value operand and the value at the addr and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to use in bitwise AND operation with the value at the <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00091">91</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="abad2bb67d94f0e525c9c768646b30f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad2bb67d94f0e525c9c768646b30f80">&#9670;&nbsp;</a></span>atomic_fetch_compare_dec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int syclcompat::atomic_fetch_compare_dec </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically set <code>operand</code> to the value stored in <code>addr</code>, if old value stored in <code>addr</code> is equal to zero or greater than <code>operand</code>, else decrease the value stored in <code>addr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The threshold value. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value stored in <code>addr</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00176">176</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="a6fd2aa5acc6e278fbfeab1d80afd7739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd2aa5acc6e278fbfeab1d80afd7739">&#9670;&nbsp;</a></span>atomic_fetch_compare_inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int syclcompat::atomic_fetch_compare_inc </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increment the value stored in <code>addr</code> if old value stored in <code>addr</code> is less than <code>operand</code>, else set 0 to the value stored in <code>addr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The threshold value. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value stored in <code>addr</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00205">205</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="a8f1c0fa55fcb68c778eb14288d33b7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1c0fa55fcb68c778eb14288d33b7c4">&#9670;&nbsp;</a></span>atomic_fetch_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_max </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically calculate the maximum of the value at addr and the value operand and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand.</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00160">160</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="aa744bf05c50d2f850c04b23097450b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa744bf05c50d2f850c04b23097450b36">&#9670;&nbsp;</a></span>atomic_fetch_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_min </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically calculate the minimum of the value at addr and the value operand and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand.</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00143">143</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="ae06163f1b6ca4a73c7f75ea38cbb7b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06163f1b6ca4a73c7f75ea38cbb7b18">&#9670;&nbsp;</a></span>atomic_fetch_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_or </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically or the value at the addr with the value operand, and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to use in bitwise OR operation with the value at the <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00109">109</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="a746b4ddb817c99930c23a03f51891b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746b4ddb817c99930c23a03f51891b44">&#9670;&nbsp;</a></span>atomic_fetch_sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_sub </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#ad3cc02af8f079b9ed7c68a35a2119d3f">arith_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtract the value operand from the value at the addr and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to subtract from the value at <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00073">73</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="ab0a04a345069fdf52c36403238b0d345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a04a345069fdf52c36403238b0d345">&#9670;&nbsp;</a></span>atomic_fetch_xor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;sycl::access::address_space addressSpace = sycl::access::address_space::generic_space, sycl::memory_order memoryOrder = sycl::memory_order::relaxed, sycl::memory_scope memoryScope = sycl::memory_scope::device, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::atomic_fetch_xor </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically xor the value at the addr with the value operand, and assign the result to the value at addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">addr</td><td>The pointer to the data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operand</td><td>The value to use in bitwise XOR operation with the value at the <code>addr</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">memoryOrder</td><td>The memory ordering used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <code>addr</code> before the call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2atomic_8hpp_source.html#l00127">127</a> of file <a class="el" href="syclcompat_2atomic_8hpp_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a id="a2ee727e0bbfa694132c2767768e6a1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee727e0bbfa694132c2767768e6a1a1">&#9670;&nbsp;</a></span>byte_level_permute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int syclcompat::byte_level_permute </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value contains 4 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value contains 4 bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>The selector value, only lower 16bit used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation result of 4 bytes selected in the way specified by <code>s</code> from <code>a</code> and <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00181">181</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a3c10c27d44679e0ae2829cb48ab76d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c10c27d44679e0ae2829cb48ab76d14">&#9670;&nbsp;</a></span>cabs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::cabs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the magnitude of a complex number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Complex element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00572">572</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00166">sycl::_V1::ext::intel::esimd::abs()</a>.</p>

</div>
</div>
<a id="aababf558fa90c938a0114bd3fb8669c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aababf558fa90c938a0114bd3fb8669c9">&#9670;&nbsp;</a></span>cast_double_to_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int syclcompat::cast_double_to_int </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_high32</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the high or low 32 bits of a double to an integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The double value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_high32</td><td>Cast the high 32 bits of the double if true; otherwise cast the low 32 bits. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00139">139</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a070e7d732535672f14d851461b643428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070e7d732535672f14d851461b643428">&#9670;&nbsp;</a></span>cast_ints_to_double()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double syclcompat::cast_ints_to_double </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>high32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>low32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine two integers, the first as the high 32 bits and the second as the low 32 bits, into a double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">high32</td><td>The integer as the high 32 bits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low32</td><td>The integer as the low 32 bits </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00151">151</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a8cba95047e6b327a88374d0ad3a595b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cba95047e6b327a88374d0ad3a595b7">&#9670;&nbsp;</a></span>cbrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; || std::is_same_v&lt;<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT&gt;, ValueT&gt; syclcompat::cbrt </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cbrt function wrapper. </p>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00417">417</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a98ca4eb5a166e3a49c085c9445fef3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ca4eb5a166e3a49c085c9445fef3c3">&#9670;&nbsp;</a></span>cdiv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;T, 2&gt; syclcompat::cdiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the division of two complex numbers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Complex element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The first input complex number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The second input complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00562">562</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab9be2b3ef2fed36c10d60ac4eb130f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9be2b3ef2fed36c10d60ac4eb130f5c">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueT syclcompat::clamp </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns min(max(val, min_val), max_val) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The input value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_val</td><td>The minimum value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_val</td><td>The maximum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value between min_val and max_val </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00400">400</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00051">syclcompat::detail::clamp()</a>.</p>

</div>
</div>
<a id="aedacf06b344702068bd0e09261dda844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedacf06b344702068bd0e09261dda844">&#9670;&nbsp;</a></span>cmul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;T, 2&gt; syclcompat::cmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the multiplication of two complex numbers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Complex element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The first input complex number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The second input complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00550">550</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a4415353f91d200fc2fbea022e53e336e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4415353f91d200fc2fbea022e53e336e">&#9670;&nbsp;</a></span>cmul_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt;ValueT, 2&gt; syclcompat::cmul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00603">603</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab11b7d2b288bb226ea5209062146ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11b7d2b288bb226ea5209062146ec63">&#9670;&nbsp;</a></span>cmul_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;ValueT, 2&gt; syclcompat::cmul_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs complex number multiply addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the operation result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00593">593</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a33a123aec0583990a7a4a44531e407e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a123aec0583990a7a4a44531e407e7">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt; syclcompat::compare </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00188">188</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00207">compare()</a>, <a class="el" href="ompat_2math_8hpp_source.html#l00245">compare_both()</a>, and <a class="el" href="ompat_2math_8hpp_source.html#l00271">compare_mask()</a>.</p>

</div>
</div>
<a id="a1df4167f117b91719debbcd1f8d954c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df4167f117b91719debbcd1f8d954c4">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;ValueT::size() == 2, ValueT&gt; syclcompat::compare </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 element comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00207">207</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00188">compare()</a>.</p>

</div>
</div>
<a id="a40a07bd08286d8161d4f99e34e89c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a07bd08286d8161d4f99e34e89c01c">&#9670;&nbsp;</a></span>compare() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;std::invoke_result_t&lt;std::not_equal_to&lt;&gt;, ValueT, ValueT&gt;, bool&gt;, bool&gt; syclcompat::compare </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::not_equal_to&lt;&gt;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00196">196</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

</div>
</div>
<a id="ac829511f38fb4f876d37b587190d00b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac829511f38fb4f876d37b587190d00b8">&#9670;&nbsp;</a></span>compare_both()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;ValueT::size() == 2, bool&gt; syclcompat::compare_both </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 element comparison and return true if both results are true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00245">245</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00188">compare()</a>.</p>

</div>
</div>
<a id="ac29a2946cfc8b1e5053f1d11a3f81a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29a2946cfc8b1e5053f1d11a3f81a55">&#9670;&nbsp;</a></span>compare_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syclcompat::compare_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 elements comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00271">271</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00188">compare()</a>.</p>

</div>
</div>
<a id="a059609bb8b030e02033312593fe5047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059609bb8b030e02033312593fe5047a">&#9670;&nbsp;</a></span>compute_nd_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt;1&gt; syclcompat::compute_nd_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>global_size_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>work_group_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00110">110</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="oneapi_2kernel__properties_2properties_8hpp_source.html#l00117">sycl::_V1::ext::oneapi::experimental::work_group_size</a>.</p>

</div>
</div>
<a id="a646c5288e3a8968d2d0182ea79ee8a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646c5288e3a8968d2d0182ea79ee8a3e">&#9670;&nbsp;</a></span>compute_nd_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt;Dim&gt; syclcompat::compute_nd_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>global_size_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; Dim &gt;&#160;</td>
          <td class="paramname"><em>work_group_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00093">93</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="range_8hpp_source.html#l00056">sycl::_V1::range&lt; Dimensions &gt;::size()</a>, and <a class="el" href="oneapi_2kernel__properties_2properties_8hpp_source.html#l00117">sycl::_V1::ext::oneapi::experimental::work_group_size</a>.</p>

</div>
</div>
<a id="a74bdeb6e393e3bb3493787eafef19dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bdeb6e393e3bb3493787eafef19dca">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;T, 2&gt; syclcompat::conj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the complex conjugate of a complex number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Complex element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The input complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00581">581</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a9c887b868bc53711bbaf533385e2975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c887b868bc53711bbaf533385e2975c">&#9670;&nbsp;</a></span>cpu_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a>&amp; syclcompat::cpu_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get a CPU device. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00788">788</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00633">syclcompat::detail::dev_mgr::cpu_device()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

</div>
</div>
<a id="a110c1e925095492f2b25c879141ab136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110c1e925095492f2b25c879141ab136">&#9670;&nbsp;</a></span>create_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> syclcompat::create_queue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_on_async_exceptions</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>in_order</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00736">736</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00478">syclcompat::device_ext::create_queue()</a>, <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

</div>
</div>
<a id="aa32b20f10c68bdb00e5d72b865c0eb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32b20f10c68bdb00e5d72b865c0eb1e">&#9670;&nbsp;</a></span>destroy_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::destroy_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a4570dc377234b5e434c0acfc4c5d01da">event_ptr</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy <code>event</code> pointed memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Pointer to the <a class="el" href="classsycl_1_1__V1_1_1event.html" title="An event object can be used to synchronize memory transfers, enqueues of kernels and signaling barrie...">sycl::event</a> address. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00089">89</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

</div>
</div>
<a id="a67762a6b2faa454a541b765c35164af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67762a6b2faa454a541b765c35164af4">&#9670;&nbsp;</a></span>extend_absdiff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_absdiff </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00825">825</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a340c344b03eef89ef8abc09cdafd03ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340c344b03eef89ef8abc09cdafd03ea">&#9670;&nbsp;</a></span>extend_absdiff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_absdiff </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> of <code>a</code>, <code>b</code> and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00843">843</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a10430015596393bf2dce1e007dfcca07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10430015596393bf2dce1e007dfcca07">&#9670;&nbsp;</a></span>extend_absdiff_sat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_absdiff_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and do <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> with saturation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> of the two values with saturation </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00856">856</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a3cf831fb5b0e0779bb550851b73af89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf831fb5b0e0779bb550851b73af89b">&#9670;&nbsp;</a></span>extend_absdiff_sat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_absdiff_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend <a class="el" href="structsyclcompat_1_1abs__diff.html" title="A sycl::abs_diff wrapper functors.">abs_diff</a> of <code>a</code>, <code>b</code> with saturation and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00875">875</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a2322aed08cbe875a97da83f7dcc8a61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2322aed08cbe875a97da83f7dcc8a61f">&#9670;&nbsp;</a></span>extend_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_add </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and add them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend addition of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00703">703</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="acebd1383b7ad2eeba4f7749eb99e0bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebd1383b7ad2eeba4f7749eb99e0bc0">&#9670;&nbsp;</a></span>extend_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_add </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, add <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend addition of <code>a</code>, <code>b</code> and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00720">720</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a3b249ad38d46680197b4252ba0a36a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b249ad38d46680197b4252ba0a36a60">&#9670;&nbsp;</a></span>extend_add_sat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_add_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and add them with saturation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend addition of the two values with saturation </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00732">732</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a8160bb0989abca1627abc8848d3e5d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8160bb0989abca1627abc8848d3e5d45">&#9670;&nbsp;</a></span>extend_add_sat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_add_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, add <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend addition of <code>a</code>, <code>b</code> with saturation and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00751">751</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a533cffd30b30a7a51f6e51283f6ad0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533cffd30b30a7a51f6e51283f6ad0fc">&#9670;&nbsp;</a></span>extend_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_max </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bigger one of the two extended values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00950">950</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aba8ec078f14bae384ecab4c45801b117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8ec078f14bae384ecab4c45801b117">&#9670;&nbsp;</a></span>extend_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_max </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bigger one of <code>a</code>, <code>b</code> and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00968">968</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a36d428f4281cef11e44e37b69d62876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d428f4281cef11e44e37b69d62876d">&#9670;&nbsp;</a></span>extend_max_sat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_max_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and return bigger one with saturation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bigger one of the two extended values with saturation </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00980">980</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a60b890c4272f2b5c60e2205f90b422f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b890c4272f2b5c60e2205f90b422f2">&#9670;&nbsp;</a></span>extend_max_sat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_max_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, find the bigger one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bigger one of <code>a</code>, <code>b</code> with saturation and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00999">999</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a513cddbc8845e942c38c04484ddb359b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513cddbc8845e942c38c04484ddb359b">&#9670;&nbsp;</a></span>extend_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_min </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller one of the two extended values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00888">888</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a4a77de29a1c643284782b3c83fba3d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a77de29a1c643284782b3c83fba3d69">&#9670;&nbsp;</a></span>extend_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_min </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller one of <code>a</code>, <code>b</code> and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00906">906</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a696a528e5d9dbe5944898a5a5ed7bf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696a528e5d9dbe5944898a5a5ed7bf6b">&#9670;&nbsp;</a></span>extend_min_sat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_min_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and return smaller one with saturation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller one of the two extended values with saturation </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00918">918</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="afcaf721a651b4656ca9f024818537215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcaf721a651b4656ca9f024818537215">&#9670;&nbsp;</a></span>extend_min_sat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_min_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, find the smaller one in <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller one of <code>a</code>, <code>b</code> with saturation and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00937">937</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a340a282cecb3084c18e11203262ef7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340a282cecb3084c18e11203262ef7d0">&#9670;&nbsp;</a></span>extend_sub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_sub </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and minus them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend subtraction of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00764">764</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad24d3ca4111c0870bce355c7283b2588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24d3ca4111c0870bce355c7283b2588">&#9670;&nbsp;</a></span>extend_sub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_sub </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code>, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend subtraction of <code>a</code>, <code>b</code> and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00781">781</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ab537af4548527320497820dbe606d5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab537af4548527320497820dbe606d5fa">&#9670;&nbsp;</a></span>extend_sub_sat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_sub_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend <code>a</code> and <code>b</code> to 33 bit and minus them with saturation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend subtraction of the two values with saturation </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00793">793</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a095a7e145440a9bee06ed5f885bcee62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095a7e145440a9bee06ed5f885bcee62">&#9670;&nbsp;</a></span>extend_sub_sat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RetT , typename AT , typename BT , typename CT , typename BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr RetT syclcompat::extend_sub_sat </td>
          <td>(</td>
          <td class="paramtype">AT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CT&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend Inputs to 33 bit, minus <code>a</code>, <code>b</code> with saturation, then do <code>second_op</code> with <code>c</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>RetT The type of the return value </td></tr>
    <tr><td class="paramname">[in]</td><td>AT The type of the first value </td></tr>
    <tr><td class="paramname">[in]</td><td>BT The type of the second value </td></tr>
    <tr><td class="paramname">[in]</td><td>CT The type of the third value </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The type of the second operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The third value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second_op</td><td>The operation to do with the third value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extend subtraction of <code>a</code>, <code>b</code> with saturation and <code>second_op</code> with <code>c</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00812">812</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a3ae74a23f7ffa7b31650daee0412f2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae74a23f7ffa7b31650daee0412f2b8">&#9670;&nbsp;</a></span>fast_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float syclcompat::fast_length </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute fast_length for variable-length array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed fast_length </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00136">136</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2math_8hpp_source.html#l00194">sycl::_V1::ext::intel::math::sqrt()</a>.</p>

</div>
</div>
<a id="ae2990f26d3b8377bb41badcae9c7c7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2990f26d3b8377bb41badcae9c7c7dd">&#9670;&nbsp;</a></span>ffs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int syclcompat::ffs </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find position of first least significant set bit in an integer. </p>
<p>ffs(0) returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00197">197</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="aa555a5c37f9422a6034503545bac2349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa555a5c37f9422a6034503545bac2349">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::fill </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously sets <code>pattern</code> to the first <code>count</code> elements starting from <code>dev_ptr</code>. </p>
<p>The function will return after the fill operation is completed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Datatype of the value to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>Pointer to the device memory address. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of type <code>T</code> to be set. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to be set to the patten. </td></tr>
    <tr><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00721">721</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00738">fill_async()</a>.</p>

</div>
</div>
<a id="ad04308ffd19da9568264086fcf59e198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04308ffd19da9568264086fcf59e198">&#9670;&nbsp;</a></span>fill_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::fill_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously sets <code>pattern</code> to the first <code>count</code> elements starting from <code>dev_ptr</code>. </p>
<p>The return of the function does NOT guarantee the fill operation is completed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Datatype of the pattern to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>Pointer to the device memory address. </td></tr>
    <tr><td class="paramname">pattern</td><td>Pattern of type <code>T</code> to be set. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to be set to the patten. </td></tr>
    <tr><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the fill operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00738">738</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00721">fill()</a>.</p>

</div>
</div>
<a id="a56980b5d12a81c3e1316d788f7730a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56980b5d12a81c3e1316d788f7730a24">&#9670;&nbsp;</a></span>fmax_nan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;std::common_type_t&lt;ValueT, ValueU&gt;, 2&gt; syclcompat::fmax_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00475">475</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00466">fmax_nan()</a>.</p>

</div>
</div>
<a id="a615ce353b7e9f28276758fe1eacf4aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615ce353b7e9f28276758fe1eacf4aaf">&#9670;&nbsp;</a></span>fmax_nan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::common_type_t&lt;ValueT, ValueU&gt; syclcompat::fmax_nan </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 elements comparison and returns the bigger one. </p>
<p>If either of inputs is NaN, then return NaN. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bigger value </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00466">466</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00475">fmax_nan()</a>.</p>

</div>
</div>
<a id="a6f095a3499a1a403aa3a5c523af0f445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f095a3499a1a403aa3a5c523af0f445">&#9670;&nbsp;</a></span>fmin_nan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;std::common_type_t&lt;ValueT, ValueU&gt;, 2&gt; syclcompat::fmin_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueU, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00494">494</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00485">fmin_nan()</a>.</p>

</div>
</div>
<a id="aa6e292b332c72f1e012dfff1543122ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e292b332c72f1e012dfff1543122ad">&#9670;&nbsp;</a></span>fmin_nan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::common_type_t&lt;ValueT, ValueU&gt; syclcompat::fmin_nan </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 elements comparison and returns the smaller one. </p>
<p>If either of inputs is NaN, then return NaN. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smaller value </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00485">485</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00494">fmin_nan()</a>.</p>

</div>
</div>
<a id="a2405e7e737482cc13809fb2260cd7cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405e7e737482cc13809fb2260cd7cc7">&#9670;&nbsp;</a></span>free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>free </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Point to free. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the free task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00536">536</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="queue_8cpp_source.html#l00074">sycl::_V1::queue::get_context()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l01056">syclcompat::device_memory&lt; T, Memory, Dimension &gt;::~device_memory()</a>.</p>

</div>
</div>
<a id="ac3c4f6e0b0f5ffcd40e4ea17e97e17dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c4f6e0b0f5ffcd40e4ea17e97e17dd">&#9670;&nbsp;</a></span>free_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::free_async </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the device memory pointed by a batch of pointers in <code>pointers</code> which are related to <code>q</code> after <code>events</code> completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointers</td><td>The pointers point to the device memory requested to be freed.</td></tr>
    <tr><td class="paramname">events</td><td>The events to be waited.</td></tr>
    <tr><td class="paramname">q</td><td>The <a class="el" href="classsycl_1_1__V1_1_1queue.html" title="Encapsulates a single SYCL queue which schedules kernels on a SYCL device.">sycl::queue</a> the memory relates to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00549">549</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a59b3ae5459d3498b3888b2688acefab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b3ae5459d3498b3888b2688acefab4">&#9670;&nbsp;</a></span>get_current_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a>&amp; syclcompat::get_current_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get the current device. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00772">772</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2util_8hpp_source.html#l00751">syclcompat::experimental::calculate_max_active_wg_per_xecore()</a>, <a class="el" href="ompat_2util_8hpp_source.html#l00816">syclcompat::experimental::calculate_max_potential_wg()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00783">get_default_context()</a>.</p>

</div>
</div>
<a id="a74920a687e04d5ecb59233c777f13416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74920a687e04d5ecb59233c777f13416">&#9670;&nbsp;</a></span>get_current_device_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int syclcompat::get_current_device_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get the id of current device in device manager. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00767">767</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00646">syclcompat::detail::dev_mgr::current_device_id()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

</div>
</div>
<a id="acee26fe4fe6f4ca9d1cf164999a65139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee26fe4fe6f4ca9d1cf164999a65139">&#9670;&nbsp;</a></span>get_default_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1context.html">sycl::context</a> syclcompat::get_default_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get the context of the default queue of current device in device manager. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00783">783</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00501">syclcompat::device_ext::get_context()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00772">get_current_device()</a>.</p>

</div>
</div>
<a id="a38b7fd6490005df50af1a36cf808035b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b7fd6490005df50af1a36cf808035b">&#9670;&nbsp;</a></span>get_default_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> syclcompat::get_default_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get the default queue of current device in device manager. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00744">744</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, <a class="el" href="syclcompat_2device_8hpp_source.html#l00466">syclcompat::device_ext::default_queue()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="launch_8hpp_source.html#l00123">launch()</a>.</p>

</div>
</div>
<a id="acc62347d3a31e511868a76c15de26829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc62347d3a31e511868a76c15de26829">&#9670;&nbsp;</a></span>get_device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1device__ext.html">device_ext</a>&amp; syclcompat::get_device </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to get a device by id. </p>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00777">777</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00641">syclcompat::detail::dev_mgr::get_device()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

<p class="reference">Referenced by <a class="el" href="queue__impl_8cpp_source.html#l00073">sycl::_V1::detail::queue_impl::get_backend_info&lt; info::device::version &gt;()</a>, <a class="el" href="queue__impl_8cpp_source.html#l00062">sycl::_V1::detail::queue_impl::get_backend_info&lt; info::platform::version &gt;()</a>, <a class="el" href="queue__impl_8cpp_source.html#l00056">sycl::_V1::detail::queue_impl::get_info&lt; info::queue::device &gt;()</a>, and <a class="el" href="bindless__images_8cpp_source.html#l00066">sycl::_V1::ext::oneapi::experimental::detail::image_mem_impl::~image_mem_impl()</a>.</p>

</div>
</div>
<a id="af8aa24f1a604f305d6e80695fd69a113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8aa24f1a604f305d6e80695fd69a113">&#9670;&nbsp;</a></span>get_device_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int syclcompat::get_device_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1device.html">sycl::device</a> &amp;&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00804">804</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00664">syclcompat::detail::dev_mgr::get_device_id()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>.</p>

</div>
</div>
<a id="a38dcfdd1fa0f22fb45aeaefdd62c087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dcfdd1fa0f22fb45aeaefdd62c087f">&#9670;&nbsp;</a></span>get_kernel_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1kernel__function.html">kernel_function</a> syclcompat::get_kernel_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> &amp;&#160;</td>
          <td class="paramname"><em>library</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find kernel function in a kernel library and return its address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">library</td><td>Handle to the kernel library. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the kernel function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00435">435</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

</div>
</div>
<a id="aab53397f91801cdf59722857305e5fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab53397f91801cdf59722857305e5fc6">&#9670;&nbsp;</a></span>get_kernel_function_info() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structsyclcompat_1_1kernel__function__info.html">kernel_function_info</a> syclcompat::get_kernel_function_info </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00075">75</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>, and <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00063">syclcompat::kernel_function_info::max_work_group_size</a>.</p>

</div>
</div>
<a id="a6614efebb83103f9e84ace3101683ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6614efebb83103f9e84ace3101683ab1">&#9670;&nbsp;</a></span>get_kernel_function_info() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::get_kernel_function_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsyclcompat_1_1kernel__function__info.html">kernel_function_info</a> *&#160;</td>
          <td class="paramname"><em>kernel_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00066">66</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>, and <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00063">syclcompat::kernel_function_info::max_work_group_size</a>.</p>

</div>
</div>
<a id="a9e9c50eec86d9f7adfc9ed8fe6f787b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9c50eec86d9f7adfc9ed8fe6f787b1">&#9670;&nbsp;</a></span>get_sycl_language_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int syclcompat::get_sycl_language_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inherited from the original SYCLomatic compatibility headers. </p>
<dl class="section return"><dt>Returns</dt><dd>compiler's SYCL version if defined, 202000 otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00501">501</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a1385985ccfe147c96c3bd2b213fb1f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1385985ccfe147c96c3bd2b213fb1f15">&#9670;&nbsp;</a></span>int_as_queue_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesyclcompat.html#a4d6e9f8a69c836759d611d115bf0a6f7">queue_ptr</a> syclcompat::int_as_queue_ptr </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If x &lt;= 2, then return a pointer to the default queue; otherwise, return x reinterpreted as a queue_ptr. </p>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00923">923</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="aa2a5f735a7d83ed624e8a4c46ae3de99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a5f735a7d83ed624e8a4c46ae3de99">&#9670;&nbsp;</a></span>invoke_kernel_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::invoke_kernel_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1kernel__function.html">kernel_function</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>group_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>local_mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>kernel_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a kernel function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queue</td><td>SYCL queue used to execute kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group_range</td><td>SYCL group range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="namespacesyclcompat_1_1local__range.html">local_range</a></td><td>SYCL local range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_mem_size</td><td>The size of local memory required by the kernel function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel_params</td><td>Array of pointers to kernel arguments. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">extra</td><td>Extra arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00459">459</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

</div>
</div>
<a id="ad717ffed265f37aad2378786fd6d89f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad717ffed265f37aad2378786fd6d89f4">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;ValueT::size() == 2, ValueT&gt; syclcompat::isnan </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether 2 element value is NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00408">408</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

</div>
</div>
<a id="a087d2c6930b8d056ee4824ef599deeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087d2c6930b8d056ee4824ef599deeae">&#9670;&nbsp;</a></span>launch() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;decltype(F), Args...&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&gt; syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00136">136</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00744">get_default_queue()</a>.</p>

</div>
</div>
<a id="aeee94da5b4aecfdd193f75f17d52b858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee94da5b4aecfdd193f75f17d52b858">&#9670;&nbsp;</a></span>launch() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launches a kernel with the templated F param and arguments on a device with a user-specified grid and block dimensions following the standard of other programming models using the default SYCL queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>SYCL kernel to be executed, expects signature F(T* local_mem, Args... args). </td></tr>
    <tr><td class="paramname">Dim</td><td>nd_range dimension number. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Grid dimensions represented with an (x, y, z) iteration space. </td></tr>
    <tr><td class="paramname">threads</td><td>Block dimensions represented with an (x, y, z) iteration space. </td></tr>
    <tr><td class="paramname">mem_size</td><td>The size, in number of bytes, of the local memory to be allocated. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SYCL event object that can be used to synchronize with the kernel's execution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00218">218</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00744">get_default_queue()</a>.</p>

</div>
</div>
<a id="ac5c89d4f603e97db00587f482df7ca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c89d4f603e97db00587f482df7ca2c">&#9670;&nbsp;</a></span>launch() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launches a kernel with the templated F param and arguments on a device with a user-specified grid and block dimensions following the standard of other programming models using a user-defined SYCL queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>SYCL kernel to be executed, expects signature F(T* local_mem, Args... args). </td></tr>
    <tr><td class="paramname">Dim</td><td>nd_range dimension number. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Grid dimensions represented with an (x, y, z) iteration space. </td></tr>
    <tr><td class="paramname">threads</td><td>Block dimensions represented with an (x, y, z) iteration space. </td></tr>
    <tr><td class="paramname">mem_size</td><td>The size, in number of bytes, of the local memory to be allocated for kernel. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SYCL event object that can be used to synchronize with the kernel's execution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00196">196</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

</div>
</div>
<a id="a741d1f0be2ea198c33fdbdb335373830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741d1f0be2ea198c33fdbdb335373830">&#9670;&nbsp;</a></span>launch() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;decltype(F), Args...&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&gt; syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00130">130</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

</div>
</div>
<a id="a0e14af63b7aa04b211d76c8c138df1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e14af63b7aa04b211d76c8c138df1c1">&#9670;&nbsp;</a></span>launch() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, int Dim, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;decltype(F), Args...&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&gt; syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00123">123</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00744">get_default_queue()</a>.</p>

</div>
</div>
<a id="ad91edb2e1a17f68148a30f1aae1b7f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91edb2e1a17f68148a30f1aae1b7f9e">&#9670;&nbsp;</a></span>launch() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, int Dim, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launches a kernel with the templated F param and arguments on a device specified by the given nd_range using theSYCL default queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>SYCL kernel to be executed, expects signature F(T* local_mem, Args... args). </td></tr>
    <tr><td class="paramname">Dim</td><td>nd_range dimension number. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Nd_range specifying the work group and global sizes for the kernel. </td></tr>
    <tr><td class="paramname">mem_size</td><td>The size, in number of bytes, of the local memory to be allocated for kernel. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SYCL event object that can be used to synchronize with the kernel's execution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00175">175</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00744">get_default_queue()</a>.</p>

</div>
</div>
<a id="a978d583d934306a78f6bf778cdb24cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978d583d934306a78f6bf778cdb24cd9">&#9670;&nbsp;</a></span>launch() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, int Dim, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launches a kernel with the templated F param and arguments on a device specified by the given nd_range and SYCL queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>SYCL kernel to be executed, expects signature F(T* local_mem, Args... args). </td></tr>
    <tr><td class="paramname">Dim</td><td>nd_range dimension number. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of the arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Nd_range specifying the work group and global sizes for the kernel. </td></tr>
    <tr><td class="paramname">q</td><td>The SYCL queue on which to execute the kernel. </td></tr>
    <tr><td class="paramname">mem_size</td><td>The size, in number of bytes, of the local memory to be allocated for kernel. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to be passed to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SYCL event object that can be used to synchronize with the kernel's execution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00155">155</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

</div>
</div>
<a id="abeafdaba8af089ffb199a179591470f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeafdaba8af089ffb199a179591470f8">&#9670;&nbsp;</a></span>launch() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto F, int Dim, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_invocable_v&lt;decltype(F), Args...&gt;, <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a>&gt; syclcompat::launch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1nd__range.html">sycl::nd_range</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="launch_8hpp_source.html#l00117">117</a> of file <a class="el" href="launch_8hpp_source.html">launch.hpp</a>.</p>

</div>
</div>
<a id="ac5204b4194f5c613a63ff91f28d31a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5204b4194f5c613a63ff91f28d31a44">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueT syclcompat::length </td>
          <td>(</td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the square root of the input array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The array pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square root </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00161">161</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2math_8hpp_source.html#l00194">sycl::_V1::ext::intel::math::sqrt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="syclcompat_2device_8hpp_source.html#l00166">syclcompat::device_info::set_name()</a>, and <a class="el" href="simd__obj__impl_8hpp_source.html#l00646">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::writeRegion()</a>.</p>

</div>
</div>
<a id="a585befc6125c977ceb4eab60f4892d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585befc6125c977ceb4eab60f4892d04">&#9670;&nbsp;</a></span>load_kernel_library()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> syclcompat::load_kernel_library </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load kernel library and return a handle to use the library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the library. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00386">386</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00357">syclcompat::detail::load_dl_from_data()</a>.</p>

</div>
</div>
<a id="a9ab4ddfee87793003a6bbb57d49fd2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab4ddfee87793003a6bbb57d49fd2a6">&#9670;&nbsp;</a></span>load_kernel_library_mem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> syclcompat::load_kernel_library_mem </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load kernel library whose image is alreay in memory and return a handle to use the library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>A pointer to the image in memory. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00400">400</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00226">syclcompat::detail::get_lib_size()</a>, and <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00357">syclcompat::detail::load_dl_from_data()</a>.</p>

</div>
</div>
<a id="a48cb6115d3ea863770733640e0c24c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cb6115d3ea863770733640e0c24c13">&#9670;&nbsp;</a></span>local_mem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto* syclcompat::local_mem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00069">69</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="launch_8hpp_source.html#l00071">syclcompat::detail::launch()</a>.</p>

</div>
</div>
<a id="acccc3b0bbff2728c7a2f2afc18744ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccc3b0bbff2728c7a2f2afc18744ca0">&#9670;&nbsp;</a></span>malloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* syclcompat::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block for 2D array on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pitch</td><td>Aligned size of x in bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>Range in dim x. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">y</td><td>Range in dim y. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00527">527</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l01001">syclcompat::device_memory&lt; T, Memory, Dimension &gt;::device_memory()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00453">malloc()</a>.</p>

</div>
</div>
<a id="af2c54c29e7d6077d5c6deb8e90437473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c54c29e7d6077d5c6deb8e90437473">&#9670;&nbsp;</a></span>malloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* syclcompat::malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_bytes</td><td>Number of bytes to allocate. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Datatype to allocate </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements to allocate. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00453">453</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00527">malloc()</a>.</p>

</div>
</div>
<a id="a1f6982731137d57e7e35d42d4f6b213e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6982731137d57e7e35d42d4f6b213e">&#9670;&nbsp;</a></span>malloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a> syclcompat::malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block for 3D array on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the memory block, in bytes. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classsyclcompat_1_1pitched__data.html" title="Pitched 2D/3D memory data.">pitched_data</a> object which stores the memory info. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00511">511</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="array_8hpp_source.html#l00062">sycl::_V1::detail::array&lt; dimensions &gt;::get()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00527">malloc()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00107">syclcompat::pitched_data::set_data_ptr()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00110">syclcompat::pitched_data::set_pitch()</a>.</p>

</div>
</div>
<a id="a7363de3a3d3fe0109c7d97ca3542c731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7363de3a3d3fe0109c7d97ca3542c731">&#9670;&nbsp;</a></span>malloc_host()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* syclcompat::malloc_host </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block on the host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_bytes</td><td>Number of bytes to allocate. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Datatype to allocate </td></tr>
    <tr><td class="paramname">num_bytes</td><td>Number of bytes to allocate. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00472">472</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ab0f4a03fece6ccde023d34dc9218a2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f4a03fece6ccde023d34dc9218a2cb">&#9670;&nbsp;</a></span>malloc_shared()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* syclcompat::malloc_shared </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory block of usm_shared memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_bytes</td><td>Number of bytes to allocate. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the allocate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00492">492</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a6d45353c2b332863e8904775dc1ad146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d45353c2b332863e8904775dc1ad146">&#9670;&nbsp;</a></span>match_all_over_sub_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int syclcompat::match_all_over_sub_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>member_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function match_all_over_sub_group conducts a comparison of values across work-items within a sub-group. </p>
<p>match_all_over_sub_group return <code>member_mask</code> and predicate <code>pred</code> will be set to 1 if all <code>value</code> that provided by each work-item in <code>member_mask</code> are equal, otherwise return 0 and the predicate <code>pred</code> will be set to 0. The n-th bit of <code>member_mask</code> representing the work-item with id n. The parameter <code>member_mask</code> indicating the work-items participating the call. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">member_mask</td><td>Input mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Input value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pred</td><td>Output predicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00560">560</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="a2955af6db3cf9aae710187072b3c3757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2955af6db3cf9aae710187072b3c3757">&#9670;&nbsp;</a></span>match_any_over_sub_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int syclcompat::match_any_over_sub_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>member_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function match_any_over_sub_group conducts a comparison of values across work-items within a sub-group. </p>
<p>match_any_over_sub_group return a mask in which some bits are set to 1, indicating that the <code>value</code> provided by the work-item represented by these bits are equal. The n-th bit of mask representing the work-item with id n. The parameter <code>member_mask</code> indicating the work-items participating the call. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">member_mask</td><td>Input mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00521">521</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="a49771fa421f438b08a8a9fd641cbc9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49771fa421f438b08a8a9fd641cbc9fb">&#9670;&nbsp;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> syclcompat::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00458">458</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00094">syclcompat::detail::extend_binary()</a>.</p>

</div>
</div>
<a id="a531bbe21767e8f4072bfcdff20f498f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531bbe21767e8f4072bfcdff20f498f7">&#9670;&nbsp;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;ValueT&gt; &amp;&amp; std::is_integral_v&lt;ValueU&gt;, std::common_type_t&lt;ValueT, ValueU&gt; &gt; syclcompat::max </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00446">446</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a85a7811f8997faff9f040545e94eb578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a7811f8997faff9f040545e94eb578">&#9670;&nbsp;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; &amp;&amp; std::is_floating_point_v&lt;ValueU&gt;, std::common_type_t&lt;ValueT, ValueU&gt; &gt; syclcompat::max </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00454">454</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ad23a63f32d830f9064135d882557fded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23a63f32d830f9064135d882557fded">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>to_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>from_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously copies a subset of a 3D matrix specified by <code>to</code> to another 3D matrix specified by <code>from</code>. </p>
<p>The from and to position info are specified by <code>from_pos</code> and <code>to_pos</code> The copied matrix size is specified by <code>size</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>Destination matrix info. </td></tr>
    <tr><td class="paramname">to_pos</td><td>Position of destination. </td></tr>
    <tr><td class="paramname">from</td><td>Source matrix info. </td></tr>
    <tr><td class="paramname">from_pos</td><td>Position of destination. </td></tr>
    <tr><td class="paramname">size</td><td>Range of the submatrix to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00684">684</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l01068">syclcompat::device_memory&lt; T, Memory, Dimension &gt;::init()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00573">memcpy()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00587">memcpy_async()</a>.</p>

</div>
</div>
<a id="ae13c96026b426484d776c34ff5cfd791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13c96026b426484d776c34ff5cfd791">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously copies <code>count</code> T's from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>. </p>
<p>The function will return after the copy is completed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Datatype to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">count</td><td>Number of T to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00621">621</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

</div>
</div>
<a id="a0c931cec177ad23a31a11f51a01c75f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c931cec177ad23a31a11f51a01c75f5">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously copies <code>size</code> bytes from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>. </p>
<p>The function will return after the copy is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00573">573</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00420">syclcompat::detail::memcpy()</a>.</p>

</div>
</div>
<a id="ac347c9efef0dac49b9b8d11d35300e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347c9efef0dac49b9b8d11d35300e71">&#9670;&nbsp;</a></span>memcpy() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously copies 2D matrix specified by <code>x</code> and <code>y</code> from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>, while <code>from_pitch</code> and <code>to_pitch</code> are the range of dim x in bytes of the matrix specified by <code>from_ptr</code> and <code>to_ptr</code>. </p>
<p>The function will return after the copy is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">to_pitch</td><td>Range of dim x in bytes of destination matrix. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">from_pitch</td><td>Range of dim x in bytes of source matrix. </td></tr>
    <tr><td class="paramname">x</td><td>Range of dim x of matrix to be copied. </td></tr>
    <tr><td class="paramname">y</td><td>Range of dim y of matrix to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00643">643</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

</div>
</div>
<a id="ac58d8e908a75bdb929bb6d0d2a78505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58d8e908a75bdb929bb6d0d2a78505f">&#9670;&nbsp;</a></span>memcpy_async() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memcpy_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>to_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1id.html">sycl::id</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>from_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously copies a subset of a 3D matrix specified by <code>to</code> to another 3D matrix specified by <code>from</code>. </p>
<p>The from and to position info are specified by <code>from_pos</code> and <code>to_pos</code> The copied matrix size is specified by <code>size</code>. The return of the function does NOT guarantee the copy is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>Destination matrix info. </td></tr>
    <tr><td class="paramname">to_pos</td><td>Position of destination. </td></tr>
    <tr><td class="paramname">from</td><td>Source matrix info. </td></tr>
    <tr><td class="paramname">from_pos</td><td>Position of destination. </td></tr>
    <tr><td class="paramname">size</td><td>Range of the submatrix to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memcpy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00703">703</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

</div>
</div>
<a id="aab75cf8f287e10bb6abf942a65e94cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab75cf8f287e10bb6abf942a65e94cc2">&#9670;&nbsp;</a></span>memcpy_async() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memcpy_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesyclcompat.html#a7b19671aff0ceba14c1a3f5f1615e7e8">type_identity_t</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously copies <code>count</code> T's from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>. </p>
<p>The return of the function does NOT guarantee the copy is completed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Datatype to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">count</td><td>Number of T to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00604">604</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

</div>
</div>
<a id="a7bf0cecf244c39b3c1b09b104fab7271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf0cecf244c39b3c1b09b104fab7271">&#9670;&nbsp;</a></span>memcpy_async() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memcpy_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously copies <code>size</code> bytes from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>. </p>
<p>The return of the function does NOT guarantee the copy is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00587">587</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

</div>
</div>
<a id="adbc8e53b9ec360517c25b151e2fc0312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc8e53b9ec360517c25b151e2fc0312">&#9670;&nbsp;</a></span>memcpy_async() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memcpy_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>from_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously copies 2D matrix specified by <code>x</code> and <code>y</code> from the address specified by <code>from_ptr</code> to the address specified by <code>to_ptr</code>, while <code><code>from_pitch</code> and</code> <code>to_pitch</code> are the range of dim x in bytes of the matrix specified by <code>from_ptr</code> and <code>to_ptr</code>. </p>
<p>The return of the function does NOT guarantee the copy is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_ptr</td><td>Pointer to destination memory address. </td></tr>
    <tr><td class="paramname">to_pitch</td><td>Range of dim x in bytes of destination matrix. </td></tr>
    <tr><td class="paramname">from_ptr</td><td>Pointer to source memory address. </td></tr>
    <tr><td class="paramname">from_pitch</td><td>Range of dim x in bytes of source matrix. </td></tr>
    <tr><td class="paramname">x</td><td>Range of dim x of matrix to be copied. </td></tr>
    <tr><td class="paramname">y</td><td>Range of dim y of matrix to be copied. </td></tr>
    <tr><td class="paramname">q</td><td>Queue to execute the copy task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memcpy operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00664">664</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00684">memcpy()</a>.</p>

</div>
</div>
<a id="a6d789b76dab62515323f57267459092f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d789b76dab62515323f57267459092f">&#9670;&nbsp;</a></span>memset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>value</code> to the 3D memory region specified by <code>pitch</code> in <code>q</code>. </p>
<p><code>size</code> specify the setted 3D memory size. The function will return after the memset operation is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pitch</td><td>Specify the 3D memory region. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">size</td><td>The setted 3D memory size. </td></tr>
    <tr><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00915">915</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2memory_8hpp_source.html#l00752">memset()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00785">memset_async()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00837">memset_d16()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00884">memset_d16_async()</a>, <a class="el" href="ompat_2memory_8hpp_source.html#l00851">memset_d32()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00900">memset_d32_async()</a>.</p>

</div>
</div>
<a id="afe9f0b7c00c63162ba76771523e6f646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9f0b7c00c63162ba76771523e6f646">&#9670;&nbsp;</a></span>memset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronously sets <code>value</code> to the first <code>size</code> bytes starting from <code>dev_ptr</code>. </p>
<p>The function will return after the memset operation is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>Pointer to the device memory address. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to be set to the value. </td></tr>
    <tr><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00752">752</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>.</p>

</div>
</div>
<a id="acfebc5a5375d64ecb0a2081ce1712477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfebc5a5375d64ecb0a2081ce1712477">&#9670;&nbsp;</a></span>memset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 1 byte data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00824">824</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

</div>
</div>
<a id="ab5649cb5f8a57196d43977d5c362c718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5649cb5f8a57196d43977d5c362c718">&#9670;&nbsp;</a></span>memset_async() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsyclcompat_1_1pitched__data.html">pitched_data</a>&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1range.html">sycl::range</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>value</code> to the 3D memory region specified by <code>pitch</code> in <code>q</code>. </p>
<p><code>size</code> specify the setted 3D memory size. The return of the function does NOT guarantee the memset operation is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pitch</td><td>Specify the 3D memory region. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">size</td><td>The setted 3D memory size. </td></tr>
    <tr><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00929">929</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>.</p>

</div>
</div>
<a id="a7ffae135ebd10229ab6455e91427e85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffae135ebd10229ab6455e91427e85d">&#9670;&nbsp;</a></span>memset_async() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 1 byte data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>Pointer to the device memory address. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be set. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to be set to the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00785">785</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>.</p>

</div>
</div>
<a id="ae05a9b0c6fd4f75cd020bd1671aed734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05a9b0c6fd4f75cd020bd1671aed734">&#9670;&nbsp;</a></span>memset_async() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 1 byte data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00866">866</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>.</p>

</div>
</div>
<a id="afd37b14e4b01bd2906e13ee4b9b6fca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd37b14e4b01bd2906e13ee4b9b6fca0">&#9670;&nbsp;</a></span>memset_d16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset_d16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 2 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_ptr</td><td>Pointer to the virtual device memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be set to the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00763">763</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a5b41d11ec6e209fc3e1c65d3ba4feacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b41d11ec6e209fc3e1c65d3ba4feacb">&#9670;&nbsp;</a></span>memset_d16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset_d16 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 2 bytes data <code>val</code> to the pitched 2D memory region pointed by ptr in <code>q</code> synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00837">837</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

</div>
</div>
<a id="a0a58df21e8428392811b4998ad111b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a58df21e8428392811b4998ad111b11">&#9670;&nbsp;</a></span>memset_d16_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_d16_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 2 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_ptr</td><td>Pointer to the virtual device memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be set to the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00798">798</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="aee9e4cd08d9a56cb63a3f4cf90e20da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9e4cd08d9a56cb63a3f4cf90e20da4">&#9670;&nbsp;</a></span>memset_d16_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_d16_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 2 bytes data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00884">884</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>.</p>

</div>
</div>
<a id="a72d2b281f21686a0a2b611eb812c0622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d2b281f21686a0a2b611eb812c0622">&#9670;&nbsp;</a></span>memset_d32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset_d32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 4 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_ptr</td><td>Pointer to the virtual device memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be set to the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00774">774</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="afad304dd894c1f50688a069958077d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad304dd894c1f50688a069958077d64">&#9670;&nbsp;</a></span>memset_d32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::memset_d32 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 4 bytes data <code>val</code> to the pitched 2D memory region pointed by ptr in <code>q</code> synchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00851">851</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>, and <a class="el" href="ext_2intel_2experimental_2esimd_2memory_8hpp_source.html#l00435">sycl::_V1::ext::intel::experimental::esimd::wait()</a>.</p>

</div>
</div>
<a id="aef5c4d682df42d0e8c447a107c7161b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5c4d682df42d0e8c447a107c7161b8">&#9670;&nbsp;</a></span>memset_d32_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_d32_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 4 bytes data <code>value</code> to the first <code>size</code> elements starting from <code>dev_ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_ptr</td><td>Pointer to the virtual device memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to be set to the value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00811">811</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="a13bb15dca317fa62ad68e77312ec1b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bb15dca317fa62ad68e77312ec1b78">&#9670;&nbsp;</a></span>memset_d32_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsycl_1_1__V1_1_1event.html">sycl::event</a> syclcompat::memset_d32_async </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets 4 bytes data <code>val</code> to the pitched 2D memory region pointed by <code>ptr</code> in <code>q</code> asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the virtual device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pitch</td><td>The pitch size by number of elements, including padding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The width of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The height of memory region by number of elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The queue in which the operation is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An event representing the memset operation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2memory_8hpp_source.html#l00900">900</a> of file <a class="el" href="ompat_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2memory_8hpp_source.html#l00439">syclcompat::detail::combine_events()</a>, and <a class="el" href="ompat_2memory_8hpp_source.html#l00915">memset()</a>.</p>

</div>
</div>
<a id="a22b268e654edb59f11023407d89dc1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b268e654edb59f11023407d89dc1e2">&#9670;&nbsp;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a> syclcompat::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00441">441</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00094">syclcompat::detail::extend_binary()</a>.</p>

</div>
</div>
<a id="a7ca23d990971b4698e3c3e5c6a7c6a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca23d990971b4698e3c3e5c6a7c6a6a">&#9670;&nbsp;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_integral_v&lt;ValueT&gt; &amp;&amp; std::is_integral_v&lt;ValueU&gt;, std::common_type_t&lt;ValueT, ValueU&gt; &gt; syclcompat::min </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00429">429</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aa3fd37967c8d72eaea54a9305713b68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fd37967c8d72eaea54a9305713b68b">&#9670;&nbsp;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; &amp;&amp; std::is_floating_point_v&lt;ValueU&gt;, std::common_type_t&lt;ValueT, ValueU&gt; &gt; syclcompat::min </td>
          <td>(</td>
          <td class="paramtype">ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00437">437</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a31cad58f2f1bb826c12486954426d77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cad58f2f1bb826c12486954426d77d">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> syclcompat::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dims_8hpp_source.html#l00060">60</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a id="a2bf990595e06de0c2521ba6fcfd31d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf990595e06de0c2521ba6fcfd31d61">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> syclcompat::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dims_8hpp_source.html#l00064">64</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a id="a1a51112cd8fe4185985d016b6975ac52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a51112cd8fe4185985d016b6975ac52">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> syclcompat::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1dim3.html">dim3</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dims_8hpp_source.html#l00068">68</a> of file <a class="el" href="dims_8hpp_source.html">dims.hpp</a>.</p>

</div>
</div>
<a id="ab4da621ecd0a155041a1ab3babf8bbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4da621ecd0a155041a1ab3babf8bbf3">&#9670;&nbsp;</a></span>permute_sub_group_by_xor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::permute_sub_group_by_xor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logical_sub_group_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>permute_sub_group_by_xor permutes values by exchanging values held by pairs of work-items identified by computing the bitwise exclusive OR of the work-item id and some fixed mask. </p>
<p>The input sub_group will be divided into several logical sub_groups with id range [0, <code>logical_sub_group_size</code> - 1]. Each work-item in logical sub_group gets value from another work-item whose id is bitwise exclusive OR of the caller's id and <code>mask</code>. If calculated id is outside the logical sub_group id range, the work-item will get value from itself. The <code>logical_sub_group_size</code> must be a power of 2 and not exceed input sub_group size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Input mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_sub_group_size</td><td>Input logical sub_group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00297">297</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="a783139834d0eb876b11b4f5af0358e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783139834d0eb876b11b4f5af0358e6b">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double syclcompat::pow </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00500">500</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a018900fdf8d4f949fd973c9d96765320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018900fdf8d4f949fd973c9d96765320">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float syclcompat::pow </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00499">499</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ace4389d66219fa53171d7a8779fd7cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4389d66219fa53171d7a8779fd7cc2">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, ValueT&gt; syclcompat::pow </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00504">504</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00513">pow()</a>.</p>

</div>
</div>
<a id="ae16d49807b1bd0c2ba162b8b041e6328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16d49807b1bd0c2ba162b8b041e6328">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueU &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_floating_point_v&lt;ValueT&gt;, double&gt; syclcompat::pow </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueU&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00513">513</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00504">pow()</a>.</p>

</div>
</div>
<a id="ae5ef6bf54a8af27e5a21365dd387ea6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ef6bf54a8af27e5a21365dd387ea6b">&#9670;&nbsp;</a></span>relu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; || std::is_same_v&lt;<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT&gt;, <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt;ValueT, 2&gt; &gt; syclcompat::relu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1marray.html">sycl::marray</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00540">540</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00524">relu()</a>.</p>

</div>
</div>
<a id="a9cefc15668bad433ae4dd61991eed446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cefc15668bad433ae4dd61991eed446">&#9670;&nbsp;</a></span>relu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; || std::is_same_v&lt;<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT&gt;, <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt;ValueT, 2&gt; &gt; syclcompat::relu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00533">533</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00524">relu()</a>.</p>

</div>
</div>
<a id="a883b7f69405f6f7dc164912b6dd25866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883b7f69405f6f7dc164912b6dd25866">&#9670;&nbsp;</a></span>relu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt; || std::is_same_v&lt;<a class="el" href="namespacesycl_1_1__V1.html#ae5d7c9229b2ced1ee8c8baec1a1596fa">sycl::half</a>, ValueT&gt;, ValueT&gt; syclcompat::relu </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs relu saturation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the relu saturation result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00524">524</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00533">relu()</a>.</p>

</div>
</div>
<a id="a877c59145672ec00842b62b0cb219384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877c59145672ec00842b62b0cb219384">&#9670;&nbsp;</a></span>reverse_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::reverse_bits </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the bit order of an unsigned integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input unsigned integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of a with the bit order reversed </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00160">160</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

</div>
</div>
<a id="a6ec6e3777ccafd2c25a065e8caf39032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec6e3777ccafd2c25a065e8caf39032">&#9670;&nbsp;</a></span>select_device() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DeviceSelector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if_t&lt; std::is_invocable_r_v&lt;int, DeviceSelector, const <a class="el" href="classsycl_1_1__V1_1_1device.html">sycl::device</a> &amp;&gt; &gt; syclcompat::select_device </td>
          <td>(</td>
          <td class="paramtype">const DeviceSelector &amp;&#160;</td>
          <td class="paramname"><em>selector</em> = <code><a class="el" href="namespacesycl_1_1__V1.html#ac52b02260b49dbe11483b0541c5c6c42">sycl::gpu_selector_v</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00800">800</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00657">syclcompat::detail::dev_mgr::select_device()</a>.</p>

</div>
</div>
<a id="afd95977e9335b81802f7d6b5e2b553b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd95977e9335b81802f7d6b5e2b553b3">&#9670;&nbsp;</a></span>select_device() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int syclcompat::select_device </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00792">792</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00657">syclcompat::detail::dev_mgr::select_device()</a>.</p>

</div>
</div>
<a id="a1117445292b8b4ab9a7273bd6332f131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1117445292b8b4ab9a7273bd6332f131">&#9670;&nbsp;</a></span>select_from_sub_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::select_from_sub_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remote_local_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logical_sub_group_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>select_from_sub_group allows work-items to obtain a copy of a value held by any other work-item in the sub_group. </p>
<p>The input sub_group will be divided into several logical sub_groups with id range [0, <code>logical_sub_group_size</code> </p><ul>
<li>1]. Each work-item in logical sub_group gets value from another work-item whose id is <code>remote_local_id</code>. If <code>remote_local_id</code> is outside the logical sub_group id range, <code>remote_local_id</code> will modulo with <code>logical_sub_group_size</code>. The <code>logical_sub_group_size</code> must be a power of 2 and not exceed input sub_group size. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_local_id</td><td>Input source work item id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_sub_group_size</td><td>Input logical sub_group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00217">217</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="ab3223fe4dfc1766754816ae2755765a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3223fe4dfc1766754816ae2755765a2">&#9670;&nbsp;</a></span>set_default_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::set_default_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Util function to change the default queue of the current device in the device manager If the device extension saved queue is the default queue, the previous saved queue will be overwritten as well. </p>
<p>This function will be blocking if there are submitted kernels in the previous default queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>New user-defined queue </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00755">755</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">References <a class="el" href="syclcompat_2device_8hpp_source.html#l00628">syclcompat::detail::dev_mgr::current_device()</a>, <a class="el" href="syclcompat_2device_8hpp_source.html#l00688">syclcompat::detail::dev_mgr::instance()</a>, and <a class="el" href="syclcompat_2device_8hpp_source.html#l00457">syclcompat::device_ext::set_default_queue()</a>.</p>

</div>
</div>
<a id="adad6b02e9f18bf61179e2037e1b678f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad6b02e9f18bf61179e2037e1b678f5">&#9670;&nbsp;</a></span>shift_sub_group_left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::shift_sub_group_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logical_sub_group_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shift_sub_group_left move values held by the work-items in a sub_group directly to another work-item in the sub_group, by shifting values a fixed number of work-items to the left. </p>
<p>The input sub_group will be divided into several logical sub_groups with id range [0, <code>logical_sub_group_size</code> - 1]. Each work-item in logical sub_group gets value from another work-item whose id is caller's id adds <code>delta</code>. If calculated id is outside the logical sub_group id range, the work-item will get value from itself. The <code>logical_sub_group_size</code> must be a power of 2 and not exceed input sub_group size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>Input delta </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_sub_group_size</td><td>Input logical sub_group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00241">241</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="abb8af01b4f8b92249353dcaee7cb74a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8af01b4f8b92249353dcaee7cb74a8">&#9670;&nbsp;</a></span>shift_sub_group_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::shift_sub_group_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsycl_1_1__V1_1_1sub__group.html">sycl::sub_group</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logical_sub_group_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shift_sub_group_right move values held by the work-items in a sub_group directly to another work-item in the sub_group, by shifting values a fixed number of work-items to the right. </p>
<p>The input sub_group will be divided into several logical_sub_groups with id range [0, <code>logical_sub_group_size</code> - 1]. Each work-item in logical_sub_group gets value from another work-item whose id is caller's id subtracts <code>delta</code>. If calculated id is outside the logical sub_group id range, the work-item will get value from itself. The <code>logical_sub_group_size</code> must be a power of 2 and not exceed input sub_group size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Input value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Input sub_group </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>Input delta </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_sub_group_size</td><td>Input logical sub_group size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2util_8hpp_source.html#l00269">269</a> of file <a class="el" href="ompat_2util_8hpp_source.html">util.hpp</a>.</p>

<p class="reference">References <a class="el" href="sub__group_8hpp_source.html#l00159">sycl::_V1::sub_group::get_local_linear_id()</a>.</p>

</div>
</div>
<a id="af5935ac7b9837629595ab0a2e0a17638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5935ac7b9837629595ab0a2e0a17638">&#9670;&nbsp;</a></span>unload_kernel_library()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::unload_kernel_library </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsyclcompat_1_1kernel__library.html">kernel_library</a> &amp;&#160;</td>
          <td class="paramname"><em>library</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unload kernel library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">library</td><td>Handle to the library to be closed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="syclcompat_2kernel_8hpp_source.html#l00408">408</a> of file <a class="el" href="syclcompat_2kernel_8hpp_source.html">kernel.hpp</a>.</p>

</div>
</div>
<a id="aded00838c044c56640295819e6509c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded00838c044c56640295819e6509c29">&#9670;&nbsp;</a></span>unordered_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt; syclcompat::unordered_compare </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs unordered comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00220">220</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00121">syclcompat::detail::isnan()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ompat_2math_8hpp_source.html#l00232">unordered_compare()</a>, <a class="el" href="ompat_2math_8hpp_source.html#l00257">unordered_compare_both()</a>, and <a class="el" href="ompat_2math_8hpp_source.html#l00287">unordered_compare_mask()</a>.</p>

</div>
</div>
<a id="a24a0dd3d4869a23e8acd0000eff243a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a0dd3d4869a23e8acd0000eff243a2">&#9670;&nbsp;</a></span>unordered_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;ValueT::size() == 2, ValueT&gt; syclcompat::unordered_compare </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 element unordered comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00232">232</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00220">unordered_compare()</a>.</p>

</div>
</div>
<a id="a89163075cb3b34a386d4e020c51ef77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89163075cb3b34a386d4e020c51ef77a">&#9670;&nbsp;</a></span>unordered_compare_both()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;ValueT::size() == 2, bool&gt; syclcompat::unordered_compare_both </td>
          <td>(</td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 element unordered comparison and return true if both results are true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00257">257</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00220">unordered_compare()</a>.</p>

</div>
</div>
<a id="ac54f0e6926d1e17b28d01849ba1969e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54f0e6926d1e17b28d01849ba1969e2">&#9670;&nbsp;</a></span>unordered_compare_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syclcompat::unordered_compare_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsycl_1_1__V1_1_1vec.html">sycl::vec</a>&lt; ValueT, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs 2 elements unordered comparison, compare result of each element is 0 (false) or 0xffff (true), returns an unsigned int by composing compare result of two elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary_op</td><td>functor that implements the binary operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comparison result </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00287">287</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ompat_2math_8hpp_source.html#l00220">unordered_compare()</a>.</p>

</div>
</div>
<a id="ad2f7af0ba11c7e398732af5088e033f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f7af0ba11c7e398732af5088e033f1">&#9670;&nbsp;</a></span>vectorized_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecT , class BinaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syclcompat::vectorized_binary </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized binary operation value for two values, with each value treated as a vector type <code>VecT</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>VecT The type of the vector </td></tr>
    <tr><td class="paramname">[in]</td><td>BinaryOperation The binary operation class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized binary operation value of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00684">684</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="aecfca16dc6307a92959d4d7ef76337cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfca16dc6307a92959d4d7ef76337cc">&#9670;&nbsp;</a></span>vectorized_isgreater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::vectorized_isgreater </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized isgreater for two values, with each value treated as a vector type <code>S</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The type of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type of the original values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized greater than of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00367">367</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a801c669031ba0dc847fe933f8640fe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801c669031ba0dc847fe933f8640fe81">&#9670;&nbsp;</a></span>vectorized_isgreater&lt; sycl::ushort2, unsigned &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="namespacesyclcompat.html#aecfca16dc6307a92959d4d7ef76337cc">syclcompat::vectorized_isgreater</a>&lt; sycl::ushort2, unsigned &gt; </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized isgreater for two unsigned int values, with each value treated as a vector of two unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized greater than of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00382">382</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a31a2a3d5e07d4bb8b20f2309f2827105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a2a3d5e07d4bb8b20f2309f2827105">&#9670;&nbsp;</a></span>vectorized_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::vectorized_max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized max for two values, with each value treated as a vector type <code>S</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The type of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type of the original values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized max of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00301">301</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a9cbf81d995e76936eb645775f69ba31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbf81d995e76936eb645775f69ba31e">&#9670;&nbsp;</a></span>vectorized_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T syclcompat::vectorized_min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized min for two values, with each value treated as a vector type <code>S</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>The type of the vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>The type of the original values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized min of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00317">317</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="ae5c6ea6f042442a0e6b83406d3be7f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c6ea6f042442a0e6b83406d3be7f47">&#9670;&nbsp;</a></span>vectorized_sum_abs_diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syclcompat::vectorized_sum_abs_diff </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized absolute difference for two values without modulo overflow, with each value treated as a vector type <code>VecT</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>VecT The type of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized absolute difference of the two values </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00348">348</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l01009">sycl::_V1::ext::intel::esimd::detail::sum()</a>.</p>

</div>
</div>
<a id="ad16b88222d07913e646022d54682371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16b88222d07913e646022d54682371d">&#9670;&nbsp;</a></span>vectorized_unary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecT , class UnaryOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned syclcompat::vectorized_unary </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryOperation&#160;</td>
          <td class="paramname"><em>unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute vectorized unary operation for a value, with the value treated as a vector type <code>VecT</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">[in]</td><td>VecT The type of the vector </td></tr>
    <tr><td class="paramname">[in]</td><td>UnaryOperation The unary operation class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vectorized unary operation value of the input value </dd></dl>

<p class="definition">Definition at line <a class="el" href="ompat_2math_8hpp_source.html#l00333">333</a> of file <a class="el" href="ompat_2math_8hpp_source.html">math.hpp</a>.</p>

</div>
</div>
<a id="a58ea882bd7bed0d3038f4692b004c5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ea882bd7bed0d3038f4692b004c5d5">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00759">759</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="syclcompat_2device_8hpp_source.html#l00268">syclcompat::device_ext::~device_ext()</a>.</p>

</div>
</div>
<a id="ad93cf9b8fbc72c4f86eaf47ca2742c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93cf9b8fbc72c4f86eaf47ca2742c72">&#9670;&nbsp;</a></span>wait_and_throw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void syclcompat::wait_and_throw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1queue.html">sycl::queue</a>&#160;</td>
          <td class="paramname"><em>q</em> = <code><a class="el" href="namespacesyclcompat.html#a38b7fd6490005df50af1a36cf808035b">get_default_queue</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="syclcompat_2device_8hpp_source.html#l00761">761</a> of file <a class="el" href="syclcompat_2device_8hpp_source.html">device.hpp</a>.</p>

</div>
</div>
<a id="a0b459bf5b9e64550f3ae84ddc7b17255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b459bf5b9e64550f3ae84ddc7b17255">&#9670;&nbsp;</a></span>wg_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void syclcompat::wg_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="id__query_8hpp_source.html#l00031">31</a> of file <a class="el" href="id__query_8hpp_source.html">id_query.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesyclcompat.html">syclcompat</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
