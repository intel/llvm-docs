<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPC++ Runtime: Shared local memory access functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPC++ Runtime
   </div>
   <div id="projectbrief">Runtime libraries for oneAPI DPC++</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__sycl__esimd__memory__slm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Shared local memory access functions.<div class="ingroups"><a class="el" href="group__sycl__esimd.html">DPC++ Explicit SIMD API</a> &raquo; <a class="el" href="group__sycl__esimd__memory.html">Memory access API.</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Shared local memory access functions.:</div>
<div class="dyncontent">
<div class="center"><img src="group__sycl__esimd__memory__slm.png" border="0" usemap="#agroup____sycl____esimd____memory____slm" alt=""/></div>
<map name="agroup____sycl____esimd____memory____slm" id="agroup____sycl____esimd____memory____slm">
<area shape="rect" title=" " alt="" coords="207,5,368,45"/>
<area shape="rect" href="group__sycl__esimd__memory.html" title="ESIMD APIs to access memory via accessors, USM pointers, perform per&#45;element atomic operations." alt="" coords="5,13,159,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplParams" colspan="2">template&lt;uint32_t SLMSize&gt; </td></tr>
<tr class="memitem:ga927d068c295204a54147ac9626cfe0e4"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">sycl::_V1::ext::intel::esimd::slm_init</a> ()</td></tr>
<tr class="memdesc:ga927d068c295204a54147ac9626cfe0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4">More...</a><br /></td></tr>
<tr class="separator:ga927d068c295204a54147ac9626cfe0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga346b7902be6b67d13f0034d77767722a"><td class="memItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">sycl::_V1::ext::intel::esimd::slm_init</a> (uint32_t size)</td></tr>
<tr class="memdesc:ga346b7902be6b67d13f0034d77767722a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare per-work-group slm size.  <a href="group__sycl__esimd__memory__slm.html#ga346b7902be6b67d13f0034d77767722a">More...</a><br /></td></tr>
<tr class="separator:ga346b7902be6b67d13f0034d77767722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-1) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3)  <a href="group__sycl__esimd__memory__slm.html#gad2fef8f292d605767fdd6bdd9a725cdf">More...</a><br /></td></tr>
<tr class="separator:gad2fef8f292d605767fdd6bdd9a725cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaeeaea968caad1111d9b1f878decee783"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gaeeaea968caad1111d9b1f878decee783"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaeeaea968caad1111d9b1f878decee783">More...</a><br /></td></tr>
<tr class="separator:gaeeaea968caad1111d9b1f878decee783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaf03a9216e379b075244936b633469cf5"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gaf03a9216e379b075244936b633469cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaf03a9216e379b075244936b633469cf5">More...</a><br /></td></tr>
<tr class="separator:gaf03a9216e379b075244936b633469cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaece7a3dd172984bf59f46482230a2448"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gaece7a3dd172984bf59f46482230a2448"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-4) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gaece7a3dd172984bf59f46482230a2448">More...</a><br /></td></tr>
<tr class="separator:gaece7a3dd172984bf59f46482230a2448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (slm-ga-5) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga44a8a1e761bcfb6e2a9d963432b9d74a">More...</a><br /></td></tr>
<tr class="separator:ga44a8a1e761bcfb6e2a9d963432b9d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga764fcd9753f206ab8c420785ba433a75"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">sycl::_V1::ext::intel::esimd::slm_gather</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:ga764fcd9753f206ab8c420785ba433a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-6) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga764fcd9753f206ab8c420785ba433a75">More...</a><br /></td></tr>
<tr class="separator:ga764fcd9753f206ab8c420785ba433a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-7) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#ga93cb6a4da266764b6fdd4421c0b717d8">More...</a><br /></td></tr>
<tr class="separator:ga93cb6a4da266764b6fdd4421c0b717d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae6fcc63ae70c075518179d4da63976dc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:gae6fcc63ae70c075518179d4da63976dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-8) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gae6fcc63ae70c075518179d4da63976dc">More...</a><br /></td></tr>
<tr class="separator:gae6fcc63ae70c075518179d4da63976dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gacc98080310feeaf350db9310986ef1ff"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">sycl::_V1::ext::intel::esimd::slm_gather</a> (OffsetSimdViewT byte_offsets, PropertyListT props={})</td></tr>
<tr class="memdesc:gacc98080310feeaf350db9310986ef1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (slm-ga-9) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements.  <a href="group__sycl__esimd__memory__slm.html#gacc98080310feeaf350db9310986ef1ff">More...</a><br /></td></tr>
<tr class="separator:gacc98080310feeaf350db9310986ef1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">sycl::_V1::ext::intel::esimd::slm_scalar_load</a> (uint32_t offset)</td></tr>
<tr class="memdesc:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scalar value from the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#ga31c2a91e85ca4cef214e90fc09d2c290">More...</a><br /></td></tr>
<tr class="separator:ga31c2a91e85ca4cef214e90fc09d2c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga452f04de1896d50b415bfcdff867a469"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">sycl::_V1::ext::intel::esimd::slm_scatter</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga452f04de1896d50b415bfcdff867a469"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-1) void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2)  <a href="group__sycl__esimd__memory__slm.html#ga452f04de1896d50b415bfcdff867a469">More...</a><br /></td></tr>
<tr class="separator:ga452f04de1896d50b415bfcdff867a469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga17da97cf44fd768030ee06b7321151bc"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">sycl::_V1::ext::intel::esimd::slm_scatter</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt; byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:ga17da97cf44fd768030ee06b7321151bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga17da97cf44fd768030ee06b7321151bc">More...</a><br /></td></tr>
<tr class="separator:ga17da97cf44fd768030ee06b7321151bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">sycl::_V1::ext::intel::esimd::slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt; mask, PropertyListT props={})</td></tr>
<tr class="memdesc:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-3) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">More...</a><br /></td></tr>
<tr class="separator:ga89f22bfc6394d6f5bf7829f5eb0f2e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafe51d24eb859e430fb759b91851cac12"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt; OffsetSimdViewT &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">sycl::_V1::ext::intel::esimd::slm_scatter</a> (OffsetSimdViewT byte_offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gafe51d24eb859e430fb759b91851cac12"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-4) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>.  <a href="group__sycl__esimd__memory__slm.html#gafe51d24eb859e430fb759b91851cac12">More...</a><br /></td></tr>
<tr class="separator:gafe51d24eb859e430fb759b91851cac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">sycl::_V1::ext::intel::esimd::slm_scalar_store</a> (uint32_t offset, T val)</td></tr>
<tr class="memdesc:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a scalar value into the Shared Local Memory.  <a href="group__sycl__esimd__memory__slm.html#gadcd8292a7c31b41dc4a2734de778d2f9">More...</a><br /></td></tr>
<tr class="separator:gadcd8292a7c31b41dc4a2734de778d2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </td></tr>
<tr class="memitem:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">sycl::_V1::ext::intel::esimd::slm_gather_rgba</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#gaa3eb9d037216c4ad80dbb16d0dc270a1">More...</a><br /></td></tr>
<tr class="separator:gaa3eb9d037216c4ad80dbb16d0dc270a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, rgba_channel_mask Mask&gt; </td></tr>
<tr class="memitem:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt;(N==8||N==16||N==32) &amp;&amp;(sizeof(T)==4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">sycl::_V1::ext::intel::esimd::slm_scatter_rgba</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; offsets, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(Mask)&gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector.  <a href="group__sycl__esimd__memory__slm.html#ga28dd84cf8f6b8a67f7c71130495686c7">More...</a><br /></td></tr>
<tr class="separator:ga28dd84cf8f6b8a67f7c71130495686c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </td></tr>
<tr class="memitem:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, Flags)</td></tr>
<tr class="memdesc:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a contiguous block of SLM memory referenced by the given byte-offset <code>offset</code>, then returns the loaded data as a simd object.  <a href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851">More...</a><br /></td></tr>
<tr class="separator:ga37e6e7ad7907665f8c5adfba3c0d3851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_load functions loads a contiguous memory block from SLM (Shared Local Memory) and the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa2fdeaef4c8bb577b0d83ac29724459b">More...</a><br /></td></tr>
<tr class="separator:gaa2fdeaef4c8bb577b0d83ac29724459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;N&gt; pred, props = {}); // (slm-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga02dc03472bfd52f7d011ce6c1d3ce499">More...</a><br /></td></tr>
<tr class="separator:ga02dc03472bfd52f7d011ce6c1d3ce499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">sycl::_V1::ext::intel::esimd::slm_block_load</a> (uint32_t offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gac26a70b8c5b5bae45aa2f68189316f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (slm-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gac26a70b8c5b5bae45aa2f68189316f66">More...</a><br /></td></tr>
<tr class="separator:gac26a70b8c5b5bae45aa2f68189316f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gae9348416d24efcd644d5c4ec03550279"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, PropertyListT props={})</td></tr>
<tr class="memdesc:gae9348416d24efcd644d5c4ec03550279"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, props={}); // (lacc-bl-1) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gae9348416d24efcd644d5c4ec03550279">More...</a><br /></td></tr>
<tr class="separator:gae9348416d24efcd644d5c4ec03550279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga4d32f796205c30b9a1e1f98299579059"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, PropertyListT props={})</td></tr>
<tr class="memdesc:ga4d32f796205c30b9a1e1f98299579059"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, props={}); // (lacc-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga4d32f796205c30b9a1e1f98299579059">More...</a><br /></td></tr>
<tr class="separator:ga4d32f796205c30b9a1e1f98299579059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga5be8a3908c474653637bfc5b1cca58de"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga5be8a3908c474653637bfc5b1cca58de"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga5be8a3908c474653637bfc5b1cca58de">More...</a><br /></td></tr>
<tr class="separator:ga5be8a3908c474653637bfc5b1cca58de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-4) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#ga8f6979e4320e9b0f0ce63dff852cc71d">More...</a><br /></td></tr>
<tr class="separator:ga8f6979e4320e9b0f0ce63dff852cc71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-5) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga1f8afccf369a6943634aeaee00d7b1bd">More...</a><br /></td></tr>
<tr class="separator:ga1f8afccf369a6943634aeaee00d7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gafb08d45df0c2e84e8ae599863fed761c"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_read &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">sycl::_V1::ext::intel::esimd::block_load</a> (AccessorT lacc, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; pass_thru, PropertyListT props={})</td></tr>
<tr class="memdesc:gafb08d45df0c2e84e8ae599863fed761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-6) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset.  <a href="group__sycl__esimd__memory__slm.html#gafb08d45df0c2e84e8ae599863fed761c">More...</a><br /></td></tr>
<tr class="separator:gafb08d45df0c2e84e8ae599863fed761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename Flags &gt; </td></tr>
<tr class="memitem:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; <a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt; Flags &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, Flags)</td></tr>
<tr class="memdesc:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores elements of the vector <code>vals</code> to a contiguous block of SLM memory at the given byte-offset <code>offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b">More...</a><br /></td></tr>
<tr class="separator:ga6924c98df8e4ade1d77d4b50bd0eb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each of the following slm_block_store functions stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#ga217ac8596b42299aa84bb2dbc7e20c89">More...</a><br /></td></tr>
<tr class="separator:ga217ac8596b42299aa84bb2dbc7e20c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">sycl::_V1::ext::intel::esimd::slm_block_store</a> (uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-2) props = {}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gaa5ee2a293cc88df37173e1fddbb9f122">More...</a><br /></td></tr>
<tr class="separator:gaa5ee2a293cc88df37173e1fddbb9f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad481435bb21bb308d9e9879e096ad329"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad481435bb21bb308d9e9879e096ad329"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-1) simd&lt;T, N&gt; vals, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>.  <a href="group__sycl__esimd__memory__slm.html#gad481435bb21bb308d9e9879e096ad329">More...</a><br /></td></tr>
<tr class="separator:gad481435bb21bb308d9e9879e096ad329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, PropertyListT props={})</td></tr>
<tr class="memdesc:gad6cdaada3b83282c9feaa3df3fb46432"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-2) props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#gad6cdaada3b83282c9feaa3df3fb46432">More...</a><br /></td></tr>
<tr class="separator:gad6cdaada3b83282c9feaa3df3fb46432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga8641f19548717b4da73177f3612808fd"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, uint32_t byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga8641f19548717b4da73177f3612808fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={});  <a href="group__sycl__esimd__memory__slm.html#ga8641f19548717b4da73177f3612808fd">More...</a><br /></td></tr>
<tr class="separator:ga8641f19548717b4da73177f3612808fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplParams" colspan="2">template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </td></tr>
<tr class="memitem:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt; AccessorT, detail::accessor_mode_cap::can_write &gt; &amp;&amp;ext::oneapi::experimental::is_property_list_v&lt; PropertyListT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">sycl::_V1::ext::intel::esimd::block_store</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; vals, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt; pred, PropertyListT props={})</td></tr>
<tr class="memdesc:ga66a15b020bd88413f2ca069c6806c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-4) simd_mask&lt;1&gt; pred, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>.  <a href="group__sycl__esimd__memory__slm.html#ga66a15b020bd88413f2ca069c6806c6b1">More...</a><br /></td></tr>
<tr class="separator:ga66a15b020bd88413f2ca069c6806c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7e9fb3b595ef693f1319288ca16446eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="slm_atomic_update0"></a> <a href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">More...</a><br /></td></tr>
<tr class="separator:ga7e9fb3b595ef693f1319288ca16446eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==0 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; pred = 1); // (lacc-au0-1) Atomically updates <code>N</code> memory locations in SLM ssociated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>, and returns a vector of old values found at the memory locations before update.  <a href="group__sycl__esimd__memory__slm.html#ga0e7b8ee1026f84dadce9a403a71419eb">More...</a><br /></td></tr>
<tr class="separator:ga0e7b8ee1026f84dadce9a403a71419eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">One argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#gaabcb5b2286f8ead94ec832ccb283cc0e">More...</a><br /></td></tr>
<tr class="separator:gaabcb5b2286f8ead94ec832ccb283cc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==1 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;1&gt; pred = 1); // (lacc-au1-1)  <a href="group__sycl__esimd__memory__slm.html#ga2892a2ffe7bce147b7b3cab6a3dc9c94">More...</a><br /></td></tr>
<tr class="separator:ga2892a2ffe7bce147b7b3cab6a3dc9c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N&gt; </td></tr>
<tr class="memitem:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">sycl::_V1::ext::intel::esimd::slm_atomic_update</a> (<a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two argument variant of the atomic update operation.  <a href="group__sycl__esimd__memory__slm.html#ga6e6121f483d21d16fe3f71c29e413e8d">More...</a><br /></td></tr>
<tr class="separator:ga6e6121f483d21d16fe3f71c29e413e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplParams" colspan="2">template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </td></tr>
<tr class="memitem:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memTemplItemLeft" align="right" valign="top">__ESIMD_API std::enable_if_t&lt; __ESIMD_DNS::get_num_args&lt; Op &gt;)==2 &amp;&amp;__ESIMD_DNS::is_rw_local_accessor_v&lt; AccessorT &gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">sycl::_V1::ext::intel::esimd::atomic_update</a> (AccessorT lacc, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt; byte_offset, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#gaf5e71710411c5038378f418933653f42">src0</a>, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt; <a class="el" href="group__sycl__esimd__math.html#ga1181d76d70bf78e70b785a92b22e6d22">src1</a>, <a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt; mask=1)</td></tr>
<tr class="memdesc:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;1&gt; pred = 1); // (lacc-au2-1)  <a href="group__sycl__esimd__memory__slm.html#ga7df7209f4d311b0d2bddf71a6c81e9f8">More...</a><br /></td></tr>
<tr class="separator:ga7df7209f4d311b0d2bddf71a6c81e9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7df7209f4d311b0d2bddf71a6c81e9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df7209f4d311b0d2bddf71a6c81e9f8">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2 &amp;&amp; __ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;1&gt; pred = 1); // (lacc-au2-1) </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06127">6127</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src1</a>.</p>

</div>
</div>
<a id="ga2892a2ffe7bce147b7b3cab6a3dc9c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2892a2ffe7bce147b7b3cab6a3dc9c94">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1 &amp;&amp; __ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;1&gt; pred = 1); // (lacc-au1-1) </p>
<p>Atomically updates <code>N</code> memory locations in SLM indicated by local accessor <code>lacc</code> and a vector of offsets, and returns a vector of old values found at the memory locations before update. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06057">6057</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>.</p>

</div>
</div>
<a id="ga0e7b8ee1026f84dadce9a403a71419eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e7b8ee1026f84dadce9a403a71419eb">&#9670;&nbsp;</a></span>atomic_update() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N, typename AccessorT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0 &amp;&amp; __ESIMD_DNS::is_rw_local_accessor_v&lt;AccessorT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::atomic_update </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; pred = 1); // (lacc-au0-1) Atomically updates <code>N</code> memory locations in SLM ssociated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>, and returns a vector of old values found at the memory locations before update. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05966">5966</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga4d32f796205c30b9a1e1f98299579059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d32f796205c30b9a1e1f98299579059">&#9670;&nbsp;</a></span>block_load() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, props={}); // (lacc-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset. </p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_load instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower GATHER instead of faster BLOCK_LOAD. !!! Passing local accessor associated with SLM starting from offset that is NOT aligned by 16-bytes and NOT specifying the actual alignment in <code>props</code> produces incorrect load results on Gen12.</p>
<p>Note: if two or more local accessors are used in the same kernel, then 16-byte alignment is guaranteed only for one of them. Other local accessors may or may not get 16-byte alignment. N-th local accessor's alignment depends on N-1 local accessor sizes, and their element-alignment/padding. Only element-alignment is guaranteed for them. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05293">5293</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8f6979e4320e9b0f0ce63dff852cc71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f6979e4320e9b0f0ce63dff852cc71d">&#9670;&nbsp;</a></span>block_load() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-4) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP, and some undefined value is returned.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The local accessor <code>lacc</code> must point to memory at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128; for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256; for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512. R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05371">5371</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gafb08d45df0c2e84e8ae599863fed761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb08d45df0c2e84e8ae599863fed761c">&#9670;&nbsp;</a></span>block_load() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-6) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at zero offset. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP, and <code>pass_thru</code> value is returned.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The local accessor <code>lacc</code> must point to memory at least 4-byte aligned for elements of 4-bytes or smaller and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128; for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256; for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512. R2: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05450">5450</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae9348416d24efcd644d5c4ec03550279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9348416d24efcd644d5c4ec03550279">&#9670;&nbsp;</a></span>block_load() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, props={}); // (lacc-bl-1) Loads a contiguous memory block from SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>. </p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_load instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower GATHER instead of faster BLOCK_LOAD. !!! Passing local accessor associated with SLM starting from offset that is NOT aligned by 16-bytes and NOT specifying the actual alignment in <code>props</code> produces incorrect load results on Gen12.</p>
<p>Note: if two or more local accessors are used in the same kernel, then 16-byte alignment is guaranteed only for one of them. Other local accessors may or may not get 16-byte alignment. N-th local accessor's alignment depends on N-1 local accessor sizes, and their element-alignment/padding. Only element-alignment is guaranteed for them. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05258">5258</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga5be8a3908c474653637bfc5b1cca58de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be8a3908c474653637bfc5b1cca58de">&#9670;&nbsp;</a></span>block_load() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP, and some undefined value is returned.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>lacc</code> + <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05332">5332</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga1f8afccf369a6943634aeaee00d7b1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8afccf369a6943634aeaee00d7b1bd">&#9670;&nbsp;</a></span>block_load() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_read&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::block_load </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-5) Loads a contiguous memory block from SLM (Shared Local Memory) associated the local accessor <code>lacc</code> at the given <code>byte_offset</code>. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP, and <code>pass_thru</code> value is returned.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>lacc</code> + <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05410">5410</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad6cdaada3b83282c9feaa3df3fb46432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6cdaada3b83282c9feaa3df3fb46432">&#9670;&nbsp;</a></span>block_store() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-2) props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>. </p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_store instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower SCATTER instead of faster BLOCK_STORE. !!! Passing <code>byte_offset</code> not aligned by 16-bytes and not specifying the actual alignment in <code>props</code> produces incorrect store results on Gen12. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05673">5673</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga66a15b020bd88413f2ca069c6806c6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a15b020bd88413f2ca069c6806c6b1">&#9670;&nbsp;</a></span>block_store() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-4) simd_mask&lt;1&gt; pred, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code>. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are stored. Otherwise, the block store operation is a NO-OP.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05749">5749</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad481435bb21bb308d9e9879e096ad329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad481435bb21bb308d9e9879e096ad329">&#9670;&nbsp;</a></span>block_store() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-1) simd&lt;T, N&gt; vals, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>. </p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_store instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower SCATTER instead of faster BLOCK_STORE. !!! Passing <code>byte_offset</code> not aligned by 16-bytes and not specifying the actual alignment in <code>props</code> produces incorrect store results on Gen12. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05645">5645</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga8641f19548717b4da73177f3612808fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8641f19548717b4da73177f3612808fd">&#9670;&nbsp;</a></span>block_store() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename AccessorT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_local_accessor_with_v&lt;AccessorT, detail::accessor_mode_cap::can_write&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::block_store </td>
          <td>(</td>
          <td class="paramtype">AccessorT&#160;</td>
          <td class="paramname"><em>lacc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={}); </p>
<p>Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) associated with the local accessor <code>lacc</code> at the given <code>byte_offset</code>. The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are stored. Otherwise, the block store operation is a NO-OP.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05711">5711</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6e6121f483d21d16fe3f71c29e413e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e6121f483d21d16fe3f71c29e413e8d">&#9670;&nbsp;</a></span>slm_atomic_update() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 2, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two argument variant of the atomic update operation. </p>
<p>simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask = 1); /// (slm-au2-1) simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;1&gt; pred = 1); // (lacc-au2-1) simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd&lt;T, N&gt; src1, simd_mask&lt;N&gt; mask = 1); /// (slm-au2-1) Atomically updates <code>N</code> memory locations in SLM indicated by a vector of offsets, and returns a vector of old values found at the memory locations before update. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand (new value). </td></tr>
    <tr><td class="paramname">src1</td><td>is the second atomic operand (expected value). </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06097">6097</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9bd99917636b94d50409d390ed3d53dda6bad67b5e8990b5f40b54dddd984ea08">sycl::_V1::ext::intel::esimd::detail::default_size</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaae4a112574052159467464500ceafe8f5">sycl::_V1::ext::intel::esimd::fcmpxchg</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>, <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00096">sycl::_V1::ext::intel::esimd::detail::isPowerOf2()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05783">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl()</a>, <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src1</a>.</p>

</div>
</div>
<a id="gaabcb5b2286f8ead94ec832ccb283cc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabcb5b2286f8ead94ec832ccb283cc0e">&#9670;&nbsp;</a></span>slm_atomic_update() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 1, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>src0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One argument variant of the atomic update operation. </p>
<p>simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask = 1); /// (slm-au1-1) simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;1&gt; pred = 1); // (lacc-au1-1) Usage of cache hints or non-standard operation width N requires DG2 or PVC. simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd&lt;T, N&gt; src0, simd_mask&lt;N&gt; mask = 1) /// (slm-au1-1)</p>
<p>Atomically updates <code>N</code> memory locations in SLM indicated by a vector of offsets, and returns a vector of old values found at the memory locations before update. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit offsets. </td></tr>
    <tr><td class="paramname">src0</td><td>is the first atomic operand. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l06008">6008</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9bd99917636b94d50409d390ed3d53dda6bad67b5e8990b5f40b54dddd984ea08">sycl::_V1::ext::intel::esimd::detail::default_size</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6d6fbe2c4e976a410868effe6deb2171">sycl::_V1::ext::intel::esimd::fadd</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa6245653b1ded5cde266a956a325465ce">sycl::_V1::ext::intel::esimd::fmax</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa91b8694b07e3650d5332a6d51af36421">sycl::_V1::ext::intel::esimd::fmin</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa09097f6fa7db7027ada3d6d8e930f3bd">sycl::_V1::ext::intel::esimd::fsub</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>, <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00096">sycl::_V1::ext::intel::esimd::detail::isPowerOf2()</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05859">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl()</a>, <a class="el" href="ext_2intel_2esimd_2math_8hpp_source.html#l00180">sycl::_V1::ext::intel::esimd::src0</a>, and <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa8cd892b7b97ef9489ae4479d3f4ef0fc">sycl::_V1::ext::intel::esimd::store</a>.</p>

</div>
</div>
<a id="ga7e9fb3b595ef693f1319288ca16446eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e9fb3b595ef693f1319288ca16446eb">&#9670;&nbsp;</a></span>slm_atomic_update() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atomic_op Op, typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;__ESIMD_DNS::get_num_args&lt;Op&gt;) == 0, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_atomic_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="slm_atomic_update0"></a></p>
<p>Atomic update operation performed on SLM. No-argument variant of the atomic update operation. simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; mask = 1); /// (slm-au0-1) The following functions do the same work as <a class="el" href="group__sycl__esimd__memory__slm.html#ga7e9fb3b595ef693f1319288ca16446eb">slm_atomic_update()</a>. They accept a local accessor <code>lacc</code> and the atomic update is done from SLM associated with <code>lacc</code> plus <code>byte_offset</code> applied to it. If <code>byte_offset</code> is omitted, then zero offset is used. simd&lt;T, N&gt; atomic_update(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;1&gt; pred = 1); // (lacc-au0-1) Usage of cache hints or non-standard operation width N requires DG2 or PVC. simd&lt;T, N&gt; slm_atomic_update(simd&lt;uint32_t, N&gt; byte_offset, simd_mask&lt;N&gt; mask = 1); /// (slm-au0-1)</p>
<p>Atomically updates <code>N</code> memory locations in SLM indicated by a vector of offsets, and returns a vector of old values found at the memory locations before update. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Op</td><td>The atomic operation - can be <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaacf9f3fde7326f1d8e64205f0e07a3695" title="Increment: *addr = *addr + 1.">atomic_op::inc</a></code> or <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaa1feea25ecb958229287f885aebe7c49b" title="Decrement: *addr = *addr - 1.">atomic_op::dec</a></code>, <code><a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">atomic_op::load</a></code>. </td></tr>
    <tr><td class="paramname">T</td><td>The vector element type. </td></tr>
    <tr><td class="paramname">N</td><td>The number of memory locations to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offset</td><td>The vector of 32-bit offsets. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask, only locations with non-zero in the corresponding mask element are updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of the old values at the memory locations before the update. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05929">5929</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1detail.html#a9bd99917636b94d50409d390ed3d53dda6bad67b5e8990b5f40b54dddd984ea08">sycl::_V1::ext::intel::esimd::detail::default_size</a>, <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>, <a class="el" href="ext_2intel_2esimd_2common_8hpp_source.html#l00096">sycl::_V1::ext::intel::esimd::detail::isPowerOf2()</a>, <a class="el" href="group__sycl__esimd__core.html#ggad3d821293325e83ff7ea04b0562225aaaec4d1eb36b22d19728e9d1d23ca84d1c">sycl::_V1::ext::intel::esimd::load</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05859">sycl::_V1::ext::intel::esimd::detail::slm_atomic_update_impl()</a>.</p>

</div>
</div>
<a id="ga37e6e7ad7907665f8c5adfba3c0d3851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37e6e7ad7907665f8c5adfba3c0d3851">&#9670;&nbsp;</a></span>slm_block_load() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename Flags  = overaligned_tag&lt;detail::OperandSize::OWORD&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a contiguous block of SLM memory referenced by the given byte-offset <code>offset</code>, then returns the loaded data as a simd object. </p>
<p>The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient gather is generated. If the loaded vector is too long for 1 flat-load GPU instruction, then a series of flat-loads and/or gathers may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to load. </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offset</td><td>The byte-offset to load from. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of loaded elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04990">4990</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa2fdeaef4c8bb577b0d83ac29724459b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2fdeaef4c8bb577b0d83ac29724459b">&#9670;&nbsp;</a></span>slm_block_load() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following slm_block_load functions loads a contiguous memory block from SLM (Shared Local Memory) and the <code>byte_offset</code>. </p>
<p>The parameter 'pred' is the one element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP. The parameter 'pass_thru' specifies the values being copied to the returned result if 'pred' is set to 0. The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored. simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, props={}); // (slm-bl-1) simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (slm-bl-2) simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (slm-bl-3) The following functions do the same work as <a class="el" href="group__sycl__esimd__memory__slm.html#ga37e6e7ad7907665f8c5adfba3c0d3851" title="Loads a contiguous block of SLM memory referenced by the given byte-offset offset,...">slm_block_load()</a>. They accept a local accessor <code>lacc</code> and the load is done from SLM associated with <code>lacc</code> plus <code>byte_offset</code> applied to it. If <code>byte_offset</code> is omitted, then zero offset is used. simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, props={}); // (lacc-bl-1) simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, props={}); // (lacc-bl-2) simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-3) simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, props={}); // (lacc-bl-4) simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-5) simd&lt;T, N&gt; block_load(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (lacc-bl-6) simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, props = {}); // (slm-bl-1) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>. The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_load instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower GATHER instead of faster BLOCK_LOAD. !!! Passing <code>byte_offset</code> not aligned by 16-bytes and not specifying the actual alignment in <code>props</code> produces incorrect load results on Gen12. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05048">5048</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga02dc03472bfd52f7d011ce6c1d3ce499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02dc03472bfd52f7d011ce6c1d3ce499">&#9670;&nbsp;</a></span>slm_block_load() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;N&gt; pred, props = {}); // (slm-bl-2) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05086">5086</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gac26a70b8c5b5bae45aa2f68189316f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26a70b8c5b5bae45aa2f68189316f66">&#9670;&nbsp;</a></span>slm_block_load() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd&lt;T, N&gt; slm_block_load(uint32_t byte_offset, simd_mask&lt;1&gt; pred, simd&lt;T, N&gt; pass_thru, props={}); // (slm-bl-3) Loads a contiguous memory block from SLM (Shared Local Memory) at the given <code>byte_offset</code>. </p>
<p>The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are loaded. Otherwise, the block load operation is a NO-OP. The parameter 'pass_thru' specifies the values being copied to the returned result if 'pred' is set to 0.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05172">5172</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa5ee2a293cc88df37173e1fddbb9f122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5ee2a293cc88df37173e1fddbb9f122">&#9670;&nbsp;</a></span>slm_block_store() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-2) props = {}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the given <code>byte_offset</code>. </p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is 16-bytes to generate block_store instruction on all known target devices (Gen12, DG2, PVC, etc). On Gen12 (opposing to DG2 and PVC) the alignment smaller than 8-bytes is valid, but requires JIT compiler generating a slower SCATTER instead of faster BLOCK_STORE. !!! Passing <code>byte_offset</code> not aligned by 16-bytes and not specifying the actual alignment in <code>props</code> produces incorrect store results on Gen12. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05611">5611</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga217ac8596b42299aa84bb2dbc7e20c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga217ac8596b42299aa84bb2dbc7e20c89">&#9670;&nbsp;</a></span>slm_block_store() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; 1 &gt;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Each of the following slm_block_store functions stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the <code>byte_offset</code>. </p>
<p>The parameter 'pred' is the one element predicate. If it is set to 1, then all 'N' elements are stored. Otherwise, the block store operation is a NO-OP. The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored. void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-1) simd_mask&lt;1&gt; pred, props={}); void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-2) props={});</p>
<p>The following functions do the same work as <a class="el" href="group__sycl__esimd__memory__slm.html#ga6924c98df8e4ade1d77d4b50bd0eb90b" title="Stores elements of the vector vals to a contiguous block of SLM memory at the given byte-offset offse...">slm_block_store()</a>. They accept a local accessor <code>lacc</code> and the store of <code>vals</code> is done to SLM associated with <code>lacc</code> plus <code>byte_offset</code> applied to it. If <code>byte_offset</code> is omitted, then zero offset is used. void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-1) simd&lt;T, N&gt; vals, props={});</p>
<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-2) props={});</p>
<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, uint32_t byte_offset, // (lacc-bs-3) simd&lt;T, N&gt; vals, simd_mask&lt;1&gt; pred, props={});</p>
<p>void block_store(<a class="el" href="classsycl_1_1__V1_1_1local__accessor.html">local_accessor</a> lacc, simd&lt;T, N&gt; vals, // (lacc-bs-4) simd_mask&lt;1&gt; pred, props={});</p>
<p>void slm_block_store(uint32_t byte_offset, simd&lt;T, N&gt; vals, // (slm-bs-1) simd_mask&lt;1&gt; pred, props={}); Stores the vector <code>vals</code> to a contiguous memory block in SLM (Shared Local Memory) at the given <code>byte_offset</code>. The parameter <code>pred</code> is the one-element predicate. If it is set to 1, then all 'N' elements are stored. Otherwise, the block stored operation is a NO-OP.</p>
<p>The parameter 'props' specifies the optional compile-time properties list. Only <a class="el" href="namespacesycl_1_1__V1_1_1ext_1_1intel_1_1esimd.html#a38c6924db507261817b495c60ae30e81">esimd::alignment</a> property is used. Other properties are ignored.</p>
<p>Alignment: If <code>props</code> does not specify the 'alignment' property, then the default expected alignment is the minimally required (see (R1) below).</p>
<p>Restrictions - predicate imposed - temporary: R1: The <code>byte_offset</code> must be at least 4-byte aligned for 4-byte or smaller elements and 8-byte aligned for 8-byte elements. R2: The number of elements must be: for 8-byte data: 1, 2, 3, 4, 8, 16, 32(max for DG2), 64; for 4-byte data: 1, 2, 3, 4, 8, 16, 32, 64(max for DG2), or 128(only if alignment is 8-bytes or more); for 2-byte data: 2, 4, 6, 8, 16, 32, 64, 128(max for DG2), or 256(only if alignment is 8-bytes or more); for 1-byte data: 4, 8, 12, 16, 32, 64, 128, 256(max for DG2), or 512(only if alignment is 8-bytes or more). R3: The target device must be DG2, PVC or newer GPU. </p>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05538">5538</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga6924c98df8e4ade1d77d4b50bd0eb90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6924c98df8e4ade1d77d4b50bd0eb90b">&#9670;&nbsp;</a></span>slm_block_store() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename Flags &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;<a class="el" href="group__sycl__esimd__core__align.html#ga0a102a7d0c547e457f534d87f450908f">is_simd_flag_type_v</a>&lt;Flags&gt; &gt; sycl::_V1::ext::intel::esimd::slm_block_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Flags&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores elements of the vector <code>vals</code> to a contiguous block of SLM memory at the given byte-offset <code>offset</code>. </p>
<p>The generated code depends on the combination {T, N, Flags}. Providing flags specifying the alignment of 16-bytes or more produces more efficient code. If the alignment is smaller than 16-bytes, then less efficient scatter is generated. If the stored vector is too long for 1 flat-store GPU instruction, then a series of flat-store and/or scatters may be generated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to store. </td></tr>
    <tr><td class="paramname">Flags</td><td>The alignment specifier type tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The byte-offset to store at. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector to store. </td></tr>
    <tr><td class="paramname">Flags</td><td>Specifies the alignment. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l05473">5473</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>.</p>

</div>
</div>
<a id="gacc98080310feeaf350db9310986ef1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc98080310feeaf350db9310986ef1ff">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (slm-ga-9) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04734">4734</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gae6fcc63ae70c075518179d4da63976dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6fcc63ae70c075518179d4da63976dc">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-8) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04706">4706</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga93cb6a4da266764b6fdd4421c0b717d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93cb6a4da266764b6fdd4421c0b717d8">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; slm_gather( OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-7) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04673">4673</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga764fcd9753f206ab8c420785ba433a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga764fcd9753f206ab8c420785ba433a75">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-6) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04635">4635</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga44a8a1e761bcfb6e2a9d963432b9d74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a8a1e761bcfb6e2a9d963432b9d74a">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (slm-ga-5) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04610">4610</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaece7a3dd172984bf59f46482230a2448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece7a3dd172984bf59f46482230a2448">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-4) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04580">4580</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaf03a9216e379b075244936b633469cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf03a9216e379b075244936b633469cf5">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04548">4548</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaeeaea968caad1111d9b1f878decee783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeaea968caad1111d9b1f878decee783">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. </p>
<p>Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element of the returned vector is undefined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. Elements in masked out lanes are undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04489">4489</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gad2fef8f292d605767fdd6bdd9a725cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2fef8f292d605767fdd6bdd9a725cdf">&#9670;&nbsp;</a></span>slm_gather() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt;, <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>pass_thru</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-1) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-2) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-3) </p>
<p>The next 3 functions are similar to the above and were added for convenience. They assume the VS parameter is set to 1 and do not require specifying the template parameters &lt;T, N, VS&gt; at function calls. template &lt;typename T, int N, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-4) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, simd_mask&lt;N&gt; mask, PropertyListT props = {});// (slm-ga-5) simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N&gt; byte_offsets, PropertyListT props = {}); // (slm-ga-6)</p>
<p>The next 3 functions are variations of the first 3 above (slm-ga-1,2,3) and were added only to support <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> instead of simd for byte_offsets and/or pass_thru operands. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT typename PropertyListT = empty_props_t&gt; simd &lt;T, N&gt; slm_gather(OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru PropertyListT props = {}); // (slm-ga-7) simd &lt;T, N&gt; slm_gather(OffsetSimdViewT byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-ga-8) simd &lt;T, N&gt; slm_gather(OffsetSimdViewT byte_offsets, PropertyListT props = {}); // (slm-ga-9) template &lt;typename T, int N, int VS, typename PropertyListT = empty_properties_t&gt; simd&lt;T, N&gt; slm_gather(simd&lt;uint32_t, N / VS&gt; byte_offsets, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, simd&lt;T, N&gt; pass_thru, PropertyListT props = {}); // (slm-ga-1) Supported platforms: DG2, PVC only - Temporary restriction for the variant with pass_thru operand. Loads ("gathers") elements of the type 'T' from Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>, and returns the loaded elements. Access to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the load from (byte_offsets[i]) is skipped and the corresponding i-th element from <code>pass_thru</code> operand is returned. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">pass_thru</td><td>The vector pass through values. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of elements read. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04421">4421</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gaa3eb9d037216c4ad80dbb16d0dc270a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3eb9d037216c4ad80dbb16d0dc270a1">&#9670;&nbsp;</a></span>slm_gather_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, rgba_channel_mask RGBAMask&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; (sizeof(T) == 4), <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt;T, N * <a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(RGBAMask)&gt; &gt; sycl::_V1::ext::intel::esimd::slm_gather_rgba </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector. </p>
<p>See <a class="el" href="group__sycl__esimd__memory.html#usm_gather_rgba">usm_gather_rgba</a> for information about the operation semantics and parameter restrictions/interdependencies. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the returned vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements to access. </td></tr>
    <tr><td class="paramname">RGBAMask</td><td>Pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>Byte offsets within the SLM of each element. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask. All-1 by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gathered data as an <code>N</code> - element vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04943">4943</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, <a class="el" href="std_2experimental_2simd_8hpp_source.html#l01673">simd_mask&lt; _Tp, _Abi &gt;::data()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
<a id="ga927d068c295204a54147ac9626cfe0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga927d068c295204a54147ac9626cfe0e4">&#9670;&nbsp;</a></span>slm_init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t SLMSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::slm_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare per-work-group slm size. </p>
<p>GPU RT/driver requires this function to be called in the beginning of the kernel using SLM. There must be only 1 call site of <a class="el" href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4" title="Declare per-work-group slm size.">slm_init()</a> per kernel. If slm_init is called from some function F called from the kernel, then inlining of F into the kernel must be managed/guaranteed. slm_init&lt;SLMSize&gt; can also be used together with slm_allocator() class. In such cases slm_allocator&lt;AdditionalMem&gt; allocates extra chunk of SLM memory and the final amount of allocated SLM may be bigger than what is requested by slm_init. See more details on <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1slm__allocator.html" title="RAII-style class used to implement &quot;semi-dynamic&quot; SLM allocation.">slm_allocator</a> class usage at it's declaration and ESIMD extension SPEC. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SLMSize</td><td>Shared Local Memory (SLM) size </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04336">4336</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga346b7902be6b67d13f0034d77767722a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga346b7902be6b67d13f0034d77767722a">&#9670;&nbsp;</a></span>slm_init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::slm_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare per-work-group slm size. </p>
<p>Non-constant argument version to be used with specialization constants only. Same restrictions are applied to this function as to it's template variant <a class="el" href="group__sycl__esimd__memory__slm.html#ga927d068c295204a54147ac9626cfe0e4" title="Declare per-work-group slm size.">slm_init&lt;SLMSize&gt;()</a>. This version has an additional restriction - it cannot be used together </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Shared Local Memory (SLM) size to be allocated for each work-group of ESIMD kernel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04348">4348</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga31c2a91e85ca4cef214e90fc09d2c290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31c2a91e85ca4cef214e90fc09d2c290">&#9670;&nbsp;</a></span>slm_scalar_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API T sycl::_V1::ext::intel::esimd::slm_scalar_load </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a scalar value from the Shared Local Memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>SLM offset in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the loaded value </dd></dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04743">4743</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gadcd8292a7c31b41dc4a2734de778d2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd8292a7c31b41dc4a2734de778d2f9">&#9670;&nbsp;</a></span>slm_scalar_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API void sycl::_V1::ext::intel::esimd::slm_scalar_store </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a scalar value into the Shared Local Memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>SLM offset in bytes </td></tr>
    <tr><td class="paramname">val</td><td>value to store </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04926">4926</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="gafe51d24eb859e430fb759b91851cac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe51d24eb859e430fb759b91851cac12">&#9670;&nbsp;</a></span>slm_scatter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_scatter </td>
          <td>(</td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-4) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector of values to store. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04915">4915</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga89f22bfc6394d6f5bf7829f5eb0f2e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f22bfc6394d6f5bf7829f5eb0f2e7a">&#9670;&nbsp;</a></span>slm_scatter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename OffsetSimdViewT , typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; detail::is_simd_view_type_v&lt;OffsetSimdViewT&gt; &amp;&amp; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_scatter </td>
          <td>(</td>
          <td class="paramtype">OffsetSimdViewT&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; void slm_scatter( OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-3) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>. </p>
<p>Storage to any element's memory location can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the storage to (byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector of values to store. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04889">4889</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga17da97cf44fd768030ee06b7321151bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17da97cf44fd768030ee06b7321151bc">&#9670;&nbsp;</a></span>slm_scatter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of reads per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector of values to store. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04854">4854</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga452f04de1896d50b415bfcdff867a469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga452f04de1896d50b415bfcdff867a469">&#9670;&nbsp;</a></span>slm_scatter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, int VS = 1, typename PropertyListT  = ext::oneapi::experimental::detail::empty_properties_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt; ext::oneapi::experimental::is_property_list_v&lt;PropertyListT&gt; &gt; sycl::_V1::ext::intel::esimd::slm_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N/VS &gt;&#160;</td>
          <td class="paramname"><em>byte_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N/VS &gt;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropertyListT&#160;</td>
          <td class="paramname"><em>props</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-1) void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-2) </p>
<p>The next 2 functions are variations of the first 2 above (slm-sc-1,2) and were added only to support <a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd__view.html" title="This class represents a reference to a sub-region of a base simd object.">simd_view</a> instead of simd for byte_offsets. template &lt;typename T, int N, int VS = 1, typename OffsetSimdViewT, typename PropertyListT = empty_props_t&gt; void slm_scatter(OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-3) void slm_scatter(OffsetSimdViewT byte_offsets, simd&lt;T, N&gt; vals, PropertyListT props = {}); // (slm-sc-4) template &lt;typename T, int N, int VS = 1, typename PropertyListT = empty_properties_t&gt; void slm_scatter(simd&lt;uint32_t, N / VS&gt; byte_offsets, simd&lt;T, N&gt; vals, <a class="el" href="classsimd__mask.html">simd_mask</a>&lt;N / VS&gt; mask, PropertyListT props = {}); // (slm-sc-1) Stores ("scatters") elements of the type 'T' to Shared Local Memory locations addressed by byte offsets <code>byte_offsets</code>. Storage of any element can be disabled via the input vector of predicates <code>mask</code>. If mask[i] is unset, then the storage to (byte_offsets[i]) is skipped. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type. </td></tr>
    <tr><td class="paramname">N</td><td>Number of elements to read. </td></tr>
    <tr><td class="paramname">VS</td><td>Vector size. It can also be read as the number of writes per each address. The parameter 'N' must be divisible by 'VS'. (VS &gt; 1) is supported only on DG2 and PVC and only for 4- and 8-byte element vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byte_offsets</td><td>the vector of 32-bit offsets in bytes. For each i, (byte_offsets[i]) must be element size aligned. If the alignment property is not passed, then it is assumed that each accessed address is aligned by element-size. </td></tr>
    <tr><td class="paramname">vals</td><td>The vector of values to store. </td></tr>
    <tr><td class="paramname">mask</td><td>The access mask, defaults to all 1s. </td></tr>
    <tr><td class="paramname">props</td><td>The optional compile-time properties. Only 'alignment' property is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04793">4793</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a id="ga28dd84cf8f6b8a67f7c71130495686c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28dd84cf8f6b8a67f7c71130495686c7">&#9670;&nbsp;</a></span>slm_scatter_rgba()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N, rgba_channel_mask Mask&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__ESIMD_API std::enable_if_t&lt;(N == 8 || N == 16 || N == 32) &amp;&amp; (sizeof(T) == 4)&gt; sycl::_V1::ext::intel::esimd::slm_scatter_rgba </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; uint32_t, N &gt;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsycl_1_1__V1_1_1ext_1_1intel_1_1esimd_1_1simd.html">simd</a>&lt; T, N *<a class="el" href="group__sycl__esimd__core.html#ga89a91f7c27b62c89109ee70a41543f7a">get_num_channels_enabled</a>(Mask)&gt;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__sycl__esimd__core__vectors.html#gabdf9f3ea8534fe5107b78fc8ae5509d3">simd_mask</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather data from the Shared Local Memory at specified <code>offsets</code> and return it as simd vector. </p>
<p>See <a class="el" href="group__sycl__esimd__memory.html#usm_scatter_rgba">usm_scatter_rgba</a> for information about the operation semantics and parameter restrictions/interdependencies. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element type of the returned vector. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements to access. </td></tr>
    <tr><td class="paramname">Mask</td><td>Pixel's channel mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsets</td><td>Byte offsets within the SLM of each element. </td></tr>
    <tr><td class="paramname">vals</td><td>values to be written. </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask. All-1 by default. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l04961">4961</a> of file <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html">memory.hpp</a>.</p>

<p class="reference">References <a class="el" href="simd__obj__impl_8hpp_source.html#l00376">sycl::_V1::ext::intel::esimd::detail::simd_obj_impl&lt; RawTy, N, Derived, SFINAE &gt;::data()</a>, and <a class="el" href="ext_2intel_2esimd_2memory_8hpp_source.html#l00053">sycl::_V1::ext::intel::esimd::get_surface_index()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
