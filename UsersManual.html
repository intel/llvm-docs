<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Users Manual &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=dfa0e015" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Preprocessor Macros" href="PreprocessorMacros.html" />
    <link rel="prev" title="Getting Started with oneAPI DPC++" href="GetStartedGuide.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>Users Manual</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="GetStartedGuide.html">Getting Started with oneAPI DPC++</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PreprocessorMacros.html">Preprocessor Macros</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="users-manual">
<h1>Users Manual<a class="headerlink" href="#users-manual" title="Link to this heading">¶</a></h1>
<p>This is the list of SYCL specific options supported by compiler and some
examples.</p>
<p>Options marked as [DEPRECATED] are going to be removed in some future updates.
Options marked as [EXPERIMENTAL] are expected to be used only in limited cases
and not recommended to use in production environment.</p>
<section id="generic-options">
<h2>Generic options<a class="headerlink" href="#generic-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>General enabling option for SYCL compilation and linking mode. List of
targets can be specified with `-fsycl-targets`. This is fundamental option
for any SYCL compilation. All other SYCL specific options require it.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-targets=&lt;T1&gt;[,...,&lt;Tn&gt;]</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables ahead of time (AOT) compilation for specified device targets. T is
a compiler target triple string, representing a target device architecture.
You can specify more than one target, comma separated. Default just in time
(JIT) compilation target can be added to the list to produce a combination
of AOT and JIT code in the resulting fat binary.

Normally, &#39;-fsycl-targets&#39; is specified when linking an application, in
which case the AOT compiled device binaries are embedded within the
application’s fat executable.  However, this option may also be used in
combination with &#39;-c&#39; and &#39;-fno-sycl-rdc&#39; when compiling a source file.
In this case, the AOT compiled device binaries are embedded within the fat
object file.

The following triples are supported by default:
* spir64 - this is the default generic SPIR-V target;
* spir64_x86_64 - generate code ahead of time for x86_64 CPUs;
* spir64_fpga - generate code ahead of time for Intel FPGA;
* spir64_gen - generate code ahead of time for Intel Processor Graphics;
Full target triples can also be used:
* spir64-unknown-unknown, spir64_x86_64-unknown-unknown,
  spir64_fpga-unknown-unknown, spir64_gen-unknown-unknown
Available in special build configuration:
* nvptx64-nvidia-cuda - generate code ahead of time for CUDA target;
* native_cpu - allows to run SYCL applications with no need of an 
additional backend (note that this feature is WIP and experimental, and 
currently overrides all the other specified SYCL targets when enabled.)

Special target values specific to Intel, NVIDIA and AMD Processor Graphics
support are accepted, providing a streamlined interface for AOT. Only one of
these values at a time is supported.
* intel_gpu_lnl_m, intel_gpu_20_4_4 - Lunar Lake Intel graphics architecture
* intel_gpu_bmg_g21, intel_gpu_20_1_4 - Battlemage G21 Intel graphics architecture
* intel_gpu_arl_h, intel_gpu_12_74_4 - Arrow Lake H Intel graphics architecture
* intel_gpu_mtl_h, intel_gpu_12_71_4 - Meteor Lake H Intel graphics architecture
* intel_gpu_mtl_u, intel_gpu_mtl_s, intel_gpu_arl_u, intel_gpu_arl_s, intel_gpu_12_70_4 - Meteor Lake U/S or Arrow Lake U/S Intel graphics architecture
* intel_gpu_pvc_vg, intel_gpu_12_61_7 - Ponte Vecchio VG Intel graphics architecture
* intel_gpu_pvc, intel_gpu_12_60_7 - Ponte Vecchio Intel graphics architecture
* intel_gpu_acm_g12, intel_gpu_dg2_g12, intel_gpu_12_57_0 - Alchemist G12 Intel graphics architecture
* intel_gpu_acm_g11, intel_gpu_dg2_g11, intel_gpu_12_56_5 - Alchemist G11 Intel graphics architecture
* intel_gpu_acm_g10, intel_gpu_dg2_g10, intel_gpu_12_55_8 - Alchemist G10 Intel graphics architecture
* intel_gpu_dg1, intel_gpu_12_10_0 - DG1 Intel graphics architecture
* intel_gpu_adl_n - Alder Lake N Intel graphics architecture
* intel_gpu_adl_p - Alder Lake P Intel graphics architecture
* intel_gpu_rpl_s - Raptor Lake Intel graphics architecture (equal to intel_gpu_adl_s)
* intel_gpu_adl_s - Alder Lake S Intel graphics architecture
* intel_gpu_rkl - Rocket Lake Intel graphics architecture
* intel_gpu_tgllp, intel_gpu_tgl, intel_gpu_12_0_0 - Tiger Lake Intel graphics architecture
* intel_gpu_jsl - Jasper Lake Intel graphics architecture (equal to intel_gpu_ehl)
* intel_gpu_ehl - Elkhart Lake Intel graphics architecture
* intel_gpu_icllp, intel_gpu_icl, intel_gpu_11_0_0 - Ice Lake Intel graphics architecture
* intel_gpu_cml, intel_gpu_9_7_0 - Comet Lake Intel graphics architecture
* intel_gpu_aml, intel_gpu_9_6_0 - Amber Lake Intel graphics architecture
* intel_gpu_whl, intel_gpu_9_5_0 - Whiskey Lake Intel graphics architecture
* intel_gpu_glk, intel_gpu_9_4_0 - Gemini Lake Intel graphics architecture
* intel_gpu_bxt - Broxton Intel graphics architecture (equal to intel_gpu_apl)
* intel_gpu_apl, intel_gpu_9_3_0 - Apollo Lake Intel graphics architecture
* intel_gpu_cfl, intel_gpu_9_2_9 - Coffee Lake Intel graphics architecture
* intel_gpu_kbl, intel_gpu_9_1_9 - Kaby Lake Intel graphics architecture
* intel_gpu_skl, intel_gpu_9_0_9 - Intel(R) microarchitecture code name Skylake Intel graphics architecture
* intel_gpu_bdw, intel_gpu_8_0_0 - Intel(R) microarchitecture code name Broadwell Intel graphics architecture
* nvidia_gpu_sm_50 - NVIDIA Maxwell architecture (compute capability 5.0)
* nvidia_gpu_sm_52 - NVIDIA Maxwell architecture (compute capability 5.2)
* nvidia_gpu_sm_53 - NVIDIA Maxwell architecture (compute capability 5.3)
* nvidia_gpu_sm_60 - NVIDIA Pascal architecture (compute capability 6.0)
* nvidia_gpu_sm_61 - NVIDIA Pascal architecture (compute capability 6.1)
* nvidia_gpu_sm_62 - NVIDIA Pascal architecture (compute capability 6.2)
* nvidia_gpu_sm_70 - NVIDIA Volta architecture (compute capability 7.0)
* nvidia_gpu_sm_72 - NVIDIA Volta architecture (compute capability 7.2)
* nvidia_gpu_sm_75 - NVIDIA Turing architecture (compute capability 7.5)
* nvidia_gpu_sm_80 - NVIDIA Ampere architecture (compute capability 8.0)
* nvidia_gpu_sm_86 - NVIDIA Ampere architecture (compute capability 8.6)
* nvidia_gpu_sm_87 - NVIDIA Jetson/Drive AGX Orin architecture
* nvidia_gpu_sm_89 - NVIDIA Ada Lovelace architecture
* nvidia_gpu_sm_90 - NVIDIA Hopper architecture
* nvidia_gpu_sm_90a - NVIDIA Hopper architecture (with wgmma and setmaxnreg instructions)
* amd_gpu_gfx700 - AMD GCN GFX7 (Sea Islands (CI)) architecture
* amd_gpu_gfx701 - AMD GCN GFX7 (Sea Islands (CI)) architecture
* amd_gpu_gfx702 - AMD GCN GFX7 (Sea Islands (CI)) architecture
* amd_gpu_gfx801 - AMD GCN GFX8 (Volcanic Islands (VI)) architecture
* amd_gpu_gfx802 - AMD GCN GFX8 (Volcanic Islands (VI)) architecture
* amd_gpu_gfx803 - AMD GCN GFX8 (Volcanic Islands (VI)) architecture
* amd_gpu_gfx805 - AMD GCN GFX8 (Volcanic Islands (VI)) architecture
* amd_gpu_gfx810 - AMD GCN GFX8 (Volcanic Islands (VI)) architecture
* amd_gpu_gfx900 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx902 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx904 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx906 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx908 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx909 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx90a - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx90c - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx940 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx941 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx942 - AMD GCN GFX9 (Vega) architecture
* amd_gpu_gfx1010 - AMD GCN GFX10.1 (RDNA 1) architecture
* amd_gpu_gfx1011 - AMD GCN GFX10.1 (RDNA 1) architecture
* amd_gpu_gfx1012 - AMD GCN GFX10.1 (RDNA 1) architecture
* amd_gpu_gfx1013 - AMD GCN GFX10.1 (RDNA 1) architecture
* amd_gpu_gfx1030 - AMD GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1031 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1032 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1033 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1034 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1035 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1036 - GCN GFX10.3 (RDNA 2) architecture
* amd_gpu_gfx1100 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1101 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1102 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1103 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1150 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1151 - GCN GFX11 (RDNA 3) architecture
* amd_gpu_gfx1200 - GCN GFX12 (RDNA 4) architecture
* amd_gpu_gfx1201 - GCN GFX12 (RDNA 4) architecture
</pre></div>
</div>
</section>
<section id="language-options">
<h2>Language options<a class="headerlink" href="#language-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-sycl-std=&lt;value&gt;</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SYCL language standard to compile for. Currently the possible value is:
* 2020 - for SYCL 2020
It doesn&#39;t guarantee specific standard compliance, but some selected
compiler features change behavior.
It is under development and not recommended to use in production
environment.
Default value is 2020.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-unnamed-lambda</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables/Disables unnamed SYCL lambda kernels support.
The default value depends on the SYCL language standard: it is enabled
by default for SYCL 2020.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-explicit-simd</span></code></strong> [DEPRECATED]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The option was used to enable/disable SYCL explicit SIMD extension.
Not used anymore.
</pre></div>
</div>
</section>
<section id="optimization-options">
<h2>Optimization options<a class="headerlink" href="#optimization-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-early-optimizations</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables (or disables) intermediate representation optimization pipeline
before translation to SPIR-V. Have effect only if optimizations are turned
on by standard compiler options (-O1 or higher).
Enabled by default.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-dead-args-optimization</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables (or disables) LLVM IR dead argument elimination pass to remove
unused arguments for the kernel functions before translation to SPIR-V.
Currently has effect only on spir64\* targets.
Enabled by default.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-id-queries-fit-in-int</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Assume/Do not assume that SYCL ID queries fit within MAX_INT. It assumes
that these values fit within MAX_INT:
* id class get() member function and operator[]
* item class get_id() member function and operator[]
* nd_item class get_global_id()/get_global_linear_id() member functions
Enabled by default.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-force-inline-kernel-lambda</span></code></strong></p>
<p>Enables/Disables inlining of the kernel lambda operator into the compiler
generated entry point function. This flag does not apply to ESIMD
kernels.
Disabled when optimizations are disabled (-O0 or equivalent). Enabled
otherwise.</p>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fgpu-inline-threshold=&lt;n&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Sets the inline threshold for device compilation to &lt;n&gt;. Note that this
option only affects the behaviour of the DPC++ compiler, not target-
specific compilers (e.g. OpenCL/Level Zero/Nvidia/AMD target compilers)
which may or may not perform additional inlining.
Default value is 225.
</pre></div>
</div>
</section>
<section id="target-toolchain-options">
<h2>Target toolchain options<a class="headerlink" href="#target-toolchain-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-Xsycl-target-backend=&lt;T&gt;</span> <span class="pre">&quot;options&quot;</span></code></strong>
<strong><code class="docutils literal notranslate"><span class="pre">-Xs</span> <span class="pre">&quot;options&quot;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Pass &quot;options&quot; to the backend of target device compiler, specified by
triple T. The backend of device compiler generates target machine code from
intermediate representation. This option can be used to tune code
generation for a specific target. The &quot;options&quot; are used during AOT
compilation. For JIT compilation &quot;options&quot; are saved in a fat binary and
used when code is JITed during runtime.
-Xs is a shortcut to pass &quot;options&quot; to all backends specified via the
&#39;-fsycl-targets&#39; option (or default one).
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-Xsycl-target-frontend=&lt;T&gt;</span> <span class="pre">&quot;options&quot;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Pass &quot;options&quot; to the frontend of target device compiler, specified by
triple T. This option can be used to control of intermediate representation
generation during offline or online compilation.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-Xsycl-target-linker=&lt;T&gt;</span> <span class="pre">&quot;options&quot;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Pass &quot;options&quot; to the device code linker, when linking multiple device
object modules. T is specific target device triple.
</pre></div>
</div>
</section>
<section id="link-options">
<h2>Link options<a class="headerlink" href="#link-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-link</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Link device object modules and wrap those into a host-compatible object
module that can be linked later by any standard host linker into the final
fat binary.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split=&lt;mode&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Specifies SYCL device code module assembly. Mode is one of the following:
* per_kernel - creates a separate device code module for each SYCL kernel.
  Each device code module will contain a kernel and all its dependencies,
  such as called functions and used variables.
* per_source - creates a separate device code module for each source
  (translation unit). Each device code module will contain a bunch of
  kernels grouped on per-source basis and all their dependencies, such as
  all used variables and called functions, including the `SYCL_EXTERNAL`
  macro-marked functions from other translation units.
* off - creates a single module for all kernels. If `-fsycl-no-rdc` is
  specified, the behavior is the same as per_source.
* auto - the compiler will use a heuristic to select the best way of
  splitting device code. This is default mode.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-device-code-split-esimd</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Controls SYCL/ESIMD device code splitting. When enabled (this is the
 default), SYCL and ESIMD entry points along with their call graphs are
 put into separate device binary images. Otherwise, SYCL and ESIMD parts
 of the device code are kept in the same device binary image and get
 compiled by the Intel GPU compiler back end as a single module. This
 option has effect only for SPIR-based targets and apps containing ESIMD
 kernels.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-max-parallel-link-jobs=&lt;N&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Experimental feature. When specified, it informs the compiler
that it can simultaneously spawn up to `N` processes to perform
actions required to link the DPC++ application. This option is
only useful in SYCL mode. It only takes effect if link action
needs to be executed, i.e. it won&#39;t have any effect in presence of
options like `-c` or `-E`. Default value of `N` is 1.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-device-lib=&lt;lib1&gt;[,&lt;lib2&gt;,...]</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables/disables linking of the device libraries. Supported libraries:
libm-fp32, libm-fp64, libc, all. Use of &#39;all&#39; will enable/disable all of
the device libraries.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-device-lib-jit-link</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables/disables jit link mechanism for SYCL device library in JIT
compilation. If jit link is enabled, all required device libraries will
be linked with user&#39;s device image by SYCL runtime during execution time,
otherwise the link will happen in build time, jit link is disabled by
default currently. This option is ignored in AOT compilation.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-instrument-device-code</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables/disables linking of the Instrumentation and Tracing Technology (ITT)
device libraries for VTune(R). This provides annotations to intercept
various events inside JIT generated kernels. These device libraries are
linked in by default.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-force-target=&lt;T&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>When used along with &#39;-fsycl-targets&#39;, force the device object being
unbundled to match the target &lt;T&gt; given.  This allows the user to override
the expected unbundling type even though the target given does not match.
The forced target applies to all objects, archives and default device
libraries.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-rdc</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enables/disables relocatable device code. If relocatable device code is
disabled, device code cannot use SYCL_EXTERNAL functions, which allows
the compiler to link device code on a per-translation-unit basis.
This may result in compile time and compiler memory usage improvements.
&#39;-fno-sycl-rdc&#39; used along with &#39;-fsycl-max-parallel-link-jobs&#39; will enable
additional device linking parallism for fat static archives.
Relocatable device code is enabled by default.
</pre></div>
</div>
</section>
<section id="intel-fpga-specific-options">
<h2>Intel FPGA specific options<a class="headerlink" href="#intel-fpga-specific-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fintelfpga</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Perform ahead of time compilation for Intel FPGA. It sets the target to
FPGA and turns on the debug options that are needed to generate FPGA
reports. It is functionally equivalent shortcut to
`-fsycl-targets=spir64_fpga -g -MMD` on Linux and
`-fsycl-targets=spir64_fpga -Zi -MMD` on Windows.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-link=&lt;output&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Controls FPGA target binary output format. Same as -fsycl-link, but
optional output can be one of the following:
* early - generate html reports and an intermediate object file that avoids
a full Quartus compile. Usually takes minutes to generate. Link can later
be resumed from this point using -fsycl-link=image.
* image - generate a bitstream which is ready to be linked and used on a
FPGA board. Usually takes hours to generate.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-reuse-exe=&lt;exe&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Speed up FPGA backend compilation if the device code in &lt;binary&gt; is
unchanged. If it&#39;s safe to do so the compiler will re-use the device binary
embedded within it. This can be used to minimize or avoid long Quartus
compile times for FPGA targets when the device code is unchanged.
</pre></div>
</div>
</section>
<section id="other-options">
<h2>Other options<a class="headerlink" href="#other-options" title="Link to this heading">¶</a></h2>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-device-only</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Compile only device part of the code and ignore host part.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-use-bitcode</span></code></strong> [DEPRECATED]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Emit SYCL device code in LLVM-IR bitcode format. When disabled, SPIR-V is
emitted.
Enabled by default.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-device-obj=&lt;arg&gt;</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Specify format of device code stored in the resulting object. The &lt;arg&gt; can
be one of the following:  &quot;spirv&quot; - SPIR-V is emitted, &quot;llvmir&quot; - LLVM-IR
bitcode format is emitted (default).
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-help[=backend]</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Emit help information from device compiler backend. Backend can be one of
the following: &quot;x86_64&quot;, &quot;fpga&quot;, &quot;gen&quot;, or &quot;all&quot;. Specifying &quot;all&quot; is the
same as specifying -fsycl-help with no argument and emits help for all
backends.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-host-compiler=&lt;arg&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Informs the compiler driver that the host compilation step that is performed
as part of the greater compilation flow will be performed by the compiler
&lt;arg&gt;.  It is expected that &lt;arg&gt; is the compiler to be called, either by
name (in which the PATH will be used to discover it) or a fully qualified
directory with compiler to invoke.  This option is only useful when -fsycl
is provided on the command line.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-host-compiler-options=&quot;opts&quot;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Passes along the space separated quoted &quot;opts&quot; string as option arguments
to the compiler specified with the -fsycl-host-compiler=&lt;arg&gt; option.  It is
expected that the options used here are compatible with the compiler
specified via -fsycl-host-compiler=&lt;arg&gt;.

NOTE: Using -fsycl-host-compiler-options to pass any kind of phase limiting
options (e.g. -c, -E, -S) may interfere with the expected output set during
the host compilation.  Doing so is considered undefined behavior.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fsycl-fp32-prec-sqrt</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enable use of correctly rounded `sycl::sqrt` function as defined by IEE754.
Without this flag, the default precision requirement for `sycl::sqrt` is 3
ULP.

NOTE: This flag is currently only supported with the CUDA and HIP targets.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]sycl-esimd-force-stateless-mem</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Enforces stateless memory access and enables the automatic conversion of
&quot;stateful&quot; memory access via SYCL accessors to &quot;stateless&quot; within ESIMD
(Explicit SIMD) kernels.

-fsycl-esimd-force-stateless-mem disables the intrinsics and methods
accepting SYCL accessors or &quot;surface-index&quot; which cannot be automatically
converted to their &quot;stateless&quot; equivalents.

-fno-sycl-esimd-force-stateless-mem is used to tell compiler not to
enforce usage of stateless memory accesses. This is the default behavior.

NOTE: &quot;Stateful&quot; access is the one that uses SYCL accessor or a pair
of &quot;surface-index&quot; + 32-bit byte-offset and uses specific memory access
data port messages to read/write/fetch.
&quot;Stateless&quot; memory access uses memory location represented with virtual
memory address pointer such as USM pointer.

The &quot;stateless&quot; memory may be beneficial as it does not have the limit
of 4Gb per surface.
Also, some of Intel GPUs or GPU run-time/drivers may support only
&quot;stateless&quot; memory accesses.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-ftarget-compile-fast</span></code></strong> [EXPERIMENTAL]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Instructs the target backend to reduce compilation time, potentially
at the cost of runtime performance. Currently only supported on Intel GPUs.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-f[no-]target-export-symbols</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Exposes exported symbols in a generated target library to allow for
visibility to other modules.

NOTE: This flag is only supported for spir64_gen AOT targets.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-ftarget-register-alloc-mode=&lt;arg&gt;</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Specify a register allocation mode for specific hardware for use by supported
target backends. The format of the argument is &quot;Device0:Mode0[,Device1:Mode1...]&quot;.
Currently the only supported Device is &quot;pvc&quot;. The supported modes are
&quot;default&quot;,&quot;small&quot;,&quot;large&quot;, and &quot;auto&quot;.
</pre></div>
</div>
<p><strong><code class="docutils literal notranslate"><span class="pre">-fpreview-breaking-changes</span></code></strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>When specified, it informs the compiler driver and compilation phases
that it is allowed to break backward compatibility. When this option is
specified the compiler will also set the macro
__INTEL_PREVIEW_BREAKING_CHANGES.
When this option is used in conjunction with -fsycl, the driver will link
against an alternate form of libsycl, libsycl-preview.
</pre></div>
</div>
</section>
</section>
<section id="example-sycl-device-code-compilation">
<h1>Example: SYCL device code compilation<a class="headerlink" href="#example-sycl-device-code-compilation" title="Link to this heading">¶</a></h1>
<p>To invoke SYCL device compiler set <code class="docutils literal notranslate"><span class="pre">-fsycl-device-only</span></code> flag.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fsycl-device-only<span class="w"> </span>sycl-app.cpp<span class="w"> </span>-o<span class="w"> </span>sycl-app.bc
</pre></div>
</div>
<p>By default the output format for SYCL device is LLVM bytecode.</p>
<p><code class="docutils literal notranslate"><span class="pre">-fno-sycl-use-bitcode</span></code> can be used to emit device code in SPIR-V format.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-fsycl-device-only<span class="w"> </span>-fno-sycl-use-bitcode<span class="w"> </span>sycl-app.cpp<span class="w"> </span>-o<span class="w"> </span>sycl-app.spv
</pre></div>
</div>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="GetStartedGuide.html">Getting Started with oneAPI DPC++</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PreprocessorMacros.html">Preprocessor Macros</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>