<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Standard C++ Modules &#8212; Clang 19.0.0git documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css?v=e491ac2d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
    <script src="_static/documentation_options.js?v=f778a350"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modules" href="Modules.html" />
    <link rel="prev" title="Source-based Code Coverage" href="SourceBasedCodeCoverage.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Clang 19.0.0git documentation</span></a></h1>
        <h2 class="heading"><span>Standard C++ Modules</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="standard-c-modules">
<h1>Standard C++ Modules<a class="headerlink" href="#standard-c-modules" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id5">Introduction</a></p></li>
<li><p><a class="reference internal" href="#standard-c-named-modules" id="id6">Standard C++ Named modules</a></p>
<ul>
<li><p><a class="reference internal" href="#background-and-terminology" id="id7">Background and terminology</a></p>
<ul>
<li><p><a class="reference internal" href="#modules" id="id8">Modules</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id9">Clang Modules</a></p></li>
<li><p><a class="reference internal" href="#module-and-module-unit" id="id10">Module and module unit</a></p></li>
<li><p><a class="reference internal" href="#built-module-interface-file" id="id11">Built Module Interface file</a></p></li>
<li><p><a class="reference internal" href="#global-module-fragment" id="id12">Global module fragment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#how-to-build-projects-using-modules" id="id13">How to build projects using modules</a></p>
<ul>
<li><p><a class="reference internal" href="#quick-start" id="id14">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-enable-standard-c-modules" id="id15">How to enable standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-a-bmi" id="id16">How to produce a BMI</a></p></li>
<li><p><a class="reference internal" href="#file-name-requirement" id="id17">File name requirement</a></p></li>
<li><p><a class="reference internal" href="#module-name-requirement" id="id18">Module name requirement</a></p></li>
<li><p><a class="reference internal" href="#how-to-specify-the-dependent-bmis" id="id19">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" id="id20">Remember that module units still have an object counterpart to the BMI</a></p></li>
<li><p><a class="reference internal" href="#consistency-requirement" id="id21">Consistency Requirement</a></p>
<ul>
<li><p><a class="reference internal" href="#options-consistency" id="id22">Options consistency</a></p></li>
<li><p><a class="reference internal" href="#definitions-consistency" id="id23">Definitions consistency</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#abi-impacts" id="id24">ABI Impacts</a></p>
<ul>
<li><p><a class="reference internal" href="#mangling-names" id="id25">Mangling Names</a></p></li>
<li><p><a class="reference internal" href="#module-initializers" id="id26">Module Initializers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reduced-bmi" id="id27">Reduced BMI</a></p></li>
<li><p><a class="reference internal" href="#performance-tips" id="id28">Performance Tips</a></p>
<ul>
<li><p><a class="reference internal" href="#reduce-duplications" id="id29">Reduce duplications</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#ideas-for-converting-to-modules" id="id30">Ideas for converting to modules</a></p>
<ul>
<li><p><a class="reference internal" href="#abi-non-breaking-styles" id="id31">ABI non-breaking styles</a></p>
<ul>
<li><p><a class="reference internal" href="#export-using-style" id="id32">export-using style</a></p></li>
<li><p><a class="reference internal" href="#export-extern-c-style" id="id33">export extern-C++ style</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#abi-breaking-style" id="id34">ABI breaking style</a></p>
<ul>
<li><p><a class="reference internal" href="#what-if-there-are-headers-only-inclued-by-the-source-files" id="id35">What if there are headers only inclued by the source files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#providing-a-header-to-skip-parsing-redundant-headers" id="id36">Providing a header to skip parsing redundant headers</a></p></li>
<li><p><a class="reference internal" href="#importing-modules" id="id37">Importing modules</a></p>
<ul>
<li><p><a class="reference internal" href="#all-dependent-libraries-providing-modules" id="id38">All dependent libraries providing modules</a></p></li>
<li><p><a class="reference internal" href="#partial-dependent-libraries-providing-modules" id="id39">Partial dependent libraries providing modules</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#known-problems" id="id40">Known Problems</a></p>
<ul>
<li><p><a class="reference internal" href="#including-headers-after-import-is-problematic" id="id41">Including headers after import is problematic</a></p></li>
<li><p><a class="reference internal" href="#ignored-preferredname-attribute" id="id42">Ignored PreferredName Attribute</a></p></li>
<li><p><a class="reference internal" href="#don-t-emit-macros-about-module-declaration" id="id43">Don’t emit macros about module declaration</a></p></li>
<li><p><a class="reference internal" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" id="id44">In consistent filename suffix requirement for importable module units</a></p></li>
<li><p><a class="reference internal" href="#clang-cl-is-not-compatible-with-the-standard-c-modules" id="id45">clang-cl is not compatible with the standard C++ modules</a></p></li>
<li><p><a class="reference internal" href="#false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type" id="id46">false positive ODR violation diagnostic due to using inconsistent qualified but the same type</a></p></li>
<li><p><a class="reference internal" href="#using-tu-local-entity-in-other-units" id="id47">Using TU-local entity in other units</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#header-units" id="id48">Header Units</a></p>
<ul>
<li><p><a class="reference internal" href="#how-to-build-projects-using-header-unit" id="id49">How to build projects using header unit</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id50">Quick Start</a></p></li>
<li><p><a class="reference internal" href="#how-to-produce-bmis" id="id51">How to produce BMIs</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id52">How to specify the dependent BMIs</a></p></li>
<li><p><a class="reference internal" href="#don-t-compile-the-bmi" id="id53">Don’t compile the BMI</a></p></li>
<li><p><a class="reference internal" href="#include-translation" id="id54">Include translation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#relationships-between-clang-modules" id="id55">Relationships between Clang modules</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#discover-dependencies" id="id56">Discover Dependencies</a></p>
<ul>
<li><p><a class="reference internal" href="#possible-issues-failed-to-find-system-headers" id="id57">Possible Issues: Failed to find system headers</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#import-modules-with-clang-repl" id="id58">Import modules with clang-repl</a></p></li>
<li><p><a class="reference internal" href="#possible-questions" id="id59">Possible Questions</a></p>
<ul>
<li><p><a class="reference internal" href="#how-modules-speed-up-compilation" id="id60">How modules speed up compilation</a></p></li>
<li><p><a class="reference internal" href="#interoperability-with-clang-modules" id="id61">Interoperability with Clang Modules</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The term <code class="docutils literal notranslate"><span class="pre">modules</span></code> has a lot of meanings. For the users of Clang, modules may
refer to <code class="docutils literal notranslate"><span class="pre">Objective-C</span> <span class="pre">Modules</span></code>, <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">C++</span> <span class="pre">Modules</span></code> (or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Header</span> <span class="pre">Modules</span></code>,
etc.) or <code class="docutils literal notranslate"><span class="pre">Standard</span> <span class="pre">C++</span> <span class="pre">Modules</span></code>. The implementation of all these kinds of modules in Clang
has a lot of shared code, but from the perspective of users, their semantics and
command line interfaces are very different. This document focuses on
an introduction of how to use standard C++ modules in Clang.</p>
<p>There is already a detailed document about <a class="reference external" href="Modules.html">Clang modules</a>, it
should be helpful to read <a class="reference external" href="Modules.html">Clang modules</a> if you want to know
more about the general idea of modules. Since standard C++ modules have different semantics
(and work flows) from <cite>Clang modules</cite>, this page describes the background and use of
Clang with standard C++ modules.</p>
<p>Modules exist in two forms in the C++ Language Specification. They can refer to
either “Named Modules” or to “Header Units”. This document covers both forms.</p>
</section>
<section id="standard-c-named-modules">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Standard C++ Named modules</a><a class="headerlink" href="#standard-c-named-modules" title="Link to this heading">¶</a></h2>
<p>This document was intended to be a manual first and foremost, however, we consider it helpful to
introduce some language background here for readers who are not familiar with
the new language feature. This document is not intended to be a language
tutorial; it will only introduce necessary concepts about the
structure and building of the project.</p>
<section id="background-and-terminology">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Background and terminology</a><a class="headerlink" href="#background-and-terminology" title="Link to this heading">¶</a></h3>
<section id="modules">
<h4><a class="toc-backref" href="#id8" role="doc-backlink">Modules</a><a class="headerlink" href="#modules" title="Link to this heading">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">modules</span></code> refers to standard C++ modules
feature if it is not decorated by <code class="docutils literal notranslate"><span class="pre">Clang</span></code>.</p>
</section>
<section id="id2">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Clang Modules</a><a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<p>In this document, the term <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">Modules</span></code>/<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">modules</span></code> refer to Clang
c++ modules extension. These are also known as <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">header</span> <span class="pre">modules</span></code>,
<code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">module</span> <span class="pre">map</span> <span class="pre">modules</span></code> or <code class="docutils literal notranslate"><span class="pre">Clang</span> <span class="pre">c++</span> <span class="pre">modules</span></code>.</p>
</section>
<section id="module-and-module-unit">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">Module and module unit</a><a class="headerlink" href="#module-and-module-unit" title="Link to this heading">¶</a></h4>
<p>A module consists of one or more module units. A module unit is a special
translation unit. Every module unit must have a module declaration. The syntax
of the module declaration is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">export</span><span class="p">]</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">module_name</span><span class="p">[</span><span class="o">:</span><span class="n">partition_name</span><span class="p">];</span>
</pre></div>
</div>
<p>Terms enclosed in <code class="docutils literal notranslate"><span class="pre">[]</span></code> are optional. The syntax of <code class="docutils literal notranslate"><span class="pre">module_name</span></code> and <code class="docutils literal notranslate"><span class="pre">partition_name</span></code>
in regex form corresponds to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z_][a-zA-Z_0-9\.]*</span></code>. In particular, a literal dot <code class="docutils literal notranslate"><span class="pre">.</span></code>
in the name has no semantic meaning (e.g. implying a hierarchy).</p>
<p>In this document, module units are classified into:</p>
<ul class="simple">
<li><p>Primary module interface unit.</p></li>
<li><p>Module implementation unit.</p></li>
<li><p>Module interface partition unit.</p></li>
<li><p>Internal module partition unit.</p></li>
</ul>
<p>A primary module interface unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">module_name</span></code> here denotes the name of the
module. A module should have one and only one primary module interface unit.</p>
<p>A module implementation unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name;</span></code>. A module could have multiple module implementation
units with the same declaration.</p>
<p>A module interface partition unit is a module unit whose module declaration is
<code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>An internal module partition unit is a module unit whose module declaration
is <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">module_name:partition_name;</span></code>. The <code class="docutils literal notranslate"><span class="pre">partition_name</span></code> should be
unique within any given module.</p>
<p>In this document, we use the following umbrella terms:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>An <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> refers to either a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span> <span class="pre">partition</span> <span class="pre">unit</span></code>
or a <code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code>.</p></li>
</ul>
</section>
<section id="built-module-interface-file">
<h4><a class="toc-backref" href="#id11" role="doc-backlink">Built Module Interface file</a><a class="headerlink" href="#built-module-interface-file" title="Link to this heading">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">Built</span> <span class="pre">Module</span> <span class="pre">Interface</span> <span class="pre">file</span></code> stands for the precompiled result of an importable module unit.
It is also called the acronym <code class="docutils literal notranslate"><span class="pre">BMI</span></code> generally.</p>
</section>
<section id="global-module-fragment">
<h4><a class="toc-backref" href="#id12" role="doc-backlink">Global module fragment</a><a class="headerlink" href="#global-module-fragment" title="Link to this heading">¶</a></h4>
<p>In a module unit, the section from <code class="docutils literal notranslate"><span class="pre">module;</span></code> to the module declaration is called the global module fragment.</p>
</section>
</section>
<section id="how-to-build-projects-using-modules">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">How to build projects using modules</a><a class="headerlink" href="#how-to-build-projects-using-modules" title="Link to this heading">¶</a></h3>
<section id="quick-start">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Quick Start</a><a class="headerlink" href="#quick-start" title="Link to this heading">¶</a></h4>
<p>Let’s see a “hello world” example that uses modules.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we type:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Hello.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fmodule-file<span class="o">=</span><span class="nv">Hello</span><span class="o">=</span>Hello.pcm<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
<p>In this example, we make and use a simple module <code class="docutils literal notranslate"><span class="pre">Hello</span></code> which contains only a
primary module interface unit <code class="docutils literal notranslate"><span class="pre">Hello.cppm</span></code>.</p>
<p>Then let’s see a little bit more complex “hello world” example which uses the 4 kinds of module units.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">// interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">// impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we are able to compile the example by the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Precompiling<span class="w"> </span>the<span class="w"> </span>module
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>interface_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M-interface_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M-impl_part.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>Impl.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>Impl.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>user
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>User.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>User.o

<span class="gp"># </span>Compiling<span class="w"> </span>the<span class="w"> </span>module<span class="w"> </span>and<span class="w"> </span>linking<span class="w"> </span>it<span class="w"> </span>together
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-interface_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-interface_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M-impl_part.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M-impl_part.o
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.pcm<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M.o
<span class="gp">$ </span>clang++<span class="w"> </span>User.o<span class="w"> </span>M-interface_part.o<span class="w">  </span>M-impl_part.o<span class="w"> </span>M.o<span class="w"> </span>Impl.o<span class="w"> </span>-o<span class="w"> </span>a.out
</pre></div>
</div>
<p>We explain the options in the following sections.</p>
</section>
<section id="how-to-enable-standard-c-modules">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">How to enable standard C++ modules</a><a class="headerlink" href="#how-to-enable-standard-c-modules" title="Link to this heading">¶</a></h4>
<p>Currently, standard C++ modules are enabled automatically
if the language standard is <code class="docutils literal notranslate"><span class="pre">-std=c++20</span></code> or newer.</p>
</section>
<section id="how-to-produce-a-bmi">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">How to produce a BMI</a><a class="headerlink" href="#how-to-produce-a-bmi" title="Link to this heading">¶</a></h4>
<p>We can generate a BMI for an importable module unit by either <code class="docutils literal notranslate"><span class="pre">--precompile</span></code>
or <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> flags.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option generates the BMI as the output of the compilation and the output path
can be specified using the <code class="docutils literal notranslate"><span class="pre">-o</span></code> option.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> option generates the BMI as a by-product of the compilation.
If <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> is specified, the BMI will be emitted the specified location. Then if
<code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code> and <code class="docutils literal notranslate"><span class="pre">-c</span></code> are specified, the BMI will be emitted in the directory of the
output file with the name of the input file with the new extension <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>. Otherwise, the BMI
will be emitted in the working directory with the name of the input file with the new extension
<code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.</p>
<p>The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> is called two-phase compilation since it takes
2 steps to compile a source file to an object file. The style to generate BMIs by <code class="docutils literal notranslate"><span class="pre">-fmodule-output</span></code>
is called one-phase compilation respectively. The one-phase compilation model is simpler
for build systems to implement and the two-phase compilation has the potential to compile faster due
to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the
one-phase compilation model would need to compile them serially, whereas the two-phase compilation
model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long
time.</p>
</section>
<section id="file-name-requirement">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">File name requirement</a><a class="headerlink" href="#file-name-requirement" title="Link to this heading">¶</a></h4>
<p>The file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). The file name of a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>
should end with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> (or <code class="docutils literal notranslate"><span class="pre">.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxx</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++</span></code>).</p>
<p>The file name of BMIs should end with <code class="docutils literal notranslate"><span class="pre">.pcm</span></code>.
The file name of the BMI of a <code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name.pcm</span></code>.
The file name of BMIs of <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">partition</span> <span class="pre">unit</span></code> should be <code class="docutils literal notranslate"><span class="pre">module_name-partition_name.pcm</span></code>.</p>
<p>If the file names use different extensions, Clang may fail to build the module.
For example, if the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
then we can’t generate a BMI for the <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> by <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option
since <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> option now would only run preprocessor, which is equal to <cite>-E</cite> now.
If we want the filename of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> ends with other suffixes instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we could put <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">c++-module</span></code> in front of the file. For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Hello.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">Hello</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">hello</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the filename of the <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">interface</span></code> ends with <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> instead of <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>,
we can’t compile them by the original command lines. But we are still able to do it by:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-x<span class="w"> </span>c++-module<span class="w"> </span>Hello.cpp<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>Hello.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.<span class="w"> </span>Hello.pcm<span class="w"> </span>-o<span class="w"> </span>Hello.out
<span class="gp">$ </span>./Hello.out
<span class="go">Hello World!</span>
</pre></div>
</div>
</section>
<section id="module-name-requirement">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Module name requirement</a><a class="headerlink" href="#module-name-requirement" title="Link to this heading">¶</a></h4>
<p>[module.unit]p1 says:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>All module-names either beginning with an identifier consisting of std followed by zero
or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not
be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved
module-name is a reserved identifier, the module name is reserved for use by C++ implementations;
otherwise it is reserved for future standardization.
</pre></div>
</div>
<p>So all of the following name is not valid by default:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>std
std1
std.foo
__test
// and so on ...
</pre></div>
</div>
<p>If you still want to use the reserved module names for any reason, use
<code class="docutils literal notranslate"><span class="pre">-Wno-reserved-module-identifier</span></code> to suppress the warning.</p>
</section>
<section id="how-to-specify-the-dependent-bmis">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">How to specify the dependent BMIs</a><a class="headerlink" href="#how-to-specify-the-dependent-bmis" title="Link to this heading">¶</a></h4>
<p>There are 3 methods to specify the dependent BMIs:</p>
<ul class="simple">
<li><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> (Deprecated).</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p><code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code>.</p></li>
</ol>
</li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> tells the compiler the path where to search for dependent BMIs.
It may be used multiple times just like <code class="docutils literal notranslate"><span class="pre">-I</span></code> for specifying paths for header files. The look up rule here is:</p>
<ul class="simple">
<li><p>(1) When we import module M. The compiler would look up M.pcm in the directories specified
by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
<li><p>(2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the
directories specified by <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>.</p></li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI directly.
The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> tells the compiler to load the specified BMI
for the module specified by <code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code> when necessary. The main difference is that
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> will load the BMI eagerly, whereas
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will only load the BMI lazily, which is similar
with <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code>. The option <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> for named modules is deprecated
and is planning to be removed in future versions.</p>
<p>In case all <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> exist, the <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code> option
takes highest precedence and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> will take the second
highest precedence.</p>
<p>We need to specify all the dependent (directly and indirectly) BMIs.
See <a class="reference external" href="https://github.com/llvm/llvm-project/issues/62707">https://github.com/llvm/llvm-project/issues/62707</a> for detail.</p>
<p>When we compile a <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">implementation</span> <span class="pre">unit</span></code>, we must specify the BMI of the corresponding
<code class="docutils literal notranslate"><span class="pre">primary</span> <span class="pre">module</span> <span class="pre">interface</span> <span class="pre">unit</span></code>.
Since the language specification says a module implementation unit implicitly imports
the primary module interface unit.</p>
<blockquote>
<div><p>[module.unit]p8</p>
<p>A module-declaration that contains neither an export-keyword nor a module-partition implicitly
imports the primary module interface unit of the module as if by a module-import-declaration.</p>
</div></blockquote>
<p>All of the 3 options <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path=&lt;path/to/directory&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;path/to/BMI&gt;</span></code>
and <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=&lt;path/to/BMI&gt;</span></code> may occur multiple times.
For example, the command line to compile <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> in
the above example could be rewritten into:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-fmodule-file<span class="o">=</span>M:interface_part<span class="o">=</span>M-interface_part.pcm<span class="w"> </span>-fmodule-file<span class="o">=</span>M:impl_part<span class="o">=</span>M-impl_part.pcm<span class="w"> </span>-o<span class="w"> </span>M.pcm
</pre></div>
</div>
<p>When there are multiple <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> options for the same
<code class="docutils literal notranslate"><span class="pre">&lt;module-name&gt;</span></code>, the last <code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> will override the previous
<code class="docutils literal notranslate"><span class="pre">-fmodule-file=&lt;module-name&gt;=</span></code> options.</p>
<p><code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> is more convenient and <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> is faster since
it saves time for file lookup.</p>
</section>
<section id="remember-that-module-units-still-have-an-object-counterpart-to-the-bmi">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Remember that module units still have an object counterpart to the BMI</a><a class="headerlink" href="#remember-that-module-units-still-have-an-object-counterpart-to-the-bmi" title="Link to this heading">¶</a></h4>
<p>It is easy to forget to compile BMIs at first since we may envision module interfaces like headers.
However, this is not true.
Module units are translation units. We need to compile them to object files
and link the object files like the example shows.</p>
<p>For example, the traditional compilation processes for headers are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>src1.cpp -+&gt; clang++ src1.cpp --&gt; src1.o ---,
hdr1.h  --&#39;                                 +-&gt; clang++ src1.o src2.o -&gt;  executable
hdr2.h  --,                                 |
src2.cpp -+&gt; clang++ src2.cpp --&gt; src2.o ---&#39;
</pre></div>
</div>
<p>And the compilation process for module units are like:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>              src1.cpp ----------------------------------------+&gt; clang++ src1.cpp -------&gt; src1.o -,
(header unit) hdr1.h    -&gt; clang++ hdr1.h ...    -&gt; hdr1.pcm --&#39;                                    +-&gt; clang++ src1.o mod1.o src2.o -&gt;  executable
              mod1.cppm -&gt; clang++ mod1.cppm ... -&gt; mod1.pcm --,--&gt; clang++ mod1.pcm ... -&gt; mod1.o -+
              src2.cpp ----------------------------------------+&gt; clang++ src2.cpp -------&gt; src2.o -&#39;
</pre></div>
</div>
<p>As the diagrams show, we need to compile the BMI from module units to object files and link the object files.
(But we can’t do this for the BMI from header units. See the later section for the definition of header units)</p>
<p>If we want to create a module library, we can’t just ship the BMIs in an archive.
We must compile these BMIs(<code class="docutils literal notranslate"><span class="pre">*.pcm</span></code>) into object files(<code class="docutils literal notranslate"><span class="pre">*.o</span></code>) and add those object files to the archive instead.</p>
</section>
<section id="consistency-requirement">
<h4><a class="toc-backref" href="#id21" role="doc-backlink">Consistency Requirement</a><a class="headerlink" href="#consistency-requirement" title="Link to this heading">¶</a></h4>
<p>If we envision modules as a cache to speed up compilation, then - as with other caching techniques -
it is important to keep cache consistency.
So <strong>currently</strong> Clang will do very strict check for consistency.</p>
<section id="options-consistency">
<h5><a class="toc-backref" href="#id22" role="doc-backlink">Options consistency</a><a class="headerlink" href="#options-consistency" title="Link to this heading">¶</a></h5>
<p>The language option of module units and their non-module-unit users should be consistent.
The following example is not allowed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>

<span class="c1">// Use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++23<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>The compiler would reject the example due to the inconsistent language options.
Not all options are language options.
For example, the following example is allowed:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp"># </span>Inconsistent<span class="w"> </span>debugging<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-g<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Although the two examples have inconsistent optimization and debugging level, both of them are accepted.</p>
<p>Note that <strong>currently</strong> the compiler doesn’t consider inconsistent macro definition a problem. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp"># </span>Inconsistent<span class="w"> </span>optimization<span class="w"> </span>level.
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O3<span class="w"> </span>-DNDEBUG<span class="w"> </span>Use.cpp<span class="w"> </span>-fprebuilt-module-path<span class="o">=</span>.
</pre></div>
</div>
<p>Currently Clang would accept the above example. But it may produce surprising results if the
debugging code depends on consistent use of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> also in other translation units.</p>
</section>
<section id="definitions-consistency">
<h5><a class="toc-backref" href="#id23" role="doc-backlink">Definitions consistency</a><a class="headerlink" href="#definitions-consistency" title="Link to this heading">¶</a></h5>
<p>The C++ language defines that same declarations in different translation units should have
the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation
units don’t dependent on each other and the compiler itself can’t perform a strong
ODR violation check. With the introduction of modules, now the compiler have
the chance to perform ODR violations with language semantics across translation units.</p>
<p>However, in the practice, we found the existing ODR checking mechanism is not stable
enough. Many people suffers from the false positive ODR violation diagnostics, AKA,
the compiler are complaining two identical declarations have different definitions
incorrectly. Also the true positive ODR violations are rarely reported.
Also we learned that MSVC don’t perform ODR check for declarations in the global module
fragment.</p>
<p>So in order to get better user experience, save the time checking ODR and keep consistent
behavior with MSVC, we disabled the ODR check for the declarations in the global module
fragment by default. Users who want more strict check can still use the
<code class="docutils literal notranslate"><span class="pre">-Xclang</span> <span class="pre">-fno-skip-odr-check-in-gmf</span></code> flag to get the ODR check enabled. It is also
encouraged to report issues if users find false positive ODR violations or false negative ODR
violations with the flag enabled.</p>
</section>
</section>
</section>
<section id="abi-impacts">
<h3><a class="toc-backref" href="#id24" role="doc-backlink">ABI Impacts</a><a class="headerlink" href="#abi-impacts" title="Link to this heading">¶</a></h3>
<p>This section describes the new ABI changes brought by modules.</p>
<p>Only Itanium C++ ABI related change are mentioned</p>
<section id="mangling-names">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">Mangling Names</a><a class="headerlink" href="#mangling-names" title="Link to this heading">¶</a></h4>
<p>The declarations in a module unit which are not in the global module fragment have new linkage names.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> would be <code class="docutils literal notranslate"><span class="pre">_ZN2NSW1M3fooEv</span></code>.
This couldn’t be demangled by previous versions of the debugger or demangler.
As of LLVM 15.x, users can utilize <code class="docutils literal notranslate"><span class="pre">llvm-cxxfilt</span></code> to demangle this:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>llvm-cxxfilt<span class="w"> </span>_ZN2NSW1M3fooEv
</pre></div>
</div>
<p>The result would be <code class="docutils literal notranslate"><span class="pre">NS::foo&#64;M()</span></code>, which reads as <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> in module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
<p>The ABI implies that we can’t declare something in a module unit and define it in a non-module unit (or vice-versa),
as this would result in linking errors.</p>
<p>If we still want to implement declarations within the compatible ABI in module unit,
we can use the language-linkage specifier. Since the declarations in the language-linkage specifier
is attached to the global module fragments. For example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">NS</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the linkage name of <code class="docutils literal notranslate"><span class="pre">NS::foo()</span></code> will be <code class="docutils literal notranslate"><span class="pre">_ZN2NS3fooEv</span></code>.</p>
</section>
<section id="module-initializers">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">Module Initializers</a><a class="headerlink" href="#module-initializers" title="Link to this heading">¶</a></h4>
<p>All the importable module units are required to emit an initializer function.
The initializer function should contain calls to importing modules first and
all the dynamic-initializers in the current module unit then.</p>
<p>Translation units explicitly or implicitly importing named modules must call
the initializer functions of the imported named modules within the sequence of
the dynamic-initializers in the TU. Initializations of entities at namespace
scope are appearance-ordered. This (recursively) extends into imported modules
at the point of appearance of the import declaration.</p>
<p>It is allowed to omit calls to importing modules if it is known empty.</p>
<p>It is allowed to omit calls to importing modules for which is known to be called.</p>
</section>
</section>
<section id="reduced-bmi">
<h3><a class="toc-backref" href="#id27" role="doc-backlink">Reduced BMI</a><a class="headerlink" href="#reduced-bmi" title="Link to this heading">¶</a></h3>
<p>To support the 2 phase compilation model, Clang chose to put everything needed to
produce an object into the BMI. But every consumer of the BMI, except itself, doesn’t
need such informations. It makes the BMI to larger and so may introduce unnecessary
dependencies into the BMI. To mitigate the problem, we decided to reduce the information
contained in the BMI.</p>
<p>To be clear, we call the default BMI as Full BMI and the new introduced BMI as Reduced
BMI.</p>
<p>Users can use <code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code> flag to enable the Reduced BMI.</p>
<p>For one phase compilation model (CMake implements this model), with
<code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code>, the generated BMI will be Reduced BMI automatically.
(The output path of the BMI is specified by <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> as usual one phase
compilation model).</p>
<p>It is still possible to support Reduced BMI in two phase compilation model. With
<code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code>, <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> and <code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> specified,
the generated BMI specified by <code class="docutils literal notranslate"><span class="pre">-o</span></code> will be full BMI and the BMI specified by
<code class="docutils literal notranslate"><span class="pre">-fmodule-output=</span></code> will be Reduced BMI. The dependency graph may be:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>module-unit.cppm --&gt; module-unit.full.pcm -&gt; module-unit.o
                  |
                  -&gt; module-unit.reduced.pcm -&gt; consumer1.cpp
                                             -&gt; consumer2.cpp
                                             -&gt; ...
                                             -&gt; consumer_n.cpp
</pre></div>
</div>
<p>We don’t emit diagnostics if <code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code> is used with a non-module
unit. This design helps the end users of one phase compilation model to perform experiments
early without asking for the help of build systems. The users of build systems which supports
two phase compilation model still need helps from build systems.</p>
<p>Within Reduced BMI, we won’t write unreachable entities from GMF, definitions of non-inline
functions and non-inline variables. This may not be a transparent change.
<a class="reference external" href="https://eel.is/c++draft/module.global.frag#example-2">[module.global.frag]ex2</a> may be a good
example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">N</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">d</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">e</span><span class="p">();</span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">h</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// M.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_f</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">);</span><span class="w">             </span><span class="c1">// N::f is decl-reachable from use_f,</span>
<span class="w">                                </span><span class="c1">// N::e is indirectly decl-reachable from use_f</span>
<span class="w">                                </span><span class="c1">//   because it is decl-reachable from N::f, and</span>
<span class="w">                                </span><span class="c1">// N::d is decl-reachable from use_f</span>
<span class="w">                                </span><span class="c1">//   because it is decl-reachable from N::f</span>
<span class="w">                                </span><span class="c1">//   even though it is not used in this call</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_g</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">g</span><span class="p">((</span><span class="n">T</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w">           </span><span class="c1">// N::g is not decl-reachable from use_g</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">use_h</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">                       </span><span class="c1">// N::X, N, and :: are decl-reachable from use_h</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">((</span><span class="n">T</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">));</span><span class="w">           </span><span class="c1">// N::h is not decl-reachable from use_h, but</span>
<span class="w">                                </span><span class="c1">// N::h is decl-reachable from use_h&lt;int&gt;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_h</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// use_h&lt;int&gt; is decl-reachable from k, so</span>
<span class="w">  </span><span class="c1">// N::h is decl-reachable from k</span>

<span class="c1">// M-impl.cpp</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// OK</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_g</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// error: no viable function for call to g;</span>
<span class="w">                                </span><span class="c1">// g is not decl-reachable from purview of</span>
<span class="w">                                </span><span class="c1">// module M&#39;s interface, so is discarded</span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">use_h</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span><span class="w">           </span><span class="c1">// OK</span>
</pre></div>
</div>
<p>In the above example, the function definition of <code class="docutils literal notranslate"><span class="pre">N::g</span></code> is elided from the Reduced
BMI of <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code>. Then the use of <code class="docutils literal notranslate"><span class="pre">use_g&lt;int&gt;</span></code> in <code class="docutils literal notranslate"><span class="pre">M-impl.cpp</span></code> fails
to instantiate. For such issues, users can add references to <code class="docutils literal notranslate"><span class="pre">N::g</span></code> in the module purview
of <code class="docutils literal notranslate"><span class="pre">M.cppm</span></code> to make sure it is reachable, e.g., <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">N::g;</span></code>.</p>
<p>We think the Reduced BMI is the correct direction. But given it is a drastic change,
we’d like to make it experimental first to avoid breaking existing users. The roadmap
of Reduced BMI may be:</p>
<p>1. <code class="docutils literal notranslate"><span class="pre">-fexperimental-modules-reduced-bmi</span></code> is opt in for 1~2 releases. The period depends
on testing feedbacks.
2. We would announce Reduced BMI is not experimental and introduce <code class="docutils literal notranslate"><span class="pre">-fmodules-reduced-bmi</span></code>.
and suggest users to enable this mode. This may takes 1~2 releases too.
3. Finally we will enable this by default. When that time comes, the term BMI will refer to
the reduced BMI today and the Full BMI will only be meaningful to build systems which
loves to support two phase compilations.</p>
</section>
<section id="performance-tips">
<h3><a class="toc-backref" href="#id28" role="doc-backlink">Performance Tips</a><a class="headerlink" href="#performance-tips" title="Link to this heading">¶</a></h3>
<section id="reduce-duplications">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">Reduce duplications</a><a class="headerlink" href="#reduce-duplications" title="Link to this heading">¶</a></h4>
<p>While it is legal to have duplicated declarations in the global module fragments
of different module units, it is not free for clang to deal with the duplicated
declarations. In other word, for a translation unit, it will compile slower if the
translation unit itself and its importing module units contains a lot duplicated
declarations.</p>
<p>For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M-partA.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">big.header.h</span></code> is big enough and there are a lot of partitions,
the compilation of <code class="docutils literal notranslate"><span class="pre">use.cpp</span></code> may be slower than
the following style significantly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;big.header.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">m</span><span class="o">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="c1">// export the needed declarations</span>

<span class="c1">// M-partA.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M-partB.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// other partitions</span>
<span class="p">...</span>

<span class="c1">// M-partZ.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">big</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wrapper</span><span class="p">;</span>
<span class="p">...</span>

<span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partA</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partB</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">partZ</span><span class="p">;</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// use declarations from module M.</span>
</pre></div>
</div>
<p>The key part of the tip is to reduce the duplications from the text includes.</p>
</section>
</section>
<section id="ideas-for-converting-to-modules">
<h3><a class="toc-backref" href="#id30" role="doc-backlink">Ideas for converting to modules</a><a class="headerlink" href="#ideas-for-converting-to-modules" title="Link to this heading">¶</a></h3>
<p>For new libraries, we encourage them to use modules completely from day one if possible.
This will be pretty helpful to make the whole ecosystems to get ready.</p>
<p>For many existing libraries, it may be a breaking change to refactor themselves
into modules completely. So that many existing libraries need to provide headers and module
interfaces for a while to not break existing users.
Here we provide some ideas to ease the transition process for existing libraries.
<strong>Note that the this section is only about helping ideas instead of requirement from clang</strong>.</p>
<p>Let’s start with the case that there is no dependency or no dependent libraries providing
modules for your library.</p>
<section id="abi-non-breaking-styles">
<h4><a class="toc-backref" href="#id31" role="doc-backlink">ABI non-breaking styles</a><a class="headerlink" href="#abi-non-breaking-styles" title="Link to this heading">¶</a></h4>
<section id="export-using-style">
<h5><a class="toc-backref" href="#id32" role="doc-backlink">export-using style</a><a class="headerlink" href="#export-using-style" title="Link to this heading">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">your_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As the example shows, you need to include all the headers containing declarations needs
to be exported and <cite>using</cite> such declarations in an <cite>export</cite> block. Then, basically,
we’re done.</p>
</section>
<section id="export-extern-c-style">
<h5><a class="toc-backref" href="#id33" role="doc-backlink">export extern-C++ style</a><a class="headerlink" href="#export-extern-c-style" title="Link to this heading">¶</a></h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/B/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/Z/headers.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then in your headers (from <code class="docutils literal notranslate"><span class="pre">header_1.h</span></code> to <code class="docutils literal notranslate"><span class="pre">header_n.h</span></code>), you need to define the macro:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef IN_MODULE_INTERFACE</span>
<span class="cp">#define EXPORT export</span>
<span class="cp">#else</span>
<span class="cp">#define EXPORT</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>And you should put <code class="docutils literal notranslate"><span class="pre">EXPORT</span></code> to the beginning of the declarations you want to export.</p>
<p>Also it is suggested to refactor your headers to include thirdparty headers conditionally:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_x.h&quot;</span>

<span class="p">...</span>
</pre></div>
</div>
<p>This may be helpful to get better diagnostic messages if you forgot to update your module
interface unit file during maintaining.</p>
<p>The reasoning for the practice is that the declarations in the language linkage are considered
to be attached to the global module. So the ABI of your library in the modular version
wouldn’t change.</p>
<p>While this style looks not as convenient as the export-using style, it is easier to convert
to other styles.</p>
</section>
</section>
<section id="abi-breaking-style">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">ABI breaking style</a><a class="headerlink" href="#abi-breaking-style" title="Link to this heading">¶</a></h4>
<p>The term <code class="docutils literal notranslate"><span class="pre">ABI</span> <span class="pre">breaking</span></code> sounds terrifying generally. But you may want it here if you want
to force your users to introduce your library in a consistent way. E.g., they either include
your headers all the way or import your modules all the way.
The style prevents the users to include your headers and import your modules at the same time
in the same repo.</p>
<p>The pattern for ABI breaking style is similar with export extern-C++ style.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/B/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/Z/headers.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>

<span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#else </span><span class="c1">// the number of .cpp files in your project are a lot</span>
<span class="c1">// Using all the declarations from thirdparty libraries which are</span>
<span class="c1">// used in the .cpp files.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">third_party_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_n</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>(And add <cite>EXPORT</cite> and conditional include to the headers as suggested in the export
extern-C++ style section)</p>
<p>Remember that the ABI get changed and we need to compile our source files into the
new ABI format. This is the job of the additional part of the interface unit:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#else </span><span class="c1">// the number of .cpp files in your project are a lot</span>
<span class="c1">// Using all the declarations from thirdparty libraries which are</span>
<span class="c1">// used in the .cpp files.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">third_party_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">third_party_decl_used_in_cpp_n</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>In case the number of your source files are small, we may put everything in the private
module fragment directly. (it is suggested to add conditional include to the source
files too). But it will make the compilation of the module interface unit to be slow
when the number of the source files are not small enough.</p>
<p><strong>Note that the private module fragment can only be in the primary module interface unit
and the primary module interface unit containing private module fragment should be the only
module unit of the corresponding module.</strong></p>
<p>In that case, you need to convert your source files (.cpp files) to module implementation units:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef IN_MODULE_INTERFACE</span>
<span class="c1">// List all the includes here.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A/headers.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header.h&quot;</span>
<span class="cp">#endif</span>

<span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>

<span class="c1">// Following off should be unchanged.</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The module implementation unit will import the primary module implicitly.
We don’t include any headers in the module implementation units
here since we want to avoid duplicated declarations between translation units.
This is the reason why we add non-exported using declarations from the third
party libraries in the primary module interface unit.</p>
<p>And if you provide your library as <code class="docutils literal notranslate"><span class="pre">libyour_library.so</span></code>, you probably need to
provide a modular one <code class="docutils literal notranslate"><span class="pre">libyour_library_modules.so</span></code> since you changed the ABI.</p>
<section id="what-if-there-are-headers-only-inclued-by-the-source-files">
<h5><a class="toc-backref" href="#id35" role="doc-backlink">What if there are headers only inclued by the source files</a><a class="headerlink" href="#what-if-there-are-headers-only-inclued-by-the-source-files" title="Link to this heading">¶</a></h5>
<p>The above practice may be problematic if there are headers only included by the source
files. If you’re using private module fragment, you may solve the issue by including them
in the private module fragment. While it is OK to solve it by including the implementation
headers in the module purview if you’re using implementation module units, it may be
suboptimal since the primary module interface units now containing entities not belongs
to the interface.</p>
<p>If you’re a perfectionist, maybe you can improve it by introducing internal module partition unit.</p>
<p>The internal module partition unit is an importable module unit which is internal
to the module itself. The concept just meets the headers only included by the source files.</p>
<p>We don’t show code snippet since it may be too verbose or not good or not general.
But it may not be too hard if you can understand the points of the section.</p>
</section>
</section>
<section id="providing-a-header-to-skip-parsing-redundant-headers">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">Providing a header to skip parsing redundant headers</a><a class="headerlink" href="#providing-a-header-to-skip-parsing-redundant-headers" title="Link to this heading">¶</a></h4>
<p>It is a problem for clang to handle redeclarations between translation units.
Also there is a long standing issue in clang (<a class="reference external" href="https://github.com/llvm/llvm-project/issues/61465">problematic include after import</a>).
But even if the issue get fixed in clang someday, the users may still get slower compilation speed
and larger BMI size. So it is suggested to not include headers after importing the corresponding
library.</p>
<p>However, it is not easy for users if your library are included by other dependencies.</p>
<p>So the users may have to write codes like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot;</span>
<span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot;</span>
</pre></div>
</div>
<p>For such cases, we suggest the libraries providing modules and the headers at the same time
to provide a header to skip parsing all the headers in your libraries. So the users can
import your library as the following style to skip redundant handling:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;your_library_imported.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/A.h&quot;</span><span class="c1"> // #include &quot;your_library/a_header.h&quot; but got skipped</span>
</pre></div>
</div>
<p>The implementation of <code class="docutils literal notranslate"><span class="pre">your_library_imported.h</span></code> can be a set of controlling macros or
an overall controlling macro if you’re using <cite>#pragma once</cite>. So you can convert your
headers to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cp">#ifndef YOUR_LIBRARY_IMPORTED</span>
<span class="p">...</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>If the modules imported by your library provides such headers too, remember to add them to
your <code class="docutils literal notranslate"><span class="pre">your_library_imported.h</span></code> too.</p>
</section>
<section id="importing-modules">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">Importing modules</a><a class="headerlink" href="#importing-modules" title="Link to this heading">¶</a></h4>
<p>When there are dependent libraries providing modules, we suggest you to import that in
your module.</p>
<p>Most of the existing libraries would fall into this catagory once the std module gets available.</p>
<section id="all-dependent-libraries-providing-modules">
<h5><a class="toc-backref" href="#id38" role="doc-backlink">All dependent libraries providing modules</a><a class="headerlink" href="#all-dependent-libraries-providing-modules" title="Link to this heading">¶</a></h5>
<p>Life gets easier if all the dependent libraries providing modules.</p>
<p>You need to convert your headers to include thirdparty headers conditionally.</p>
<p>Then for export-using style:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">your_namespace</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_1</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">decl_n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For export extern-C++ style:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C++&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For ABI breaking style,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">your_library</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">modules_from_third_party</span><span class="p">;</span>
<span class="cp">#define IN_MODULE_INTERFACE</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_1.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_2.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;header_n.h&quot;</span>

<span class="cp">#if the number of .cpp files in your project are small</span>
<span class="nl">module</span><span class="w"> </span><span class="p">:</span><span class="k">private</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_1.cpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_2.cpp&quot;</span>
<span class="p">...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;source_n.cpp&quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>We don’t need the non-exported using declarations if we’re using implementation module
units now. We can import thirdparty modules directly in the implementation module
units.</p>
</section>
<section id="partial-dependent-libraries-providing-modules">
<h5><a class="toc-backref" href="#id39" role="doc-backlink">Partial dependent libraries providing modules</a><a class="headerlink" href="#partial-dependent-libraries-providing-modules" title="Link to this heading">¶</a></h5>
<p>In this case, we have to mix the use of <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">import</span></code> in the module of our
library. The key point here is still to remove duplicated declarations in translation
units as much as possible. If the imported modules provide headers to skip parsing their
headers, we should include that after the including. If the imported modules don’t provide
the headers, we can make it ourselves if we still want to optimize it.</p>
</section>
</section>
</section>
<section id="known-problems">
<h3><a class="toc-backref" href="#id40" role="doc-backlink">Known Problems</a><a class="headerlink" href="#known-problems" title="Link to this heading">¶</a></h3>
<p>The following describes issues in the current implementation of modules.
Please see <a class="reference external" href="https://github.com/llvm/llvm-project/labels/clang%3Amodules">https://github.com/llvm/llvm-project/labels/clang%3Amodules</a> for more issues
or file a new issue if you don’t find an existing one.
If you’re going to create a new issue for standard C++ modules,
please start the title with <code class="docutils literal notranslate"><span class="pre">[C++20]</span> <span class="pre">[Modules]</span></code> (or <code class="docutils literal notranslate"><span class="pre">[C++23]</span> <span class="pre">[Modules]</span></code>, etc)
and add the label <code class="docutils literal notranslate"><span class="pre">clang:modules</span></code> (if you have permissions for that).</p>
<p>For higher level support for proposals, you could visit <a class="reference external" href="https://clang.llvm.org/cxx_status.html">https://clang.llvm.org/cxx_status.html</a>.</p>
<section id="including-headers-after-import-is-problematic">
<h4><a class="toc-backref" href="#id41" role="doc-backlink">Including headers after import is problematic</a><a class="headerlink" href="#including-headers-after-import-is-problematic" title="Link to this heading">¶</a></h4>
<p>For example, the following example can be accept:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but it will get rejected if we reverse the order of <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// assume module &#39;foo&#39; contain the declarations from `&lt;iostream&gt;`</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Both of the above examples should be accepted.</p>
<p>This is a limitation in the implementation. In the first example,
the compiler will see and parse &lt;iostream&gt; first then the compiler will see the import.
So the ODR Checking and declarations merging will happen in the deserializer.
In the second example, the compiler will see the import first and the include second.
As a result, the ODR Checking and declarations merging will happen in the semantic analyzer.</p>
<p>So there is divergence in the implementation path. It might be understandable that why
the orders matter here in the case.
(Note that “understandable” is different from “makes sense”).</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/61465">https://github.com/llvm/llvm-project/issues/61465</a></p>
</section>
<section id="ignored-preferredname-attribute">
<h4><a class="toc-backref" href="#id42" role="doc-backlink">Ignored PreferredName Attribute</a><a class="headerlink" href="#ignored-preferredname-attribute" title="Link to this heading">¶</a></h4>
<p>Due to a tricky problem, when Clang writes BMIs, Clang will ignore the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> attribute, if any.
This implies that the <code class="docutils literal notranslate"><span class="pre">preferred_name</span></code> wouldn’t show in debugger or dumping.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56490">https://github.com/llvm/llvm-project/issues/56490</a></p>
</section>
<section id="don-t-emit-macros-about-module-declaration">
<h4><a class="toc-backref" href="#id43" role="doc-backlink">Don’t emit macros about module declaration</a><a class="headerlink" href="#don-t-emit-macros-about-module-declaration" title="Link to this heading">¶</a></h4>
<p>This is covered by P1857R3. We mention it again here since users may abuse it before we implement it.</p>
<p>Someone may want to write code which could be compiled both by modules or non-modules.
A direct idea would be use macros like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MODULE</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT_MODULE</span><span class="w"> </span><span class="n">MODULE_NAME</span><span class="p">;</span>
<span class="n">IMPORT</span><span class="w"> </span><span class="n">header_name</span>
<span class="n">EXPORT</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>So this file could be triggered like a module unit or a non-module unit depending on the definition
of some macros.
However, this kind of usage is forbidden by P1857R3 but we haven’t implemented P1857R3 yet.
This means that is possible to write illegal modules code now, and obviously this will stop working
once P1857R3 is implemented.
A simple suggestion would be “Don’t play macro tricks with module declarations”.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/56917">https://github.com/llvm/llvm-project/issues/56917</a></p>
</section>
<section id="in-consistent-filename-suffix-requirement-for-importable-module-units">
<h4><a class="toc-backref" href="#id44" role="doc-backlink">In consistent filename suffix requirement for importable module units</a><a class="headerlink" href="#in-consistent-filename-suffix-requirement-for-importable-module-units" title="Link to this heading">¶</a></h4>
<p>Currently, clang requires the file name of an <code class="docutils literal notranslate"><span class="pre">importable</span> <span class="pre">module</span> <span class="pre">unit</span></code> should end with <code class="docutils literal notranslate"><span class="pre">.cppm</span></code>
(or <code class="docutils literal notranslate"><span class="pre">.ccm</span></code>, <code class="docutils literal notranslate"><span class="pre">.cxxm</span></code>, <code class="docutils literal notranslate"><span class="pre">.c++m</span></code>). However, the behavior is inconsistent with other compilers.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/57416">https://github.com/llvm/llvm-project/issues/57416</a></p>
</section>
<section id="clang-cl-is-not-compatible-with-the-standard-c-modules">
<h4><a class="toc-backref" href="#id45" role="doc-backlink">clang-cl is not compatible with the standard C++ modules</a><a class="headerlink" href="#clang-cl-is-not-compatible-with-the-standard-c-modules" title="Link to this heading">¶</a></h4>
<p>Now we can’t use the <cite>/clang:-fmodule-file</cite> or <cite>/clang:-fprebuilt-module-path</cite> to specify
the BMI within <code class="docutils literal notranslate"><span class="pre">clang-cl.exe</span></code>.</p>
<p>This is tracked in: <a class="reference external" href="https://github.com/llvm/llvm-project/issues/64118">https://github.com/llvm/llvm-project/issues/64118</a></p>
</section>
<section id="false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type">
<h4><a class="toc-backref" href="#id46" role="doc-backlink">false positive ODR violation diagnostic due to using inconsistent qualified but the same type</a><a class="headerlink" href="#false-positive-odr-violation-diagnostic-due-to-using-inconsistent-qualified-but-the-same-type" title="Link to this heading">¶</a></h4>
<p>ODR violation is a pretty common issue when using modules.
Sometimes the program violated the One Definition Rule actually.
But sometimes it shows the compiler gives false positive diagnostics.</p>
<p>One often reported example is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// part.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="o">:</span><span class="n">part</span><span class="p">;</span>

<span class="c1">// repro.cc</span>
<span class="k">module</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">ns</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">fun</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">repro</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">part</span><span class="p">;</span>
</pre></div>
</div>
<p>Currently the compiler complains about the inconsistent definition of <cite>fun()</cite> in
2 module units. This is incorrect. Since both definitions of <cite>fun()</cite> has the same
spelling and <cite>T</cite> refers to the same type entity finally. So the program should be
fine.</p>
<p>This is tracked in <a class="reference external" href="https://github.com/llvm/llvm-project/issues/78850">https://github.com/llvm/llvm-project/issues/78850</a>.</p>
</section>
<section id="using-tu-local-entity-in-other-units">
<h4><a class="toc-backref" href="#id47" role="doc-backlink">Using TU-local entity in other units</a><a class="headerlink" href="#using-tu-local-entity-in-other-units" title="Link to this heading">¶</a></h4>
<p>Module units are translation units. So the entities which should only be local to the
module unit itself shouldn’t be used by other units in any means.</p>
<p>In the language side, to address the idea formally, the language specification defines
the concept of <code class="docutils literal notranslate"><span class="pre">TU-local</span></code> and <code class="docutils literal notranslate"><span class="pre">exposure</span></code> in
<a class="reference external" href="https://eel.is/c++draft/basic.link#14">basic.link/p14</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#15">basic.link/p15</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#16">basic.link/p16</a>,
<a class="reference external" href="https://eel.is/c++draft/basic.link#17">basic.link/p17</a> and
<a class="reference external" href="https://eel.is/c++draft/basic.link#18">basic.link/p18</a>.</p>
<p>However, the compiler doesn’t support these 2 ideas formally.
This results in unclear and confusing diagnostic messages.
And it is worse that the compiler may import TU-local entities to other units without any
diagnostics.</p>
<p>This is tracked in <a class="reference external" href="https://github.com/llvm/llvm-project/issues/78173">https://github.com/llvm/llvm-project/issues/78173</a>.</p>
</section>
</section>
</section>
<section id="header-units">
<h2><a class="toc-backref" href="#id48" role="doc-backlink">Header Units</a><a class="headerlink" href="#header-units" title="Link to this heading">¶</a></h2>
<section id="how-to-build-projects-using-header-unit">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">How to build projects using header unit</a><a class="headerlink" href="#how-to-build-projects-using-header-unit" title="Link to this heading">¶</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The user interfaces of header units is highly experimental. There are still
many unanswered question about how tools should interact with header units.
The user interfaces described here may change after we have progress on how
tools should support for header units.</p>
</div>
<section id="id3">
<h4><a class="toc-backref" href="#id50" role="doc-backlink">Quick Start</a><a class="headerlink" href="#id3" title="Link to this heading">¶</a></h4>
<p>For the following example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>we could compile it as</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>main.cpp
</pre></div>
</div>
</section>
<section id="how-to-produce-bmis">
<h4><a class="toc-backref" href="#id51" role="doc-backlink">How to produce BMIs</a><a class="headerlink" href="#how-to-produce-bmis" title="Link to this heading">¶</a></h4>
<p>Similar to named modules, we could use <code class="docutils literal notranslate"><span class="pre">--precompile</span></code> to produce the BMI.
But we need to specify that the input file is a header by <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>.</p>
<p>Also we could use <cite>-fmodule-header={user,system}</cite> option to produce the BMI for header units
which has suffix like <cite>.h</cite> or <cite>.hh</cite>.
The value of <cite>-fmodule-header</cite> means the user search path or the system search path.
The default value for <cite>-fmodule-header</cite> is <cite>user</cite>.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello World.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We could compile it as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="w"> </span>foo.h<span class="w"> </span>-o<span class="w"> </span>foo.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>foo.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
<p>For headers which don’t have a suffix, we need to pass <code class="docutils literal notranslate"><span class="pre">-xc++-header</span></code>
(or <code class="docutils literal notranslate"><span class="pre">-xc++-system-header</span></code> or <code class="docutils literal notranslate"><span class="pre">-xc++-user-header</span></code>) to mark it as a header.
For example,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// use.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-header<span class="o">=</span>system<span class="w"> </span>-xc++-header<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>use.cpp
</pre></div>
</div>
</section>
<section id="id4">
<h4><a class="toc-backref" href="#id52" role="doc-backlink">How to specify the dependent BMIs</a><a class="headerlink" href="#id4" title="Link to this heading">¶</a></h4>
<p>We could use <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to specify the BMIs, and this option may occur multiple times as well.</p>
<p>With the existing implementation <code class="docutils literal notranslate"><span class="pre">-fprebuilt-module-path</span></code> cannot be used for header units
(since they are nominally anonymous).
For header units, use  <code class="docutils literal notranslate"><span class="pre">-fmodule-file</span></code> to include the relevant PCM file for each header unit.</p>
<p>This is expect to be solved in future editions of the compiler either by the tooling finding and specifying
the -fmodule-file or by the use of a module-mapper that understands how to map the header name to their PCMs.</p>
</section>
<section id="don-t-compile-the-bmi">
<h4><a class="toc-backref" href="#id53" role="doc-backlink">Don’t compile the BMI</a><a class="headerlink" href="#don-t-compile-the-bmi" title="Link to this heading">¶</a></h4>
<p>Another difference with modules is that we can’t compile the BMI from a header unit.
For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp"># </span>This<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>allowed!
<span class="gp">$ </span>clang++<span class="w"> </span>iostream.pcm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>iostream.o
</pre></div>
</div>
<p>It makes sense due to the semantics of header units, which are just like headers.</p>
</section>
<section id="include-translation">
<h4><a class="toc-backref" href="#id54" role="doc-backlink">Include translation</a><a class="headerlink" href="#include-translation" title="Link to this heading">¶</a></h4>
<p>The C++ spec allows the vendors to convert <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">header-name</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">header-name;</span></code> when possible.
Currently, Clang would do this translation for the <code class="docutils literal notranslate"><span class="pre">#include</span></code> in the global module fragment.</p>
<p>For example, the following two examples are the same:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>with the following one:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-xc++-system-header<span class="w"> </span>--precompile<span class="w"> </span>iostream<span class="w"> </span>-o<span class="w"> </span>iostream.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fmodule-file<span class="o">=</span>iostream.pcm<span class="w"> </span>--precompile<span class="w"> </span>M.cppm<span class="w"> </span>-o<span class="w"> </span>M.cpp
</pre></div>
</div>
<p>In the latter example, the Clang could find the BMI for the <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code>
so it would try to replace the <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;iostream&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;iostream&gt;;</span></code> automatically.</p>
</section>
</section>
<section id="relationships-between-clang-modules">
<h3><a class="toc-backref" href="#id55" role="doc-backlink">Relationships between Clang modules</a><a class="headerlink" href="#relationships-between-clang-modules" title="Link to this heading">¶</a></h3>
<p>Header units have pretty similar semantics with Clang modules.
The semantics of both of them are like headers.</p>
<p>In fact, we could even “mimic” the sytle of header units by Clang modules:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">module</span><span class="w"> </span><span class="s">&quot;iostream&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">export</span><span class="w"> </span><span class="o">*</span>
<span class="w">  </span><span class="n">header</span><span class="w"> </span><span class="s">&quot;/path/to/libstdcxx/iostream&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fmodule-map-file<span class="o">=</span>.modulemap<span class="w"> </span>main.cpp
</pre></div>
</div>
<p>It would be simpler if we are using libcxx:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>main.cpp<span class="w"> </span>-fimplicit-modules<span class="w"> </span>-fimplicit-module-maps
</pre></div>
</div>
<p>Since there is already one
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in">module map</a>
in the source of libcxx.</p>
<p>Then immediately leads to the question: why don’t we implement header units through Clang header modules?</p>
<p>The main reason for this is that Clang modules have more semantics like hierarchy or
wrapping multiple headers together as a big module.
However, these things are not part of Standard C++ Header units,
and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior.</p>
<p>Another reason is that there are proposals to introduce module mappers to the C++ standard
(for example, <a class="reference external" href="https://wg21.link/p1184r2">https://wg21.link/p1184r2</a>).
If we decide to reuse Clang’s modulemap, we may get in trouble once we need to introduce another module mapper.</p>
<p>So the final answer for why we don’t reuse the interface of Clang modules for header units is that
there are some differences between header units and Clang modules and that ignoring those
differences now would likely become a problem in the future.</p>
</section>
</section>
<section id="discover-dependencies">
<h2><a class="toc-backref" href="#id56" role="doc-backlink">Discover Dependencies</a><a class="headerlink" href="#discover-dependencies" title="Link to this heading">¶</a></h2>
<p>Prior to modules, all the translation units can be compiled parallelly.
But it is not true for the module units. The presence of module units requires
us to compile the translation units in a (topological) order.</p>
<p>The clang-scan-deps scanner implemented
<a class="reference external" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html">P1689 paper</a>
to describe the order. Only named modules are supported now.</p>
<p>We need a compilation database to use clang-scan-deps. See
<a class="reference external" href="JSONCompilationDatabase.html">JSON Compilation Database Format Specification</a>
for example. Note that the <code class="docutils literal notranslate"><span class="pre">output</span></code> entry is necessary for clang-scan-deps
to scan P1689 format. Here is an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//--- M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Hello</span><span class="p">();</span>

<span class="c1">//--- interface_part.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">interface_part</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">();</span>

<span class="c1">//--- Impl.cpp</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- impl_part.cppm</span>
<span class="k">module</span><span class="p">;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="o">:</span><span class="n">impl_part</span><span class="p">;</span>
<span class="nl">import</span><span class="w"> </span><span class="p">:</span><span class="n">interface_part</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World.&quot;</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">World</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//--- User.cpp</span>
<span class="k">import</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="n">third_party_module</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Hello</span><span class="p">();</span>
<span class="w">  </span><span class="n">World</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here is the compilation database:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>[
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 M.cppm -c -o M.o&quot;,
    &quot;file&quot;: &quot;M.cppm&quot;,
    &quot;output&quot;: &quot;M.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 Impl.cpp -c -o Impl.o&quot;,
    &quot;file&quot;: &quot;Impl.cpp&quot;,
    &quot;output&quot;: &quot;Impl.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o&quot;,
    &quot;file&quot;: &quot;impl_part.cppm&quot;,
    &quot;output&quot;: &quot;impl_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o&quot;,
    &quot;file&quot;: &quot;interface_part.cppm&quot;,
    &quot;output&quot;: &quot;interface_part.o&quot;
},
{
    &quot;directory&quot;: &quot;.&quot;,
    &quot;command&quot;: &quot;&lt;path-to-compiler-executable&gt;/clang++ -std=c++20 User.cpp -c -o User.o&quot;,
    &quot;file&quot;: &quot;User.cpp&quot;,
    &quot;output&quot;: &quot;User.o&quot;
}
]
</pre></div>
</div>
<p>And we can get the dependency information in P1689 format by:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>-compilation-database<span class="w"> </span>P1689.json
</pre></div>
</div>
<p>And we will get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;Impl.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;M.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;User.o&quot;,
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M&quot;,
          &quot;source-path&quot;: &quot;M.cppm&quot;
        },
        {
          &quot;logical-name&quot;: &quot;third_party_module&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    },
    {
      &quot;primary-output&quot;: &quot;interface_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: true,
          &quot;logical-name&quot;: &quot;M:interface_part&quot;,
          &quot;source-path&quot;: &quot;interface_part.cppm&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>See the P1689 paper for the meaning of the fields.</p>
<p>And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,
the user can choose to get the dependency information per file. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o
</pre></div>
</div>
<p>And we’ll get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>{
  &quot;revision&quot;: 0,
  &quot;rules&quot;: [
    {
      &quot;primary-output&quot;: &quot;impl_part.o&quot;,
      &quot;provides&quot;: [
        {
          &quot;is-interface&quot;: false,
          &quot;logical-name&quot;: &quot;M:impl_part&quot;,
          &quot;source-path&quot;: &quot;impl_part.cppm&quot;
        }
      ],
      &quot;requires&quot;: [
        {
          &quot;logical-name&quot;: &quot;M:interface_part&quot;
        }
      ]
    }
  ],
  &quot;version&quot;: 1
}
</pre></div>
</div>
<p>In this way, we can pass the single command line options after the <code class="docutils literal notranslate"><span class="pre">--</span></code>.
Then clang-scan-deps will extract the necessary information from the options.
Note that we need to specify the path to the compiler executable instead of saying
<code class="docutils literal notranslate"><span class="pre">clang++</span></code> simply.</p>
<p>The users may want the scanner to get the transitional dependency information for headers.
Otherwise, the users have to scan twice for the project, once for headers and once for modules.
To address the requirement, clang-scan-deps will recognize the specified preprocessor options
in the given command line and generate the corresponding dependency information. For example,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>../bin/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>impl_part.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>impl_part.o<span class="w"> </span>-MD<span class="w"> </span>-MT<span class="w"> </span>impl_part.ddi<span class="w"> </span>-MF<span class="w"> </span>impl_part.dep
<span class="gp">$ </span>cat<span class="w"> </span>impl_part.dep
</pre></div>
</div>
<p>We will get:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>impl_part.ddi: \
  /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \
  /usr/include/bits/types/mbstate_t.h \
  /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \
  /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \
  /usr/include/bits/types/__locale_t.h \
  ...
</pre></div>
</div>
<p>When clang-scan-deps detects <code class="docutils literal notranslate"><span class="pre">-MF</span></code> option, clang-scan-deps will try to write the
dependency information for headers to the file specified by <code class="docutils literal notranslate"><span class="pre">-MF</span></code>.</p>
<section id="possible-issues-failed-to-find-system-headers">
<h3><a class="toc-backref" href="#id57" role="doc-backlink">Possible Issues: Failed to find system headers</a><a class="headerlink" href="#possible-issues-failed-to-find-system-headers" title="Link to this heading">¶</a></h3>
<p>In case the users encounter errors like <code class="docutils literal notranslate"><span class="pre">fatal</span> <span class="pre">error:</span> <span class="pre">'stddef.h'</span> <span class="pre">file</span> <span class="pre">not</span> <span class="pre">found</span></code>,
probably the specified <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code> refers to a symlink
instead a real binary. There are 4 potential solutions to the problem:</p>
<ul class="simple">
<li><p>(1) End users can resolve the issue by pointing the specified compiler executable to
the real binary instead of the symlink.</p></li>
<li><p>(2) End users can invoke <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span> <span class="pre">-print-resource-dir</span></code>
to get the corresponding resource directory for your compiler and add that directory
to the include search paths manually in the build scripts.</p></li>
<li><p>(3) Build systems that use a compilation database as the input for clang-scan-deps
scanner, the build system can add the flag <code class="docutils literal notranslate"><span class="pre">--resource-dir-recipe</span> <span class="pre">invoke-compiler</span></code> to
the clang-scan-deps scanner to calculate the resources directory dynamically.
The calculation happens only once for a unique <code class="docutils literal notranslate"><span class="pre">&lt;path-to-compiler-executable&gt;/clang++</span></code>.</p></li>
<li><p>(4) For build systems that invokes the clang-scan-deps scanner per file, repeatedly
calculating the resource directory may be inefficient. In such cases, the build
system can cache the resource directory by itself and pass <code class="docutils literal notranslate"><span class="pre">-resource-dir</span> <span class="pre">&lt;resource-dir&gt;</span></code>
explicitly in the command line options:</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-scan-deps<span class="w"> </span>-format<span class="o">=</span>p1689<span class="w"> </span>--<span class="w"> </span>&lt;path-to-compiler-executable&gt;/clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-resource-dir<span class="w"> </span>&lt;resource-dir&gt;<span class="w"> </span>mod.cppm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>mod.o
</pre></div>
</div>
</section>
</section>
<section id="import-modules-with-clang-repl">
<h2><a class="toc-backref" href="#id58" role="doc-backlink">Import modules with clang-repl</a><a class="headerlink" href="#import-modules-with-clang-repl" title="Link to this heading">¶</a></h2>
<p>We’re able to import C++20 named modules with clang-repl.</p>
<p>Let’s start with a simple example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// M.cppm</span>
<span class="k">export</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">M</span><span class="p">;</span>
<span class="k">export</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">Hello</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hello Interpreter for Modules!&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We still need to compile the named module in ahead.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang++<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>M.cppm<span class="w"> </span>--precompile<span class="w"> </span>-o<span class="w"> </span>M.pcm
<span class="gp">$ </span>clang++<span class="w"> </span>M.pcm<span class="w"> </span>-c<span class="w"> </span>-o<span class="w"> </span>M.o
<span class="gp">$ </span>clang++<span class="w"> </span>-shared<span class="w"> </span>M.o<span class="w"> </span>-o<span class="w"> </span>libM.so
</pre></div>
</div>
<p>Note that we need to compile the module unit into a dynamic library so that the clang-repl
can load the object files of the module units.</p>
<p>Then we are able to import module <code class="docutils literal notranslate"><span class="pre">M</span></code> in clang-repl.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>clang-repl<span class="w"> </span>-Xcc<span class="o">=</span>-std<span class="o">=</span>c++20<span class="w"> </span>-Xcc<span class="o">=</span>-fprebuilt-module-path<span class="o">=</span>.
<span class="gp"># </span>We<span class="w"> </span>need<span class="w"> </span>to<span class="w"> </span>load<span class="w"> </span>the<span class="w"> </span>dynamic<span class="w"> </span>library<span class="w"> </span>first<span class="w"> </span>before<span class="w"> </span>importing<span class="w"> </span>the<span class="w"> </span>modules.
<span class="go">clang-repl&gt; %lib libM.so</span>
<span class="go">clang-repl&gt; import M;</span>
<span class="go">clang-repl&gt; extern &quot;C&quot; int printf(const char *, ...);</span>
<span class="go">clang-repl&gt; printf(&quot;%s\n&quot;, Hello());</span>
<span class="go">Hello Interpreter for Modules!</span>
<span class="go">clang-repl&gt; %quit</span>
</pre></div>
</div>
</section>
<section id="possible-questions">
<h2><a class="toc-backref" href="#id59" role="doc-backlink">Possible Questions</a><a class="headerlink" href="#possible-questions" title="Link to this heading">¶</a></h2>
<section id="how-modules-speed-up-compilation">
<h3><a class="toc-backref" href="#id60" role="doc-backlink">How modules speed up compilation</a><a class="headerlink" href="#how-modules-speed-up-compilation" title="Link to this heading">¶</a></h3>
<p>A classic theory for the reason why modules speed up the compilation is:
if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> headers and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files and each header is included by each source file,
then the complexity of the compilation is <code class="docutils literal notranslate"><span class="pre">O(n*m)</span></code>;
But if there are <code class="docutils literal notranslate"><span class="pre">n</span></code> module interfaces and <code class="docutils literal notranslate"><span class="pre">m</span></code> source files, the complexity of the compilation is
<code class="docutils literal notranslate"><span class="pre">O(n+m)</span></code>. So, using modules would be a big win when scaling.
In a simpler word, we could get rid of many redundant compilations by using modules.</p>
<p>Roughly, this theory is correct. But the problem is that it is too rough.
The behavior depends on the optimization level, as we will illustrate below.</p>
<p>First is <code class="docutils literal notranslate"><span class="pre">O0</span></code>. The compilation process is described in the following graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------------frontend----------┼-------------middle end----------------┼----backend----┤
│                               │                                       │               │
└---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘

┌---------------------------------------------------------------------------------------┐
|                                                                                       │
|                                     source file                                       │
|                                                                                       │
└---------------------------------------------------------------------------------------┘

            ┌--------┐
            │        │
            │imported│
            │        │
            │  code  │
            │        │
            └--------┘
</pre></div>
</div>
<p>Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the
whole pipeline.
But the imported code would only get involved in semantic analysis, which is mainly about name lookup,
overload resolution and template instantiation.
All of these processes are fast relative to the whole compilation process.
More importantly, the imported code only needs to be processed once in frontend code generation,
as well as the whole middle end and backend.
So we could get a big win for the compilation time in O0.</p>
<p>But with optimizations, things are different:</p>
<p>(we omit <code class="docutils literal notranslate"><span class="pre">code</span> <span class="pre">generation</span></code> part for each end due to the limited space)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤
│                           │                                               │                   │
└--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘

┌-----------------------------------------------------------------------------------------------┐
│                                                                                               │
│                                         source file                                           │
│                                                                                               │
└-----------------------------------------------------------------------------------------------┘
              ┌---------------------------------------┐
              │                                       │
              │                                       │
              │            imported code              │
              │                                       │
              │                                       │
              └---------------------------------------┘
</pre></div>
</div>
<p>It would be very unfortunate if we end up with worse performance after using modules.
The main concern is that when we compile a source file, the compiler needs to see the function body
of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining
in practice) to optimize functions in current source file with the help of the information provided by
the imported module units.
In other words, the imported code would be processed again and again in importee units
by optimizations (including IPO itself).
The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.
So from this perspective, we might not be able to get the improvements described in the theory.
But we could still save the time for optimizations after IPO and the whole backend.</p>
<p>Overall, at <code class="docutils literal notranslate"><span class="pre">O0</span></code> the implementations of functions defined in a module will not impact module users,
but at higher optimization levels the definitions of such functions are provided to user compilations for the
purposes of optimization (but definitions of these functions are still not included in the use’s object file)-
this means the build speedup at higher optimization levels may be lower than expected given <code class="docutils literal notranslate"><span class="pre">O0</span></code> experience,
but does provide by more optimization opportunities.</p>
</section>
<section id="interoperability-with-clang-modules">
<h3><a class="toc-backref" href="#id61" role="doc-backlink">Interoperability with Clang Modules</a><a class="headerlink" href="#interoperability-with-clang-modules" title="Link to this heading">¶</a></h3>
<p>We <strong>wish</strong> to support clang modules and standard c++ modules at the same time,
but the mixed using form is not well used/tested yet.</p>
<p>Please file new github issues as you find interoperability problems.</p>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="SourceBasedCodeCoverage.html">Source-based Code Coverage</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="Modules.html">Modules</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2007-2024, The Clang Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>