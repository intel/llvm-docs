<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Behavior for optional kernel features &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Parallel For Range Rounding" href="ParallelForRangeRounding.html" />
    <link rel="prev" title="Dynamic linking of device code" href="SharedLibraries.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>Behavior for optional kernel features</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="SharedLibraries.html">Dynamic linking of device code</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ParallelForRangeRounding.html">Parallel For Range Rounding</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="behavior-for-optional-kernel-features">
<h1>Behavior for optional kernel features<a class="headerlink" href="#behavior-for-optional-kernel-features" title="Link to this heading">¶</a></h1>
<p>This design document describes the changes that are needed in DPC++ in order to
conform to the SYCL 2020 specification regarding the behavior of applications
that use optional kernel features.  An optional kernel feature is any feature
that is supported by some devices and not by others.  For example, not all
devices support 16-bit floating point operations, so the <code class="docutils literal notranslate"><span class="pre">sycl::half</span></code> data type
is an optional kernel feature.  Some DPC++ extensions like AMX are also
optional kernel features.</p>
<p>The requirements for this design come mostly from the SYCL 2020 specification
<a class="reference external" href="https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:optional-kernel-features">section 5.7 “Optional kernel features”</a> but they also encompass the C++
attribute <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> that is described in <a class="reference external" href="https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:kernel.attributes">section 5.8.1 “Kernel
attributes”</a> and <a class="reference external" href="https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_device_function_attributes">section 5.8.2 “Device function attributes”</a>.</p>
<section id="definition-of-terms">
<h2>Definition of terms<a class="headerlink" href="#definition-of-terms" title="Link to this heading">¶</a></h2>
<section id="a-kernel-s-static-call-graph">
<h3>A kernel’s static call graph<a class="headerlink" href="#a-kernel-s-static-call-graph" title="Link to this heading">¶</a></h3>
<p>The term “static call graph” of a kernel means the set of all functions that
a kernel may call, including functions that are called transitively from other
functions.  In standard SYCL, device code is not allowed to contain function
pointers, virtual functions, or indirect function calls.  It is therefore easy
to compute the static call graph of a kernel.  By starting at the kernel
function itself (e.g.  the function passed to <code class="docutils literal notranslate"><span class="pre">parallel_for</span></code>), the compiler can
identify all functions called by that function, then it can find all functions
called by those functions, etc.  Depending on the tool which does the analysis,
the “static call graph” could include only those functions that reside in the
same translation unit as the kernel, or it could include all functions that
reside in the same executable image (or shared library) as the kernel.  In the
sections below, we try to make the distinction clear whenever we refer to a
kernel’s static call graph.</p>
<p>We are contemplating a DPC++ extension that would allow some limited use of
function pointers in device code.  This feature is not yet fully defined or
supported.  We expect that the semantics of this feature will include some way
for the compiler to deduce a limited set of possible targets for each indirect
function call.  Therefore, it is still possible for the compiler to construct a
“static call graph” for each kernel, the only difference is that each call site
now adds a set of possible target functions to a kernel’s static call graph.
The details about how this will work are expected to be included in the DPC++
extension specification that enables indirect function calls.</p>
</section>
<section id="an-exported-device-function">
<h3>An exported device function<a class="headerlink" href="#an-exported-device-function" title="Link to this heading">¶</a></h3>
<p>The term “exported device function” means a device function that is exported
from a shared library as defined by <a class="reference internal" href="SharedLibraries.html"><span class="std std-doc">Device Code Dynamic Linking</span></a>.</p>
</section>
<section id="the-fe-compiler">
<h3>The FE compiler<a class="headerlink" href="#the-fe-compiler" title="Link to this heading">¶</a></h3>
<p>The term “FE compiler” refers to the entire DPC++ compiler chain that runs
when the user executes the <code class="docutils literal notranslate"><span class="pre">clang++</span></code> command.  This includes the clang
front-end itself, all passes over LLVM IR, the post-link tool, and any AOT
compilation phases (when the user compiles in AOT mode).  The FE compiler does
not include the JIT compiler which translates SPIR-V (or another IL format)
into native code when the application executes.</p>
</section>
</section>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<p>There are several categories of requirements covered by this design.  Each of
these is described in more detail in the sections that follow:</p>
<ul class="simple">
<li><p>The FE compiler must issue a diagnostic in some cases when a kernel or device
function uses an optional feature.  However, the FE compiler must <strong>not</strong>
generate a diagnostic in other cases.</p></li>
<li><p>The runtime must raise an exception when a kernel using optional features
is submitted to a device that does not support those features.  This
exception must be raised synchronously from the kernel invocation command
(e.g. <code class="docutils literal notranslate"><span class="pre">parallel_for()</span></code>).</p></li>
<li><p>The runtime must not raise an exception (or otherwise fail) merely due to
speculative compilation of a kernel for a device, when the application does
not specifically submit the kernel to that device.</p></li>
</ul>
<section id="diagnostics-from-the-fe-compiler">
<h3>Diagnostics from the FE compiler<a class="headerlink" href="#diagnostics-from-the-fe-compiler" title="Link to this heading">¶</a></h3>
<p>In general, the FE compiler does not know which kernels the application will
submit to which devices.  Therefore, the FE compiler does not generally know
which optional features a kernel can legally use.  Thus, in general, the FE
compiler must not issue any diagnostic simply because a kernel uses an optional
feature.</p>
<p>The only exception to this rule occurs when the application uses the C++
attribute <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>.  When the application decorates a kernel or
device function with this attribute, it is an assertion that the kernel or
device function is allowed to use only those optional features which are listed
by the attribute.  Therefore, the FE compiler must issue a diagnostic if the
kernel or device function uses any other optional kernel features.</p>
<p>The SYCL 2020 specification only mandates this diagnostic when a kernel or
device function that is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> uses an
optional kernel feature (not listed in the attribute), <strong>and</strong> when that use is
in the kernel’s static call graph as computed for the translation unit that
contains the kernel function.  Thus, the compiler is not required to issue a
diagnostic if the use is in a <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function that is defined in
another translation unit.</p>
<p>Note that this behavior does not change when the compiler runs in AOT mode.
Even if the user specifies a target device via “-fsycl-targets”, that does not
necessarily mean that the user expects all the code in the application to be
runnable on that device.  Consider an application that uses some middleware
library, where the library’s header contains kernels optimized for different
devices.  An application should be able to compile in AOT mode with this
library without getting errors.  Therefore the AOT compiler must not fail
simply because the middleware header contains device code for devices that
are not being compiled for.</p>
</section>
<section id="runtime-exception-if-device-doesn-t-support-feature">
<h3>Runtime exception if device doesn’t support feature<a class="headerlink" href="#runtime-exception-if-device-doesn-t-support-feature" title="Link to this heading">¶</a></h3>
<p>When the application submits a kernel to a device via one of the kernel
invocation commands (e.g. <code class="docutils literal notranslate"><span class="pre">parallel_for()</span></code>), the runtime must check if the
kernel uses optional features that are not supported on that device.  If the
kernel uses an unsupported feature, the runtime must throw a synchronous
<code class="docutils literal notranslate"><span class="pre">errc::kernel_not_supported</span></code> exception.</p>
<p>When doing these checks, the runtime must consider all uses of optional
features in the kernel’s static call graph, regardless of whether those uses
are in the same translation unit as the kernel and regardless of whether those
uses come from device code in a shared library.</p>
<p>This exception, however, is only required for features that are exposed via a
C++ type or function.  Examples of this include <code class="docutils literal notranslate"><span class="pre">sycl::half</span></code> or instantiating
<code class="docutils literal notranslate"><span class="pre">sycl::atomic_ref</span></code> for a 64-bit type.  If the kernel relies on optional
features that are more “notional” such as sub-group independent forward
progress (<code class="docutils literal notranslate"><span class="pre">info::device::sub_group_independent_forward_progress</span></code>), no exception
is required.</p>
<p>To further clarify, this exception must be thrown in the following
circumstances:</p>
<ul class="simple">
<li><p>For a kernel that is not decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>, the
exception must be thrown if the kernel uses a feature that the device does
not support.</p></li>
<li><p>For a kernel that is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>, the exception
must be thrown if the device does not have the aspects listed in that
attribute.  Note that the exception must be thrown even if the kernel does
not actually use a feature corresponding to the aspect, and it must be
thrown even if the aspect does not correspond to any optional feature.</p></li>
<li><p>For a kernel that is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>, the FE compiler
will mostly check (at compile time) whether the kernel uses any features that
are not listed in the attribute.  However, this check only results in a
warning, so the runtime is still responsible for throwing the exception if
any of the functions called by the kernel uses an optional feature that the
device does not support.</p></li>
<li><p>For a kernel that is decorated with the <code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_work_group_size(W)]]</span></code>
or <code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_sub_group_size(S)]]</span></code> attribute, the exception must be thrown
if the device does not support the work group size <code class="docutils literal notranslate"><span class="pre">W</span></code> or the sub-group size
<code class="docutils literal notranslate"><span class="pre">S</span></code>.</p></li>
</ul>
<p>Note that the exception must be thrown synchronously, not delayed and thrown on
the queue’s asynchronous handler.</p>
</section>
<section id="no-runtime-exception-for-speculative-compilation">
<h3>No runtime exception for speculative compilation<a class="headerlink" href="#no-runtime-exception-for-speculative-compilation" title="Link to this heading">¶</a></h3>
<p>It is currently common for the runtime to speculatively compile some kernels.
For example, DPC++ may bundle all kernels from the same translation unit
together into a single device image.  When the application submits one kernel
<em>K</em> to a device <em>D</em>, the runtime actually compiles all kernels in <em>K</em>’s device
image for device <em>D</em>.  Let’s assume in this example that the kernel <em>K</em> uses
only features that are supported by <em>D</em>.  It would be illegal for the runtime
to throw an exception in such a case just because some other kernel in the same
device image uses a feature that is not supported by device <em>D</em>.</p>
</section>
<section id="compiler-switch-to-diagnose-optional-feature-usage">
<h3>Compiler switch to diagnose optional feature usage<a class="headerlink" href="#compiler-switch-to-diagnose-optional-feature-usage" title="Link to this heading">¶</a></h3>
<p>As noted above, the FE compiler does not generally know which kernels will be
submitted to which devices, and this limits the errors that the FE compiler can
diagnose.  However, some users may know that all code in their application will
run on some specific target device, and these users would prefer a compiler
diagnostic if any kernel uses a feature that is not compatible with that
device.  This is particularly true for FPGA users who always AOT compile their
application for a specific FPGA device.</p>
<p>To satisfy this use case, this design adds a new compile-time switch
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> which is an assertion by the user that all device code
in the translation unit is expected to be runnable on the specified target
device(s).</p>
<p>The definition of this switch is:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets=target,target...</span></code></p>
<p>This switch may be passed on the compilation line as an assertion by the
user that all device code in the source file (translation unit) is expected
to be runnable on the target devices that are listed, and it will not be run
on any other target device.  The compiler checks whether the device code uses
any features that are incompatible with any of the listed devices.  If so,
the compiler raises a diagnostic.</p>
<p>This switch may be used either with or without the <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code> switch.
When used without <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code>, the <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> switch checks
for kernels that use features that are not compatible with the listed target
devices, but those kernels are still just-in-time (JIT) compiled when the
application runs.  When used with <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code>, the compiler does the
same checks, but it also compiles the kernels ahead-of-time (AOT).  When both
switches are used together, it is typical to pass the same set of target
devices to both switches.</p>
</div></blockquote>
<p>In order for readers of this design document to better understand the
relationship between the target list in <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> vs. the target
list in <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code>, consider a weird case where both switches are
specified with different target lists.  If <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets=X</span></code> is
specified on the command line, the compiler checks that all device code is
compatible with all targets in list <code class="docutils literal notranslate"><span class="pre">X</span></code>, so it issues a diagnostic if any of
that code uses a feature that is incompatible with any of those targets.  As
described below, this command line switch also provides certain guarantees
about how kernels in the translation unit are bundled together into device
images.</p>
<p>Let’s further assume in our example that the <code class="docutils literal notranslate"><span class="pre">-fsycl-targets=Y</span></code> is also
specified on the command line.  This causes the compiler to AOT compile all
<em>eligible</em> device code for each target in <code class="docutils literal notranslate"><span class="pre">Y</span></code>.  However, the
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> switch indicates that the device code is only eligible
to run on targets in the <code class="docutils literal notranslate"><span class="pre">X</span></code> list.  As a result, the <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code> switch
will only AOT compile for the devices that are present in both lists (i.e. the
intersection of the two sets <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code>).</p>
</section>
<section id="must-preserve-ability-to-precisely-control-device-images">
<h3>Must preserve ability to precisely control device images<a class="headerlink" href="#must-preserve-ability-to-precisely-control-device-images" title="Link to this heading">¶</a></h3>
<p>FPGA users need the ability to control how kernels are bundled together into
device images because an FPGA device is reprogrammed with the contents of a
single device image.  Most FPGA users want all kernels in their application to
be bundled into a single device image, so that they can all exist on the same
FPGA device at the same time.  Advanced users may want to partition some
kernels into one device image and other kernels into another device image,
allowing kernels to be programmed on two (or more) different FPGA devices.</p>
<p>FPGA users are accustomed to doing this via the <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code>
link-time switch.  However, not all users agree on the semantic of this switch.
Whereas FPGA users see this switch as a hard requirement that controls the
way kernels are bundled into device images, other users see this switch as an
optimization that controls JIT-time overhead.  These users do not expect
<code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> to ever produce incorrect code which could lead to
an exception at runtime.</p>
<p>To satisfy both users, the meaning of <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> is changed as
follows.  When used without <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, it specifies a minimum
granularity of splitting, but the implementation may perform additional device
code splits in order to preserve the correctness of the code.</p>
<p>However, when <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> is used in conjunction with
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, we can guarantee that additional device code splits are
not needed for correctness.  Thus, when both switches are specified together,
the <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> provides the precise control over bundling of
kernels into device images that FPGA users expect.</p>
<p>Note that these switches are useful even for non-FPGA users.  For example,
non-FPGA users may want to use the <code class="docutils literal notranslate"><span class="pre">device_global</span></code> property
<a class="reference download internal" download="" href="../_downloads/ba88595f12ef1a14d94e3dc26fa352c0/sycl_ext_oneapi_device_global.asciidoc"><span class="xref download myst"><code class="docutils literal notranslate"><span class="pre">device_image_scope</span></code></span></a>, which requires even non-FPGA users to have precise
control over the way kernels are bundled into device images.</p>
<p>The new definition of <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> is as follows:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split[=value]</span></code></p>
<p>This switch helps optimize the JIT time performance by adjusting the way
kernels are grouped together into device images.  The value <code class="docutils literal notranslate"><span class="pre">off</span></code> places most
kernels into one large device image, which avoids some duplicated code but
results in all kernels being JIT compiled whenever one of them is submitted
to a device.  The values <code class="docutils literal notranslate"><span class="pre">per_kernel</span></code> and <code class="docutils literal notranslate"><span class="pre">per_source</span></code> cause kernels to be
split into multiple device images, which can avoid JIT overhead for kernels
that are never submitted to a device.  However, these values can also cause
common functions to be duplicated if they are shared by kernels in two or
more device images.</p>
<p>Normally, this switch specifies only a minimum granularity for device code
splitting, and DPC++ may perform additional device code splits beyond those
that are requested.  However, translation units that are compiled with
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> have stricter guarantees.  All kernels from
translation units that are compiled with the same set of targets are first
logically bundled into the same device image.  Kernels in each of these
device images are then split exactly as specified by
<code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code>.  For example, when source files are compiled with
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets=X</span></code> and then linked with <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split=off</span></code>,
all kernels in those source files are guaranteed to be grouped into a single
device image.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> can be any one of the following:</p>
<p><code class="docutils literal notranslate"><span class="pre">per_kernel</span></code>: Creates a separate device image for each SYCL kernel.  Each
device image will contain a kernel and all its dependencies, such as called
functions and used variables.</p>
<p><code class="docutils literal notranslate"><span class="pre">per_source</span></code>: Creates a separate device image for each source (translation
unit).  Each device image will contain a collection of kernels grouped on a
per-source basis and all their dependencies, such as all used variables and
called functions, including the <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> macro-marked functions from
other translation units.</p>
<p><code class="docutils literal notranslate"><span class="pre">off</span></code>: Creates a single device image for all kernels.</p>
<p><code class="docutils literal notranslate"><span class="pre">auto</span></code>: The compiler will use a heuristic to select the best way of splitting
device code.  This is the same as specifying <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> with
no value.</p>
</div></blockquote>
</section>
</section>
<section id="design">
<h2>Design<a class="headerlink" href="#design" title="Link to this heading">¶</a></h2>
<section id="changes-to-dpc-headers">
<h3>Changes to DPC++ headers<a class="headerlink" href="#changes-to-dpc-headers" title="Link to this heading">¶</a></h3>
<p>With the exception of the <code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_work_group_size()]]</span></code> and
<code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_sub_group_size()]]</span></code> attributes, all kernel optional features
are associated with some device aspect.  For example, the <code class="docutils literal notranslate"><span class="pre">sycl::half</span></code> type
is an optional feature which is only supported on devices that have the
<code class="docutils literal notranslate"><span class="pre">aspect::fp16</span></code> aspect.  We can therefore use device aspects as a way to
describe the set of optional features that a kernel uses (with the exception
of the required work-group or sub-group size).</p>
<p>As we will see later, it is helpful to decorate all APIs in DPC++ headers that
correspond to optional kernel features with a C++ attribute that identifies the
associated aspect.  We cannot use the <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> attribute for
this purpose, though, because that attribute is allowed only for functions.
Instead, we invent a new internal attribute <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code>
that can be used to decorate both functions and types.  This attribute is not
documented for user code; instead it is an internal implementation detail of
DPC++.</p>
<p>Like all use of C++ attributes in the DPC++ headers, the headers should spell
the attribute using initial and trailing double underscores
(<code class="docutils literal notranslate"><span class="pre">[[__sycl_detail__::__uses_aspects__()]]</span></code>).  We show that form in the code
samples below, but this design document uses the form without the underbars
elsewhere.  Both forms refer to the same attribute.</p>
<p>To illustrate, the type <code class="docutils literal notranslate"><span class="pre">sycl::half</span></code> is an optional feature whose associated
aspect is <code class="docutils literal notranslate"><span class="pre">aspect::fp16</span></code>.  We therefore decorate the declaration like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>namespace sycl::detail::half_impl {

class [[__sycl_detail__::__uses_aspects__(aspect::fp16)]] half {
/* ... */
};

} // namespace sycl::detail::half_impl;
</pre></div>
</div>
<p>This attribute is also used to decorate function declarations that correspond
to optional features.  Illustrating a hypothetical AMX extension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">__sycl_detail__</span><span class="p">::</span><span class="n">__uses_aspects__</span><span class="p">(</span><span class="n">aspect</span><span class="p">::</span><span class="n">ext_intel_amx</span><span class="p">)]]</span>
<span class="n">void</span> <span class="n">amx_multiply</span><span class="p">();</span>
</pre></div>
</div>
<p>This attribute can also be used to decorate class templates where only certain
instantiations correspond to optional features.  See <a class="reference internal" href="#appendix-adding-an-attribute-to-8-byte-atomic-ref">“Appendix: Adding an
attribute to 8-byte <code class="docutils literal notranslate"><span class="pre">atomic_ref</span></code>”</a> for an illustration of how this attribute
can be used in conjunction with partial specialization to mark only certain
instantiations of <code class="docutils literal notranslate"><span class="pre">sycl::atomic_ref</span></code> as an optional feature.</p>
<p>Because the <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attribute is only needed for the
device compiler, the headers should protect it with
<code class="docutils literal notranslate"><span class="pre">#ifdef</span> <span class="pre">__SYCL_DEVICE_ONLY__</span></code>.  This avoids warnings when our headers are
compiled with a third-party host compiler.</p>
<p>Although the examples above show only a single aspect parameter to the
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attribute, this attribute should support a
list of aspects, similar to the <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> attribute.  This will
allow us to support future features that depend on a conjunction of aspects
(e.g. a feature that does atomic operations on 64-bit floating point values
might be decorated with
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects(aspect::fp64,</span> <span class="pre">aspect::atomic64)]]</span></code>).</p>
<p>Unfortunately, the fundamental type <code class="docutils literal notranslate"><span class="pre">double</span></code> is also an optional kernel
feature.  Since there is no type definition for <code class="docutils literal notranslate"><span class="pre">double</span></code> in the headers, there
is no convenient place to add an attribute.  Instead, the FE device compiler
must behave as though there was an implicit
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects(aspect::fp64)]]</span></code> attribute for any device code
that uses the <code class="docutils literal notranslate"><span class="pre">double</span></code> type.</p>
</section>
<section id="new-llvm-ir-metadata">
<h3>New LLVM IR metadata<a class="headerlink" href="#new-llvm-ir-metadata" title="Link to this heading">¶</a></h3>
<p>In order to communicate the information from <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> and
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attributes to the DPC++ post-link tool, we
introduce several new LLVM IR metadata.</p>
<p>The named metadata <code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> conveys information about
types that are decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code>.  This metadata
is not referenced by any instruction in the module, so it must be looked up by
name.  The format looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!sycl_types_that_use_aspects = !{!0, !1, !2}
!0 = !{!&quot;class.sycl::detail::half_impl::half&quot;, i32 8}
!1 = !{!&quot;class.sycl::amx_type&quot;, i32 9}
!2 = !{!&quot;class.sycl::other_type&quot;, i32 8, i32 9}
</pre></div>
</div>
<p>The value of the <code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> metadata is a list of unnamed
metadata nodes, each of which describes one type that is decorated with
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code>.  The value of each unnamed metadata node
starts with a string giving the name of the type which is followed by a list of
<code class="docutils literal notranslate"><span class="pre">i32</span></code> constants where each constant is a value from <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code> telling
the numerical value of an aspect from the type’s
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attribute.  In the example above, the type
<code class="docutils literal notranslate"><span class="pre">sycl::detail::half_impl::half</span></code> uses an aspect whose numerical value is
<code class="docutils literal notranslate"><span class="pre">8</span></code> and the type <code class="docutils literal notranslate"><span class="pre">sycl::other_type</span></code> uses two aspects <code class="docutils literal notranslate"><span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
<p><strong>NOTE</strong>: The reason we choose this representation is because LLVM IR does not
allow metadata to be attached directly to types.  This representation works
around that limitation by creating global named metadata that references the
type’s name.</p>
<p>To synchronize the integral values of given aspects between the SYCL headers and
the compiler, the <code class="docutils literal notranslate"><span class="pre">!sycl_aspects</span></code> metadata is added to the module, based on the
values defined in the enum. Inside this metadata node, each value of the aspect
enum is represented by another metadata node with two operands; the name of the
value and the corresponding integral value. An example of this is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!sycl_aspects = !{!0, !1, !2, ...}
!0 = !{!&quot;host&quot;, i32 0}
!1 = !{!&quot;cpu&quot;, i32 1}
!2 = !{!&quot;gpu&quot;, i32 2}
...
</pre></div>
</div>
<p><strong>NOTE</strong>: The <code class="docutils literal notranslate"><span class="pre">!sycl_aspects</span></code> metadata is both used by the compiler to identify
the aspect values of implicit aspect requirements, such as <code class="docutils literal notranslate"><span class="pre">aspect::fp64</span></code> from
the use of <code class="docutils literal notranslate"><span class="pre">double</span></code>, and to offer better diagnostic messages.</p>
<p>We also introduce three metadata that can be attached to a function definition:</p>
<ul>
<li><p>The <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> metadata is used for functions that are
decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>.  The value of the metadata node is a
list of <code class="docutils literal notranslate"><span class="pre">i32</span></code> constants, where each constant is a value from
<code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code> representing the aspects listed in the attribute.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata is used to store the propagated
information about all aspects used by a kernel or exported device function.
The value of this metadata node is also a list of <code class="docutils literal notranslate"><span class="pre">i32</span></code> constants, where each
constant is a value from <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code> representing the aspects that
are used by the kernel or exported device function.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">!sycl_fixed_targets</span></code> metadata is used to decorate kernel functions and
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions, telling the value of the <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>
switch that was used to compile the translation unit.  The value of this
metadata node is a list of string literals corresponding to the list of
targets specified on that command line switch.  If the translation unit is
compiled without the <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, the metadata has an empty list.</p>
<p>The reason an empty metadata is added to functions compiled without the
command line switch is to aid with the error checking that happens in the
<code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> tool w.r.t. <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions.  The presence of the
empty metadata allows <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> to identify functions that are
definitely known to be compiled without <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>.  Functions
with no metadata might be created by backend IR passes, even when this switch
<em>is</em> specified.</p>
</li>
</ul>
<p>To illustrate, the following IR corresponds to a function <code class="docutils literal notranslate"><span class="pre">foo</span></code> that is
decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> where the required aspects have the
numerical values <code class="docutils literal notranslate"><span class="pre">8</span></code> and <code class="docutils literal notranslate"><span class="pre">9</span></code>.  In addition, the function uses an optional
feature that corresponds to an aspect with numerical value <code class="docutils literal notranslate"><span class="pre">8</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>define void @foo() !sycl_declared_aspects !1 !sycl_used_aspects !2 {}
!1 = !{i32 8, i32 9}
!2 = !{i32 8}
</pre></div>
</div>
</section>
<section id="changes-to-the-dpc-front-end">
<h3>Changes to the DPC++ front-end<a class="headerlink" href="#changes-to-the-dpc-front-end" title="Link to this heading">¶</a></h3>
<p>The front-end of the device compiler is responsible for parsing the
<code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> and <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attributes and
transferring the information to the LLVM IR metadata described above according
to the following rules:</p>
<ul class="simple">
<li><p>If the translation unit contains any type definitions that are decorated with
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code>, the front-end creates an
<code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> metadata describing the aspects used by all
such types.</p></li>
<li><p>If a function is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code>, the
front-end adds an <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata to the function’s definition
listing the aspects from that attribute.</p></li>
<li><p>If a function is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>, the front-end adds
an <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> metadata to the function’s definition listing
the aspects from that attribute.</p></li>
<li><p>If a completed enum is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::sycl_type(aspect)]]</span></code> the
front-end adds an <code class="docutils literal notranslate"><span class="pre">!sycl_aspects</span></code> metadata to the module containing one
metadata node for each value in the enum. If there are multiple enum
definitions with the <code class="docutils literal notranslate"><span class="pre">[[sycl_detail::sycl_type(aspect)]]</span></code> attribute a
diagnostic is issued.</p></li>
</ul>
</section>
<section id="new-llvm-ir-pass-to-propagate-aspect-usage">
<h3>New LLVM IR pass to propagate aspect usage<a class="headerlink" href="#new-llvm-ir-pass-to-propagate-aspect-usage" title="Link to this heading">¶</a></h3>
<p>We add a new IR phase to the device compiler which does the following:</p>
<ul class="simple">
<li><p>Creates (or augments) a function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata with
aspects that come from references to types in the
<code class="docutils literal notranslate"><span class="pre">sycl_types_that_use_aspects</span></code> list.</p></li>
<li><p>If a function has the <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> metadata, creates (or augments)
the function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata with aspects from the
<code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> list.</p></li>
<li><p>Propagates each function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata up the static call
graph so that each function lists the aspects used by that function and by
any functions it calls.</p></li>
<li><p>Creates an <code class="docutils literal notranslate"><span class="pre">!sycl_fixed_targets</span></code> metadata for each kernel function or
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function that is defined.  This is done regardless of whether
the <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> command line switch is specified.  If the switch
is not specified, the metadata has an empty list of targets.</p></li>
</ul>
<p>Additionally, the pass will issue warning diagnostics in the following cases:</p>
<ul class="simple">
<li><p>If any function that has <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> uses an aspect not listed in
that declared set.</p></li>
<li><p>If the <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> command line switch is specified and any
function uses an aspect that is not compatible with all target devices
specified by that switch.</p></li>
</ul>
<p>It is important that this IR phase runs before any other optimization phase
that might eliminate a reference to a type or inline a function call because
such optimizations will cause us to miss information about aspects that are
used.  Therefore, it is recommended that this new phase run first, before all
other IR phases.</p>
<p>Implementing the first bullet point is straightforward.  The implementation can
scan the IR for each function looking for instructions that reference a type.
It can then see if that type is in the <code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> set; if
so it adds the type’s aspects to the function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> set.
While doing this, the implementation must have a special case for the <code class="docutils literal notranslate"><span class="pre">double</span></code>
type because the front-end does not include that type in the
<code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> set.  If a function references the <code class="docutils literal notranslate"><span class="pre">double</span></code>
type, the implementation implicitly assumes that the function uses
<code class="docutils literal notranslate"><span class="pre">aspect::fp64</span></code> and adds that aspect to the function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code>
set. If <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> is attached to instruction then it is also added
to the function’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> set.</p>
<p><strong>NOTE</strong>: This scan of the IR will require comparing the type referenced by
each IR instruction with the names of the types in the
<code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> metadata.  It would be very inefficient if we
did a string comparison each time.  As an optimization, the implementation can
first lookup up each type name in the <code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> metadata
set, finding the “type pointer” that corresponds to each type name.  Then the
pass over the IR can compare the type pointer in each IR instruction with the
type pointers from the <code class="docutils literal notranslate"><span class="pre">!sycl_types_that_use_aspects</span></code> metadata set.</p>
<p>The second bullet point requires building the static call graph, but the
implementation need not scan the instructions in each function.  Instead, it
need only look at the <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata for each function,
propagating the aspects used by each function up to it callers and augmenting
the caller’s <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> set.</p>
<p>Diagnosing warnings for the fifth bullet point is then straightforward.  The
implementation looks for functions that have <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> and
compares that set with the <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> set (if any).  If a function
uses an aspect that is not in the declared set, the implementation issues a
warning.</p>
<p>Diagnosing warnings for the sixth bullet point requires the <a class="reference internal" href="#device-configuration-file">device
configuration file</a> which gives the set of allowed optional features for
each target device.  The implementation looks for functions that have either
<code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> or <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code>, and it compares the aspects
from these metadata to the allowed list in the configuration file.  If any
aspect is not on the allowed list, the implementation issues a warning.  In
addition, the implementation looks for device functions that have
<code class="docutils literal notranslate"><span class="pre">!intel_reqd_sub_group_size</span></code> or <code class="docutils literal notranslate"><span class="pre">!reqd_work_group_size</span></code>.  If the required
sub-group size or the required work-group size is not allowed for the target
devices according to the configuration file, the implementation issues a
warning.</p>
<p>One weakness of this design is that the warning message will only be able to
contain the source location of the problem if the compiler was invoked with
<code class="docutils literal notranslate"><span class="pre">-g</span></code> because this is the only time when the front-end propagates source
location information into the IR.  To compensate, the warning message displays
the static call chain that leads to the problem.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">warning</span><span class="p">:</span> <span class="n">function</span> <span class="s1">&#39;foo&#39;</span> <span class="n">uses</span> <span class="n">aspect</span> <span class="s1">&#39;fp64&#39;</span> <span class="ow">not</span> <span class="n">listed</span> <span class="ow">in</span> <span class="s1">&#39;sycl::device_has&#39;</span>
<span class="n">use</span> <span class="ow">is</span> <span class="kn">from</span> <span class="nn">this</span> <span class="n">call</span> <span class="n">chain</span><span class="p">:</span>
  <span class="n">foo</span><span class="p">()</span>
  <span class="n">bar</span><span class="p">()</span>
  <span class="n">boo</span><span class="p">()</span>
<span class="nb">compile</span> <span class="k">with</span> <span class="s1">&#39;-g&#39;</span> <span class="n">to</span> <span class="n">get</span> <span class="n">source</span> <span class="n">location</span>
</pre></div>
</div>
<p>Including the call chain in the warning message will require maintaining some
additional information during the traversal of the static call graph described
above.</p>
<p>When the compiler is invoked with <code class="docutils literal notranslate"><span class="pre">-g</span></code>, the implementation uses the
<code class="docutils literal notranslate"><span class="pre">!DILocation</span></code> metadata to improve the warning message with source file, line,
and column information like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hw</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">27</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">function</span> <span class="s1">&#39;foo&#39;</span> <span class="n">uses</span> <span class="n">aspect</span> <span class="s1">&#39;fp64&#39;</span> <span class="ow">not</span> <span class="n">listed</span> <span class="ow">in</span> <span class="s1">&#39;sycl::device_has&#39;</span>
<span class="n">use</span> <span class="ow">is</span> <span class="kn">from</span> <span class="nn">this</span> <span class="n">call</span> <span class="n">chain</span><span class="p">:</span>
  <span class="n">foo</span><span class="p">()</span>
  <span class="n">bar</span><span class="p">()</span> <span class="n">hw</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">15</span><span class="p">:</span><span class="mi">3</span>
  <span class="n">boo</span><span class="p">()</span> <span class="n">hw</span><span class="o">.</span><span class="n">cpp</span><span class="p">:</span><span class="mi">25</span><span class="p">:</span><span class="mi">5</span>
</pre></div>
</div>
<p>In the example above, the location <code class="docutils literal notranslate"><span class="pre">hw.cpp:27:4</span></code> gives the source location of
the code that uses the <code class="docutils literal notranslate"><span class="pre">fp64</span></code> aspect, in this case somewhere in the <code class="docutils literal notranslate"><span class="pre">boo()</span></code>
function.  The location <code class="docutils literal notranslate"><span class="pre">hw.cpp:15:3</span></code> tells the location in <code class="docutils literal notranslate"><span class="pre">foo()</span></code> of the call
to <code class="docutils literal notranslate"><span class="pre">bar()</span></code>, etc.</p>
<p><strong>NOTE</strong>: Issuing this warning message from an IR pass is a compromise.  We
would get better source location if the front-end diagnosed this warning.
However, we feel that the analysis required to diagnose this warning would be
too expensive in the front-end because it requires an additional pass over the
AST.  By contrast, we can diagnose the warning more efficiently in an IR pass
because traversal of the IR is much more efficient than traversal of the AST.
The downside, though, is that the warning message is less informative.</p>
<section id="pre-and-post-optimization-aspect-propagation">
<h4>Pre- and post-optimization aspect propagation<a class="headerlink" href="#pre-and-post-optimization-aspect-propagation" title="Link to this heading">¶</a></h4>
<p>Sometimes aspects that are used by a kernel in source code are eliminated during
optimization. The most common case is when a kernel uses a double precision
floating point literal to initialize a single precision floating point variable.
Although the kernel uses the aspect <code class="docutils literal notranslate"><span class="pre">fp64</span></code> (corresponding to <code class="docutils literal notranslate"><span class="pre">double</span></code>) in its
source code, the optimizer commonly replaces the double precision literal with a
single precision literal, and this can sometimes mean that the kernel does not
actually rely on the <code class="docutils literal notranslate"><span class="pre">fp64</span></code> aspect at all. We therefore have a quandary, should
kernels like this be allowed to run on a device that doesn’t have <code class="docutils literal notranslate"><span class="pre">fp64</span></code>
support?</p>
<p>It seems too extreme to raise an exception if the application attempts to submit
a kernel like this to a device without fp64 support because applications like
this previously ran without error (prior to this design being implemented).
However, it also seems useful to issue a warning in a case like this if the
application specifically decorated the kernel with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>
(i.e. requesting a warning if the kernel uses aspects not listed in that
attribute). We therefore run the aspect propagation pass twice: once before
optimization and again after optimization.</p>
<p>The first run of the pass takes a list of aspect names to exclude when saving
the result of the propagation. It will still propagate the excluded aspects to
correctly issue strict warning diagnostics for the cases mentioned above, but
after the pass finishes functions will only have the excluded aspects in their
<code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata if they had them prior to the execution of the
pass.</p>
<p>In the second run of the pass, all aspects are propagated and saved. For the
aspects that were not excluded from the first run of the pass this will have no
effect and the pass may elect to ignore these aspects. To avoid repeating
warnings issued by the previous execution of the pass, this run will not issue
any warning diagnostics.</p>
</section>
</section>
<section id="assumptions-on-other-phases-of-clang">
<h3>Assumptions on other phases of clang<a class="headerlink" href="#assumptions-on-other-phases-of-clang" title="Link to this heading">¶</a></h3>
<p>The post-link tool (described below) uses the <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> and
<code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> metadata, so this metadata must be retained by any
other clang passes.  However, post-link only uses this metadata when it
decorates the definition of a kernel function or the definition of an exported
device function, so it does not matter if intervening clang passes discard the
metadata on other device functions.</p>
<p>We think this is a safe assumption for two reasons.  First, the existing design
must already preserve the <code class="docutils literal notranslate"><span class="pre">!reqd_work_group_size</span></code> metadata that decorates
kernel functions.  Second, the kernel functions and exported device functions
always have external linkage, so there is no possibility that a clang phase
will optimize them away.</p>
<p><strong>NOTE</strong>: Ideally, we would change the llvm-link tool to somehow preserve the
<code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> and <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> metadata for functions
marked <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> so that we could compare the declared aspects (in the
module that imports the function) with the used aspects (in the module the
exports the function).  This would allow us to diagnose errors where the
importing translation unit’s declared aspects do not match the aspects actually
used by the function.</p>
<p>We do not propose this change as part of this design, though.  We expect that
this will not be a common error because applications can avoid this problem by
declaring the <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function in a common header that is included by
both the importing and the exporting translation unit.  If the declaration (in
the header) is decorated with <code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code>, the shared declaration
will ensure that the definition stays in sync with the declaration.</p>
</section>
<section id="changes-to-the-post-link-tool">
<h3>Changes to the post-link tool<a class="headerlink" href="#changes-to-the-post-link-tool" title="Link to this heading">¶</a></h3>
<p>As noted in the requirements section above, DPC++ currently bundles kernels
together regardless of the optional features they use, and this can lead to
problems resulting from speculative compilation.  To illustrate, consider
kernel <em>K1</em> that uses no optional features and kernel <em>K2</em> that uses a feature
corresponding to aspect <em>A</em>, and consider the case when <em>K1</em> and <em>K2</em> are
bundled together in the same device image.  Now consider an application that
submits <em>K1</em> to a device that does not have aspect <em>A</em>.  The application should
expect this to work, but DPC++ currently fails because JIT-compiling <em>K1</em>
causes the entire bundle to be compiled, and this fails when trying to compile
<em>K2</em> for a device that does not have aspect <em>A</em>.</p>
<p>We solve this problem by changing the post-link tool to bundle kernels and
exported device functions according to the aspects that they use.</p>
<section id="changes-to-the-device-code-split-algorithm">
<h4>Changes to the device code split algorithm<a class="headerlink" href="#changes-to-the-device-code-split-algorithm" title="Link to this heading">¶</a></h4>
<p>The algorithm for splitting device functions into images must be changed to
account for the aspects used by each kernel or exported device function.  The
goal is to ensure that two kernels or exported device functions are only
bundled together into the same device image if they use exactly the same set
of aspects.</p>
<p>For the purposes of this analysis, the set of <em>UsedAspects</em> aspects is computed
by taking the union of the aspects listed in the kernel’s (or device
function’s) <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> and <code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> sets.  This is
consistent with the SYCL specification, which says that a kernel decorated with
<code class="docutils literal notranslate"><span class="pre">[[sycl::device_has()]]</span></code> may only be submitted to a device that provides the
listed aspects, regardless of whether the kernel actually uses those aspects.</p>
<p>We must also split two kernels into different device images if they have
different <code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_sub_group_size()]]</span></code> or different
<code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_work_group_size()]]</span></code> values.  The reasoning is similar as the
aspect case.  The JIT compiler currently raises an error if it tries to compile
a kernel that has a required sub-group size if the size isn’t supported by the
target device.  The behavior for required work-group size is less clear.  The
Intel implementation does not raise a JIT compilation error when compiling a
kernel that uses an unsupported work-group size, but other backends might.
Therefore, it seems safest to split device code based required work-group size
also.</p>
<p>The algorithm is different, though, for translation units that were compiled
with <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>.  Since the user has asserted that device code in
these translation units will be run <em>only</em> on the targets listed in that
switch, we know that all such device code can be bundled together in the same
device image so long as the translation units were compiled with the same
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code> switch.</p>
<p>Therefore, two kernels or exported device functions can only be bundled
together into the same device image if:</p>
<ul class="simple">
<li><p>They both have <code class="docutils literal notranslate"><span class="pre">!sycl_fixed_targets</span></code> metadata with the same non-empty set of
targets, or</p></li>
<li><p>All of the following are true:</p>
<ul>
<li><p>Both have an empty set of <code class="docutils literal notranslate"><span class="pre">!sycl_fixed_targets</span></code> metadata,</p></li>
<li><p>They share the same set of <em>UsedAspects</em> aspects,</p></li>
<li><p>They either both have no required work-group size or both have the same
required work-group size, and</p></li>
<li><p>They either both have the same numeric value for their required sub-group
size or neither has a numeric value for a required sub-group size.  (Note
that this implies that kernels decorated with
<code class="docutils literal notranslate"><span class="pre">[[intel::named_sub_group_size(automatic)]]</span></code> can be bundled together with
kernels that are decorated with <code class="docutils literal notranslate"><span class="pre">[[intel::named_sub_group_size(primary)]]</span></code>
and that either of these kernels could be bundled with a kernel that has no
required sub-group size.)</p></li>
</ul>
</li>
</ul>
<p>These criteria are an additional filter applied to the device code split
algorithm after taking into account the <code class="docutils literal notranslate"><span class="pre">-fsycl-device-code-split</span></code> command line
option.  If the user requests <code class="docutils literal notranslate"><span class="pre">per_kernel</span></code> device code split, then each kernel
is already in its own device image, so no further splitting is required.  If
the user requests any other option, device code is first split according to
that option, and then another split is performed to ensure that each device
image contains only kernels or exported device functions that meet the criteria
listed above.</p>
</section>
<section id="error-checking-for-sycl-external-functions">
<h4>Error checking for SYCL_EXTERNAL functions<a class="headerlink" href="#error-checking-for-sycl-external-functions" title="Link to this heading">¶</a></h4>
<p>After bundling the device functions into images, the <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> tool does
another pass over the IR of each image to catch errors that occur with
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions:</p>
<ul class="simple">
<li><p>It’s possible that a translation unit calling a <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function did
not properly decorate the function’s declaration with the set of aspects that
it uses.  Such an error would not be caught in earlier phases, which operate
on a single translation unit at a time.</p></li>
<li><p>It’s possible that a translation unit calling a <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function was
compiled with <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, but the translation unit defining the
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function was not compiled with this option (or was compiled
to assume a different set of target devices).</p></li>
</ul>
<p>If the image contains kernels that were <em>not</em> compiled with
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, the pass works as follows:</p>
<ul class="simple">
<li><p>Set <em>FinalUsedAspects</em> to the image’s <em>UsedAspects</em> set of aspects (which
could be the empty set if the image has no required aspects).</p></li>
<li><p>Set <em>FinalSubGroup</em> to the image’s required sub-group size (which could be
the empty set if the image has no required sub-group size).</p></li>
<li><p>Set <em>FinalWorkGroup</em> to the image’s required work-group size (which could be
the empty set if the image has no required work-group size).</p></li>
<li><p>Scan over all functions in the image and examine the function’s metadata:</p>
<ul>
<li><p>If the function has either <code class="docutils literal notranslate"><span class="pre">!sycl_used_aspects</span></code> or
<code class="docutils literal notranslate"><span class="pre">!sycl_declared_aspects</span></code> metadata and one of the aspects in that metadata
is not in the image’s <em>UsedAspects</em> set, issue a warning and add that
aspect to the <em>FinalUsedAspects</em> set.</p></li>
<li><p>If the function has <code class="docutils literal notranslate"><span class="pre">!intel_reqd_sub_group_size</span></code> metadata and the size is
not the same as the image’s required sub-group size, issue a warning and
add that sub-group size to the <em>FinalSubGroup</em> set.</p></li>
<li><p>(Since the <code class="docutils literal notranslate"><span class="pre">[[sycl::reqd_work_group_size()]]</span></code> attribute cannot be specified
on a <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function, there is no need for a similar check on the
required work-group size.)</p></li>
</ul>
</li>
<li><p>Set the following properties in the “SYCL/device requirements” property set
(described below):</p>
<ul>
<li><p>If <em>FinalUsedAspects</em> is not the empty set, create an “aspect” property
with those values.</p></li>
<li><p>If <em>FinalSubGroup</em> is not the empty set, create a “reqd_sub_group_size”
property with those values.</p></li>
<li><p>If <em>FinalWorkGroup</em> is not the empty set, create a
“reqd_work_group_size” property with those values.</p></li>
</ul>
</li>
</ul>
<p>Warning messages from this pass look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>warning: function &#39;foo&#39; uses aspect &#39;fp64&#39; not expected by its calling kernel.
Missing [[sycl::device_has()]] on SYCL_EXTERNAL function?

warning: function &#39;bar&#39; has required sub-group size &#39;32&#39; that does not match
its calling kernel.  Missing [[sycl::reqd_sub_group()]] attribute on
SYCL_EXTERNAL function?
</pre></div>
</div>
<p>If the image contains kernels that <em>were</em> compiled with <code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>,
the pass works as follows:</p>
<ul class="simple">
<li><p>Set <em>FinalFixedTargets</em> to the image’s set of fixed target devices.</p></li>
<li><p>Scan over all functions in the image looking for functions that have the
<code class="docutils literal notranslate"><span class="pre">!sycl_fixed_targets</span></code> metadata.  If the metadata exists and its set includes
any target devices not in the image’s set of fixed targets, issue a warning
and set <em>FinalFixedTargets</em> to the intersection of the metadata’s target set
and the <em>FinalFixedTargets</em> set.  (This may result in <em>FinalFixedTargets</em>
being the empty set.)</p></li>
<li><p>Set the following properties in the “SYCL/device requirements” property set:</p>
<ul>
<li><p>Create a “fixed_target” property (even if <em>FinalFixedTargets</em> is the empty
set).  This requires converting each target name in <em>FinalFixedTargets</em> to
its associated aspect.</p></li>
</ul>
</li>
</ul>
<p>Warning messages from this pass look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>warning: function &#39;foo&#39; compiled with a different `-fsycl-fixed-targets` switch
than its calling kernel.
</pre></div>
</div>
</section>
<section id="create-the-sycl-device-requirements-property-set">
<h4>Create the “SYCL/device requirements” property set<a class="headerlink" href="#create-the-sycl-device-requirements-property-set" title="Link to this heading">¶</a></h4>
<p>The DPC++ runtime needs some way to know about the requirements of an image
(e.g. the set of aspects that it uses).  Therefore, the <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> tool
provides this information in a new property set named
“SYCL/device requirements”.</p>
<p>The following table lists the properties that this set may contain and their
types:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property Name</p></th>
<th class="head"><p>Property Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“aspect”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PI_PROPERTY_TYPE_BYTE_ARRAY</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>“reqd_sub_group_size”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PI_PROPERTY_TYPE_BYTE_ARRAY</span></code></p></td>
</tr>
<tr class="row-even"><td><p>“reqd_work_group_size”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PI_PROPERTY_TYPE_BYTE_ARRAY</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>“fixed_target”</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">PI_PROPERTY_TYPE_BYTE_ARRAY</span></code></p></td>
</tr>
</tbody>
</table>
<p>The “aspect” property tells the set of aspects that a device must have in order
to use the image.  The image is only compatible with a device that supports
<strong>all</strong> of the listed aspects.  The value of the property is an array of
<code class="docutils literal notranslate"><span class="pre">uint32</span></code> values, where each <code class="docutils literal notranslate"><span class="pre">uint32</span></code> value is the numerical value of an aspect
from <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code>.  The size of the property (which is always divisible
by <code class="docutils literal notranslate"><span class="pre">4</span></code>) tells the number of aspects in the array.</p>
<p>The “reqd_sub_group_size” property tells the set of numeric sub-group sizes
that a device must support in order to use the image.  (This does not include
named sub-group sizes like <code class="docutils literal notranslate"><span class="pre">automatic</span></code> or <code class="docutils literal notranslate"><span class="pre">primary</span></code>.)  The image is only
compatible with a device that supports <strong>all</strong> of the listed sizes.  The value
of the property is an array of <code class="docutils literal notranslate"><span class="pre">uint32</span></code> values, where each <code class="docutils literal notranslate"><span class="pre">uint32</span></code> value tells
a required sub-group size.  The size of the property (which is always divisible
by <code class="docutils literal notranslate"><span class="pre">4</span></code>) tells the number of entries in the array.</p>
<p>The “reqd_work_group_size” property tells the set of work-group sizes that a
device must support in order to use the image.  The image is only compatible
with a device that supports <strong>all</strong> of the listed sizes.  The value of the
property is a <code class="docutils literal notranslate"><span class="pre">BYTE_ARRAY</span></code> with entries that have the following layout:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">dim_count</span> <span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">dim0</span> <span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">...</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">dim_count</span></code> is the number of work group dimensions (i.e. 1, 2, or 3), and
<code class="docutils literal notranslate"><span class="pre">dim0</span> <span class="pre">...</span></code> are the values of the dimensions from the
<code class="docutils literal notranslate"><span class="pre">[[reqd_work_group_size()]]</span></code> attribute, in the same order as they appear in the
attribute.  The size of the property tells the number of entries in the array.</p>
<p>The “fixed_target” property indicates that the image was compiled with
<code class="docutils literal notranslate"><span class="pre">-fsycl-fixed-targets</span></code>, and it is assumed to be runnable only on the set of
target devices that are listed in this property.  The value of the property is
an array of <code class="docutils literal notranslate"><span class="pre">uint32</span></code> values where each <code class="docutils literal notranslate"><span class="pre">uint32</span></code> value is the numerical value of
an aspect from <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code>, telling one of the target devices from the
command line switch.  (Each target device has a corresponding aspect.)  The
size of the property (which is always divisible by <code class="docutils literal notranslate"><span class="pre">4</span></code>) tells the number of
aspects in the array.</p>
</section>
</section>
<section id="changes-specific-to-aot-mode">
<h3>Changes specific to AOT mode<a class="headerlink" href="#changes-specific-to-aot-mode" title="Link to this heading">¶</a></h3>
<p>In AOT mode, for each AOT target specified by the <code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code> command
line option, DPC++ normally invokes the AOT compiler for each device IR module
resulting from the sycl-post-link tool.  For example, this is the <code class="docutils literal notranslate"><span class="pre">ocloc</span></code>
command for Intel Graphics AOT target and the <code class="docutils literal notranslate"><span class="pre">opencl-aot</span></code> command for the x86 AOT
target with SPIR-V as the input, or other specific tools for the PTX target
with LLVM IR bitcode input.  This causes a problem, though, for IR modules that
use optional features because these commands could fail if they attempt to
compile IR using an optional feature that is not supported by the target
device.  We therefore need some way to avoid calling these commands in these
cases.</p>
<p>The overall design is as follows.  The DPC++ installation includes a
configuration file that has one entry for each device that it supports.  Each
entry contains the set of aspects that the device supports and the set of
sub-group sizes that it supports.  DPC++ then consults this configuration
file to decide whether to invoke a particular AOT compiler on each device IR
module, using the information from the module’s “SYCL/device requirements”
property set.</p>
<section id="device-configuration-file">
<h4>Device configuration file<a class="headerlink" href="#device-configuration-file" title="Link to this heading">¶</a></h4>
<p>The configuration file uses a simple YAML format where each top-level key is
a name of a device architecture. There are sub-keys under each device for
the supported aspects and sub-group sizes.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">intel_gpu_12_0_0</span><span class="p">:</span>
  <span class="n">aspects</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="n">may_support_other_aspects</span><span class="p">:</span> <span class="n">false</span>
  <span class="n">sub</span><span class="o">-</span><span class="n">group</span><span class="o">-</span><span class="n">sizes</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">intel_gpu_icl</span><span class="p">:</span>
  <span class="n">aspects</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="n">may_support_other_aspects</span><span class="p">:</span> <span class="n">false</span>
  <span class="n">sub</span><span class="o">-</span><span class="n">group</span><span class="o">-</span><span class="n">sizes</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>
<span class="n">x86_64_avx512</span><span class="p">:</span>
  <span class="n">aspects</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
  <span class="n">may_support_other_aspects</span><span class="p">:</span> <span class="n">false</span>
  <span class="n">sub</span><span class="o">-</span><span class="n">group</span><span class="o">-</span><span class="n">sizes</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="p">]</span>
</pre></div>
</div>
<p>The device entries have an optional <code class="docutils literal notranslate"><span class="pre">may_support_other_aspects</span></code> sub-key
specifying if a given target may be supported by devices that support aspects
not in the <code class="docutils literal notranslate"><span class="pre">aspects</span></code> list. This is used by the <a class="reference internal" href="DeviceAspectTraitDesign.html"><span class="std std-doc">DeviceAspectTraitDesign.md</span></a>
design.</p>
<p>The values of the aspects in this configuration file can be the numerical
values from the <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span> <span class="pre">aspect</span></code> enumeration or the enum identifier itself.</p>
<p>One advantage to encoding this information in a textual configuration file is
that customers can update the file if necessary.  This could be useful, for
example, if a new device is released before there is a new DPC++ release.  In
fact, the DPC++ driver supports a command line option which allows the user
to select an alternate configuration file.</p>
<p><strong>TODO</strong>:</p>
<ul class="simple">
<li><p>Define location of the default device configuration file.</p></li>
</ul>
</section>
<section id="new-features-in-clang-compilation-driver-and-tools">
<h4>New features in clang compilation driver and tools<a class="headerlink" href="#new-features-in-clang-compilation-driver-and-tools" title="Link to this heading">¶</a></h4>
<p>NOTE: the term <em>device binary image</em> used to refer to a device
code form consumable by the DPC++ runtime library. Earlier device code forms are
referred to as <em>device code module</em> or <em>device IR module</em>. In case of AOT,
device binary image is a natively compiled binary, and IR module - either a
SPIR-V or LLVM IR bitcode module.</p>
<section id="overview">
<h5>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h5>
<p>After the <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> performs necessary aspect usage analysis and splits
the incoming monolithic device code module into pieces - smaller device code
modules - it outputs a file table as a result. Each row in the table corresponds
to an individual output module, and each element of a row is a name of a file
containing necessary information about the module, such as the code itself, and
its properties.</p>
<p>At the action graph building stage for each requested AOT compilation target -
SPIR-V-based (such as Intel Graphics targets) and/or non-SPIR-V-based (such as
PTX) - the driver adds an <code class="docutils literal notranslate"><span class="pre">aspect-filter</span></code> action which filters out input file
table rows with device code modules using features unsupported on current
target. Then the output table goes as input into the AOT stage, and the prior
filtering guarantees that the AOT compiler will not encounter device code it
can’t compile. In the extreme case when all device code
modules use unsupported aspects, the input file table will be empty. The picture
below illustrates the action graph built by the clang driver along with file
lists and tables generated and consumed by various nodes of the graph. The
example set of targets used for the illustration is 4 targets</p>
<ul class="simple">
<li><p>spir64 (runtime JITted SPIR-V)</p></li>
<li><p>AOT targets</p>
<ul>
<li><p>non-SPIR-V based</p>
<ul>
<li><p>ptx64 (PTX)</p></li>
</ul>
</li>
<li><p>SPIR-V based</p>
<ul>
<li><p>intel_gpu_12_0_0 (Intel Graphics)</p></li>
<li><p>x86_64_avx512 (AVX512)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="Device SPIRV translation and AOT compilation" src="../_images/DeviceLinkAOTAndWrap.svg" /></p>
</section>
<section id="aspect-filter-tool">
<h5>Aspect filter tool<a class="headerlink" href="#aspect-filter-tool" title="Link to this heading">¶</a></h5>
<p>This tool transforms an input file table by removing rows with device code files
that use features unsupported for the target architecture given as tool’s
argument.</p>
<p><em>Name</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl-aspect-filter</span></code>, located next to other tools like <code class="docutils literal notranslate"><span class="pre">file-table-tform</span></code></p></li>
</ul>
<p><em>Input</em>:</p>
<ul class="simple">
<li><p>file table, normally coming out of <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> or <code class="docutils literal notranslate"><span class="pre">file-table-tform</span></code>
tools</p></li>
</ul>
<p><em>Command line arguments</em>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-target=&lt;target&gt;</span></code> target device architecture to filter for</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-device-config-file=&lt;path&gt;</span></code> path to the device configuration file</p></li>
</ul>
<p><em>Output</em>:</p>
<ul class="simple">
<li><p>the input file table filtered as needed</p></li>
</ul>
<p>In more details, the tool performs the following actions:</p>
<ol class="arabic simple">
<li><p>Checks if the input file table contains “Properties” column. If not, copies
the input file table to output and exits without error.</p></li>
<li><p>Reads in the device configuration file and finds some entry <code class="docutils literal notranslate"><span class="pre">E</span></code> corresponding
to the architecture given on the command line. If there is no such entry -
reports an error and exits.</p></li>
<li><p>For each row in the input file table:</p>
<ul class="simple">
<li><p>Load the properties file from the “Properties” column.</p></li>
<li><p>Check if the <code class="docutils literal notranslate"><span class="pre">SYCL/device</span> <span class="pre">requirements</span></code> property set exists.</p></li>
<li><p>If not, copy the current row to the output file table and go the next row.</p></li>
<li><p>If it does exist, all of the following checks are performed.  If they all
pass, the row is copied to the output file table, otherwise it is skipped.
Either way, it advances to the next row.</p>
<ul>
<li><p>If there is an “aspect” property, check if entry <code class="docutils literal notranslate"><span class="pre">E.aspects</span></code> contains
all of the aspects listed in the property.  If any are missing, the
check fails.</p></li>
<li><p>If there is a “reqd_sub_group_size” property, check if entry
<code class="docutils literal notranslate"><span class="pre">E.sub-group-sizes</span></code> contains all of the sub-group sizes listed in the
property.  If any are missing, the check fails.</p></li>
<li><p>If there is a “fixed_target” property, check if <code class="docutils literal notranslate"><span class="pre">E.aspects</span></code> contains
at least one of the aspects from the property.  If it does not, the
check fails.  (The “fixed_target” property lists the corresponding
aspect for each target device.  The <code class="docutils literal notranslate"><span class="pre">E.aspects</span></code> list will only contain
this aspect if <code class="docutils literal notranslate"><span class="pre">E</span></code> corresponds to that target.)</p></li>
</ul>
</li>
</ul>
</li>
</ol>
</section>
<section id="configuration-file-location-and-driver-option">
<h5>Configuration file location and driver option<a class="headerlink" href="#configuration-file-location-and-driver-option" title="Link to this heading">¶</a></h5>
<p>A default device configuration file is present in DPC++ build. Users may override it using the
<code class="docutils literal notranslate"><span class="pre">-fsycl-device-config-file=&lt;path&gt;</span></code> compiler command line option.
Exact location of the file and final name of the compiler option is TBD.</p>
</section>
<section id="aot-target-identification">
<h5>AOT target identification<a class="headerlink" href="#aot-target-identification" title="Link to this heading">¶</a></h5>
<p>There are several user-visible places in the SDK where SYCL device target
architectures need to be identified:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-fsycl-targets</span></code> option</p></li>
<li><p>a device configuration file entry</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-target</span></code> option of the <code class="docutils literal notranslate"><span class="pre">sycl-aspect-filter</span></code> tool</p></li>
<li><p>a new SYCL enumeration named <code class="docutils literal notranslate"><span class="pre">architecture</span></code></p></li>
</ul>
<p>The following table lists these target names:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>name</p></th>
<th class="head"><p>has <code class="docutils literal notranslate"><span class="pre">architecture</span></code> enum</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ptx64</p></td>
<td><p>no</p></td>
<td><p>Generic 64-bit PTX target architecture</p></td>
</tr>
<tr class="row-odd"><td><p>spir64</p></td>
<td><p>no</p></td>
<td><p>Generic 64-bit SPIR-V target</p></td>
</tr>
<tr class="row-even"><td><p>x86_64</p></td>
<td><p>yes</p></td>
<td><p>Generic 64-bit x86 architecture</p></td>
</tr>
<tr class="row-odd"><td><p>intel_gpu_&lt;name&gt;</p></td>
<td><p>yes</p></td>
<td><p>Intel graphics architecture &lt;name&gt;</p></td>
</tr>
</tbody>
</table>
<p>The “name” column in this table lists the possible target names.  Since not all
targets have a corresponding enumerator in the <code class="docutils literal notranslate"><span class="pre">architecture</span></code> enumeration, the
second column tells when there is such an enumerator.  The last row in this
table corresponds to all of the architecture names listed in the
<a class="reference download internal" download="" href="../_downloads/29eec7da90e760d8eaf2283a50ff5ea3/sycl_ext_oneapi_device_architecture.asciidoc"><span class="xref download myst">sycl_ext_oneapi_device_architecture</span></a> extension whose name starts with
<code class="docutils literal notranslate"><span class="pre">intel_gpu_</span></code>.</p>
<p>TODO: This table needs to be filled out for the CPU variants supported by the
<code class="docutils literal notranslate"><span class="pre">opencl-aot</span></code> tool (avx512, avx2, avx, sse4.2) and for the FPGA targets.  We
also need to figure out how CUDA fits in here.</p>
<p>Example of clang compilation invocation with 2 AOT targets and generic SPIR-V:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span><span class="o">++</span> <span class="o">-</span><span class="n">fsycl</span> <span class="o">-</span><span class="n">fsycl</span><span class="o">-</span><span class="n">targets</span><span class="o">=</span><span class="n">spir64</span><span class="p">,</span><span class="n">intel_gpu_12_0_0</span><span class="p">,</span><span class="n">ptx64</span> <span class="o">...</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="changes-to-the-dpc-runtime">
<h3>Changes to the DPC++ runtime<a class="headerlink" href="#changes-to-the-dpc-runtime" title="Link to this heading">¶</a></h3>
<p>The DPC++ runtime must be changed to check if a kernel uses any optional
features that the device does not support.  If this happens, the runtime must
raise a synchronous <code class="docutils literal notranslate"><span class="pre">errc::kernel_not_supported</span></code> exception.</p>
<p>When the application submits a kernel to a device, the runtime identifies all
the other device images that export device functions which are needed by the
kernel as described in <a class="reference internal" href="SharedLibraries.html"><span class="std std-doc">Device Code Dynamic Linking</span></a>.  Before the runtime
actually links these images together, it compares each image’s
“SYCL/device requirements” against the features provided by the target
device.  If any of the following checks fail, the runtime throws
<code class="docutils literal notranslate"><span class="pre">errc::kernel_not_supported</span></code>:</p>
<ul class="simple">
<li><p>The “fixed_target” property exists, and the device is not one of the target
devices listed in the property, or</p></li>
<li><p>The “aspect” property contains an aspect that is not provided by the device,
or</p></li>
<li><p>The “reqd_sub_group_size” property contains a sub-group size that the
device does not support, or</p></li>
<li><p>The “reqd_work_group_size” property contains a work-group size that the
device does not support.  Currently, the only portable check that will work
for all devices is to verify that the total number of work items in the
“reqd_work_group_size” property is no greater than the device’s value for
<code class="docutils literal notranslate"><span class="pre">info::device::max_work_group_size</span></code>.  However, individual backends may
provide other checks.</p></li>
</ul>
<p>If the runtime throws an exception, it happens even before the runtime tries to
access the contents of the device image.</p>
<p>The exception’s <code class="docutils literal notranslate"><span class="pre">what</span></code> string contains a message describing the reason the
device image is incompatible.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Kernel</span> <span class="n">was</span> <span class="n">compiled</span> <span class="k">with</span> <span class="s1">&#39;-fsycl-fixed-targets=intel_gpu_12_0_0&#39;</span> <span class="n">but</span> <span class="n">was</span>
<span class="n">submitted</span> <span class="n">to</span> <span class="n">a</span> <span class="n">different</span> <span class="n">device</span><span class="o">.</span>

<span class="n">Kernel</span> <span class="n">uses</span> <span class="n">optional</span> <span class="n">feature</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="s1">&#39;aspect::fp16&#39;</span> <span class="n">but</span> <span class="n">device</span> <span class="n">does</span>
<span class="ow">not</span> <span class="n">support</span> <span class="n">this</span> <span class="n">aspect</span><span class="o">.</span>

<span class="n">Kernel</span> <span class="n">has</span> <span class="n">a</span> <span class="n">required</span> <span class="n">sub</span><span class="o">-</span><span class="n">group</span> <span class="n">size</span> <span class="n">of</span> <span class="s1">&#39;32&#39;</span> <span class="n">but</span> <span class="n">device</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">support</span> <span class="n">this</span>
<span class="n">sub</span><span class="o">-</span><span class="n">group</span> <span class="n">size</span><span class="o">.</span>
</pre></div>
</div>
</section>
<section id="sycl-internal-aspects-for-device-image-splitting">
<h3>SYCL internal aspects for device image splitting<a class="headerlink" href="#sycl-internal-aspects-for-device-image-splitting" title="Link to this heading">¶</a></h3>
<p>There are scenarios when we would like to split device images based on
optional kernel features but we don’t want to expose corresponding
aspects to the user. Internal SYCL aspects are used for this purpose.</p>
<p>To differentiate them from regular aspects, internal aspects are assigned
negative values. If optional feature is used in the kernel then SYCL
device compiler adds value of internal aspect to ‘sycl_used_aspects’ metadata,
it gets propagated through the call graph and participates in device image
splitting together with regular aspects but it’s not passed to the SYCL runtime,
it is filtered out when generating a set of device requirements.</p>
<p>New value can be added to ‘SYCLInternalAspect’ enum to introduce new internal
aspect.</p>
<p>Example of internal aspects usage is splitting device images based on floating
point accuracy level for math functions provided by user using -ffp-accuracy option.</p>
</section>
</section>
<section id="appendix-adding-an-attribute-to-8-byte-atomic-ref">
<h2>Appendix: Adding an attribute to 8-byte <code class="docutils literal notranslate"><span class="pre">atomic_ref</span></code><a class="headerlink" href="#appendix-adding-an-attribute-to-8-byte-atomic-ref" title="Link to this heading">¶</a></h2>
<p>As described above under <a class="reference internal" href="#changes-to-dpc-headers">“Changes to DPC++ headers”</a>, we need to decorate
any SYCL type representing an optional device feature with the
<code class="docutils literal notranslate"><span class="pre">[[sycl_detail::uses_aspects()]]</span></code> attribute.  This is somewhat tricky for
<code class="docutils literal notranslate"><span class="pre">atomic_ref</span></code>, though, because it is only an optional feature when specialized
for a 8-byte type.  However, we can accomplish this by using partial
specialization techniques.  The following code snippet demonstrates (best read
from bottom to top):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>namespace sycl {
namespace detail {

template&lt;typename T&gt;
class atomic_ref_impl_base {
 public:
  atomic_ref_impl_base(T x) : x(x) {}

  // All the member functions for atomic_ref go here

 private:
  T x;
};

// Template class which can be specialized based on the size of the underlying
// type.
template&lt;typename T, size_t S&gt;
class atomic_ref_impl : public atomic_ref_impl_base&lt;T&gt; {
 public:
  using atomic_ref_impl_base&lt;T&gt;::atomic_ref_impl_base;
};

// Explicit specialization for 8-byte types.  Only this specialization has the
// attribute.
template&lt;typename T&gt;
class [[__sycl_detail__::__uses_aspects__(aspect::atomic64)]]
    atomic_ref_impl&lt;T, 8&gt; : public atomic_ref_impl_base&lt;T&gt; {
 public:
  using atomic_ref_impl_base&lt;T&gt;::atomic_ref_impl_base;
};

} // namespace detail

// Publicly visible atomic_ref class.
template&lt;typename T&gt;
class atomic_ref : public detail::atomic_ref_impl&lt;T, sizeof(T)&gt; {
 public:
  atomic_ref(T x) : detail::atomic_ref_impl&lt;T, sizeof(T)&gt;(x) {}
};

} // namespace sycl
</pre></div>
</div>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="SharedLibraries.html">Dynamic linking of device code</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ParallelForRangeRounding.html">Parallel For Range Rounding</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>