<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Assert feature &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Dynamic linking of device code" href="SharedLibraries.html" />
    <link rel="prev" title="Linked allocations" href="LinkedAllocations.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>Assert feature</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="LinkedAllocations.html">Linked allocations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SharedLibraries.html">Dynamic linking of device code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="assert-feature">
<h1>Assert feature<a class="headerlink" href="#assert-feature" title="Link to this heading">¶</a></h1>
<p><strong>IMPORTANT</strong>: This document is a draft.</p>
<p>Using the standard C++ <code class="docutils literal notranslate"><span class="pre">assert</span></code> API (“assertions”) is an important debugging
technique widely used by developers. This document describes the design of
supporting assertions within SYCL device code.
The basic approach we chose is delivering device-side assertions as call to
<code class="docutils literal notranslate"><span class="pre">std::abort()</span></code> at host-side.</p>
<p>As usual, device-side assertions can be disabled by defining <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro at
compile time.</p>
<section id="use-case-example">
<h2>Use-case example<a class="headerlink" href="#use-case-example" title="Link to this heading">¶</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">sycl</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">user_func</span><span class="p">(</span><span class="n">item</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">((</span><span class="n">Item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="err">“</span><span class="n">Nil</span><span class="err">”</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="o">&amp;</span><span class="w"> </span><span class="n">CGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">TheKernel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">{</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">item</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">It</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">do_smth</span><span class="p">();</span>
<span class="w">      </span><span class="n">user_func</span><span class="p">(</span><span class="n">It</span><span class="p">);</span>
<span class="w">      </span><span class="n">do_smth_else</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="err">“</span><span class="n">One</span><span class="w"> </span><span class="n">shouldn</span><span class="err">’</span><span class="n">t</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="n">message</span><span class="p">.</span><span class="err">“</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this use-case every work-item with even index along 0 dimension will trigger
assertion failure. Assertion failure should trigger a call to <code class="docutils literal notranslate"><span class="pre">std::abort()</span></code> at
host as described in
<a class="reference download internal" download="" href="../_downloads/292bf929b84890cb56c6e35dc55dfc02/sycl_ext_oneapi_assert.asciidoc"><span class="xref download myst">extension</span></a>.
Even though multiple failures of the same or different assertions can happen in
multiple work-items, implementation is required to deliver at least one
assertion. The assertion failure message is printed to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> by DPCPP
Runtime or underlying backend.</p>
<p>When multiple kernels are enqueued and more than one fail at assertion, at least
one assertion should be reported.</p>
</section>
<section id="user-requirements">
<h2>User requirements<a class="headerlink" href="#user-requirements" title="Link to this heading">¶</a></h2>
<p>From user’s point of view there are the following requirements:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p>Title</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Importance</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Abort DPC++ application</p></td>
<td><p>Abort host application when assert function is called and print a message about assertion</p></td>
<td><p>Must have</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Print assert message</p></td>
<td><p>Assert function should print message to stderr at host</p></td>
<td><p>Must have</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Stop under debugger</p></td>
<td><p>When debugger is attached, break at assertion point</p></td>
<td><p>Highly desired</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Reliability</p></td>
<td><p>Assert failure should be reported regardless of kernel deadlock</p></td>
<td><p>Highly desired</p></td>
</tr>
</tbody>
</table>
<p>Implementations without enough capabilities to implement fourth requirement are
allowed to realize the fallback approach described below, which does not
guarantee assertion failure delivery to host, but is still useful in many
practical cases.</p>
</section>
<section id="terms">
<h2>Terms<a class="headerlink" href="#terms" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Device-side Runtime - runtime library supplied by the Native Device Compiler
and running on the device.</p></li>
<li><p>Native Device Compiler - compiler which generates device-native binary image
based on input SPIR-V image.</p></li>
<li><p>Low-level Runtime - the backend/runtime behind DPCPP Runtime attached via the
Plugin Interface.</p></li>
</ul>
</section>
<section id="how-it-works">
<h2>How it works?<a class="headerlink" href="#how-it-works" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">assert(expr)</span></code> macro ends up in call to <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code>. This function
is part of <a class="reference external" href="https://github.com/intel/llvm/blob/sycl/doc/design/DeviceLibExtensions.rst#cl_intel_devicelib_cassert">Device library extension</a>.</p>
<p>The format of the assert message is unspecified, but it will always include the
text of the failing expression, the values of the standard macros <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__LINE__</span></code>, and the value of the standard variable <code class="docutils literal notranslate"><span class="pre">__func__</span></code>. If the failing
assert comes from an <code class="docutils literal notranslate"><span class="pre">nd_range</span></code> <code class="docutils literal notranslate"><span class="pre">parallel_for</span></code> it will also include the global
ID and the local ID of the failing work item.</p>
<p>Implementation of this function is supplied by Native Device Compiler for
safe approach or by DPCPP Compiler for fallback one.</p>
<p>In order to distinguish which implementation to use, DPCPP Runtime checks for
<code class="docutils literal notranslate"><span class="pre">PI_DEVICE_INFO_EXTENSION_DEVICELIB_ASSERT</span></code> extension. If the extension isn’t
available, then fallback implementation is used.</p>
</section>
<section id="safe-approach">
<h2>Safe approach<a class="headerlink" href="#safe-approach" title="Link to this heading">¶</a></h2>
<p>This is the preferred approach and implementations should use it when possible.
It guarantees assertion failure notification delivery to the host regardless of
kernel behavior which hit the assertion. If backend suports the safe approach,
it must report this capability to DPCPP Runtime via the
<code class="docutils literal notranslate"><span class="pre">PI_DEVICE_INFO_EXTENSION_DEVICELIB_ASSERT</span></code> extension query.</p>
<p>The Native Device Compiler is responsible for providing implementation of
<code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> which completely hides details of communication
between the device code and the Low-Level Runtime from the SYCL device compiler
and runtime. The Low-Level Runtime is responsible for:</p>
<ul class="simple">
<li><p>detecting if assert failure took place;</p></li>
<li><p>flushing assert message to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> on host.</p></li>
</ul>
<p>The following sequence of events describes how user code gets notified:</p>
<ul class="simple">
<li><p>Device side:</p>
<ol class="arabic simple">
<li><p>Assert fails in device-code in kernel
// It’s not defined if GPU thread stops execution
// Other GPU threads are left untouched</p></li>
<li><p>Specialized version of <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> is called</p></li>
<li><p>Device immediately signals to host (Low-Level Runtime)</p></li>
</ol>
</li>
<li><p>Host side:</p>
<ol class="arabic simple">
<li><p>The assert failure gets detected by Low-Level Runtime</p></li>
<li><p>Low-Level Runtime prints assert failure message to <code class="docutils literal notranslate"><span class="pre">stderr</span></code></p></li>
<li><p>Low-Level Runtime calls <code class="docutils literal notranslate"><span class="pre">abort()</span></code></p></li>
</ol>
</li>
</ul>
</section>
<section id="fallback-approach">
<h2>Fallback approach<a class="headerlink" href="#fallback-approach" title="Link to this heading">¶</a></h2>
<p>If Device-side Runtime doesn’t support <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> (as reported
via <code class="docutils literal notranslate"><span class="pre">PI_DEVICE_INFO_EXTENSION_DEVICELIB_ASSERT</span></code> extension query) then a fallback
approach comes in place. The approach doesn’t require any support from
Device-side Runtime and Native Device Compiler. Neither it does from Low-level
Runtime.</p>
<p>Within this approach, a mutable program scope variable is introduced. This
variable stores a flag which says if an assert failure was encountered. Fallback
implementation of <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> atomically raises the flag so that
DPCPP Runtime is able to detect assert failure after kernel finishes.</p>
<p>The following sequence of events describes how user code gets notified:</p>
<ul class="simple">
<li><p>Device side:</p>
<ol class="arabic simple">
<li><p>Assert fails in device-code in kernel</p></li>
<li><p>Fallback version of <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> is called</p></li>
<li><p>Assert information is stored into program-scope variable</p></li>
<li><p>Kernel continues running</p></li>
</ol>
</li>
<li><p>Host side:</p>
<ol class="arabic simple">
<li><p>A copy ‘kernel’ is enqueued as the one depending on user’s kernel to get
the value of assert failure flag.</p></li>
<li><p>A host-task is enqueued to check value of assert failure flag.</p></li>
<li><p>The host task calls abort whenever assert failure flag is set.</p></li>
</ol>
</li>
</ul>
<p>DPCPP Runtime will automatically check if assertions are used in the kernel
being run, and won’t enqueue the auxiliary kernels if assertions are not
used. So there is no host-side runtime overhead when assertion are not used.</p>
<p>Illustrating this with an example, lets assume the user enqueues three kernels:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Kernel</span> <span class="pre">#1</span></code>, uses assert</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Kernel</span> <span class="pre">#2</span></code>, uses assert</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Kernel</span> <span class="pre">#3</span></code>, uses assert and depends on <code class="docutils literal notranslate"><span class="pre">Kernel</span> <span class="pre">#1</span></code></p></li>
</ul>
<p>The resulting graph will look like this: <img alt="graph" src="../_images/assert-fallback-graph.svg" /></p>
<section id="interface-to-program-scope-variable">
<h3>Interface to program scope variable<a class="headerlink" href="#interface-to-program-scope-variable" title="Link to this heading">¶</a></h3>
<p>Multiple translation units could be compiled/linked into a single device binary
image. All of them should have <code class="docutils literal notranslate"><span class="pre">extern</span></code> declaration of program scope variable
available. Definition of the variable is only available within devicelib in the
same binary image where fallback <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> resides.</p>
<p id="prog-scope-var-decl"><a name="prog-scope-var-decl">The variable has the following structure and
declaration:</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">__SYCL_AssertHappened</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">Expr</span><span class="p">[</span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">File</span><span class="p">[</span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">Func</span><span class="p">[</span><span class="mi">128</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">Line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">GID0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">GID1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">GID2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">LID0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">LID1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">LID2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#ifdef __SYCL_DEVICE_ONLY__</span>
<span class="k">extern</span><span class="w"> </span><span class="n">SYCL_GLOBAL_VAR</span><span class="w"> </span><span class="n">__SYCL_AssertHappened</span><span class="w"> </span><span class="n">__SYCL_AssertHappenedMem</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">SYCL_GLOBAL_VAR</span></code> is a macro which wraps special attribute to allow for
mutable program-scope variable.</p>
<p>The reference to extern variable is resolved within online-linking against
fallback devicelib.</p>
<section id="description-of-fields">
<h4>Description of fields<a class="headerlink" href="#description-of-fields" title="Link to this heading">¶</a></h4>
<p>The value stored here denotes if assert happened at all. There are two valid
values at host:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>No assert failure detected</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Assert failure detected and reported within this instance of struct</p></td>
</tr>
</tbody>
</table>
<p>At device-side, there’s another valid value: 1, which means that assert failure
is detected and the structure is filling up at the moment. This value is for
device-side only and should never be reported to host. Otherwise, it means, that
atomic operation malfunctioned.</p>
<p><code class="docutils literal notranslate"><span class="pre">Expr</span></code>, <code class="docutils literal notranslate"><span class="pre">File</span></code>, <code class="docutils literal notranslate"><span class="pre">Func</span></code>, <code class="docutils literal notranslate"><span class="pre">Line</span></code> are to describe the assert message itself and
contain the expression, file name, function name, line in the file where assert
failure had happened respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">GID*</span></code> and <code class="docutils literal notranslate"><span class="pre">LID*</span></code> fields describe the global and local ID respectively of a
work-item in which assert had failed.</p>
</section>
</section>
<section id="online-linking-fallback-devicelib-assert-fail">
<h3>Online-linking fallback <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code><a class="headerlink" href="#online-linking-fallback-devicelib-assert-fail" title="Link to this heading">¶</a></h3>
<p>Online linking against fallback implementation of <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> is
performed only when assertion is enabled and Device-side Runtime doesn’t provide
implementation of <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code>.</p>
<p>In DPCPP headers one can see if assert is enabled with status of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro
with <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>’s. When in DPCPP Runtime Library this knowledge is obtained from
device binary image descriptor’s property sets.</p>
<p>Each device image is supplied with an array of property sets. For description
of property sets see <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">pi_device_binary_struct</span></code> in
<a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/include/sycl/detail/pi.h#L692"><code class="docutils literal notranslate"><span class="pre">pi.h</span></code></a></p>
<p>A distinct property set <code class="docutils literal notranslate"><span class="pre">SYCL/assert</span> <span class="pre">used</span></code> is added. In this set a property
with the name of the kernel is added whenever the kernel uses assert. The use of
assert is detected by a specific LLVM IR pass invoked by the <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code>
tool which runs on linked device code, i.e. after linking with the <code class="docutils literal notranslate"><span class="pre">libsycl-crt</span></code>
library which defines the assert function. The pass builds complete call graph
for a kernel, and sees if there’s a call to <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> anywhere
in the graph. If found, <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> adds the property for the kernel.</p>
<p>The same is done for all indirect callable functions (marked with specific
attribute) found in the linked device code. Those are functions whose pointers
can be taken and passed around in device code. If a callgraph for any such
function has a call to <code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code>, then all kernels in the module
are conservatively marked as using asserts.</p>
<p>The added property is used for:</p>
<ul class="simple">
<li><p>deciding if online-linking against fallback devicelib is required;</p></li>
<li><p>if there’s a need to enqueue program scope variable copier kernel and checker
host-task.</p></li>
</ul>
<p>Suppose the following example user code:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">user_func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="err">“</span><span class="n">X</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">nil</span><span class="err">”</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">(...);</span>
<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">handler</span><span class="o">&amp;</span><span class="w"> </span><span class="n">CGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CGH</span><span class="p">.</span><span class="n">single_task</span><span class="p">([</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">do_smth</span><span class="p">();</span>
<span class="w">      </span><span class="n">user_func</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">      </span><span class="n">do_smth_else</span><span class="p">();</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following LLVM IR pseudo code will be generated after linking against
fallback implementation of devicelib:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>@AssertHappenedMem = global AssertHappened

/// user&#39;s code
void user_func(int X) {
if (!(X &amp;&amp; “X is nil&quot;)) {
    __assert_fail(...);
  }
}

kernel(...) {
  do_smth()
  user_func(0);
  do_smth_else();
}

/// __assert_fail belongs to Linux version of devicelib
void __assert_fail(...) {
  ...
  __devicelib_assert_fail(...);
}

void __devicelib_assert_fail(Expr, File, Line, GlobalID, LocalID) {
  ...
  volatile int *Ptr = (volatile int *)AssertHappenedMem.Flag;
  int Expected = 0;
  int Desired = 1;

  if (atomic_CAS(&amp;AssertHappenedMem.Flag, Expected, Desired))
    printf(&quot;Assertion `%s&#39; failed in %s at line %i. GlobalID: %i, LocalID: %i&quot;,
           Expr, File, Line, GlobalID, LocalID);
}
</pre></div>
</div>
<section id="compiling-with-assert-enabled-disabled">
<h4>Compiling with assert enabled/disabled<a class="headerlink" href="#compiling-with-assert-enabled-disabled" title="Link to this heading">¶</a></h4>
<p>Consider the following example sources:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// impl.cpp</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">sycl</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">calculus</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Invalid value&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">enqueueKernel</span><span class="p">(</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">Acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">read_write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
<span class="w">    </span><span class="n">H</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="cm">/* range */</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">item</span><span class="w"> </span><span class="n">It</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">Acc</span><span class="p">[</span><span class="n">It</span><span class="p">]);</span>
<span class="w">      </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>
<span class="c1">// ...</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">sycl</span><span class="p">;</span>

<span class="n">SYCL_EXTERNAL</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">calculus</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">enqueueKernel</span><span class="p">(</span><span class="n">queue</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="o">&amp;</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">workload</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">  </span><span class="n">buffer</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>

<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">Acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">read_write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
<span class="w">    </span><span class="n">H</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="cm">/* range */</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">item</span><span class="w"> </span><span class="n">It</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculus</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// should fail assertion</span>
<span class="w">      </span><span class="n">assert</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Nil in result&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">Acc</span><span class="p">[</span><span class="n">It</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="n">enqueueKernel</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These two files are compiled into a single binary application. There are four
states of definition of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro available:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>#</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">impl.cpp</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">main.cpp</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>defined</p></td>
<td><p>defined</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>defined</p></td>
<td><p>undefined</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>undefined</p></td>
<td><p>defined</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>undefined</p></td>
<td><p>undefined</p></td>
</tr>
</tbody>
</table>
<p>States of definition of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro defines the set of assertions which can
fail.</p>
</section>
</section>
<section id="raising-assert-failure-flag-and-reading-it-on-host">
<h3>Raising assert failure flag and reading it on host<a class="headerlink" href="#raising-assert-failure-flag-and-reading-it-on-host" title="Link to this heading">¶</a></h3>
<p>In DPCPP headers one can see if assert is enabled with status of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro
with <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>’s. Though, in order to support for multi translation unit use-case
it’s not allowed to rely on definition of <code class="docutils literal notranslate"><span class="pre">NDEBUG</span></code> macro.</p>
<p><em>Note: Multi translation unit use-case here is the one with <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code>
function compiled with assertions enabled and used in a kernel  but the kernel
is compiled with assertions disabled.</em></p>
<p>There’re two commands used for reading assert failure flag: copy kernel and
checker host task. The copy kernel will copy <code class="docutils literal notranslate"><span class="pre">AssertHappenedMem</span></code> to host and
host-task will check the <code class="docutils literal notranslate"><span class="pre">Flag</span></code> value and <code class="docutils literal notranslate"><span class="pre">abort()</span></code> as needed. The kernel and
host task are enqueued together with a kernel only when the corresponding device
binary image for this kernel tells that it may use (maybe indirectly) the
<code class="docutils literal notranslate"><span class="pre">assert</span></code> in its code.</p>
<p>All translation units provided by the user should have a declaration of the
assert flag read function available:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">__devicelib_assert_read</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Also, the <a class="reference internal" href="#prog-scope-var-decl">AssertHappened</a> structure type should be
available for the copier kernel.</p>
<p>The definition is only provided within devicelib along with
<code class="docutils literal notranslate"><span class="pre">__devicelib_assert_fail</span></code> function which raises the flag.</p>
<p>Reading of assert failure flag is performed with the help of auxiliary kernel
which is enqueued as dependent on user’s one. The flag state is checked later
in host-task. This is achieved with approximately the following changes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AssertFlagCopier</span><span class="p">;</span>
<span class="cp">#ifdef __SYCL_DEVICE_ONLY__</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">__devicelib_assert_read</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">class</span><span class="w"> </span><span class="nc">queue</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="n">submit</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">CGF</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">event</span><span class="w"> </span><span class="n">Event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">submit_impl</span><span class="p">(</span><span class="n">CGF</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">KernelName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* get kernel name from calls to parallel_for, etc. */</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// assert required</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">get_device</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">assert_fail_supported</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isAssertUsed</span><span class="p">(</span><span class="n">KernelName</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// __devicelib_assert_fail isn&#39;t supported by Device-side Runtime</span>
<span class="w">      </span><span class="c1">// Linking against fallback impl of __devicelib_assert_fail is performed</span>
<span class="w">      </span><span class="c1">// by program manager class</span>
<span class="w">      </span><span class="n">AssertHappened</span><span class="w"> </span><span class="o">*</span><span class="n">AH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AssertHappened</span><span class="p">;</span>
<span class="w">      </span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">AssertHappened</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">Buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">buffer</span><span class="o">&lt;</span><span class="n">AssertHappened</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">AH</span><span class="p">};</span>

<span class="w">      </span><span class="c1">// read flag value</span>
<span class="w">      </span><span class="n">event</span><span class="w"> </span><span class="n">CopierEv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">submit_impl</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">CGH</span><span class="p">.</span><span class="n">depends_on</span><span class="p">(</span><span class="n">Event</span><span class="p">);</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">Acc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Buffer</span><span class="o">-&gt;</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CGH</span><span class="p">);</span>

<span class="w">        </span><span class="n">CGH</span><span class="p">.</span><span class="n">single_task</span><span class="o">&lt;</span><span class="n">AssertFlagCopier</span><span class="o">&gt;</span><span class="p">([</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef __SYCL_DEVICE_ONLY__</span>
<span class="w">          </span><span class="n">Acc</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__devicelib_assert_read</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">      </span><span class="p">});</span>

<span class="w">      </span><span class="c1">// check flag state</span>
<span class="w">      </span><span class="n">submit_impl</span><span class="p">([</span><span class="o">=</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">CGH</span><span class="p">.</span><span class="n">depends_on</span><span class="p">(</span><span class="n">CopierEv</span><span class="p">);</span>

<span class="w">        </span><span class="n">CGH</span><span class="p">.</span><span class="n">codeplay_host_task</span><span class="p">([</span><span class="o">=</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AH</span><span class="o">-&gt;</span><span class="n">Flag</span><span class="p">)</span>
<span class="w">            </span><span class="n">abort</span><span class="p">();</span>

<span class="w">          </span><span class="n">free</span><span class="p">(</span><span class="n">Buffer</span><span class="p">);</span>
<span class="w">          </span><span class="n">free</span><span class="p">(</span><span class="n">AH</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">      </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Event</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="LinkedAllocations.html">Linked allocations</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="SharedLibraries.html">Dynamic linking of device code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>