
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Dynamic linking of device code &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Behavior for optional kernel features" href="OptionalDeviceFeatures.html" />
    <link rel="prev" title="Assert feature" href="Assert.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>Dynamic linking of device code</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="Assert.html">Assert feature</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OptionalDeviceFeatures.html">Behavior for optional kernel features</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section class="tex2jax_ignore mathjax_ignore" id="dynamic-linking-of-device-code">
<h1>Dynamic linking of device code<a class="headerlink" href="#dynamic-linking-of-device-code" title="Permalink to this headline">¶</a></h1>
<p>This document describes purpose and design of dynamic linking of device code
feature.</p>
<p><strong>NOTE</strong>: This is not a final version. The document is still in progress.</p>
<section id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>Sometimes users want to link device code dynamically at run time. One possible
use case for such linkage - providing device functions via shared libraries.
The example below shows how device function <code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> can be dynamically
linked to a SYCL app:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// app.cpp</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">int</span> <span class="nf">LibDeviceFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

<span class="cm">/* ... */</span>
<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
<span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="cm">/* ... */</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">item</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LibDeviceFunc</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">get_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">});</span> <span class="cm">/* ... */</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>

<span class="c1">// lib.cpp</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">int</span> <span class="nf">LibDeviceFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="p">;</span> Commands
clang++ -fsycl lib.cpp -shared -o helpers.so
clang++ -fsycl app.cpp -lhelpers -o a.out
./a.out
Output: <span class="m">0</span> <span class="m">2</span> <span class="m">4</span> <span class="m">6</span> ...
</pre></div>
</div>
<p>The first invocation of <code class="docutils literal notranslate"><span class="pre">clang++</span></code> driver will create a “fat” shared library
which contains both host code and device code. The second invocation of
<code class="docutils literal notranslate"><span class="pre">clang++</span></code> driver will create a “fat” application binary that also contains
embedded device code. Host part of the application and library will be linked
automatically by standard C++ toolchain and system linker, while linking of
device part of the application and library requires new functionality which is
described in this document.</p>
<p>It is possible to manually create <code class="docutils literal notranslate"><span class="pre">sycl::program</span></code> in both app and shared
library, then use <code class="docutils literal notranslate"><span class="pre">link</span></code> SYCL API to get a single program and launch kernels
using it. But this approach is a noticeable deviations from regular C/C++
workflow and requires some amount of source code boilerplate.</p>
<p>Another possible scenario - use functions defined in a pre-compiled device image
provided by the user. Example:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// a.cpp</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibDeviceFunc</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">([]()</span> <span class="p">{</span> <span class="n">LibDeviceFunc</span><span class="p">();</span> <span class="p">});</span>
<span class="p">});</span>

<span class="c1">// b.cpp</span>
<span class="cm">/*no SYCL_EXTERNAL*/</span> <span class="kt">void</span> <span class="nf">LibDeviceFunc</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>We have a <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function <code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> called from a kernel, but the
application defined only host version of this function. Then user adds device
image with definition of <code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> to the fat object via special compiler
option (like <code class="docutils literal notranslate"><span class="pre">-fsycl-add-targets</span></code>).</p>
<p>The main purpose of this feature is to provide a user-friendly mechanism which
allows to link device code dynamically at runtime, such as in the scenarios
above.</p>
</section>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p>User’s device code can be compiled into some form and not linked statically with
device code of application. It can be embedded as a device image into a shared
library or supplied as a separate device image with attached properties. This
code is linked dynamically at run time with device image of a user’s application
in order to resolve dependencies. The requirements listed below must be
satisfied to enable such use case.</p>
<p>The presented dynamic device code linkage mechanism must:</p>
<ul>
<li><p>Allow to link device code represented as device binary image dynamically at
runtime with other device binary images. In order to use this functionality
the user can create and supply device binary image to DPC++ Runtime library
via following ways:</p>
<ul>
<li><p>Create a “fat” shared library by standard SYCL compiler driver invocation</p></li>
<li><p>Supply host binary or shared object with device binary image using manual
invocations of SYCL tools such as <code class="docutils literal notranslate"><span class="pre">clang-offload-wrapper</span></code> and linker</p></li>
<li><p>Load device binary image into memory via dlopen-like API</p>
<ul class="simple">
<li><p>This is a TODO item, since SYCL standard doesn’t define such API yet.
Example how such API may look like:</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// suppose, mylib.spv defines SYCL_EXTERNAL function foo, then this call:</span>
<span class="n">device_image</span> <span class="n">img</span> <span class="o">=</span> <span class="n">device_dlopen</span><span class="p">(</span><span class="s">&quot;mylib.spv&quot;</span><span class="p">);</span>
<span class="c1">// will make foo available for dynamic symbol resolution. If any subsequent</span>
<span class="c1">// JIT compilations try to compile device code with external reference to</span>
<span class="c1">// foo, it can now be resolved following the resolution mechanism described</span>
<span class="c1">// in this doc, and JIT compilation will succeed.</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>Allow different format for device code - e.g. it can be SPIR-V or native
device binary</p></li>
<li><p>Provide automatic runtime resolution of <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function references
within the SYCL app to their definitions (if found) within any suitable
dynamically linked device binary image</p></li>
<li><p>Support pointers to <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions across the dynamic linkage
boundaries within the device code - taking a pointer, call through a pointer.</p></li>
<li><p>Specific code changes are not required, i.e. the mechanism of linking works
as close as possible to host shared libraries.</p></li>
</ul>
</section>
<section id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<p>The overall idea:</p>
<ul class="simple">
<li><p>Each device image is supplied with a list of imported and exported symbol
names through device image properties mechanism</p></li>
<li><p>In order to create a program executable from device image DPC++ RT will check
if this device image has a list of imported symbols and if it has, then RT
will search for device images which define required symbols using lists of
exported symbols.</p>
<ul>
<li><p>Besides symbol names, additional attributes are taken into account (like
device image format: SPIR-V or native device binary)</p></li>
<li><p>No logical binding between host module and export/import lists, i.e.
resolution is performed w/o regard to containing host modules</p></li>
</ul>
</li>
<li><p>All found device images are used to create program objects and then these
programs are linked together.</p></li>
<li><p>Actual linking is performed by underlying backend (OpenCL/L0/etc.)</p>
<ul>
<li><p>Underlying backend is the backend used by DPC++ RT to create program
from device binary image, perform JIT compilation (if required for chosen
device image format) and linking with other programs in order to resolve
symbols.</p></li>
</ul>
</li>
</ul>
<p>Next sections describe details of changes in each component.</p>
<section id="dpc-front-end-changes">
<h3>DPC++ front-end changes<a class="headerlink" href="#dpc-front-end-changes" title="Permalink to this headline">¶</a></h3>
<p>Now during device code split process <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions are
considered as entry points (as well as kernels).
For this purpose DPC++ front-end generates <code class="docutils literal notranslate"><span class="pre">module-id</span></code> attribute on each
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function.</p>
</section>
<section id="sycl-post-link-changes">
<h3>sycl-post-link changes<a class="headerlink" href="#sycl-post-link-changes" title="Permalink to this headline">¶</a></h3>
<p>In order to support dynamic linking of device code, <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> performs
2 main tasks:</p>
<ul class="simple">
<li><p>Supplies device images containing exports with an information about exported
symbols</p></li>
<li><p>Supplies device images with an information about imported symbols</p></li>
</ul>
<p>In addition, <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions as well as kernels are considered as entry
points during device code split.
If device code split is enabled <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions defined in shared
libraries and used within it can be duplicated.
Example:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Shared library</span>

<span class="c1">// A.cpp</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">int</span> <span class="nf">LibDeviceFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// B.cpp</span>
<span class="cm">/* ... */</span>
<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
<span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="cm">/* ... */</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">item</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LibDeviceFunc</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">get_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span> <span class="cm">/* ... */</span>
</pre></div>
</div>
<p>If user requested per-source device code split, then for this shared library
<code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> will create two device images and both of them will define
<code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> function. However <code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> won’t be exported from device
image that corresponds to source file <code class="docutils literal notranslate"><span class="pre">B.cpp</span></code> and it will be exported only from
device image that corresponds to source file where <code class="docutils literal notranslate"><span class="pre">LibDeviceFunc</span></code> was defined,
i.e. <code class="docutils literal notranslate"><span class="pre">A.cpp</span></code>.</p>
<p>Such duplication is needed for two reasons:</p>
<ul class="simple">
<li><p>We aim to make device images with kernels self-contained so no JIT linker
invocations would be needed if we have definitions of all called functions.</p></li>
<li><p>We could export <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions from device images with kernels,
but it would mean that when user’s app calls <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function, it has
to link a whole kernel and all its dependencies - so we leave a possibility
for user to arrange code on per-source basis.</p></li>
</ul>
<p>Non-<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions used by <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions are copied to
device images corresponding to those <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions to make them
self-contained - in the same way as it is done when splitting kernels across
device images.
In case one <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function uses another <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> function
with different value in <code class="docutils literal notranslate"><span class="pre">sycl-module-id</span></code> attribute, the second one is not copied
to the device image with the first function, but dependency between those device
images is recorded instead.</p>
<p>After device code split, all non-<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions and copied
<code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions left in device images with kernels marked with
internal linkage to avoid multiple definition errors during runtime linking.
After that <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> records list of names of exported functions, i.e.
functions with <code class="docutils literal notranslate"><span class="pre">sycl-module-id</span></code> attribute and external linkage.</p>
<p>In order to collect information about imported symbols <code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> looks
through LLVM IR and for each declared but not defined symbol records its
name, except the following cases:</p>
<ul class="simple">
<li><p>Declarations with <code class="docutils literal notranslate"><span class="pre">__</span></code> prefix in demangled name are not recorded as imported
functions</p>
<ul>
<li><p>Declarations with <code class="docutils literal notranslate"><span class="pre">__spirv_*</span></code> prefix should not be recorded as dependencies
since they represent SPIR-V operations and will be transformed to SPIR-V
instructions during LLVM-&gt;SPIR-V translation.</p></li>
</ul>
</li>
<li><p>Based on some attributes (which could be defined later) we may want to avoid
listing some functions as imported ones</p>
<ul>
<li><p>This is needed to have possibility to call device-specific builtins not
starting with <code class="docutils literal notranslate"><span class="pre">__</span></code> by forward-declaring them in DPC++ code</p></li>
</ul>
</li>
</ul>
<p><strong>NOTE</strong>: If device code split is enabled, imports collection is performed after
split and it is performed on separated images.</p>
<p>All collected information is attached to a device image via properties
mechanism.</p>
<p>Each device image is supplied with an array of property sets:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">pi_device_binary_struct</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="c1">// Array of property sets</span>
  <span class="n">pi_device_binary_property_set</span> <span class="n">PropertySetsBegin</span><span class="p">;</span>
  <span class="n">pi_device_binary_property_set</span> <span class="n">PropertySetsEnd</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Each property set is represented by the following struct:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Named array of properties.</span>
<span class="k">struct</span> <span class="n">_pi_device_binary_property_set_struct</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">Name</span><span class="p">;</span>                                <span class="c1">// the name</span>
  <span class="n">pi_device_binary_property</span> <span class="n">PropertiesBegin</span><span class="p">;</span> <span class="c1">// array start</span>
  <span class="n">pi_device_binary_property</span> <span class="n">PropertiesEnd</span><span class="p">;</span>   <span class="c1">// array end</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It contains name of property set and array of properties. Each property is
represented by the following struct:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_pi_device_binary_property_struct</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">Name</span><span class="p">;</span>       <span class="c1">// null-terminated property name</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">ValAddr</span><span class="p">;</span>    <span class="c1">// address of property value</span>
  <span class="kt">uint32_t</span> <span class="n">Type</span><span class="p">;</span>    <span class="c1">// _pi_property_type</span>
  <span class="kt">uint64_t</span> <span class="n">ValSize</span><span class="p">;</span> <span class="c1">// size of property value in bytes</span>
<span class="p">};</span>
</pre></div>
</div>
<p>List of imported symbols is represented as a single property set with name
<code class="docutils literal notranslate"><span class="pre">SYCL/imported</span> <span class="pre">symbols</span></code> recorded in the <code class="docutils literal notranslate"><span class="pre">Name</span></code> field of property set.
Each property in this set holds name of the particular imported symbol recorded
in the <code class="docutils literal notranslate"><span class="pre">Name</span></code> field of the property.
List of exported symbols is represented in the same way, except the
corresponding set has the name <code class="docutils literal notranslate"><span class="pre">SYCL/exported</span> <span class="pre">symbols</span></code>.</p>
</section>
<section id="dpc-runtime-changes">
<h3>DPC++ runtime changes<a class="headerlink" href="#dpc-runtime-changes" title="Permalink to this headline">¶</a></h3>
<p>DPC++ RT performs <em>device images collection</em> task by grouping all device
images required to execute a kernel based on the list of exports/imports, creates
programs using collected images and links them together using PI API.
Resulting program is then added to the cache to avoid repetition of symbol
resolution, compilation, and linking processes for any future attempts to invoke
kernels defined by this program.</p>
<section id="dpc-runtime-plugin-interface-pi-changes">
<h4>DPC++ runtime plugin interface (PI) changes<a class="headerlink" href="#dpc-runtime-plugin-interface-pi-changes" title="Permalink to this headline">¶</a></h4>
<p>During <em>device images collection</em> process RT considers modules as available for
linking using information about ability of chosen device backend to compile
and link programs created from particular device image format. The information
about ability to compile and link particular format of device code is provided
by PI plugin implementation for concrete backend. For this purpose
<code class="docutils literal notranslate"><span class="pre">piDeviceGetInfo</span></code> API is used. For each device image format supported by DPC++
RT PI device extension is defined. Each extension is a string that can be
returned by <code class="docutils literal notranslate"><span class="pre">piDeviceGetInfo</span></code> call with query <code class="docutils literal notranslate"><span class="pre">PI_DEVICE_INFO_EXTENSIONS</span></code>.
Mapping of extension strings and formats that can be linked:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Device image format</p></th>
<th class="head"><p>Extension string</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__SYCL_PI_DEVICE_BINARY_TARGET_SPIRV64</span></code></p></td>
<td><p>“pi_ext_spirv64_linking”</p></td>
<td><p>Linking of SPIR-V 64-bit programs is supported</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__SYCL_PI_DEVICE_BINARY_TARGET_SPIRV64_X86_64</span></code></p></td>
<td><p>“pi_ext_spirv64_x86_64_linking”</p></td>
<td><p>Linking of 64-bit programs that were AOT compiled for CPU device is supported</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">__SYCL_PI_DEVICE_BINARY_TARGET_SPIRV64_GEN</span></code></p></td>
<td><p>“pi_ext_spirv64_gen_linking”</p></td>
<td><p>Linking of 64-bit programs that were AOT compiled for GPU device is supported</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">__SYCL_PI_DEVICE_BINARY_TARGET_SPIRV64_FPGA</span></code></p></td>
<td><p>“pi_ext_spirv64_fpga_linking”</p></td>
<td><p>Linking of 64-bit programs that were AOT compiled for FPGA device is supported</p></td>
</tr>
</tbody>
</table>
<p>To link several device images together <code class="docutils literal notranslate"><span class="pre">piProgramLink</span></code> API will be used.
Depending on concrete plugin implementation and set of device image formats that
can be linked at run-time, <code class="docutils literal notranslate"><span class="pre">piProgramLink</span></code> API may receive programs made from
device images in different formats as inputs (including SPIR-V and native code).</p>
<section id="support-of-runtime-linking-in-backends">
<h5>Support of runtime linking in backends<a class="headerlink" href="#support-of-runtime-linking-in-backends" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><p>The initial implementation will support dynamic linking of device code in SPIR-V
format on OpenCL backend:</p>
<ul>
<li><p>OpenCL plugin will use the existing OpenCL <code class="docutils literal notranslate"><span class="pre">clLinkProgram()</span></code> API to online
link the SPIR-V modules together.</p></li>
<li><p>A new Level Zero API to online link programs on SPIR-V level is required for
better performance.</p></li>
<li><p>While there is no Level Zero API to link programs on SPIR-V level, existing
<code class="docutils literal notranslate"><span class="pre">zeModuleDynamicLink()</span></code> can be used as fallback.</p></li>
</ul>
</li>
<li><p>In order to support dynamic linking of AOT compiled device code the
following should be implemented on backends site:</p>
<ul>
<li><p>AOT compilers must allow to compile SPIR-V modules with unresolved symbols
and produce device code in format that can be linked in run time and allows
to reduce JIT overhead</p></li>
<li><p>OpenCL program binary type <code class="docutils literal notranslate"><span class="pre">CL_PROGRAM_BINARY_TYPE_[COMPILED_OBJECT/LIBRARY]</span></code>
should have native code format or any other format that can be emitted by AOT
compiler and allows to reduce JIT overhead</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="device-images-collection-and-linking">
<h4>Device images collection and linking<a class="headerlink" href="#device-images-collection-and-linking" title="Permalink to this headline">¶</a></h4>
<p>Device images collection and linking of programs is performed by DPC++ Runtime
class named <code class="docutils literal notranslate"><span class="pre">ProgramManager</span></code>.</p>
<p>When the program manager gets a request to create a program object using device
image, it examines its list of imported symbols and finds device images which
export those symbols, then program manager creates programs for each required
device image and links them all together.</p>
<p>All needed device images are found by iterating through all available OS modules
without predefined order and searching for first unresolved symbol in list of
imports of target device image. During search device image format is taken
into account, i.e. only device images that have the same format as target device
image will be considered as suitable ones. Once suitable device image that
contains first symbol is met, remaining exported symbols are checked in found
image. If they match some imported symbols then these matched symbols will be
marked as resolved. The procedure repeats until all imported symbols are marked
as resolved. In case all available device images are viewed, but some imported
symbols remain unresolved, exception will be thrown.</p>
<p>The following assumption is made: each device image represents some combination
of defined symbols (kernels or <code class="docutils literal notranslate"><span class="pre">SYCL_EXTERNAL</span></code> functions) and different
device images either contain exactly the same symbols or not overlapping list
of defined symbols. If this assumption is not correct, there can be two cases:</p>
<ul class="simple">
<li><p>Same symbols have the same definitions. In this case it doesn’t matter which
device image is taken to use duplicated symbol</p></li>
<li><p>Same symbols have different definitions. In this case ODR violation takes
place, such situation leads to undefined behaviour. For more details refer
to <a class="reference external" href="#ODR-violations">ODR violations</a> section.</p>
<ul>
<li><p>The situation when two device images of different formats define the same
symbols with two different definitions is not considered as ODR violation.
In this case the suitable device image will be picked.</p></li>
</ul>
</li>
</ul>
<p>So, it is valid to pick the met first device image which defines required symbol
during search.</p>
</section>
<section id="program-caching">
<h4>Program caching<a class="headerlink" href="#program-caching" title="Permalink to this headline">¶</a></h4>
<p>Existing support for device code caching can be re-used to cache
dynamically linked programs with slight changes.</p>
<section id="in-memory-cache">
<h5>In-memory cache<a class="headerlink" href="#in-memory-cache" title="Permalink to this headline">¶</a></h5>
<p>The existing mechanism of caching can be re-used in presence of dynamic
linking. Example of code when caching mechanism is successfully re-used for
dynamically linked code:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Application</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">();</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="n">InternalKernel</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
<span class="p">});</span> <span class="c1">// 1. Program is compiled, linked and saved in cache</span>
    <span class="c1">// 2. Prepared program is used to enqueue kernel</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">handler</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">([]</span> <span class="p">{</span> <span class="n">LibFunc</span><span class="p">();</span> <span class="p">});</span> <span class="c1">// Prepared program is used to enqueue kernel</span>
<span class="p">});</span>

<span class="c1">// Library</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In current cache structure the programs map’s key consists of four components:
kernel set id, specialization constants values, the device this program is built
for, build options id. In this example Id of kernel set where application’s
kernels can be used to access program cache. However when shared library
defines kernels and these kernels are run by the application unchanged cache
structure may lead to double compilation of the same code. Example of code
that leads to double compilation of library code:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Application</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">();</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">handler</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">([]</span> <span class="p">{</span> <span class="n">LibFunc</span><span class="p">();</span> <span class="p">});</span>  <span class="c1">// Device code for library is</span>
                                            <span class="c1">// compiled and linked together with</span>
                                            <span class="c1">// device code for application, i.e.</span>
                                            <span class="c1">// LibFunc1 and ExternalKernel exist</span>
                                            <span class="c1">// in prepared state</span>
<span class="p">});</span>
<span class="c1">// ...</span>
<span class="n">EnqueueLibraryKernel</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span> <span class="c1">// If cache mechanism is not changed, this line will</span>
                         <span class="c1">// lead to second compilation of ExternalKernel and</span>
                         <span class="c1">// LibFunc</span>

<span class="c1">// Library</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="p">}</span>

<span class="n">EnqueueLibraryKernel</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="n">ExternalKernel</span><span class="o">&gt;</span><span class="p">(...));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Such case can be optimized by bringing nesting into cache keys structure.
Kernel set id can be found for each kernel using its name and OS module it is
coming from. In presence of dynamic linking resulting program can be combined
out of device images which come from different OS modules. So, it should be
possible to find needed program by kernel name and any OS module that was
involved in this program. The new mapping structure is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">kernel</span> <span class="n">name</span><span class="p">}</span> <span class="o">=&gt;</span>
  <span class="p">{</span><span class="n">OSModuleHandle</span><span class="p">,</span> <span class="n">spec</span> <span class="n">const</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">dev</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="n">program</span>
</pre></div>
</div>
<p>I.e. each kernel name is mapped to a set of tuples that consists of OS module,
spec constant values, JIT compiler options and device. Then concrete tuple is
mapped to a program object. Several tuples can be mapped to the same program
object. These tuples are created during process of compilation and symbols
resolution for concrete device image.
When some program is a result of linking several programs from device images
with different OS modules, a tuple is created for each OS module ID.
These tuples are used as nested cache entries after kernel name.
Example of modified cache structure when dynamic linking is involved:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Application</span>
<span class="c1">// OSModule = 1</span>

<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">();</span>
<span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="n">InternalKernel</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">...</span> <span class="p">));</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CGH</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">([]</span> <span class="p">{</span> <span class="n">LibFunc</span><span class="p">();</span> <span class="p">});</span>
<span class="p">});</span>

<span class="n">EnqueueLibraryKernel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="c1">// Library</span>
<span class="c1">// OSModule = 2</span>

<span class="n">SYCL_EXTERNAL</span> <span class="nf">LibFunc</span><span class="p">();</span>

<span class="n">EnqueueLibraryKernel</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="n">ExternalKernel</span><span class="o">&gt;</span><span class="p">(...));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Program</span> <span class="n">cache</span> <span class="n">will</span> <span class="n">have</span> <span class="n">the</span> <span class="n">following</span> <span class="n">structure</span><span class="p">:</span>
 <span class="s2">&quot;InternalKernel&quot;</span> <span class="o">=&gt;</span>
   <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="n">program</span> <span class="mi">1</span>
 <span class="s2">&quot;ExternalKernel&quot;</span> <span class="o">=&gt;</span>
   <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="n">program</span> <span class="mi">1</span>
   <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span> <span class="o">=&gt;</span> <span class="n">program</span> <span class="mi">1</span>
</pre></div>
</div>
<p>However the library code will be compiled twice if kernel from the library
was enqueued before kernels from the application, i.e. in such case:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Application</span>
<span class="n">SYCL_EXTERNAL</span> <span class="kt">void</span> <span class="nf">LibFunc</span><span class="p">();</span>

<span class="n">EnqueueLibraryKernel</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span> <span class="c1">// First, library code is compiled alone since it</span>
                         <span class="c1">// doesn&#39;t have any dependencies</span>
<span class="c1">// ...</span>
<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span> <span class="o">&amp;</span><span class="n">CGH</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">handler</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">([]</span> <span class="p">{</span> <span class="n">LibFunc</span><span class="p">();</span> <span class="p">});</span>  <span class="c1">// Second, library code is compiled</span>
                                            <span class="c1">// and linked together with code of</span>
                                            <span class="c1">// the application</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The kernel caching mechanism is re-used without changes.</p>
</section>
<section id="persistent-cache">
<h5>Persistent cache<a class="headerlink" href="#persistent-cache" title="Permalink to this headline">¶</a></h5>
<p>The documented approach to persistent cache needs to be expanded in presence
of dynamic linking support. One of the identifiers for built image hash is
hash made out of device image used as input for the JIT compilation.
In case when “main” image have imports information, device image hash should be
created from all device images that are necessary to build it, i.e. hash out
of “main” device image and set of images that define all
symbols imported by “main” device image.
The hash string is a result of appending device images. To make order of device
images defined and persistent across runs of the same application, device images
are sorted before they are used to create hash string.
A string made out of names of defined symbols defined by a device image is used
to compare device images during sorting process.</p>
</section>
</section>
</section>
</section>
<section id="corner-cases-and-limitations">
<h2>Corner cases and limitations<a class="headerlink" href="#corner-cases-and-limitations" title="Permalink to this headline">¶</a></h2>
<p>It is not guaranteed that behaviour of host shared libraries and device shared
libraries will always match. There are several cases when behaviours don’t match,
the next sections will cover details of such cases.</p>
<section id="odr-violations">
<h3>ODR violations<a class="headerlink" href="#odr-violations" title="Permalink to this headline">¶</a></h3>
<p>C++ standard defines One Definition Rule as:</p>
<blockquote>
<div><p>Every program shall contain exactly one definition of every non-inline
function or variable that is odr-used in that program outside of a discarded
statement; no diagnostic required.
The definition can appear explicitly in the program, it can be found in the
standard or a user-defined library, or (when appropriate) it is implicitly
defined.</p>
</div></blockquote>
<p>Here is an example:</p>
<p><img alt="ODR violation" src="../_images/ODR-shared-libraries.svg" /></p>
<p>Both libraries libB and libC provide two different definitions of function
<code class="docutils literal notranslate"><span class="pre">b()</span></code>, so this example illustrates ODR violation. Technically this case has
undefined behaviour, however it is possible to run and compile this example on
Linux and Windows. Whereas on Linux only function <code class="docutils literal notranslate"><span class="pre">b()</span></code> from library libB is
called, on Windows both versions of function <code class="docutils literal notranslate"><span class="pre">b()</span></code> are used.
Most of backends online linkers act like static linkers, i.e. just merge
device code from different programs, so it is not possible to correctly imitate
Windows behaviour in device code linking because attempts to do it will result
in multiple definition errors.</p>
<p>Given that, it is not guaranteed that behaviour of shared host libraries and
shared device libraries will always match in case of such ODR violations.</p>
<section id="ld-preload">
<h4>LD_PRELOAD<a class="headerlink" href="#ld-preload" title="Permalink to this headline">¶</a></h4>
<p>Another way to violate ODR is <code class="docutils literal notranslate"><span class="pre">LD_PRELOAD</span></code> environment variable on Linux. It
allows to load specified shared library before any other shared libraries so it
will be searched for symbols before other shared libraries. It allows to
substitute functions from regular shared libraries by functions from preloaded
library.
Device code registration is implemented using global constructors. Order of
global constructors calling is not defined across different translation units,
so with current design of device shared libraries and device code registration
mechanism it is not possible to understand which device code comes from
preloaded library and which comes from regular shared libraries.</p>
<p>Here is an example:</p>
<p><img alt="LD_PRELOAD" src="../_images/LD-preload-shared-libraries.svg" /></p>
<p>“libPreload” library is preloaded using <code class="docutils literal notranslate"><span class="pre">LD_PRELOAD</span></code> environment variable.
In this example, device code from “libPreload” might be registered after
device code from “libA”.</p>
<p>To implement basic support, for each device image we can record name of the
library where this device image comes from and parse content of <code class="docutils literal notranslate"><span class="pre">LD_PRELOAD</span></code>
environment variable to choose the proper images. However such implementation
will only allow to substitute a whole device image and not an arbitrary
function (unless it is the only function in a device image), because partial
substitution will cause multiple definition errors during runtime linking.</p>
</section>
</section>
<section id="run-time-libraries-loading">
<h3>Run-time libraries loading<a class="headerlink" href="#run-time-libraries-loading" title="Permalink to this headline">¶</a></h3>
<p>It is possible to load shared library during run-time. Both Linux and Windows
provide a way to do so (for example <code class="docutils literal notranslate"><span class="pre">dlopen()</span></code> on Linux or <code class="docutils literal notranslate"><span class="pre">LoadLibrary</span></code> on
Windows).
In case run-time loading is used to load some shared library, the symbols from
this shared library do not appear in the namespace of the main program. It means
that even though shared library is loaded successfully in run-time, it is not
possible to use symbols from it directly. The symbols from run-time loaded
library can be accessed by address which can be obtained using corresponding
OS-dependent API (for example <code class="docutils literal notranslate"><span class="pre">dlsym()</span></code> on Linux).</p>
<p>The problem here is that even though symbols from run-time loaded shared
library are not part of application’s namespace, the library is loaded through
standard mechanism, i.e. its global constructors are invoked which means that
device code from it is registered, so it is not possible to
understand whether device code comes from run-time loaded library or not.
If such run-time loaded library exports device symbols and they
somehow match with symbols that actually directly used in device code
somewhere, it is possible that symbols from run-time loaded library
will be unexpectedly used.</p>
<p>To resolve this problem we need to ensure that device code registered from
run-time loaded library appears at the end of symbols search list, however
having that device code registration is triggered by global constructors, it
doesn’t seem possible.</p>
<p>One more possible mitigation would be to record name of the library from which
each symbol should be imported, but it still won’t resolve all potential
issues with run-time library loading, because user can load the library with the
same name as one of the explicitly linked libraries.</p>
</section>
</section>
<section id="related-links">
<h2>Related links<a class="headerlink" href="#related-links" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Test plan for this feature
https://github.com/intel/llvm-test-suite/blob/intel/SYCL/TestPlans/DynamicLinkingTestPlan.md</p></li>
</ol>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="Assert.html">Assert feature</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="OptionalDeviceFeatures.html">Behavior for optional kernel features</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.1.2.
    </div>
  </body>
</html>