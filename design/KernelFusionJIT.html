<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>User driven Kernel Fusion &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Non-Relocatable Device Code" href="NonRelocatableDeviceCode.html" />
    <link rel="prev" title="Implementation design for “device_if” and “device_architecture”" href="DeviceIf.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>User driven Kernel Fusion</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="DeviceIf.html">Implementation design for “device_if” and “device_architecture”</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="NonRelocatableDeviceCode.html">Non-Relocatable Device Code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="user-driven-kernel-fusion">
<h1>User driven Kernel Fusion<a class="headerlink" href="#user-driven-kernel-fusion" title="Link to this heading">¶</a></h1>
<section id="context">
<h2>Context<a class="headerlink" href="#context" title="Link to this heading">¶</a></h2>
<p>To support the <a class="reference external" href="https://github.com/intel/llvm/pull/7098">user driven kernel fusion extension</a> (a presentation can be found <a class="reference external" href="https://github.com/oneapi-src/oneAPI-tab/blob/main/language/presentations/oneAPI-TAB-20220727-Kernel-Fusion.pdf">here</a>).</p>
<p>The basic workflow is shown in the diagram below</p>
<p><img alt="Fusion workflow" src="../_images/KernelFusionRuntimeWorkflow.svg" /></p>
<p>During the SYCL program execution, kernels to be fused are collected in a list in the queue (see <a class="reference internal" href="#scheduler-integration">Scheduler Integration</a> section).
When the fusion of kernels is requested, the SPIR-V modules containing them are passed to the JIT that will perform the fusion process (see <a class="reference internal" href="#fusion-process">Fusion Process</a>).
The fusion JIT will generate a new entry point containing all kernels to fuse and run the optimization pipeline.
The result is a new SPIR-V module that is injected back into the SYCL runtime for execution.</p>
<p>The feature is a pure runtime process, no action at compile time is required at the moment.</p>
<section id="fusion-jit-integration">
<h3>Fusion JIT integration<a class="headerlink" href="#fusion-jit-integration" title="Link to this heading">¶</a></h3>
<p><img alt="Fusion via plugin" src="../_images/RuntimeArchitecture-with-fusion.svg" /></p>
<p>The JIT is integrated into the SYCL runtime via a companion library to <code class="docutils literal notranslate"><span class="pre">libsycl.so</span></code> (Fusion plugin box).
The runtime communicates with the JIT via 2 main entry points: a context object (<code class="docutils literal notranslate"><span class="pre">JITContext</span></code>) and a <code class="docutils literal notranslate"><span class="pre">fuseKernels</span></code> function.</p>
</section>
</section>
<section id="scheduler-integration">
<h2>Scheduler Integration<a class="headerlink" href="#scheduler-integration" title="Link to this heading">¶</a></h2>
<section id="tasks">
<h3>Tasks<a class="headerlink" href="#tasks" title="Link to this heading">¶</a></h3>
<p>The integration of kernel fusion into the scheduling process needs to fulfill three main tasks:</p>
<ol class="arabic simple">
<li><p>Maintain the list of kernels submitted for fusion (the <em>fusion list</em>) for each queue.</p></li>
<li><p>Make sure that the kernel(s) submitted at the end of the fusion process, i.e., either the individual kernels (in case fusion is aborted or <code class="docutils literal notranslate"><span class="pre">cancel_fusion</span></code> is called) or the fused kernel (in case of <code class="docutils literal notranslate"><span class="pre">complete_fusion</span></code>), have the correct requirements &amp; dependencies.</p></li>
<li><p>Synchronization - the extension proposal outlines a number of scenarios in which kernel fusion must be aborted early for synchronization and to avoid circular dependencies in the SYCL RT execution graph.</p></li>
</ol>
<p>To achieve these tasks, the command graph gained a new command node (<code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code>) and the behavior of the queue is modified accordingly.</p>
</section>
<section id="kernelfusioncommand">
<h3>KernelFusionCommand<a class="headerlink" href="#kernelfusioncommand" title="Link to this heading">¶</a></h3>
<p>A part of the necessary functionality is implemented as part of a new <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> as a sub-class of the <code class="docutils literal notranslate"><span class="pre">Command</span></code> class. This class fulfills two of the tasks listed above, as it maintains the fusion list for a queue (1) and allows the detection of scenarios in the scheduler where synchronization is necessary (3), as set out by the kernel fusion extension proposal.</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">queue</span></code> for which <code class="docutils literal notranslate"><span class="pre">start_fusion</span></code> has been called, the <code class="docutils literal notranslate"><span class="pre">GraphBuilder</span></code> maintains one <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> in a map, with the map key being the unique numeric ID introduced for each <code class="docutils literal notranslate"><span class="pre">queue_impl</span></code>.</p>
<p>The execution of the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> (<code class="docutils literal notranslate"><span class="pre">enqueueImp</span></code>) is similar to the <code class="docutils literal notranslate"><span class="pre">EmptyCommand</span></code>, as it simply waits for all its dependencies and then completes.</p>
</section>
<section id="behavior-on-queue-ext-codeplay-start-fusion">
<h3>Behavior on <code class="docutils literal notranslate"><span class="pre">queue::ext_codeplay_start_fusion</span></code><a class="headerlink" href="#behavior-on-queue-ext-codeplay-start-fusion" title="Link to this heading">¶</a></h3>
<p>On a call to <code class="docutils literal notranslate"><span class="pre">ext_codeplay_start_fusion</span></code>, a new <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> with status <code class="docutils literal notranslate"><span class="pre">ACTIVE</span></code> is created and inserted into the map maintained by the <code class="docutils literal notranslate"><span class="pre">GraphBuilder</span></code>, effectively putting the queue into fusion mode.
If a previous <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> for this queue is still present, its status is now set to <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> and it is processed for clean-up (more details on why this is necessary can be found in the section on event handling).</p>
</section>
<section id="behavior-on-queue-submit">
<h3>Behavior on <code class="docutils literal notranslate"><span class="pre">queue::submit</span></code><a class="headerlink" href="#behavior-on-queue-submit" title="Link to this heading">¶</a></h3>
<p>If the queue is not in fusion mode, the behavior of this call remains unchanged. In case the submitted command is not a device kernel, the synchronization rules detailed below and in the kernel fusion extension proposal apply.</p>
<p>In all other cases, the kernel is added to the graph as usual, setting up the necessary dependency edges for all requirements, adding the kernel to the leaves of the memory records, and connecting event dependencies specified for the kernel. However, in contrast to the regular process, the kernel command and potential auxiliary commands (e.g., connection commands for event dependencies across different contexts) are <strong>not</strong> passed to the <code class="docutils literal notranslate"><span class="pre">GraphProcessor</span></code> for enqueueing right away, but rather stored in the fusion list of the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code>. Also, an event dependency between the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> and the newly added kernel command is added to the graph.</p>
</section>
<section id="behavior-on-queue-ext-codeplay-cancel-fusion">
<h3>Behavior on <code class="docutils literal notranslate"><span class="pre">queue::ext_codeplay_cancel_fusion</span></code><a class="headerlink" href="#behavior-on-queue-ext-codeplay-cancel-fusion" title="Link to this heading">¶</a></h3>
<p>If the queue is not in fusion mode, a warning is printed if <code class="docutils literal notranslate"><span class="pre">SYCL_RT_WARNING_LEVEL</span></code> is set to 1 otherwise nothing needs to be done.</p>
<p>Otherwise, as the individual kernels which need to be executed after <code class="docutils literal notranslate"><span class="pre">ext_codeplay_cancel_fusion</span></code> are already correctly added to the graph with all their requirements and event dependencies, the process for <code class="docutils literal notranslate"><span class="pre">ext_codeplay_cancel_fusion</span></code> is comparably simple: The fusion command’s status is changed to <code class="docutils literal notranslate"><span class="pre">CANCELLED</span></code> and the fusion command, all the kernels in the fusion list and all the auxiliary commands associated with them are enqueued to the <code class="docutils literal notranslate"><span class="pre">GraphProcessor</span></code>.</p>
</section>
<section id="behavior-on-queue-ext-codeplay-complete-fusion">
<h3>Behavior on <code class="docutils literal notranslate"><span class="pre">queue::ext_codeplay_complete_fusion</span></code><a class="headerlink" href="#behavior-on-queue-ext-codeplay-complete-fusion" title="Link to this heading">¶</a></h3>
<p>If the queue is not in fusion mode (this might be due to an earlier cancellation on a synchronization event, see section on <a class="reference internal" href="#synchronization-behavior">synchronization</a>), <code class="docutils literal notranslate"><span class="pre">ext_codeplay_complete_fusion</span></code> still needs to return a valid event. More details on how this case is handled can be found in the section on event handling.</p>
<p>If the queue is still in fusion mode, the <code class="docutils literal notranslate"><span class="pre">GraphBuilder</span></code> will call into the <code class="docutils literal notranslate"><span class="pre">jit_compiler</span></code> to try and fuse the fusion list associated with the fusion command (but not the auxiliary commands) into a single command-group.</p>
<p>In case the fusion process in the JIT compiler fails, the fusion will be aborted by calling <code class="docutils literal notranslate"><span class="pre">ext_codeplay_cancel_fusion</span></code>, with the effects described in the corresponding section above.</p>
<p>If the fusion process completes successfully, the event dependencies of the kernels in the fusion list are filtered to remove any event dependencies that are internal to the fused kernel, i.e., dependencies from one kernel in the fusion list to another kernel in the fusion list.</p>
<p>After that, a new <code class="docutils literal notranslate"><span class="pre">ExecCGCommand</span></code> is constructed and placed in the graph instead of the individual kernels in the fusion list. This is implemented by first removing all the individual kernels from the graph, including their requirement and dependency edges, and restoring the leaves for all memory records that the individual kernels had requirements on. Now that the graph state is restored, the new fused kernel command can be added to the graph, using the union of the requirements and event dependencies of the individual kernels, to create all necessary requirements and dependency edges.
Additionally, an event dependency between the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> and the fused kernel <code class="docutils literal notranslate"><span class="pre">ExecCGCommand</span></code> is added to the graph before all auxiliary commands.
The fused kernel and the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> are eventually enqueued to the <code class="docutils literal notranslate"><span class="pre">GraphProcessor</span></code>.
The <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> status is set to <code class="docutils literal notranslate"><span class="pre">COMPLETED</span></code>.</p>
</section>
<section id="internalization-behavior">
<h3>Internalization Behavior<a class="headerlink" href="#internalization-behavior" title="Link to this heading">¶</a></h3>
<p>Users can provide hints to perform local and private promotion of arguments when performing fusion. On local promotion, arguments become <em>local internal</em>, meaning memory is shared between work-items of the same work-group. On the other hand, on private promotion, they become <em>private internal</em>, meaning memory is private to each work-item.</p>
<p>Local internalization is implemented by replacing the pointer to global memory corresponding to the argument to be promoted with a new argument being a pointer to local memory. The size of the local memory region will be <code class="docutils literal notranslate"><span class="pre">original_size</span> <span class="pre">/</span> <span class="pre">num_work_groups</span></code>, being <code class="docutils literal notranslate"><span class="pre">original_size</span></code> the number of elements in the accessor argument. Note that an ND-range kernel (parametrized by a <code class="docutils literal notranslate"><span class="pre">sycl::nd_range</span></code>) has to be used to perform local internalization.</p>
<p>Private internalization is implemented by dropping the pointer to global memory corresponding to the argument to be promoted and using a pointer to a private memory allocation instead. The size of the private memory allocation will be <code class="docutils literal notranslate"><span class="pre">original_size</span> <span class="pre">/</span> <span class="pre">global_size</span></code>. Note that a basic kernel (parametrized by a <code class="docutils literal notranslate"><span class="pre">sycl::range</span></code>) can be used to perform private internalization.</p>
<p>As the promoted address space will be potentially smaller than the original one, each access has to be remapped accordingly. Our current approach is to replace each access <code class="docutils literal notranslate"><span class="pre">ptr</span> <span class="pre">+</span> <span class="pre">offset</span></code> to <code class="docutils literal notranslate"><span class="pre">ptr</span> <span class="pre">+</span> <span class="pre">offset</span> <span class="pre">%</span> <span class="pre">new_size</span></code>. Users should be aware of this transformation and write their code carefully, making sure the resulting memory access pattern is legal and respects the original program semantics.</p>
<p>As kernel fusion supports fusing kernel with different ND-ranges, in some cases, internalization will be affected. For both local and private internalization, internalization when fusing kernels with different ND-ranges is allowed as long as the size of the memory allocations replacing the original argument are the same for all kernels using the argument to be promoted. Meaning:</p>
<ul class="simple">
<li><p>For local internalization: all kernels specify a local size and <code class="docutils literal notranslate"><span class="pre">original_size</span> <span class="pre">/</span> <span class="pre">num_work_groups</span></code> is the same for all kernels;</p></li>
<li><p>For private internalization: <code class="docutils literal notranslate"><span class="pre">original_size</span> <span class="pre">/</span> <span class="pre">global_size</span></code> is the same for all kernels.</p></li>
</ul>
</section>
<section id="synchronization-behavior">
<h3>Synchronization Behavior<a class="headerlink" href="#synchronization-behavior" title="Link to this heading">¶</a></h3>
<p>As described in the <a class="reference external" href="https://github.com/intel/llvm/pull/7098">kernel fusion extension proposal</a>, several scenarios require aborting the fusion early to avoid semantic violations or circular dependencies in the execution graph. Essentially, this affects all commands that do not become part of the fusion process, e.g., kernels on other queues, host tasks, or explicit memory operations, that have a dependency on at least one of the kernels in the current fusion list due to a requirement or event dependency.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GraphProcessor</span></code> is able to detect such scenarios. Independent of the actual command requiring synchronization, all execution paths end up enqueueing the command itself and/or its dependencies to  <code class="docutils literal notranslate"><span class="pre">GraphProcessor::enqueueCommand</span></code> . This member function is responsible for detecting if any of the commands enqueued is associated with an active <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code>. If that is the case, the enqueue process is paused and the fusion on the queue associated with the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> is canceled, identical to an explicit call to <code class="docutils literal notranslate"><span class="pre">queue::ext_codeplay_cancel_fusion</span></code> as described above.</p>
<p>The detection at this stage is possible because even if the queue is in fusion mode, the individual kernels in the fusion list are added to the graph (and the leaves of memory records) such that other commands not part of the fusion process can correctly register them in their dependencies.</p>
<p>Special case treatment and earlier detection during graph-construction in the <code class="docutils literal notranslate"><span class="pre">GraphBuilder</span></code> are necessary for the case where commands submitted to one queue have requirements or dependencies on commands submitted to another queue in fusion mode.</p>
<p>If the fusion for a queue is aborted early, a warning can be printed to inform the user. This warning can be enabled by setting the environment variable <code class="docutils literal notranslate"><span class="pre">SYCL_RT_WARNING_LEVEL</span></code> to a value of  <code class="docutils literal notranslate"><span class="pre">1</span></code> or higher.</p>
</section>
<section id="event-handling">
<h3>Event Handling<a class="headerlink" href="#event-handling" title="Link to this heading">¶</a></h3>
<p>The calls to <code class="docutils literal notranslate"><span class="pre">queue::submit</span></code> as well as to <code class="docutils literal notranslate"><span class="pre">queue::ext_codeplay_complete_fusion</span></code> need to return an event to allow synchronization with the execution of submitted kernels or the fused kernel.</p>
<p>Returning the event associated with the individual kernels (<code class="docutils literal notranslate"><span class="pre">ExecCGCommand</span></code>) from <code class="docutils literal notranslate"><span class="pre">queue::submit</span></code> while in fusion mode would mean that these events become useless if the fusion mode is later on completed successfully because the individual kernels are removed from the graph and never executed in this case.</p>
<p>To overcome this problem, a call to <code class="docutils literal notranslate"><span class="pre">queue::submit</span></code> while in fusion mode will instead return the event associated with the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code>.
This event will always remain valid and allow for synchronization, independent of whether the fusion mode was terminated through early cancellation, <code class="docutils literal notranslate"><span class="pre">ext_codeplay_cancel_fusion</span></code>, or <code class="docutils literal notranslate"><span class="pre">ext_codeplay_complete_fusion</span></code>, as the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> in all these scenarios has event dependencies on all relevant commands.</p>
<p>Another important scenario is a call to <code class="docutils literal notranslate"><span class="pre">ext_codeplay_complete_fusion</span></code> after the fusion for this queue has been aborted early (see section on <a class="reference internal" href="#synchronization-behavior">Synchronization Behavior</a>).
In this case, the individual kernels and the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> could have been enqueued and even executed long ago, but the call to <code class="docutils literal notranslate"><span class="pre">ext_codeplay_complete_fusion</span></code> still needs to return a valid event for synchronization.
To handle this case, the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> for each queue remains in the fusion map until the next <code class="docutils literal notranslate"><span class="pre">ext_codeplay_start_fusion</span></code> on the same queue and does not undergo the cleanup process until its status has been set to <code class="docutils literal notranslate"><span class="pre">DELETE</span></code> by <code class="docutils literal notranslate"><span class="pre">ext_codeplay_start_fusion</span></code>.
This way, the lifetime of the event associated with the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> is extended such that it is still valid for synchronization when returned from a later call to <code class="docutils literal notranslate"><span class="pre">ext_codeplay_complete_fusion</span></code>.</p>
<p>Note that even though the <code class="docutils literal notranslate"><span class="pre">KernelFusionCommand</span></code> is associated with a particular queue and context, the associated event does not have an underlying PI event, i.e., it is essentially a host event.</p>
</section>
</section>
<section id="fusion-process">
<h2>Fusion Process<a class="headerlink" href="#fusion-process" title="Link to this heading">¶</a></h2>
<p>To fuse kernels, a small LLVM based JIT compiler (later just JIT for brevity) is responsible to perform the following tasks:</p>
<ul class="simple">
<li><p>Load input modules in LLVM IR format (translate SPIR-V module to LLVM IR for now)</p></li>
<li><p>Fuse kernels in a new module</p></li>
<li><p>Perform fusion specific optimization</p></li>
<li><p>Finalize for the target (emit SPIR-V module for now)</p></li>
</ul>
<p>The pipeline is triggered by the SYCL runtime by calling the <code class="docutils literal notranslate"><span class="pre">fuseKernels</span></code> function and its result is then injected into the runtime as a kernel bundle.</p>
<p>The fusion specific optimization is composed of new LLVM passes we wrote for this task.</p>
<p>The rest of the code is just plumbing code to build the pipeline. The SPIR-V loading and emission are done by the LLVM-SPIRV-Translator.</p>
<section id="kernel-fusion-pipeline">
<h3>Kernel fusion pipeline<a class="headerlink" href="#kernel-fusion-pipeline" title="Link to this heading">¶</a></h3>
<p>The kernel fusion process is triggered by the <code class="docutils literal notranslate"><span class="pre">fuseKernels</span></code> function from the fusion JIT module.
It takes as parameters the information required for the fusion: a context, a list of information about kernels to be fused, an ordered list of kernels to fuse (the same kernel may appear more than once), the name of the fused kernel, a list of identical parameters, and a list of buffers to promote to private or local memory and constant from the runtime to inject into the module.</p>
<p>The function creates a new LLVM module with a stub function that will become the fused kernel and adds the kernels to fuse and their dependencies into this module.
In the case the original module is SPIR-V, the module is first translated to LLVM IR and then added to the module.
Information about the fusion is registered within the module by attaching metadata to the stub function (see section <a class="reference internal" href="#passing-information-to-the-fusion-pipeline">Passing information to the fusion pipeline</a>) and runs the fusion and optimization pipeline.</p>
<p>The pipeline currently consists of the following passes (in order):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SYCLKernelFusion</span></code> performs the actual fusion process by inlining kernels to fuse inside the fused kernel. In case not all kernels being fused share the same nd-range, it also handles work-items remapping (<a class="reference internal" href="#fusing-kernels-with-different-nd-ranges">see</a>)</p></li>
<li><p>Generic optimization passes: <code class="docutils literal notranslate"><span class="pre">IndVarSimplifyPass</span></code>, <code class="docutils literal notranslate"><span class="pre">LoopUnrollPass</span></code>, <code class="docutils literal notranslate"><span class="pre">SROAPass</span></code>, <code class="docutils literal notranslate"><span class="pre">InferAddressSpacesPass</span></code> to remove pointers to the generic address-space</p>
<ul>
<li><p>These optimizations are important to help the internalizer, see note below.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">SYCLInternalizer</span></code> promotes buffer to local or private memory</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SYCLCP</span></code> propagates runtime information as constant in the kernel</p></li>
<li><p>Generic optimization passes post-fusion: <code class="docutils literal notranslate"><span class="pre">SROAPass</span></code>, <code class="docutils literal notranslate"><span class="pre">SCCPPass</span></code>, <code class="docutils literal notranslate"><span class="pre">InstCombinePass</span></code>, <code class="docutils literal notranslate"><span class="pre">SimplifyCFGPass</span></code>, <code class="docutils literal notranslate"><span class="pre">SROAPass</span></code>, <code class="docutils literal notranslate"><span class="pre">InstCombinePass</span></code>, <code class="docutils literal notranslate"><span class="pre">SimplifyCFGPass</span></code>, <code class="docutils literal notranslate"><span class="pre">ADCEPass</span></code>, <code class="docutils literal notranslate"><span class="pre">EarlyCSEPass</span></code></p></li>
</ul>
<p>Note: ideally the <code class="docutils literal notranslate"><span class="pre">InferAddressSpacesPass</span></code> task should be done by the static compiler.
However, to help the inference and (in fine) the internalizer passes in general, we need to run optimizations more aggressively than the static currently does.
The main barrier that could prevent the internalization of buffers is the presence of generic pointers.
As we need to change a pointer to generic to a pointer to private / local, if it is casted to generic we need to ensure that any casts back
to global can be safely changed to the proper address space.
A more precise inference pass and memory analysis will be required to lift this workaround.</p>
<p>Once the pipeline is finished, the module is translated into a SPIR-V module and encapsulated into a <code class="docutils literal notranslate"><span class="pre">SYCLKernelInfo</span></code> object containing metadata required for its injection into the runtime.</p>
</section>
<section id="passing-information-to-the-fusion-pipeline">
<h3>Passing information to the fusion pipeline<a class="headerlink" href="#passing-information-to-the-fusion-pipeline" title="Link to this heading">¶</a></h3>
<p>Most of the information passed from the runtime into the JIT is stored as metadata inside the LLVM module the JIT creates.
This eases lit testing as all the information is self-contained in the module.</p>
<p>The metadata is attached to a function that will become the fused kernel:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.fused</span></code>: declare the kernels to fuse. Contains a list of kernel names to fuse.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.param</span></code>: declare identical parameters. Contains a list of tuples, each tuple represents identical arguments and each element of that tuple contains a pair of indexes referencing the kernel index in <code class="docutils literal notranslate"><span class="pre">sycl.kernel.fused</span></code> and the parameter index of that kernel (0 indexed). For instance ((0,1),(2,3)) means the second argument of the first kernel is identical to the fourth argument of the third kernel.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.promote</span></code>: declare identical parameters to be promoted. Contains a list of strings specifying promotion hints for each argument: <code class="docutils literal notranslate"><span class="pre">none</span></code> for no promotion and <code class="docutils literal notranslate"><span class="pre">local</span></code>/<code class="docutils literal notranslate"><span class="pre">private</span></code> for local/private promotion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.promote.localsize</span></code>: declare the address space size for the promoted memory. Contains a list specifying the number of elements in the replacement memory allocation for each argument or <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> when no promotion needs to be performed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.promote.elemsize</span></code>: declare the element size for the promoted memory. Contains a list specifying the element size for each promoted argument or <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> when no promotion needs to be performed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.constants</span></code>: declare the value of a scalar or aggregate to be used as constant values. Contains a list of indexes (of the fused kernel, after identical arguments elision) and the value as a string. Note: the string is used to store the value, the string is read as a buffer of char and reinterpreted into the value of the argument’s type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.nd-range</span></code>: declare the nd-range to be used by the fused kernel in case work-item remapping was needed. It is a tuple with 4 elements:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">num_dims</span></code>: scalar integer representing the number of dimensions of the nd-range;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_size</span></code>: triple representing nd-range global size, an element for each dimension, using <code class="docutils literal notranslate"><span class="pre">0</span></code> for unused dimensions;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code>: triple representing nd-range local size, an element for each dimension, using <code class="docutils literal notranslate"><span class="pre">0</span></code> for unused dimensions. If the local size is not specified, all elements will be 0;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: triple representing nd-range offset, an element for each dimension, using <code class="docutils literal notranslate"><span class="pre">0</span></code> for unused dimensions.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl.kernel.nd-ranges</span></code>: declare the nd-ranges of each original kernels. This information is used by the <code class="docutils literal notranslate"><span class="pre">SYCLKernelFuson</span></code> pass to perform work-item remapping. It is a list with references to tuples as the one contained in <code class="docutils literal notranslate"><span class="pre">sycl.kernel.nd-range</span></code>. Constraints on the legal combinations of nd-ranges are described in <a class="reference internal" href="#fusing-kernels-with-different-nd-ranges">the corresponding section</a>.</p></li>
</ul>
</section>
<section id="fusing-kernels-with-different-nd-ranges">
<h3>Fusing kernels with different nd-ranges<a class="headerlink" href="#fusing-kernels-with-different-nd-ranges" title="Link to this heading">¶</a></h3>
<p>This section explains actions performed by the kernel fusion JIT compiler when fusing kernels with different nd-ranges. Throughout this section, we refer to “work-item components”. A comprehensive list of these components mentioned in this document is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">global_size</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_id</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group_id</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_offset</span></code></p></li>
</ul>
<p>The meaning of each of these is self-explainatory for the SYCL user.</p>
<section id="restrictions">
<h4>Restrictions<a class="headerlink" href="#restrictions" title="Link to this heading">¶</a></h4>
<p>Following kernel fusion principles, SYCL constraints and technical decisions, some basic constraints are set for valid combinations of nd-ranges:</p>
<ol class="arabic simple">
<li><p>The fused kernel should perform no more visible work than the union of the unfused kernels;</p></li>
<li><p>The fused kernel should perform no less visible work than the union of the unfused kernels;</p></li>
<li><p>If two work items belong to the same work-group in one of the unfused grids, they must also belong to the same work-group in the fused grid;</p></li>
<li><p>Either none or all of the work-items of a work-group must execute barriers inserted by the kernel fusion process;</p></li>
<li><p>The fused kernel must not launch more work-items than the maximum number of work-items launched by the original kernels.</p></li>
<li><p>All work-groups will be the same size, <a class="reference external" href="https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#_work_group_data_parallel_kernels">as per the SYCL 2020 rev 7. 3.9.4</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id(i)</span> <span class="pre">=</span> <span class="pre">group_id(i)</span> <span class="pre">*</span> <span class="pre">local_size(i)</span> <span class="pre">+</span> <span class="pre">local_id(i)</span></code> <a class="reference external" href="https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_API.html#_mapping_work_items_onto_an_ndrange">as per OpenCL 3.0 3.2.1</a>.</p></li>
<li><p>A work-item will have the same global linear id in the fused grid as in the unfused grid;</p></li>
<li><p>All the fused nd-ranges must have the same offset.</p></li>
</ol>
<p>These restrictions can be simplified to:</p>
<ul class="simple">
<li><p>No two local sizes specified by the nd-ranges will be different;</p></li>
<li><p>No global id remapping is needed (<a class="reference internal" href="#work-item-remapping">see</a>) or all input offsets are 0;</p></li>
<li><p>All the fused nd-ranges must have the same offset;</p></li>
<li><p>No global id remapping is needed for kernels specifying a local size.</p></li>
</ul>
<p>As we can see, there is no restrictions in the number of dimensions or global sizes of the input nd-ranges.</p>
</section>
<section id="work-item-remapping">
<h4>Work-item remapping<a class="headerlink" href="#work-item-remapping" title="Link to this heading">¶</a></h4>
<p>Work-item remapping is performed at the input kernel level, i.e., a different remapping is performed for each input kernel, as different input nd-ranges will result in different remappings.</p>
<p>This remapping consists on an inter-procedural pass replacing each built-in querying components of a work-item, e.g., the global id or the local size, with a JIT-generated value.</p>
<p>First of all, work-item remapping will always be performed when the list of input nd-ranges is heterogeneous. Additional remapping conditions are present for the following work-item components. For each input kernel:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code> and <code class="docutils literal notranslate"><span class="pre">local_size</span></code>: Only performed if the input nd-range has an explicit local size, may result in better performance, as this replaces built-in calls with constants;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id</span></code>: Only needed if the number of dimensions differ w.r.t. that of the fused kernel or any component of the global size in the range [2, <code class="docutils literal notranslate"><span class="pre">num_dims</span></code>] differs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_id</span></code> and <code class="docutils literal notranslate"><span class="pre">group_id</span></code>: Never needed as per <a class="reference internal" href="#restrictions">kernel fusion restrictions</a>. These are invariant after fusion.</p></li>
</ul>
<p>Once this rules are set, also taking into account remapping constraints, the remapping is performed as follows for each input kernel:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">global_id</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id(0)</span> <span class="pre">=</span> <span class="pre">GLID</span> <span class="pre">/</span> <span class="pre">(global_size(1)</span> <span class="pre">*</span> <span class="pre">global_size(2))</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id(1)</span> <span class="pre">=</span> <span class="pre">(GLID</span> <span class="pre">/</span> <span class="pre">global_size(2))</span> <span class="pre">%</span> <span class="pre">global_size(1)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id(2)</span> <span class="pre">=</span> <span class="pre">GLID</span> <span class="pre">%</span> <span class="pre">global_size(2)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups(x)</span> <span class="pre">=</span> <span class="pre">global_size(x)</span> <span class="pre">/</span> <span class="pre">local_size(x)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_size</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">global_size(x)</span> <span class="pre">=</span> <span class="pre">GS(x)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size(x)</span> <span class="pre">=</span> <span class="pre">LS(x)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_offset</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">global_offset(x)</span> <span class="pre">=</span> <span class="pre">GO(x)</span></code></p></li>
</ul>
</li>
</ul>
<p>On the RHS of the expressions, component names refer to the remapped values and upper case <code class="docutils literal notranslate"><span class="pre">GS</span></code>, <code class="docutils literal notranslate"><span class="pre">LS</span></code> and <code class="docutils literal notranslate"><span class="pre">GO</span></code> values refer to each of the components of the original nd-range (global size, local size and global offset), whereas <code class="docutils literal notranslate"><span class="pre">GLID</span></code> refers to the global linear id, which is an invariant during the fusion process.</p>
<p>Special care needs to be taken when handling elements from the original nd-range, as the input index needs to be remapped to take into account different array subscript ordering of the underlying API w.r.t. SYCL. See <a class="reference external" href="https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:opencl:kernel-conventions-sycl">SYCL 2020 rev. 7 C.7.7</a> for more information on this index remapping.</p>
<p><strong>Note</strong>: As there is no <code class="docutils literal notranslate"><span class="pre">global_id</span></code> counterpart for PTX, global id is specified as <code class="docutils literal notranslate"><span class="pre">global_id(i)</span> <span class="pre">=</span> <span class="pre">group_id(i)</span> <span class="pre">*</span> <span class="pre">local_size(i)</span> <span class="pre">+</span> <span class="pre">local_id(i)</span> <span class="pre">+</span> <span class="pre">global_offset(i)</span></code>. This way, when targetting PTX, <code class="docutils literal notranslate"><span class="pre">local_size</span></code>, <code class="docutils literal notranslate"><span class="pre">local_id</span></code> and <code class="docutils literal notranslate"><span class="pre">group_id</span></code> will need special treatment <strong>when no explicit local size is provided</strong>. In this particular case, remapping will take place as follows (also respecting original constraints):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups(x)</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">group_id</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">group_id(x)</span> <span class="pre">=</span> <span class="pre">0</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size(x)</span> <span class="pre">=</span> <span class="pre">GS(x)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_id</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">local_id(x)</span> <span class="pre">=</span> <span class="pre">global_id(x)</span></code></p></li>
</ul>
</li>
</ul>
<section id="remapped-spir-v-built-ins">
<h5>Remapped SPIR-V built-ins<a class="headerlink" href="#remapped-spir-v-built-ins" title="Link to this heading">¶</a></h5>
<p>Following <a class="reference external" href="https://registry.khronos.org/OpenCL/specs/3.0-unified/html/OpenCL_Env.html#_built_in_variables">OpenCL SPIR-V Environment Specification 3.0 2.9</a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">global_size</span></code>: <code class="docutils literal notranslate"><span class="pre">GlobalSize</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code>: <code class="docutils literal notranslate"><span class="pre">WorkgroupSize</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code>: <code class="docutils literal notranslate"><span class="pre">NumWorkgroups</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_id</span></code>: <code class="docutils literal notranslate"><span class="pre">GlobalInvocationId</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_id</span></code>: <code class="docutils literal notranslate"><span class="pre">LocalInvocationId</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group_id</span></code>: <code class="docutils literal notranslate"><span class="pre">WorkgroupId</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_offset</span></code>: <code class="docutils literal notranslate"><span class="pre">GlobalOffset</span></code></p></li>
</ul>
</section>
<section id="remapped-ptx-intrinsics">
<h5>Remapped PTX intrinsics<a class="headerlink" href="#remapped-ptx-intrinsics" title="Link to this heading">¶</a></h5>
<p>Following <a class="reference external" href="https://llvm.org/docs/NVPTXUsage.html#llvm-nvvm-read-ptx-sreg">User Guide for NVPTX</a> and <a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/design/CompilerAndRuntimeDesign.md#global-offset-support">Compiler and runtime design #global-offset-support</a>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">local_id</span></code>: <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.tid.*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group_id</span></code>: <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.sreg.ctaid.*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code>: <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.ntid.*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_work_groups</span></code>: <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.read.ptx.nctaid.*</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_offset</span></code>: <code class="docutils literal notranslate"><span class="pre">llvm.nvvm.implicit.offset</span></code></p></li>
</ul>
</section>
</section>
</section>
<section id="support-for-non-spir-v-targets">
<h3>Support for non SPIR-V targets<a class="headerlink" href="#support-for-non-spir-v-targets" title="Link to this heading">¶</a></h3>
<p>Fusion is currently supported for the NVPTX/CUDA and HIP backend.</p>
<p>As this backend cannot ingest a SPIR-V module, additional changes to the
compilation flow are necessary. During static compilation the LLVM module for
this backend is stored in addition to the finalized binary.</p>
<p>This behavior is controlled by the <code class="docutils literal notranslate"><span class="pre">-fsycl-embed-ir</span></code> flag to avoid binary
inflation in case kernel fusion is not used. If users want to use kernel fusion
at runtime on the NVPTX/HIP backend, they need to pass the <code class="docutils literal notranslate"><span class="pre">-fsycl-embed-ir</span></code>
flag during static compilation.</p>
<p>During the fusion process at runtime, the JIT will load the LLVM IR and
finalize the fused kernel to the final target. More information is available
<a class="reference internal" href="CompilerAndRuntimeDesign.html#kernel-fusion-support"><span class="std std-ref">here</span></a>.</p>
</section>
<section id="interaction-with-parallel-for-range-rounding">
<h3>Interaction with <code class="docutils literal notranslate"><span class="pre">parallel_for</span></code> range rounding<a class="headerlink" href="#interaction-with-parallel-for-range-rounding" title="Link to this heading">¶</a></h3>
<p>DPCPP’s <a class="reference internal" href="ParallelForRangeRounding.html"><span class="std std-doc">range rounding</span></a> transformation is
transparent for fusion, meaning the generated wrapper kernel with the rounded up
range will be used.</p>
<p><a class="reference internal" href="#internalization-behavior">Private internalization</a> is supported when fusing
such kernels. We use the original, unrounded global size in dimension 0 when
computing the private memory size. As range rounding only applies to basic
kernels (parametrized by a <code class="docutils literal notranslate"><span class="pre">sycl::range</span></code>), local internalization is not affected
by the range rounding transformation.</p>
</section>
<section id="reductions">
<h3>Reductions<a class="headerlink" href="#reductions" title="Link to this heading">¶</a></h3>
<p>Kernel fusion of reductions is partially supported. In order to preserve the
legality of the fused kernel, i.e., the fact that fused kernel must perform the
same work as the graph of kernels to be fused, only the fusion of the following
reduction strategies is supported at the time of writing:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">group_reduce_and_last_wg_detection</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_atomic_and_atomic_cross_wg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">range_basic</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">group_reduce_and_atomic_cross_wg</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">local_mem_tree_and_atomic_cross_wg</span></code></p></li>
</ul>
<p>Other strategies require implicit inter-work-group synchronization, not
supported in kernel fusion.</p>
<p>Users may encounters errors, e.g., fusion being aborted or incorrect results due
to race conditions or any other cause, when using the <code class="docutils literal notranslate"><span class="pre">sycl::reduction</span></code>
interface. The SYCL runtime will choose different algorithms depending on the
reduction operator, data type and hardware capabilities, so strategy selection
is not possible through the regular interface. In this case, users can instead
use <code class="docutils literal notranslate"><span class="pre">sycl::detail::reduction_parallel_for</span></code>, forcing a supported fusion
strategy. Reductions implementation in
<a class="reference download internal" download="" href="../_downloads/c05ebb4c5211de13f965d2835abc4c6e/reduction.hpp"><span class="xref download myst"><code class="docutils literal notranslate"><span class="pre">sycl/reduction.hpp</span></code></span></a> might give users an
insight into which kind of reductions to use for their purposes:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="nf">in</span><span class="p">(</span><span class="n">dataBuf</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">read_only</span><span class="p">);</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">reduction</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">sumBuf</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;&gt;</span><span class="p">{});</span>
<span class="w">  </span><span class="c1">// Force supported &#39;group_reduce_and_last_wg_detection&#39; strategy</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">reduction_parallel_for</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">auto_name</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">strategy</span><span class="o">::</span><span class="n">group_reduce_and_last_wg_detection</span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
<section id="group-algorithms-and-functions">
<h3>Group Algorithms and Functions<a class="headerlink" href="#group-algorithms-and-functions" title="Link to this heading">¶</a></h3>
<p>Kernel fusion supports group algorithms and functions. As per <a class="reference internal" href="#work-item-remapping">remapping
rules</a>, group ID and local ID are invariant after fusion
even when different ND-ranges are involved. This way, group functions and
algorithms conceptually executed for a given group and using a given local ID
as, e.g., the <code class="docutils literal notranslate"><span class="pre">group_broadcast</span></code> local ID, will keep semantics after fusion.</p>
</section>
<section id="unsupported-sycl-constructs">
<h3>Unsupported SYCL constructs<a class="headerlink" href="#unsupported-sycl-constructs" title="Link to this heading">¶</a></h3>
<p>The following SYCL API constructs are currently not officially supported for
kernel fusion and should be considered untested/unsupported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl::stream</span></code></p></li>
<li><p>Specialization constants and <code class="docutils literal notranslate"><span class="pre">sycl::kernel_handler</span></code></p></li>
<li><p>Images (<code class="docutils literal notranslate"><span class="pre">sycl::unsampled_image</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::sampled_image</span></code>)</p></li>
</ul>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="DeviceIf.html">Implementation design for “device_if” and “device_architecture”</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="NonRelocatableDeviceCode.html">Non-Relocatable Device Code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>