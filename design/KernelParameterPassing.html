<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SYCL Kernel Parameter Handling and Array Support &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The DPC++ Runtime Plugin Interface." href="PluginInterface.html" />
    <link rel="prev" title="oneAPI DPC++ Compiler and Runtime architecture design" href="CompilerAndRuntimeDesign.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>SYCL Kernel Parameter Handling and Array Support</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="CompilerAndRuntimeDesign.html">oneAPI DPC++ Compiler and Runtime architecture design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PluginInterface.html">The DPC++ Runtime Plugin Interface.</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="sycl-kernel-parameter-handling-and-array-support">
<h1>SYCL Kernel Parameter Handling and Array Support<a class="headerlink" href="#sycl-kernel-parameter-handling-and-array-support" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>This document describes how parameters of SYCL kernels are passed
from host to device. Support for arrays as kernel parameters was added
later and aspects of that design are covered in more detail.
The special treatment of arrays of <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code> objects is also discussed.
Array support covers these cases:</p>
<ol class="arabic simple">
<li><p>arrays of standard-layout type</p></li>
<li><p>arrays of accessors</p></li>
<li><p>arrays of structs that contain accessor arrays or accessor fields</p></li>
</ol>
<p>The motivation for allowing arrays as kernel parameters is to
bring consistency to the treatment of arrays.
In C++ a lambda function is allowed to access an element of an array
defined outside the lambda. The compiler captures the entire array
by value. Note that this behavior is limited to implicit
capture of the array by value. If the array name were in
the capture list then the base address of the array would be captured
and not the entire array.</p>
<p>A user would expect the same mode of array capture in a SYCL kernel
lambda object as in any other lambda object.</p>
<p>The first few sections describe the overall design.
The last three sections provide additional details of array support.
The implementation of this design is confined to four classes in the
file <code class="docutils literal notranslate"><span class="pre">SemaSYCL.cpp</span></code>.</p>
</section>
<section id="a-sycl-kernel">
<h2>A SYCL Kernel<a class="headerlink" href="#a-sycl-kernel" title="Link to this heading">¶</a></h2>
<p>The SYCL constructs <code class="docutils literal notranslate"><span class="pre">single_task</span></code>, <code class="docutils literal notranslate"><span class="pre">parallel_for</span></code>, and
<code class="docutils literal notranslate"><span class="pre">parallel_for_work_group</span></code> each take a function object or a lambda function
as one of their arguments. The code within the function object or
lambda function is executed on the device.
To enable execution of the kernel on OpenCL devices, the lambda/function object
is converted into the format of an OpenCL kernel.</p>
</section>
<section id="sycl-kernel-code-generation">
<h2>SYCL Kernel Code Generation<a class="headerlink" href="#sycl-kernel-code-generation" title="Link to this heading">¶</a></h2>
<p>Consider a source code example that captures an int, a struct and an accessor
by value:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">c_num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">num_items</span><span class="p">{</span><span class="n">c_num_items</span><span class="p">};</span><span class="w"> </span><span class="c1">// range&lt;1&gt;(num_items)</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">output</span><span class="p">[</span><span class="n">c_num_items</span><span class="p">];</span>
<span class="w">  </span><span class="n">queue</span><span class="w"> </span><span class="n">myQueue</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">55</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">66</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">outBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">num_items</span><span class="p">);</span>

<span class="w">  </span><span class="n">myQueue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">outAcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outBuf</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
<span class="w">    </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">outAcc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The input to the code generation routines is a function object that represents
the kernel. In pseudo-code:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">outAcc</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">outAcc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The compiler-generated code for a call to such a lambda function would look like this:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">()(</span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">);</span>
</pre></div>
</div>
<p>When offloading the kernel to a device, the lambda/function object’s
function operator cannot be directly called with a capture object address.
Instead, the code generated for the device is in the form of a
“kernel caller” and a “kernel callee”.
The callee is a clone of the SYCL kernel object.
The caller is generated in the form of an OpenCL kernel function.
It receives the lambda capture object in pieces, assembles the pieces
into the original lambda capture object and then calls the callee:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">spir_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">caller</span><span class="p">(</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">AccData</span><span class="p">,</span><span class="w"> </span><span class="c1">// arg1 of accessor init function</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AccR1</span><span class="p">,</span><span class="w">        </span><span class="c1">// arg2 of accessor init function</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AccR2</span><span class="p">,</span><span class="w">        </span><span class="c1">// arg3 of accessor init function</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w">               </span><span class="c1">// arg4 of accessor init function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="n">s</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Local capture object</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="n">local</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Reassemble capture object from parts</span>
<span class="w">    </span><span class="n">local</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">local</span><span class="p">.</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Call accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">outAcc</span><span class="p">,</span><span class="w"> </span><span class="n">AccData</span><span class="p">,</span><span class="w"> </span><span class="n">AccR1</span><span class="p">,</span><span class="w"> </span><span class="n">AccR2</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Call the kernel body</span>
<span class="w">    </span><span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wi</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">spir_func</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">callee</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wi</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As may be observed from the example above, standard-layout lambda capture
components are passed by value to the device as separate parameters.
This includes scalars, pointers, and standard-layout structs.
Certain object types defined by the SYCL standard, such as
<code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::sampler</span></code> although standard-layout, cannot be
simply copied from host to device. Their layout on the device may be different
from that on the host. Some host fields may be absent on the device,
other host fields replaced with device-specific fields and
the host data pointer field must be translated to an OpenCL
or L0 memory object before it can be passed as a kernel parameter.
To enable all of this, the parameters of the <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code>
and <code class="docutils literal notranslate"><span class="pre">sycl::sampler</span></code> init functions are transfered from
host to device separately. The values received on the device
are passed to the <code class="docutils literal notranslate"><span class="pre">init</span></code> functions executed on the device,
which results in the reassembly of the SYCL object in a form usable on the device.</p>
<p>There is one other aspect of code generation. An “integration header”
is generated for use during host compilation.
This header file contains entries for each kernel.
Among the items it defines is a table of sizes and offsets of the
kernel parameters.
For the source example above the integration header contains the
following snippet:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// array representing signatures of all kernels defined in the</span>
<span class="c1">// corresponding source</span>
<span class="k">static</span><span class="w"> </span><span class="k">constexpr</span>
<span class="k">const</span><span class="w"> </span><span class="n">kernel_param_desc_t</span><span class="w"> </span><span class="n">kernel_signatures</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">//--- _ZTSZZ4mainENKUlRN2cl4sycl7handlerEE19-&gt;18clES2_E6Worker</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_std_layout</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_std_layout</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">36</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Each entry in the kernel_signatures table is a <code class="docutils literal notranslate"><span class="pre">kernel_param_desc_t</span></code>
object which contains three values:</p>
<ol class="arabic simple">
<li><p>an encoding of the type of capture object member</p></li>
<li><p>a field that encodes additional properties, and</p></li>
<li><p>an offset within the lambda object where the value of that kernel argument is placed</p></li>
</ol>
<p>The previous sections described how kernel arguments are handled today.
The next three sections describe support for arrays.</p>
</section>
<section id="fix-1-kernel-arguments-that-are-standard-layout-arrays">
<h2>Fix 1: Kernel Arguments that are Standard-Layout Arrays<a class="headerlink" href="#fix-1-kernel-arguments-that-are-standard-layout-arrays" title="Link to this heading">¶</a></h2>
<p>As described earlier, each variable captured by a lambda that comprises a
SYCL kernel becomes a parameter of the kernel caller function.
For arrays, simply allowing them through would result in a
function parameter of array type. This is not supported in C++.
Therefore, the array needing capture is decomposed into its elements for
the purposes of passing to the device. Each array element is passed as a
separate parameter. The array elements received on the device
are copied into the array within the local capture object.</p>
<p><strong>Source code fragment:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">num_items</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">output</span><span class="p">[</span><span class="n">num_items</span><span class="p">];</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">outBuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">num_items</span><span class="p">);</span>

<span class="w">  </span><span class="n">myQueue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">outAcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outBuf</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>
<span class="w">    </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">outAcc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)];</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
</pre></div>
</div>
<p><strong>Integration header produced:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span>
<span class="k">const</span><span class="w"> </span><span class="n">kernel_param_desc_t</span><span class="w"> </span><span class="n">kernel_signatures</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">//--- _ZTSZZ1fRN2cl4sycl5queueEENK3$_0clERNS0_7handlerEE6Worker</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_std_layout</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_std_layout</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">36</span><span class="w"> </span><span class="p">},</span>

<span class="p">};</span>
</pre></div>
</div>
<p><strong>The changes to device code made to support this extension, in pseudo-code:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">outAcc</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">num_items</span><span class="p">];</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Body</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">spir_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">caller</span><span class="p">(</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">AccData</span><span class="p">,</span><span class="w"> </span><span class="c1">// arg1 of accessor init function</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AccR1</span><span class="p">,</span><span class="w">        </span><span class="c1">// arg2 of accessor init function</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AccR2</span><span class="p">,</span><span class="w">        </span><span class="c1">// arg3 of accessor init function</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w">               </span><span class="c1">// arg4 of accessor init function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p_array_0</span><span class="p">;</span><span class="w">         </span><span class="c1">// Pass array element 0</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p_array_1</span><span class="p">;</span><span class="w">         </span><span class="c1">// Pass array element 1</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Local capture object</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="n">local</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Reassemble capture object from parts</span>
<span class="w">    </span><span class="c1">// Initialize array using existing clang Initialization mechanisms</span>
<span class="w">    </span><span class="n">local</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_array_0</span><span class="p">;</span>
<span class="w">    </span><span class="n">local</span><span class="p">.</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_array_1</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// Call accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">outAcc</span><span class="p">,</span><span class="w"> </span><span class="n">AccData</span><span class="p">,</span><span class="w"> </span><span class="n">AccR1</span><span class="p">,</span><span class="w"> </span><span class="n">AccR2</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">);</span>

<span class="w">    </span><span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fix-2-kernel-arguments-that-are-arrays-of-accessors">
<h2>Fix 2: Kernel Arguments that are Arrays of Accessors<a class="headerlink" href="#fix-2-kernel-arguments-that-are-arrays-of-accessors" title="Link to this heading">¶</a></h2>
<p>Arrays of accessors are supported in a manner similar to that of a plain
accessor. For each accessor array element, the four values required to
call its init function are passed as separate arguments to the kernel.
Reassembly within the kernel caller is done by calling the <code class="docutils literal notranslate"><span class="pre">init</span></code> functions
of each accessor array element in ascending index value.</p>
<p><strong>Source code fragment:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">myQueue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Accessor</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">accessor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="p">,</span><span class="w"> </span><span class="n">access</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">global_buffer</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">Accessor</span><span class="w"> </span><span class="n">inAcc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">in_buffer1</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">),</span>
<span class="w">                         </span><span class="n">in_buffer2</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">)};</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">outAcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out_buffer</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

<span class="w">    </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">outAcc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inAcc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inAcc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">];</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">});</span>
</pre></div>
</div>
<p><strong>Integration header:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span>
<span class="k">const</span><span class="w"> </span><span class="n">kernel_param_desc_t</span><span class="w"> </span><span class="n">kernel_signatures</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">//--- _ZTSZZ4mainENKUlRN2cl4sycl7handlerEE20-&gt;18clES2_E6Worker</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>Device code generated in pseudo-code form:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">outAcc</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">inAcc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Body</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">spir_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">caller</span><span class="p">(</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">outAccData</span><span class="p">,</span><span class="w">    </span><span class="c1">// args of OutAcc</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outAccR1</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outAccR2</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outI</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">inAccData_0</span><span class="p">,</span><span class="w">   </span><span class="c1">// args of inAcc[0]</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR1_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR2_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inI_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">inAccData_1</span><span class="p">,</span><span class="w">   </span><span class="c1">// args of inAcc[1]</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR1_1</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR2_1</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inI_1</span><span class="p">,</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Local capture object</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="n">local</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Reassemble capture object from parts </span>
<span class="w">    </span><span class="c1">// Call outAcc accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">outAcc</span><span class="p">,</span><span class="w"> </span><span class="n">outAccData</span><span class="p">,</span><span class="w"> </span><span class="n">outAccR1</span><span class="p">,</span><span class="w"> </span><span class="n">outAccR2</span><span class="p">,</span><span class="w"> </span><span class="n">outI</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Call inAcc[0] accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">inAccData_0</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR1_0</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR2_0</span><span class="p">,</span><span class="w"> </span><span class="n">inI_0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Call inAcc[1] accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">inAccData_1</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR1_1</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR2_1</span><span class="p">,</span><span class="w"> </span><span class="n">inI_1</span><span class="p">);</span>

<span class="w">    </span><span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="fix-3-accessor-arrays-within-structs">
<h2>Fix 3: Accessor Arrays within Structs<a class="headerlink" href="#fix-3-accessor-arrays-within-structs" title="Link to this heading">¶</a></h2>
<p>Kernel parameters that are structs are traversed member
by member, recursively, to enumerate member structs that are one of
the SYCL special types: <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::sampler</span></code>.
The arguments of the <code class="docutils literal notranslate"><span class="pre">init</span></code> functions of each special struct encountered
in the traversal are added as separate arguments to the kernel.
Support for arrays containing SYCL special types
builds upon the support for single accessors within structs.
Each element of such arrays is treated as
an individual object, and the arguments of its init function
are added to the kernel arguments in sequence.
Within the kernel caller function, the lambda object is reassembled
in a manner similar to other instances of accessor arrays.</p>
<p><strong>Source code fragment:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="n">myQueue</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">using</span><span class="w"> </span><span class="n">Accessor</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">accessor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="p">,</span><span class="w"> </span><span class="n">access</span><span class="o">::</span><span class="n">target</span><span class="o">::</span><span class="n">global_buffer</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">   </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">     </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">inAcc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">55</span><span class="p">,</span>
<span class="w">           </span><span class="p">{</span><span class="n">in_buffer1</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">),</span>
<span class="w">            </span><span class="n">in_buffer2</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">read</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">)}</span>
<span class="w">   </span><span class="p">};</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">outAcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out_buffer</span><span class="p">.</span><span class="n">get_access</span><span class="o">&lt;</span><span class="n">access</span><span class="o">::</span><span class="n">mode</span><span class="o">::</span><span class="n">write</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cgh</span><span class="p">);</span>

<span class="w">   </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Worker</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num_items</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="n">outAcc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">];</span>
<span class="w">   </span><span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<p><strong>Integration header:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span>
<span class="k">const</span><span class="w"> </span><span class="n">kernel_param_desc_t</span><span class="w"> </span><span class="n">kernel_signatures</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">//--- _ZTSZZ4mainENKUlRN2cl4sycl7handlerEE20-&gt;18clES2_E6Worker</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_std_layout</span><span class="p">,</span><span class="w"> </span><span class="mi">72</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">kernel_param_kind_t</span><span class="o">::</span><span class="n">kind_accessor</span><span class="p">,</span><span class="w"> </span><span class="mi">4062</span><span class="p">,</span><span class="w"> </span><span class="mi">72</span><span class="w"> </span><span class="p">},</span>

<span class="p">};</span>
</pre></div>
</div>
<p><strong>Device code generated in pseudo-code form:</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="w"> </span><span class="n">outAcc</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Body</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">spir_kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">caller</span><span class="p">(</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">outAccData</span><span class="p">,</span><span class="w">  </span><span class="c1">// args of OutAcc</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outAccR1</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outAccR2</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outI</span><span class="p">,</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w">                </span><span class="c1">// the struct S</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">inAccData_0</span><span class="p">,</span><span class="w"> </span><span class="c1">// args of s.inAcc[0]</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR1_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR2_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inI_0</span><span class="p">,</span>
<span class="w">    </span><span class="n">__global</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">inAccData_1</span><span class="p">,</span><span class="w"> </span><span class="c1">// args of s.inAcc[1]</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR1_1</span><span class="p">,</span>
<span class="w">    </span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inAccR2_1</span><span class="p">,</span>
<span class="w">    </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inI_1</span><span class="p">,</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Local capture object</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Capture</span><span class="w"> </span><span class="n">local</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Reassemble capture object from parts</span>

<span class="w">    </span><span class="c1">// 1. Copy struct argument contents to local copy</span>
<span class="w">    </span><span class="n">local</span><span class="p">.</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 2. Initialize accessors by calling init functions</span>
<span class="w">    </span><span class="c1">// 2a. Call outAcc accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span>
<span class="w">       </span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">outAcc</span><span class="p">,</span><span class="w"> </span><span class="n">outAccData</span><span class="p">,</span><span class="w"> </span><span class="n">outAccR1</span><span class="p">,</span><span class="w"> </span><span class="n">outAccR2</span><span class="p">,</span><span class="w"> </span><span class="n">outI</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// 2b. Call s.inAcc[0] accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span>
<span class="w">       </span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">inAccData_0</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR1_0</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR2_0</span><span class="p">,</span><span class="w"> </span><span class="n">inI_0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 2c. Call s.inAcc[1] accessor&#39;s init function</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">::</span><span class="n">init</span><span class="p">(</span>
<span class="w">       </span><span class="o">&amp;</span><span class="n">local</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">inAcc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">inAccData_1</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR1_1</span><span class="p">,</span><span class="w"> </span><span class="n">inAccR2_1</span><span class="p">,</span><span class="w"> </span><span class="n">inI_1</span><span class="p">);</span>

<span class="w">    </span><span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">wi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="CompilerAndRuntimeDesign.html">oneAPI DPC++ Compiler and Runtime architecture design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="PluginInterface.html">The DPC++ Runtime Plugin Interface.</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>