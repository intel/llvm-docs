<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Explicit SIMD design notes &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Implementation design for “device_if” and “device_architecture”" href="DeviceIf.html" />
    <link rel="prev" title="ESIMD “stateless” accessors support design" href="ESIMDStatelesAccessors.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>Explicit SIMD design notes</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ESIMDStatelesAccessors.html">ESIMD “stateless” accessors support design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DeviceIf.html">Implementation design for “device_if” and “device_architecture”</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="explicit-simd-design-notes">
<h1>Explicit SIMD design notes<a class="headerlink" href="#explicit-simd-design-notes" title="Link to this heading">¶</a></h1>
<p>This documents is a collection of notes describing design and/or implementation
of various parts of the ESIMD programming model support within the DPC++.</p>
<section id="overview-of-esimd-support-in-dpc-components">
<h2>Overview of ESIMD support in DPC++ components<a class="headerlink" href="#overview-of-esimd-support-in-dpc-components" title="Link to this heading">¶</a></h2>
<p>ESIMD support is spread across a number of components in the oneAPI software
stack, spanning compile time, link time and runtime. The picture below shows
simplified view of the DPC++ compiler and runtime diagram and where ESIMD
(sub-)components fit in it.</p>
<p><img alt="Esimd Components" src="../_images/esimd_components.png" /></p>
<section id="user-program">
<h3>User program<a class="headerlink" href="#user-program" title="Link to this heading">¶</a></h3>
<p>User program can contain both SYCL and ESIMD kernels, either in the same or
different translation units. DPC++ ESIMD support will automatically split the
device code into SYCL and ESIMD parts to redirect them to different back-ends.
To facilitate this splitting, compiler will automatically identify markup and
clone parts of the ESIMD callgraph starting from kernels and functions
explicitly marked with the <code class="docutils literal notranslate"><span class="pre">intel::sycl_explicit_simd</span></code> attribute.</p>
</section>
<section id="device-headers">
<h3>Device headers<a class="headerlink" href="#device-headers" title="Link to this heading">¶</a></h3>
<p>There are two distinct parts of ESIMD support in the SYCL device headers. The
first one is ESIMD-related “tweaks” within the usual SYCL headers, and the
second is the ESIMD APIs themselves.</p>
<section id="esimd-tweaks-in-sycl-device-headers">
<h4>ESIMD tweaks in SYCL device headers<a class="headerlink" href="#esimd-tweaks-in-sycl-device-headers" title="Link to this heading">¶</a></h4>
<p>The most important one is device-side definition of the sycl::accessor class
definition. It has different layout for SYCL and ESIMD (but the same size due
to padding), as well as different initialization function used to assemble
accessor object on the device side from incoming kernel arguments. For SYCL,
the function name is <code class="docutils literal notranslate"><span class="pre">sycl::accessor::__init</span></code>, for ESIMD it is
<code class="docutils literal notranslate"><span class="pre">sycl::accessor::__init_esimd</span></code>. The difference is caused by the ESIMD limitation
- it does not support offset, memory and access range for an accessor object.</p>
<p>There are also couple ESIMD-specific proxy classes used by ESIMD API
implementation to access internals of ESIMD objects:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl::ext::intel::esimd::detail::AccessorPrivateProxy</span></code>
this one is used by ESIMD memory APIs to access internals of <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code>
objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl::ext::intel::esimd::detail::WrapperElementTypeProxy</span></code>
used to access internals of SYCL types such as <code class="docutils literal notranslate"><span class="pre">sycl::detail::half_impl::half</span></code></p></li>
</ul>
</section>
<section id="esimd-api-headers">
<h4>ESIMD API headers<a class="headerlink" href="#esimd-api-headers" title="Link to this heading">¶</a></h4>
<p>These headers define ESIMD APIs to be used by ESIMD user kernels. For example,
the basic vector data type <code class="docutils literal notranslate"><span class="pre">sycl::ext::intel::esimd::simd</span></code>,
<code class="docutils literal notranslate"><span class="pre">sycl::ext::intel::esimd::gather</span></code> memory APIs</p>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl/ext/intel/esimd</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sycl/ext/intel/experimental/esimd</span></code></p></li>
</ul>
</section>
</section>
<section id="clang-driver">
<h3>Clang driver<a class="headerlink" href="#clang-driver" title="Link to this heading">¶</a></h3>
<p>TODO: describe driver modifications.</p>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/Driver/ToolChains/Clang.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/include/clang/Driver/Options.td</span></code></p></li>
</ul>
</section>
<section id="clang-front-end">
<h3>Clang front-end<a class="headerlink" href="#clang-front-end" title="Link to this heading">¶</a></h3>
<section id="semantic-analyzer-integration-header-generator">
<h4>Semantic analyzer, integration header generator<a class="headerlink" href="#semantic-analyzer-integration-header-generator" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>Generation of ESIMD kernel signature and prolog code (which re-assembles
objects such as accessors from incoming arguments) is tweaked for ESIMD
kernels:</p>
<ul>
<li><p>accessors generate fewer kernel arguments</p></li>
<li><p>accessor object is assembled in the prolog using <code class="docutils literal notranslate"><span class="pre">__init_esimd</span></code> function
instead of <code class="docutils literal notranslate"><span class="pre">__init</span></code>. See function name definition and its usage
<a class="reference external" href="https://github.com/intel/llvm/blob/eb33bbcfbeab7af1a7f58fb4dc6b53bc47f73dba/clang/lib/Sema/SemaSYCL.cpp#L62">here</a>.</p></li>
</ul>
</li>
<li><p>Defines <code class="docutils literal notranslate"><span class="pre">intel::sycl_explicit_simd</span></code> function and variable attribute to markup
kernels top-level ESIMD external functions and “private globals”.</p></li>
<li><p>Performs various ESIMD-specific semantic analysis and diagnostics. All kinds
of ESIMD error messages can be found in
<code class="docutils literal notranslate"><span class="pre">clang/include/clang/Basic/DiagnosticSemaKinds.td</span></code>.</p></li>
<li><p>Integration header generator inserts additional
<code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">constexpr</span> <span class="pre">bool</span> <span class="pre">isESIMD()</span></code> function into kernel discriptor type, which
is used by the host compiler to obtain compile-time details for the kernel via
inclusion of the integration header generated by the generator. For ESIMD
kernels <code class="docutils literal notranslate"><span class="pre">isESIMD()</span></code> returns true, and this is used in SYCL RT headers to
distinguish ESIMD kernels from SYCL kernels, e.g. to customize kernel argument
setting for accessors.</p></li>
<li><p>defines <code class="docutils literal notranslate"><span class="pre">sycl_esimd_vectorize</span></code> attribute propagated to the VC BE, aimed at
making it possible to call SIMT function from ESIMD code while vectorizing the
former. Used internally to implement certain math functions in SYCL spec
conformant manner (proper precision) via vectorizing scalar conformant
implementations - see example
<a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/include/sycl/ext/intel/esimd/detail/math_intrin.hpp#L199">usage</a></p></li>
</ul>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/Sema/SemaSYCL.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/Sema/SemaDecl.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/Sema/SemaExpr.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/include/clang/Basic/Attr.td</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/include/clang/Basic/DiagnosticSemaKinds.td</span></code></p></li>
</ul>
</section>
<section id="code-llvmir-generator">
<h4>Code (LLVMIR) generator<a class="headerlink" href="#code-llvmir-generator" title="Link to this heading">¶</a></h4>
<p>ESIMD-specific code generator tweaks are mostly translations of internal FE
representation of variaous ESIMD attributes into LLVM IR attributes or metadata.</p>
<section id="kernel-signature-generation">
<h5>Kernel signature generation<a class="headerlink" href="#kernel-signature-generation" title="Link to this heading">¶</a></h5>
<p>For ESIMD kernels, a number of additional attributes are generated for the
kernel function itself as well as certain argument.</p>
<ul class="simple">
<li><p>Kernels are annotated with <code class="docutils literal notranslate"><span class="pre">sycl_explicit_simd</span></code> and
<code class="docutils literal notranslate"><span class="pre">intel_reqd_sub_group_size</span></code> attributes. The latter must always be <code class="docutils literal notranslate"><span class="pre">1</span></code> for a
ESIMD kernel or function.</p></li>
<li><p>An argument which conveys accessor’s pointer is assigned a
<code class="docutils literal notranslate"><span class="pre">kernel_arg_accessor_ptr</span></code> attribute</p></li>
</ul>
</section>
<section id="global-variable-code-generation">
<h5>Global variable code generation<a class="headerlink" href="#global-variable-code-generation" title="Link to this heading">¶</a></h5>
<p>ESIMD supports “private globals” - global variables which have one copy per
thread of execution (similar to C++ thread_local), normally allocated of Gen
register file. To make a global variable a “private global”,
<code class="docutils literal notranslate"><span class="pre">__attribute__((opencl_private))</span> <span class="pre">__attribute__((sycl_explicit_simd))</span></code>
attributes are used. Globals of this can be forced to a specific register using
the <code class="docutils literal notranslate"><span class="pre">__attribute__((register_num(n)))</span></code> attribute. The clang code generator
translates these to <code class="docutils literal notranslate"><span class="pre">genx_volatile</span></code> and <code class="docutils literal notranslate"><span class="pre">genx_byte_offset</span></code> LLVM IR attributes.</p>
</section>
<section id="function-attributes-translations">
<h5>Function attributes translations<a class="headerlink" href="#function-attributes-translations" title="Link to this heading">¶</a></h5>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sycl_esimd_vectorize</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">CMGenxSIMT</span></code></p></li>
</ul>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/CodeGen/CGSYCLRuntime.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/CodeGen/CodeGenFunction.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">clang/lib/CodeGen/CodeGenModule.cpp</span></code></p></li>
</ul>
</section>
</section>
</section>
<section id="clang-middle-end">
<h3>Clang middle-end<a class="headerlink" href="#clang-middle-end" title="Link to this heading">¶</a></h3>
<section id="esimd-api-restriction-verifier">
<h4>ESIMD API restriction verifier<a class="headerlink" href="#esimd-api-restriction-verifier" title="Link to this heading">¶</a></h4>
<p>This component is an LLVM IR pass over a compiled translation unit. It checks
for presence of certain SYCL APIs which are disallowed within ESIMD code. For
exaple, SYCL reductions are not allowed in ESIMD. The verifier does this by
demangling all the call targets within ESIMD code and matching them with
internal sub-string filters. Invoked from <code class="docutils literal notranslate"><span class="pre">clang/lib/CodeGen/BackendUtil.cpp</span></code>.</p>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm/lib/SYCLLowerIR/ESIMD/ESIMDVerifier.cpp</span></code></p></li>
</ul>
</section>
</section>
<section id="sycl-post-link-transformations">
<h3>sycl-post-link transformations<a class="headerlink" href="#sycl-post-link-transformations" title="Link to this heading">¶</a></h3>
<p>As a part of the input device code module transformation pipeline, the
sycl-post-link tool splits the input module (or modules resulting from splitting
by other characteristics, such as aspects) into two - SYCL and ESIMD ones.
Shared functions invoked both from SYCL and ESIMD are cloned during the process.
This is necessary because SYCL and ESIMD parts must undergo different set of
transformations before generating resulting SPIR-V. ESIMD modules resulting from
splitting are marked with specific device binary property <code class="docutils literal notranslate"><span class="pre">isEsimdImage</span></code> (see
<a class="reference external" href="https://github.com/intel/llvm/blob/9dc14a292f479880b5ab2e95f99a8414b31d1165/llvm/tools/sycl-post-link/sycl-post-link.cpp#L453">source</a>
.)</p>
<p><code class="docutils literal notranslate"><span class="pre">sycl-post-link</span></code> is the post-link process driver, it invokes necessary
transformations as well as optimizations on fully linked device code. As a part
of the process it splits SYCL and ESIMD parts of the code into separate LLVM IR
modules and invokes different set or transformations on them. If a program has
an <code class="docutils literal notranslate"><span class="pre">invoke_simd</span></code> call in it, then sycl-post-link will link SYCL and ESIMD parts
back, cloning overlaping parts as needed.</p>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">llvm/tools/sycl-post-link/sycl-post-link.cpp</span></code></p></li>
</ul>
<section id="esimd-lowerer">
<h4>ESIMD Lowerer<a class="headerlink" href="#esimd-lowerer" title="Link to this heading">¶</a></h4>
<p>ESIMD part of device code undergoes a set of ESIMD-specific transformations.
First, intrinsic lowering and metadata generation phase happens. It is
implemented in the <code class="docutils literal notranslate"><span class="pre">SYCLLowerESIMDPass</span></code> LLVM IR Module pass. Its primary
purposes are:</p>
<ul class="simple">
<li><p>translate <code class="docutils literal notranslate"><span class="pre">__esimd_*</span></code> intrinsic calls into corresponding <code class="docutils literal notranslate"><span class="pre">genx.*</span></code> intrinsics
known to the VC BE</p>
<ul>
<li><p>in some cases, there is no direct equivalent (for example,
<code class="docutils literal notranslate"><span class="pre">__esimd_pack_mask</span></code>), in which case the lowerer generates LLVM IR with
desired semantics</p></li>
</ul>
</li>
<li><p>translate some of the <code class="docutils literal notranslate"><span class="pre">__spirv.*</span></code> intrinsics to something acceptable by VC
BE</p></li>
</ul>
<p>Source locations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LowerESIMD.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ESIMDOptimizeVecArgCallConv.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LowerESIMDVecArg.cpp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LowerESIMDVLoadVStore.cpp</span></code></p></li>
</ul>
</section>
<section id="genx-spir-v-writer-adaptor">
<h4>Genx SPIR-V writer adaptor<a class="headerlink" href="#genx-spir-v-writer-adaptor" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">(part</span> <span class="pre">of</span> <span class="pre">vc-intrinsics</span> <span class="pre">repo)</span></code></p>
</section>
</section>
<section id="sycl-runtime">
<h3>SYCL Runtime<a class="headerlink" href="#sycl-runtime" title="Link to this heading">¶</a></h3>
<p>SYCL runtime (RT) has a few places where ESIMD is handled specially:</p>
<ul class="simple">
<li><p>When setting kernel invocation arguments corresponding to an accessor, RT will
skip setting offset, memory and access ranges arguments (normally set for
usual SYCL kernels), because ESIMD does not support these. In other words, an
accessors used within kernel (and captured in kernel lambda) is translated to
4 SPIR-V kernel arguments for a normal SYCL kernel, and just to 1 argument for
a ESIMD kernel.
<a class="reference external" href="https://github.com/intel/llvm/blob/d7a7de79f8a6498bae52331f4789adcac76b8e8c/sycl/source/handler.cpp#L373">Link</a>.</p></li>
<li><p>When creating JIT compilation options, SYCL runtime checks if the device
binary image to be JIT-compiled has “isESIMDImage” property, in which case it
adds <code class="docutils literal notranslate"><span class="pre">-vc-codegen</span></code> JIT options, which makes Intel GPU runtime use the vector
backend (aka ‘VC BE’) to JIT-compile the device binary (SPIR-V).
<a class="reference external" href="https://github.com/intel/llvm/blob/d7a7de79f8a6498bae52331f4789adcac76b8e8c/sycl/source/detail/program_manager/program_manager.cpp#L412">Link</a>.</p></li>
</ul>
</section>
</section>
<section id="todos">
<h2>TODOs<a class="headerlink" href="#todos" title="Link to this heading">¶</a></h2>
<p>This section lists current major ESIMD gaps/TODOs.</p>
<ol class="arabic simple">
<li><p>Move all APIs out of the experimental namespace. One of the major APIs there
is LSC memory accesses. The main roadblock for making it stable API is
absense of specification for cache hints, which should be shared between SYCL
and ESIMD.</p></li>
<li><p>Architecture specific APIs should be explicitly marked as such in the user
documentation with references to the
<a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/experimental/sycl_ext_oneapi_device_architecture.asciidoc">list of architectures</a>
known to oneAPI.</p></li>
<li><p>Properly markup architecture-specific APIs, such as <code class="docutils literal notranslate"><span class="pre">dpas</span></code>, with required
aspects, according to the “optional device features”
<a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/design/OptionalDeviceFeatures.md">design</a>.
This might require splitting implementations into per-architecture variants.
<code class="docutils literal notranslate"><span class="pre">if_device_has</span></code>
<a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/proposed/sycl_ext_oneapi_device_if.asciidoc">feature</a>
may help avoid duplication of common parts and dispatch to
architecture-dependent code at fine-grained level from within a function.</p></li>
<li><p>As VC BE moves away from <code class="docutils literal notranslate"><span class="pre">genx.*</span></code> intrinsics replacing them with <code class="docutils literal notranslate"><span class="pre">__spirv_*</span></code>
ones defined in various extensions, ESIMD should catch up.</p></li>
<li><p>Unification of common <code class="docutils literal notranslate"><span class="pre">simd_view</span></code>/<code class="docutils literal notranslate"><span class="pre">simd</span></code> interfaces in fact leads to
significant complication of implementation rather than its intended
simplification via avoiding code duplication, might make sense to have
separate implementations.</p></li>
</ol>
</section>
<section id="directions">
<h2>Directions<a class="headerlink" href="#directions" title="Link to this heading">¶</a></h2>
<p>This section lists possible directions for ESIMD improvements.</p>
<ol class="arabic simple">
<li><p>Support <code class="docutils literal notranslate"><span class="pre">std::simd</span></code>. This is the standard C++ way for explicit SIMD
programming. Can help run (subsest of ESIMD) on CPU efficiently in the
future.</p></li>
<li><p>Clear (via namespace?) separation of ESIMD APIs into portable and
architecture-specific parts.</p></li>
<li><p>Standardizing <code class="docutils literal notranslate"><span class="pre">simd_view</span></code> or equivalent. This is effectively a reference
to a <em>subset</em> of <code class="docutils literal notranslate"><span class="pre">esimd::simd</span></code> vector object’s elements. The subset is
defined in a regular way via starting offset, stride and number of elements
in the subset. This proved to be very useful and loved by users. Missing in
<code class="docutils literal notranslate"><span class="pre">std::simd</span></code>.</p></li>
<li><p>Design something like <code class="docutils literal notranslate"><span class="pre">invoke_spmd</span></code> (similar to <code class="docutils literal notranslate"><span class="pre">invoke_simd</span></code> extension) to
be able to invoke SPMD functions from ESIMD code while vectorizing the calls
in the back-end. This would replace <code class="docutils literal notranslate"><span class="pre">sycl_esimd_vectorize</span></code> and make this
concept usable by all users, not only internal ESIMD implementation.</p></li>
<li><p>Create a specification for ESIMD kernel ABI and stand-alone kernel
declaration rules to make ESIMD kernels callable by arbitrary host offload
runtimes, such as Level Zero.</p></li>
</ol>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ESIMDStatelesAccessors.html">ESIMD “stateless” accessors support design</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="DeviceIf.html">Implementation design for “device_if” and “device_architecture”</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>