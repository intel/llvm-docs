<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SYCLcompat &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=dfa0e015" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frequently Asked Questions" href="../FAQ.html" />
    <link rel="prev" title="CUDA crosslane vs OpenCL sub-groups" href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>SYCLcompat</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html">CUDA crosslane vs OpenCL sub-groups</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../FAQ.html">Frequently Asked Questions</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="syclcompat">
<h1>SYCLcompat<a class="headerlink" href="#syclcompat" title="Link to this heading">¶</a></h1>
<p>SYCLcompat is a header-only library that intends to help developers familiar
with other heterogeneous programming models (such as OpenMP, CUDA or HIP) to
familiarize themselves with the SYCL programming API while porting their
existing codes. Compatibility tools can also benefit from the reduced API size
when converting legacy codebases.</p>
<p>SYCLcompat provides:</p>
<ul class="simple">
<li><p>A high-level API that provides closer semantics to other programming models,
simplifying line by line conversions.</p></li>
<li><p>Alternative submission APIs that encapsulate SYCL-specific “queue” and
“event” APIs for easier reference.</p></li>
<li><p>Ability to gradually introduce other SYCL concepts as the user familiarizes
themselves with the core SYCL API.</p></li>
<li><p>Clear distinction between core SYCL API and the compatibility interface via
separate namespaces.</p></li>
</ul>
<section id="notice">
<h2>Notice<a class="headerlink" href="#notice" title="Link to this heading">¶</a></h2>
<p>Copyright © 2023-2024 Codeplay Software Limited. All rights reserved.</p>
<p>Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks of
The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.</p>
</section>
<section id="support">
<h2>Support<a class="headerlink" href="#support" title="Link to this heading">¶</a></h2>
<p>SYCLcompat depends on specific oneAPI DPC++ compiler extensions that may not be
available to all the SYCL 2020 specification implementations.</p>
<p>Specifically, this library depends on the following SYCL extensions:</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/0999c0bfbd428178cb701853a8d57be0/sycl_ext_oneapi_local_memory.asciidoc"><span class="xref download myst">sycl_ext_oneapi_local_memory</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/d519c283ec7dc492aa901f61d888cdb7/sycl_ext_oneapi_complex.asciidoc"><span class="xref download myst">sycl_ext_oneapi_complex</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/cd2e3ebabcf6d6094c5a3274d5a2ddb0/sycl_ext_oneapi_free_function_queries.asciidoc"><span class="xref download myst">sycl_ext_oneapi_free_function_queries</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/292bf929b84890cb56c6e35dc55dfc02/sycl_ext_oneapi_assert.asciidoc"><span class="xref download myst">sycl_ext_oneapi_assert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/e3cc36403d28a69692d6fe3db1525577/sycl_ext_oneapi_enqueue_barrier.asciidoc"><span class="xref download myst">sycl_ext_oneapi_enqueue_barrier</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/511cbbf41116faa3a2cb8f10ff6d90f5/sycl_ext_oneapi_usm_device_read_only.asciidoc"><span class="xref download myst">sycl_ext_oneapi_usm_device_read_only</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/cf84d53b369dc75483e0cfad122cde56/sycl_ext_oneapi_properties.asciidoc"><span class="xref download myst">sycl_ext_oneapi_properties</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/977a42cd2e821913a24e29380421b8d2/sycl_ext_oneapi_enqueue_functions.asciidoc"><span class="xref download myst">sycl_ext_oneapi_enqueue_functions</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/788c539eeb458db27f9bcae740589092/sycl_ext_oneapi_kernel_properties.asciidoc"><span class="xref download myst">sycl_ext_oneapi_kernel_properties</span></a></p></li>
</ul>
<p>If available, the following extensions extend SYCLcompat functionality:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_intel_device_info.md">sycl_ext_intel_device_info</a> [Optional]</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/0d9e2f39b3cca9b1cb20bb5ccebe0adb/sycl_ext_oneapi_bfloat16_math_functions.asciidoc"><span class="xref download myst">sycl_ext_oneapi_bfloat16_math_functions</span></a> [Optional]</p></li>
<li><p><a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/experimental/sycl_ext_oneapi_max_work_group_query.md">sycl_ext_oneapi_max_work_group_query</a>
[Optional]</p></li>
</ul>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>All functionality is available under the <code class="docutils literal notranslate"><span class="pre">syclcompat::</span></code> namespace, imported
through the main header, <code class="docutils literal notranslate"><span class="pre">syclcompat.hpp</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">syclcompat.hpp</span></code> does not
import the &lt;sycl/sycl.hpp&gt; header.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;syclcompat.hpp&gt;</span>
</pre></div>
</div>
<p>This document presents the public API under the <a class="reference internal" href="#features">Features</a> section,
and provides a working <a class="reference internal" href="#sample-code">Sample code</a> using this library. Refer to
those to learn to use the library.</p>
</section>
<section id="versioning">
<h2>Versioning<a class="headerlink" href="#versioning" title="Link to this heading">¶</a></h2>
<p>SYCLcompat adopts <a class="reference external" href="https://semver.org/">semantic versioning</a>
(<code class="docutils literal notranslate"><span class="pre">major.minor.patch</span></code>) in a manner which aligns with oneAPI releases. Each oneAPI
product release has an associated SYCLcompat release. Between oneAPI releases,
there will be at most one <code class="docutils literal notranslate"><span class="pre">major</span></code> or <code class="docutils literal notranslate"><span class="pre">minor</span></code> bump. In other words, if a given
oneAPI release has SYCLcompat version <code class="docutils literal notranslate"><span class="pre">1.0.0</span></code>, the next release will have either
<code class="docutils literal notranslate"><span class="pre">1.1.0</span></code> or, if breaking changes have been made, <code class="docutils literal notranslate"><span class="pre">2.0.0</span></code>. This guarantee has
implications for code merged to the <code class="docutils literal notranslate"><span class="pre">sycl</span></code> branch, described below.</p>
<p>Between release cycles, ongoing updates to SYCLcompat (including possibly
breaking changes) are merged into DPC++ via PRs to the
<a class="reference external" href="https://github.com/intel/llvm/tree/sycl"><code class="docutils literal notranslate"><span class="pre">sycl</span></code></a> branch. If a PR introduces the
<em>first</em> breaking changes since the last release, that PR must bump to the next
<code class="docutils literal notranslate"><span class="pre">major</span></code> version. Otherwise, if the PR introduces <em>new functionality</em> and neither
the <code class="docutils literal notranslate"><span class="pre">major</span></code> nor <code class="docutils literal notranslate"><span class="pre">minor</span></code> have been bumped since the last release, it must bump to
the next <code class="docutils literal notranslate"><span class="pre">minor</span></code> release. If a PR introduces important bugfixes to existing
functionality, <code class="docutils literal notranslate"><span class="pre">patch</span></code> should be bumped, and there are no limits to how many
<code class="docutils literal notranslate"><span class="pre">patch</span></code> bumps can occur between release cycles.</p>
<section id="release-process">
<h3>Release Process<a class="headerlink" href="#release-process" title="Link to this heading">¶</a></h3>
<p>Once all changes planned for a release have been merged, the release process is
defined as:</p>
<ol class="arabic simple">
<li><p>Check the <code class="docutils literal notranslate"><span class="pre">major.minor</span></code> version associated with the <em>previous</em> release.</p></li>
<li><p>Confirm the version bump process outlined above has been followed.</p></li>
<li><p>If no version bump has occurred since previous release, bump to next <code class="docutils literal notranslate"><span class="pre">minor</span></code>.</p></li>
<li><p>oneAPI release is delivered.</p></li>
<li><p>Tag the SYCLcompat release on DPC++ repo: <code class="docutils literal notranslate"><span class="pre">SYCLcompat-major.minor.0</span></code>.</p></li>
</ol>
</section>
<section id="deprecation-process-breaking-changes">
<h3>Deprecation Process/Breaking Changes<a class="headerlink" href="#deprecation-process-breaking-changes" title="Link to this heading">¶</a></h3>
<p>As outlined above, SYCLcompat may sometimes make API breaking changes, indicated
with a <code class="docutils literal notranslate"><span class="pre">major</span></code> version bump. Advanced notice (at least one major oneAPI release)
will be provided via a deprecation warning on the relevant APIs, indicating to
the user which alternative API should be used instead.</p>
<p>Note that SYCLcompat is currently in pre-release, and until version <code class="docutils literal notranslate"><span class="pre">1.0.0</span></code> we
do not consider our API to be stable, and may change it with shorter notice.</p>
</section>
<section id="changelog">
<h3>Changelog<a class="headerlink" href="#changelog" title="Link to this heading">¶</a></h3>
<p>Since SYCLcompat releases are aligned with oneAPI product releases, the changelog for SYCLcompat is incorporated into <a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/ReleaseNotes.md">SYCL’s Release Notes</a>.</p>
</section>
<section id="experimental-namespace">
<h3>Experimental Namespace<a class="headerlink" href="#experimental-namespace" title="Link to this heading">¶</a></h3>
<p>SYCLcompat provides some new experimental features in the <code class="docutils literal notranslate"><span class="pre">syclcompat::experimental</span></code> namespace. This serves as a testing ground for new features which are expected to migrate to <code class="docutils literal notranslate"><span class="pre">syclcompat::</span></code> in time, but the developers do not guarantee either API stability or continued existence of these features; they may be modified or removed without notice. When features are migrated from <code class="docutils literal notranslate"><span class="pre">syclcompat::experimental</span></code> to <code class="docutils literal notranslate"><span class="pre">syclcompat::</span></code>, this will be treated as a <code class="docutils literal notranslate"><span class="pre">minor</span></code> version bump.</p>
</section>
</section>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Link to this heading">¶</a></h2>
<section id="dim3">
<h3>dim3<a class="headerlink" href="#dim3" title="Link to this heading">¶</a></h3>
<p>SYCLcompat provides a <code class="docutils literal notranslate"><span class="pre">dim3</span></code> class akin to that of CUDA or HIP programming
models. <code class="docutils literal notranslate"><span class="pre">dim3</span></code> encapsulates other languages iteration spaces that are
represented with coordinate letters (x, y, z). In SYCL, the fastest-moving
dimension is the one with the highest index, e.g. in a SYCL 2D range iteration
space, there are two dimensions, 0 and 1, and 1 will be the one that “moves
faster”. For CUDA/HIP, the convention is reversed: <code class="docutils literal notranslate"><span class="pre">x</span></code> is the dimension which
moves fastest. <code class="docutils literal notranslate"><span class="pre">syclcompat::dim3</span></code> follows this convention, so that
<code class="docutils literal notranslate"><span class="pre">syclcompat::dim3(32,</span> <span class="pre">4)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">sycl::range&lt;2&gt;(4,</span> <span class="pre">32)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">syclcompat::dim3(32,</span> <span class="pre">4,</span> <span class="pre">2)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">sycl::range&lt;3&gt;(2,</span> <span class="pre">4,</span> <span class="pre">32)</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">dim3</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">();</span>

<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Element-wise operators</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>The compatibility headers for SYCL offer a number of convenience functions that
help the mapping between xyz-based coordinates to SYCL iteration spaces in the
different scopes available. In addition to the global range, the following
helper functions are also provided:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">local_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace local_id</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">local_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace local_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">work_group_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace work_group_id</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">work_group_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace work_group_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">global_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace global_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">global_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace global_id</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>These translate any kernel dimensions from one convention to the other. An
example of an equivalent SYCL call for a 3D kernel using <code class="docutils literal notranslate"><span class="pre">compat</span></code> is
<code class="docutils literal notranslate"><span class="pre">syclcompat::global_id::x()</span> <span class="pre">==</span> <span class="pre">get_global_id(2)</span></code>.</p>
</section>
<section id="launch">
<h3>launch<function><a class="headerlink" href="#launch" title="Link to this heading">¶</a></h3>
<p>SYCLcompat provides a kernel <code class="docutils literal notranslate"><span class="pre">launch</span></code> interface which accepts a function that
executes on the device (a.k.a “kernel”) instead of a lambda/functor. It can be
called either by using a pair of “teams”/”blocks” and “threads”, from
OpenMP/CUDA terminology, or using a <code class="docutils literal notranslate"><span class="pre">sycl::nd_range</span></code>. The interface accepts a
device <em>function</em> with the use of an <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">F</span></code> template parameter, and a variadic
<code class="docutils literal notranslate"><span class="pre">Args</span></code> for the function’s arguments.</p>
<p>Various overloads for <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> exist to permit the user to launch on a
specific <code class="docutils literal notranslate"><span class="pre">queue</span></code>, or to describe the range as either <code class="docutils literal notranslate"><span class="pre">nd_range</span></code> or <code class="docutils literal notranslate"><span class="pre">dim3,</span> <span class="pre">dim3</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>For example, if the user had an existing function named <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> to execute
on a device such as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vectorAdd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>using SYCLcompat, the user can call it as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>which would be equivalent to the following call using a <code class="docutils literal notranslate"><span class="pre">sycl::nd_range</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="n">blocksPerGrid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span>
<span class="w">                               </span><span class="n">threadsPerBlock</span><span class="p">};</span>
<span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that since <code class="docutils literal notranslate"><span class="pre">syclcompat::launch</span></code> accepts a device function, the kernel
lambda is constructed by SYCLcompat internally. This means that, for
example, <code class="docutils literal notranslate"><span class="pre">sycl::local_accessor</span></code>s cannot be declared. Instead, users wishing to
use local memory should launch with a <code class="docutils literal notranslate"><span class="pre">launch_policy</span></code> object as described below.</p>
<section id="launch-policy">
<h4>launch_policy<a class="headerlink" href="#launch-policy" title="Link to this heading">¶</a></h4>
<p>In addition to the simple <code class="docutils literal notranslate"><span class="pre">syclcompat::launch</span></code> interface described above,
SYCLcompat provides a more flexible (<code class="docutils literal notranslate"><span class="pre">experimental</span></code>) interface to <code class="docutils literal notranslate"><span class="pre">launch</span></code> a
kernel with a given <code class="docutils literal notranslate"><span class="pre">launch_policy</span></code>. By constructing and passing a
<code class="docutils literal notranslate"><span class="pre">launch_policy</span></code>, users can pass <code class="docutils literal notranslate"><span class="pre">sycl::ext::oneapi::experimental::properties</span></code>
associated with the kernel or launch, as well as request <strong>local memory</strong> for
the kernel.</p>
<p>In order to disambiguate the variadic constructor of <code class="docutils literal notranslate"><span class="pre">launch_policy</span></code>, the
following wrapper structs are defined. The <code class="docutils literal notranslate"><span class="pre">kernel_properties</span></code> and
<code class="docutils literal notranslate"><span class="pre">launch_properties</span></code> wrappers can be constructed <em>either</em> with a variadc set of
properties, or with an existing <code class="docutils literal notranslate"><span class="pre">sycl_exp::properties</span></code> object.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="o">::</span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">sycl_exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">sycl</span><span class="o">::</span><span class="nn">ext</span><span class="o">::</span><span class="nn">oneapi</span><span class="o">::</span><span class="nn">experimental</span><span class="p">;</span>

<span class="c1">// Wrapper for kernel sycl_exp::properties</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Properties</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kernel_properties</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Props</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Properties</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Props</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">kernel_properties</span><span class="p">(</span><span class="n">Props</span><span class="p">...</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Props</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">kernel_properties</span><span class="p">(</span><span class="n">sycl_exp</span><span class="o">::</span><span class="n">properties</span><span class="o">&lt;</span><span class="n">Props</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">properties</span><span class="p">)</span>
<span class="w">  </span><span class="n">Properties</span><span class="w"> </span><span class="n">props</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Wrapper for launch sycl_exp::properties</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Properties</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">launch_properties</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Props</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Properties</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Props</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">launch_properties</span><span class="p">(</span><span class="n">Props</span><span class="p">...</span><span class="w"> </span><span class="n">properties</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Props</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">launch_properties</span><span class="p">(</span><span class="n">sycl_exp</span><span class="o">::</span><span class="n">properties</span><span class="o">&lt;</span><span class="n">Props</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">properties</span><span class="p">)</span>
<span class="w">  </span><span class="n">Properties</span><span class="w"> </span><span class="n">props</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Wrapper for local memory size</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">local_mem_size</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">local_mem_size</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">//namespace syclcompat::experimental</span>
</pre></div>
</div>
<p>The constructors of <code class="docutils literal notranslate"><span class="pre">launch_policy</span></code> are variadic, accepting any form of range
(<code class="docutils literal notranslate"><span class="pre">nd_range</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">dim3</span></code>, <code class="docutils literal notranslate"><span class="pre">dim3,</span> <span class="pre">dim3</span></code>), followed by zero or more of
<code class="docutils literal notranslate"><span class="pre">local_memory_size</span></code>, <code class="docutils literal notranslate"><span class="pre">kernel_properties</span></code>, and <code class="docutils literal notranslate"><span class="pre">launch_properties</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="o">::</span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">sycl_exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">sycl</span><span class="o">::</span><span class="nn">ext</span><span class="o">::</span><span class="nn">oneapi</span><span class="o">::</span><span class="nn">experimental</span><span class="p">;</span>

<span class="c1">// launch_policy is constructed by the user &amp; passed to `compat_exp::launch`</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Range</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">KProps</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">LProps</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">LocalMem</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">launch_policy</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">KPropsT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KProps</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">LPropsT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LProps</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">RangeT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Range</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">HasLocalMem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LocalMem</span><span class="p">;</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">launch_policy</span><span class="p">(</span><span class="n">Range</span><span class="w"> </span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">);</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">launch_policy</span><span class="p">(</span><span class="n">dim3</span><span class="w"> </span><span class="n">global_range</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">);</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">launch_policy</span><span class="p">(</span><span class="n">dim3</span><span class="w"> </span><span class="n">global_range</span><span class="p">,</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="n">local_range</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">);</span>

<span class="w">  </span><span class="n">KProps</span><span class="w"> </span><span class="nf">get_kernel_properties</span><span class="p">();</span>
<span class="w">  </span><span class="n">LProps</span><span class="w"> </span><span class="nf">get_launch_properties</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_mem_size</span><span class="p">();</span>
<span class="w">  </span><span class="n">Range</span><span class="w"> </span><span class="nf">get_range</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">//namespace syclcompat::experimental</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">launch</span></code> overloads accepting a <code class="docutils literal notranslate"><span class="pre">launch_policy</span></code> are:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="o">::</span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">LaunchPolicy</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="n">LaunchPolicy</span><span class="w"> </span><span class="n">launch_policy</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">LaunchPolicy</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="n">LaunchPolicy</span><span class="w"> </span><span class="n">launch_policy</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="c1">//namespace syclcompat::experimental</span>
</pre></div>
</div>
<p>For local memory, <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> injects a <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> pointer to the beginning
of a local accessor of the requested <code class="docutils literal notranslate"><span class="pre">local_mem_size</span></code> as the last argument of
the kernel function. This <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> can then be reinterpreted as the datatype
required by the user within the kernel function.</p>
<p>For example, the previous function named <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> can be modified
with the following signature, which adds a <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> pointer to access local
memory inside the kernel:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vectorAdd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">               </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">local_mem</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, the new <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> can be launched like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span>
<span class="n">launch_policy</span><span class="w"> </span><span class="n">policy</span><span class="p">{</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span>
<span class="w">                      </span><span class="n">local_mem_size</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)};</span>
<span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>To request a different cache/local memory split on supported hardware:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">sycl_intel_exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">sycl</span><span class="o">::</span><span class="nn">ext</span><span class="o">::</span><span class="nn">intel</span><span class="o">::</span><span class="nn">experimental</span><span class="p">;</span>

<span class="n">sycl_intel_exp</span><span class="o">::</span><span class="n">cache_config</span><span class="w"> </span><span class="n">cache_config</span><span class="p">{</span>
<span class="w">    </span><span class="n">sycl_intel_exp</span><span class="o">::</span><span class="n">large_slm</span><span class="p">};</span>
<span class="n">kernel_properties</span><span class="w"> </span><span class="n">kernel_props</span><span class="p">{</span><span class="n">cache_config</span><span class="p">};</span>
<span class="n">launch_policy</span><span class="w"> </span><span class="n">policy</span><span class="p">{</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span>
<span class="w">                      </span><span class="n">local_mem_size</span><span class="p">(</span><span class="n">nbytes</span><span class="p">),</span><span class="w"> </span><span class="n">kernel_props</span><span class="p">};</span>

<span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>To request a certain cluster dimension on supported hardware:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">experimental</span><span class="p">;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">sycl_exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">sycl</span><span class="o">::</span><span class="nn">ext</span><span class="o">::</span><span class="nn">oneapi</span><span class="o">::</span><span class="nn">experimental</span><span class="p">;</span>

<span class="n">sycl_exp</span><span class="o">::</span><span class="n">cuda</span><span class="o">::</span><span class="n">cluster_size</span><span class="w"> </span><span class="nf">cluster_dims</span><span class="p">(</span><span class="n">cluster_range</span><span class="p">);</span>
<span class="n">launch_policy</span><span class="w"> </span><span class="n">policy</span><span class="p">{</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">local_mem_size</span><span class="p">(</span><span class="n">nbytes</span><span class="p">),</span><span class="w"> </span>
<span class="w">                                  </span><span class="n">launch_properties</span><span class="p">{</span><span class="n">cluster_dims</span><span class="p">}};</span>

<span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Link to this heading">¶</a></h3>
<p>SYCLcompat introduces a set of utility functions designed to streamline the
usage of the library and its <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> mechanism.</p>
<p>The first utility function is <code class="docutils literal notranslate"><span class="pre">syclcompat::wg_barrier()</span></code>, which provides a
concise work-group barrier. <code class="docutils literal notranslate"><span class="pre">syclcompat::wg_barrier()</span></code> uses the
<em>SYCL_INTEL_free_function_queries</em> extension to provide this functionality.</p>
<p>The second utility function, <code class="docutils literal notranslate"><span class="pre">syclcompat::compute_nd_range</span></code>, ensures that the
provided global size and work group sizes are appropriate for a given
dimensionality, and that global size is rounded up to a multiple of the work
group size in each dimension.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wg_barrier</span><span class="p">();</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compute_nd_range</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">global_size_in</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">work_group_size</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compute_nd_range</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">global_size_in</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                          </span><span class="kt">int</span><span class="w"> </span><span class="n">work_group_size</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="queues">
<h3>Queues<a class="headerlink" href="#queues" title="Link to this heading">¶</a></h3>
<p>The design for this library assumes <em>in-order</em> queues
(<code class="docutils literal notranslate"><span class="pre">sycl::property::queue::in_order()</span></code>).</p>
<p>Many of the APIs accept an optional <code class="docutils literal notranslate"><span class="pre">queue</span></code> parameter, and this can be an
out-of-order queue, either created manually or retrieved via a call to
<code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue()</span></code>, specifying <code class="docutils literal notranslate"><span class="pre">false</span></code> for the <code class="docutils literal notranslate"><span class="pre">in_order</span></code> parameter.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>However, SYCLcompat does not implement any mechanisms to deal with this case.
The rationale for this is that a user wanting the full power of SYCL’s
dependency management shouldn’t be using the this library. As such, support for
out-of-order queues is very limited. The only way to safely use an out-of-order
queue at present is to explicitly <code class="docutils literal notranslate"><span class="pre">q.wait()</span></code> or <code class="docutils literal notranslate"><span class="pre">e.wait()</span></code> where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the
<code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> returned through a <code class="docutils literal notranslate"><span class="pre">syclcompat::async</span></code> API.</p>
<p>To facilitate machine translation from other heterogeneous programming models to
SYCL, SYCLcompat provides the following pointer aliases for <code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> and
<code class="docutils literal notranslate"><span class="pre">sycl::queue</span></code>, and the function <code class="docutils literal notranslate"><span class="pre">destroy_event</span></code> which destroys an <code class="docutils literal notranslate"><span class="pre">event_ptr</span></code>
allocated on the heap.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">using</span><span class="w"> </span><span class="n">event_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">queue_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy_event</span><span class="p">(</span><span class="n">event_ptr</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="memory-operations">
<h3>Memory Operations<a class="headerlink" href="#memory-operations" title="Link to this heading">¶</a></h3>
<p>This library provides interfaces to allocate memory to be accessed within kernel
functions and on the host. The <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc</span></code> function allocates device
USM memory, the <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc_host</span></code> function allocates host USM memory,
and the <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc_shared</span></code> function allocates shared USM memory.</p>
<p>In each case we provide a template and non-templated interface for allocating
memory, taking the number of elements or number of bytes respectively.</p>
<p>The interface includes both synchronous and asynchronous <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>,
<code class="docutils literal notranslate"><span class="pre">memset</span></code>, <code class="docutils literal notranslate"><span class="pre">fill</span></code>, and <code class="docutils literal notranslate"><span class="pre">free</span></code> operations.</p>
<p>There is a helper class <code class="docutils literal notranslate"><span class="pre">pointer_attributes</span></code> to query allocation type for memory
pointers using SYCLcompat, through <code class="docutils literal notranslate"><span class="pre">sycl::usm::alloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">sycl::get_pointer_device</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Expects number of elements</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc_host</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc_shared</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Expects size of the memory in bytes</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc_host</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc_shared</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// 2D, 3D memory allocation wrappers</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">())</span>
<span class="n">pitched_data</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Blocking memcpy</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">to_pitch</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">from_pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_pos</span><span class="p">,</span>
<span class="w">            </span><span class="n">pitched_data</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">from_pos</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="c1">// Non-blocking memcpy</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">to_pitch</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">from_pitch</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_pos</span><span class="p">,</span>
<span class="w">                         </span><span class="n">pitched_data</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">from_pos</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="c1">// Fill</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">fill</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">fill_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Memset</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                          </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="c1">// Free</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wait_and_free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">enqueue_free</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pointers</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Queries pointer allocation type</span>
<span class="k">class</span><span class="w"> </span><span class="nc">pointer_attributes</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">usm</span><span class="o">::</span><span class="n">alloc</span><span class="w"> </span><span class="nf">get_memory_type</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_device_pointer</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_host_pointer</span><span class="p">();</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_memory_shared</span><span class="p">();</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_device_id</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">syclcompat::experimental</span></code> namespace contains currently unsupported <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> overloads which take a <code class="docutils literal notranslate"><span class="pre">syclcompat::experimental::memcpy_parameter</span></code> argument. These are included for forwards compatibility and currently throw a <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// Forward declarations for types relating to unsupported memcpy_parameter API:</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">memcpy_direction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">host_to_host</span><span class="p">,</span>
<span class="w">  </span><span class="n">host_to_device</span><span class="p">,</span>
<span class="w">  </span><span class="n">device_to_host</span><span class="p">,</span>
<span class="w">  </span><span class="n">device_to_device</span><span class="p">,</span>
<span class="w">  </span><span class="n">automatic</span>
<span class="p">};</span>

<span class="cp">#ifdef SYCL_EXT_ONEAPI_BINDLESS_IMAGES</span>
<span class="k">class</span><span class="w"> </span><span class="nc">image_mem_wrapper</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="k">class</span><span class="w"> </span><span class="nc">image_matrix</span><span class="p">;</span>

<span class="c1">/// Memory copy parameters for 2D/3D memory data.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">memcpy_parameter</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">data_wrapper</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pitched_data</span><span class="w"> </span><span class="n">pitched</span><span class="p">{};</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pos</span><span class="p">{};</span>
<span class="cp">#ifdef SYCL_EXT_ONEAPI_BINDLESS_IMAGES</span>
<span class="w">    </span><span class="n">experimental</span><span class="o">::</span><span class="n">image_mem_wrapper</span><span class="w"> </span><span class="o">*</span><span class="n">image_bindless</span><span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">image_matrix</span><span class="w"> </span><span class="o">*</span><span class="n">image</span><span class="p">{</span><span class="k">nullptr</span><span class="p">};</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">data_wrapper</span><span class="w"> </span><span class="n">from</span><span class="p">{};</span>
<span class="w">  </span><span class="n">data_wrapper</span><span class="w"> </span><span class="n">to</span><span class="p">{};</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">{};</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">memcpy_direction</span><span class="w"> </span><span class="n">direction</span><span class="p">{</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">memcpy_direction</span><span class="o">::</span><span class="n">automatic</span><span class="p">};</span>
<span class="p">};</span>

<span class="c1">/// [UNSUPPORTED] Synchronously copies 2D/3D memory data specified by \p param .</span>
<span class="c1">/// The function will return after the copy is completed.</span>
<span class="c1">///</span>
<span class="c1">/// \param param Memory copy parameters.</span>
<span class="c1">/// \param q Queue to execute the copy task.</span>
<span class="c1">/// \returns no return value.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">memcpy_parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span>
<span class="w">                          </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">/// [UNSUPPORTED] Asynchronously copies 2D/3D memory data specified by \p param</span>
<span class="c1">/// . The return of the function does NOT guarantee the copy is completed.</span>
<span class="c1">///</span>
<span class="c1">/// \param param Memory copy parameters.</span>
<span class="c1">/// \param q Queue to execute the copy task.</span>
<span class="c1">/// \returns no return value.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">memcpy_parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">param</span><span class="p">,</span>
<span class="w">                                </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace experimental</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>Finally, the class <code class="docutils literal notranslate"><span class="pre">pitched_data</span></code>, which manages memory allocation for 3D
spaces, padded to avoid uncoalesced memory accesses.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">pitched_data</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">pitched_data</span><span class="p">();</span>
<span class="w">  </span><span class="n">pitched_data</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_data_ptr</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_pitch</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_x</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_y</span><span class="p">();</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_ptr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_pitch</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_x</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_y</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>There are various helper classes and aliases defined within SYCLcompat to
encapsulate and define memory operations and objects. These classes and aliases
are primarily designed to assist with machine translation from other
heterogeneous programming models.</p>
<p>The wrapper class <code class="docutils literal notranslate"><span class="pre">device_memory</span></code> provides a unified representation for device
memory in various regions. The class provides methods to allocate memory for the
object (<code class="docutils literal notranslate"><span class="pre">init()</span></code>) and access the underlying memory in various ways (<code class="docutils literal notranslate"><span class="pre">get_ptr()</span></code>,
<code class="docutils literal notranslate"><span class="pre">get_access()</span></code>, <code class="docutils literal notranslate"><span class="pre">operator[]</span></code>). Aliases for global and USM shared specializations
are provided.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">memory_traits</span></code> class is provided as a traits helper for <code class="docutils literal notranslate"><span class="pre">device_memory</span></code>.
The <code class="docutils literal notranslate"><span class="pre">accessor</span></code> class template provides a 2D or 3D <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code>-like wrapper
around raw pointers.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">memory_region</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// device global memory</span>
<span class="w">  </span><span class="n">constant</span><span class="p">,</span><span class="w">   </span><span class="c1">// device read-only memory</span>
<span class="w">  </span><span class="n">local</span><span class="p">,</span><span class="w">      </span><span class="c1">// device local memory</span>
<span class="w">  </span><span class="n">usm_shared</span><span class="p">,</span><span class="w"> </span><span class="c1">// memory which can be accessed by host and device</span>
<span class="p">};</span>

<span class="k">using</span><span class="w"> </span><span class="n">byte_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8_t</span><span class="p">;</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">byte_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">memory_traits</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">asp</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">local_space</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">local</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">device</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">constant</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_write</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span>
<span class="w">      </span><span class="n">target</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">local_accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">device_memory</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">syclcompat_accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">();</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">,</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">init_list</span><span class="p">);</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">init_list</span><span class="p">);</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range_in</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Variadic constructor taking 1, 2 or 3 integers to be interpreted as a</span>
<span class="w">  </span><span class="c1">// sycl::range&lt;Dim&gt;.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">Arguments</span><span class="p">);</span>

<span class="w">  </span><span class="o">~</span><span class="n">device_memory</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Allocate memory with default queue, and init memory if has initial value.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Allocate memory with specified queue, and init memory if has initial</span>
<span class="w">  </span><span class="c1">// value.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The variable is assigned to a device pointer.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">assign</span><span class="p">(</span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get memory pointer of the memory object, which is virtual pointer when</span>
<span class="w">  </span><span class="c1">// usm is not used, and device pointer when usm is used.</span>
<span class="w">  </span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="nf">get_ptr</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Get memory pointer of the memory object, which is virtual pointer when</span>
<span class="w">  </span><span class="c1">// usm is not used, and device pointer when usm is used.</span>
<span class="w">  </span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="nf">get_ptr</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get the device memory object size in bytes.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_size</span><span class="p">();</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get accessor with dimension info for the device memory object</span>
<span class="w">  </span><span class="c1">// when usm is used and dimension is greater than 1.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">syclcompat_accessor_t</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="w">  </span><span class="n">get_access</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">);</span>
<span class="p">};</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">base</span><span class="o">::</span><span class="n">value_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">global_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">constant_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">shared_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">usm_shared</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">memory_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">element_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">pointer_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="n">pointer_t</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">);</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>

<span class="w">  </span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">memory_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">element_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">pointer_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="n">pointer_t</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">);</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="device-information">
<h3>Device Information<a class="headerlink" href="#device-information" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sycl::device</span></code> properties are encapsulated using the <code class="docutils literal notranslate"><span class="pre">device_info</span></code> helper class.
The class is meant to be constructed and used through the extended device
implemented in SYCLcompat.</p>
<p>This is the synopsis of <code class="docutils literal notranslate"><span class="pre">device_info</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">device_info</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">get_name</span><span class="p">();</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_name</span><span class="p">();</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">WorkItemSizesTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_work_item_sizes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">WorkItemSizesTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_work_item_sizes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_host_unified_memory</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_major_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_minor_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_integrated</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_clock_frequency</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_compute_units</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_sub_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_items_per_compute_unit</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_register_size_per_work_group</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">NDRangeSizeTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_nd_range_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">NDRangeSizeTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_nd_range_size</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_global_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_memory_clock_rate</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_memory_bus_width</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_device_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_uuid</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_global_mem_cache_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_image1d_max</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_image2d_max</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_image2d_max</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_image3d_max</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_image3d_max</span><span class="p">();</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_work_item_sizes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_work_item_sizes</span><span class="p">);</span>
<span class="w">  </span><span class="p">[[</span><span class="n">deprecated</span><span class="p">]]</span><span class="w"> </span><span class="kt">void</span>
<span class="w">  </span><span class="n">set_max_work_item_sizes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_work_item_sizes</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_host_unified_memory</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">host_unified_memory</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_major_version</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">major</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_minor_version</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">minor</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_integrated</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">integrated</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_clock_frequency</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frequency</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_compute_units</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_compute_units</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_global_mem_size</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_local_mem_size</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_work_group_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_group_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_sub_group_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_sub_group_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">set_max_work_items_per_compute_unit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_items_per_compute_unit</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_nd_range_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_nd_range_size</span><span class="p">[]);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_nd_range_size</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_nd_range_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_memory_clock_rate</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">memory_clock_rate</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_memory_bus_width</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">memory_bus_width</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span>
<span class="w">  </span><span class="nf">set_max_register_size_per_work_group</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_register_size_per_work_group</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_device_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">device_id</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_uuid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uuid</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_global_mem_cache_size</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">global_mem_cache_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_image1d_max</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_buffer_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_image2d_max</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_width_buffer_size</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_height_buffer_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_image3d_max</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_width_buffer_size</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_height_buffer_size</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">image_max_depth_buffer_size</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="device-management">
<h3>Device Management<a class="headerlink" href="#device-management" title="Link to this heading">¶</a></h3>
<p>Multiple SYCL functionalities are exposed through utility functions to manage
the current <code class="docutils literal notranslate"><span class="pre">sycl::device</span></code>, <code class="docutils literal notranslate"><span class="pre">sycl::queue</span></code>, and <code class="docutils literal notranslate"><span class="pre">sycl::context</span></code>, exposed as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Util function to create a new queue for the current device</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// Util function to get the default queue of current device in</span>
<span class="c1">// device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">get_default_queue</span><span class="p">();</span>

<span class="c1">// Util function to set the default queue of the current device in the</span>
<span class="c1">// device manager.</span>
<span class="c1">// If the device extension saved queue is the default queue, </span>
<span class="c1">// the previous saved queue will be overwritten as well.</span>
<span class="c1">// This function will be blocking if there are submitted kernels in the</span>
<span class="c1">// previous default queue.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_default_queue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>

<span class="c1">// Util function to wait for the queued kernels.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wait</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Util function to wait for the queued kernels and throw unhandled errors.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wait_and_throw</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Util function to get the id of current device in</span>
<span class="c1">// device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_current_device_id</span><span class="p">();</span>

<span class="c1">// Util function to get the current device.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_current_device</span><span class="p">();</span>

<span class="c1">// Util function to get a device by id.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_device</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="c1">// Util function to get the context of the default queue of current</span>
<span class="c1">// device in device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">context</span><span class="w"> </span><span class="nf">get_default_context</span><span class="p">();</span>

<span class="c1">// Util function to get a CPU device.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">cpu_device</span><span class="p">();</span>

<span class="c1">/// Filter out devices; only keep the device whose name contains one of the</span>
<span class="c1">/// subname in \p dev_subnames.</span>
<span class="c1">/// May break device id mapping and change current device. It&#39;s better to be</span>
<span class="c1">/// called before other SYCLcompat or SYCL APIs.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">filter_device</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev_subnames</span><span class="p">);</span>

<span class="c1">/// Print all the devices (and their IDs) in the dev_mgr</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">list_devices</span><span class="p">();</span>

<span class="c1">// Util function to select a device by its id</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">select_device</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="c1">// Util function to get the device id from a device</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_device_id</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>

<span class="c1">// Util function to get the number of available devices</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">device_count</span><span class="p">();</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>The exposed functionalities include creation and destruction of queues, through
<code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue</span></code> and <code class="docutils literal notranslate"><span class="pre">syclcompat::destroy_queue</span></code>, and providing the
ability to wait for submitted kernels using <code class="docutils literal notranslate"><span class="pre">syclcompat::wait</span></code> or
<code class="docutils literal notranslate"><span class="pre">syclcompat::wait_and_throw</span></code>. Any async errors will be output to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> if
<code class="docutils literal notranslate"><span class="pre">print_on_async_exceptions</span></code>, and will have the default behavior otherwise, which
calls <code class="docutils literal notranslate"><span class="pre">std:terminate</span></code>. Synchronous exceptions have to be managed by users
independently of what is set in this parameter.</p>
<p>Devices are managed through a helper class, <code class="docutils literal notranslate"><span class="pre">device_ext</span></code>. The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> class
associates a vector of <code class="docutils literal notranslate"><span class="pre">sycl::queues</span></code> with its <code class="docutils literal notranslate"><span class="pre">sycl::device</span></code>. The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code>
destructor waits on a set of <code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> which can be added to via
<code class="docutils literal notranslate"><span class="pre">add_event</span></code>. This is used, for example, to implement <code class="docutils literal notranslate"><span class="pre">syclcompat::enqueue_free</span></code> to
schedule release of memory after a kernel or <code class="docutils literal notranslate"><span class="pre">mempcy</span></code>. SYCL device properties
can be queried through <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> as well.
<code class="docutils literal notranslate"><span class="pre">device_ext</span></code> also provides the <code class="docutils literal notranslate"><span class="pre">has_capability_or_fail</span></code> member function, which
throws a <code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> if the device does not have the specified list of
<code class="docutils literal notranslate"><span class="pre">sycl::aspect</span></code>.</p>
<p>Devices can be listed and filtered using <code class="docutils literal notranslate"><span class="pre">syclcompat::list_devices()</span></code> and
<code class="docutils literal notranslate"><span class="pre">syclcompat::filter_device()</span></code>. If <code class="docutils literal notranslate"><span class="pre">SYCLCOMPAT_VERBOSE</span></code> is defined at compile
time, the available SYCL devices are printed to the standard output both at
initialization time, and when the device list is filtered using
<code class="docutils literal notranslate"><span class="pre">syclcompat::filter_device</span></code>.</p>
<p>Users can manage queues through the <code class="docutils literal notranslate"><span class="pre">syclcompat::set_default_queue(sycl::queue</span> <span class="pre">q)</span></code> free function, and the <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> <code class="docutils literal notranslate"><span class="pre">set_saved_queue</span></code>, <code class="docutils literal notranslate"><span class="pre">set_default_queue</span></code>,
and <code class="docutils literal notranslate"><span class="pre">get_saved_queue</span></code> member functions.
<code class="docutils literal notranslate"><span class="pre">set_default_queue</span></code> is blocking, and overwrites the previous default queue with
a user defined one, waiting for any submitted kernels to finish.
The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> automatically sets the saved queue to the default queue.
Therefore, it’s important to note that if the previous default queue was the
device’s saved queue, setting a new default queue will update the reference of
the saved queue to the new default one to keep the state of the class
consistent.</p>
<p>The class is exposed as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">device_ext</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">device_ext</span><span class="p">();</span>
<span class="w">  </span><span class="n">device_ext</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">             </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="o">~</span><span class="n">device_ext</span><span class="p">();</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_native_host_atomic_supported</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_major_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_minor_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_compute_units</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_clock_frequency</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_integrated</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_sub_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_register_size_per_work_group</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_mem_base_addr_align</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_global_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_memory_info</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">free_memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">total_memory</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_device_info</span><span class="p">(</span><span class="n">device_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="n">device_info</span><span class="w"> </span><span class="nf">get_device_info</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">default_queue</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_default_queue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">queues_wait_and_throw</span><span class="p">();</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy_queue</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">queue</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_saved_queue</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">get_saved_queue</span><span class="p">();</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">context</span><span class="w"> </span><span class="nf">get_context</span><span class="p">();</span>

<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">has_capability_or_fail</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">aspect</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">props</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>Free functions are provided for querying major and minor version directly from a <code class="docutils literal notranslate"><span class="pre">sycl::device</span></code>, equivalent to the methods of <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> described above:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_major_version</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_minor_version</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<section id="multiple-devices">
<h4>Multiple devices<a class="headerlink" href="#multiple-devices" title="Link to this heading">¶</a></h4>
<p>SYCLcompat allows you to manage multiple devices through
<code class="docutils literal notranslate"><span class="pre">syclcompat::select_device</span></code> and <code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue</span></code>. The library uses the
default SYCL device (i.e. the device returned by <code class="docutils literal notranslate"><span class="pre">sycl::default_selector_v</span></code>) as
the default device, and exposes all other devices available on the system
through the <code class="docutils literal notranslate"><span class="pre">syclcompat::select_device(unsigned</span> <span class="pre">int</span> <span class="pre">id)</span></code> member function.</p>
<p>The interface uses the <code class="docutils literal notranslate"><span class="pre">syclcompat::device_ext::get_current_device_id()</span></code> to get
the current CPU thread, and returns the associated device stored internally as a
map with that thread. The map is constructed using calls to
<code class="docutils literal notranslate"><span class="pre">syclcompat::select_device(unsigned</span> <span class="pre">int</span> <span class="pre">id)</span></code>. Any thread which hasn’t used this
member function to select a device will be given the default device. Note that
this implies multiple threads on a single device by default.</p>
<p>Be aware that targetting multiple devices may lead to unintended behavior caused
by developers, as SYCLcompat does not implement a mechanism to warn when the
wrong queue is used as an argument in any of the member functions of the
<code class="docutils literal notranslate"><span class="pre">syclcompat</span></code> namespace.</p>
</section>
<section id="atomic-operations">
<h4>Atomic Operations<a class="headerlink" href="#atomic-operations" title="Link to this heading">¶</a></h4>
<p>SYCLcompat provides an interface for common atomic operations (<code class="docutils literal notranslate"><span class="pre">add</span></code>, <code class="docutils literal notranslate"><span class="pre">sub</span></code>,
<code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">xor</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, <code class="docutils literal notranslate"><span class="pre">dec</span></code>, <code class="docutils literal notranslate"><span class="pre">exchange</span></code>, <code class="docutils literal notranslate"><span class="pre">compare_exchange</span></code>).
While SYCL exposes atomic operations through member functions of
<code class="docutils literal notranslate"><span class="pre">sycl::atomic_ref</span></code>, this library provides access via functions taking a standard
pointer argument. Template arguments control the <code class="docutils literal notranslate"><span class="pre">sycl::memory_scope</span></code>,
<code class="docutils literal notranslate"><span class="pre">sycl::memory_order</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::access::address_space</span></code> of these atomic
operations. SYCLcompat also exposes overloads for these atomic functions which
take a runtime memoryScope argument. Every atomic operation is implemented via
an API function taking a raw pointer as the target. Additional overloads for
<code class="docutils literal notranslate"><span class="pre">syclcompat::compare_exchange_strong</span></code> are provided which take a
<code class="docutils literal notranslate"><span class="pre">sycl::multi_ptr</span></code> instead of a raw pointer. The type of the operand for most
atomic operations is defined as <code class="docutils literal notranslate"><span class="pre">syclcompat::type_identity_t&lt;T&gt;</span></code> to avoid
template deduction issues when an operand of a different type (e.g. double
literal) is supplied. Atomic addition and subtraction free functions make use of
<code class="docutils literal notranslate"><span class="pre">syclcompat::arith_t&lt;T&gt;</span></code> to differentiate between numeric and pointer
arithmetic.</p>
<p>The available operations are exposed as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">type_identity</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type_identity_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">arith</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">arith_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">arith</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_sub</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_and</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_or</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_xor</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_min</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomic_fetch_compare_inc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomic_fetch_compare_dec</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_exchange</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_compare_exchange_strong</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">multi_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">addressSpace</span><span class="o">&gt;</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span>
<span class="w">    </span><span class="n">type_identity_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_compare_exchange_strong</span><span class="p">(</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>SYCLcompat also provides an atomic class with the <code class="docutils literal notranslate"><span class="pre">store</span></code>, <code class="docutils literal notranslate"><span class="pre">load</span></code>, <code class="docutils literal notranslate"><span class="pre">exchange</span></code>,
<code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code>, <code class="docutils literal notranslate"><span class="pre">fetch_add</span></code>, and <code class="docutils literal notranslate"><span class="pre">fetch_sub</span></code> operations. The atomic
class wrapper supports int, unsigned int, long, unsigned long, long long,
unsigned long long, float, double and pointer datatypes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">DefaultScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">system</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">Space</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">atomic</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_read_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Space</span><span class="o">&gt;::</span><span class="n">default_read_order</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_write_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Space</span><span class="o">&gt;::</span><span class="n">default_write_order</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">default_scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">DefaultOrder</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">atomic</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">atomic</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">store</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_write_order</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_order</span><span class="p">,</span>
<span class="w">         </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">exchange</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_weak</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">failure</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_weak</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_strong</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">failure</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_strong</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">fetch_add</span><span class="p">(</span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">fetch_sub</span><span class="p">(</span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
</section>
<section id="compatibility-utilities">
<h3>Compatibility Utilities<a class="headerlink" href="#compatibility-utilities" title="Link to this heading">¶</a></h3>
<p>This library provides a number of small compatibility utilities which exist to
facilitate machine translation of code from other programming models to SYCL.
These functions are part of the public API, but they are not expected to be
useful to developers writing their own code.</p>
<p>Functionality is provided to represent a pair of integers as a <code class="docutils literal notranslate"><span class="pre">double</span></code>.
<code class="docutils literal notranslate"><span class="pre">cast_ints_to_double(int,</span> <span class="pre">int)</span></code> returns a <code class="docutils literal notranslate"><span class="pre">double</span></code> containing the given integers
in the high &amp; low 32-bits respectively. <code class="docutils literal notranslate"><span class="pre">cast_double_to_int</span></code> casts the high or
low 32-bits back into an integer.</p>
<p><code class="docutils literal notranslate"><span class="pre">reverse_bits</span></code> reverses the bits of a 32-bit unsigned integer, <code class="docutils literal notranslate"><span class="pre">ffs</span></code> returns the
position of the first least significant set bit in an integer.
<code class="docutils literal notranslate"><span class="pre">byte_level_permute</span></code> returns a byte-permutation of two input unsigned integers,
with bytes selected according to a third unsigned integer argument.
<code class="docutils literal notranslate"><span class="pre">match_all_over_sub_group</span></code> and <code class="docutils literal notranslate"><span class="pre">match_any_over_sub_group</span></code> allows comparison of
values across work-items within a sub-group.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">select_from_sub_group</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_sub_group_left</span></code>,
<code class="docutils literal notranslate"><span class="pre">shift_sub_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">permute_sub_group_by_xor</span></code> provide equivalent
functionality to <code class="docutils literal notranslate"><span class="pre">sycl::select_from_group</span></code>, <code class="docutils literal notranslate"><span class="pre">sycl::shift_group_left</span></code>,
<code class="docutils literal notranslate"><span class="pre">sycl::shift_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::permute_group_by_xor</span></code>, respectively.
However, they provide an optional argument to represent the <code class="docutils literal notranslate"><span class="pre">logical_group</span></code> size
(default 32).</p>
<p><code class="docutils literal notranslate"><span class="pre">int_as_queue_ptr</span></code> helps with translation of code by reinterpret casting an
address to <code class="docutils literal notranslate"><span class="pre">sycl::queue</span> <span class="pre">*</span></code>, or returning a pointer to SYCLcompat’s default queue
if the address is &lt;= 2.
<code class="docutils literal notranslate"><span class="pre">args_selector</span></code> is a helper class for extracting arguments from an array of
pointers to arguments or buffer of arguments to pass to a kernel function.
The class allows users to exclude parameters such as <code class="docutils literal notranslate"><span class="pre">sycl::nd_item</span></code>.
Experimental support for masked versions of <code class="docutils literal notranslate"><span class="pre">select_from_sub_group</span></code>,
<code class="docutils literal notranslate"><span class="pre">shift_sub_group_left</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_sub_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">permute_sub_group_by_xor</span></code>
is provided only for SPIRV or CUDA devices.</p>
<p>As part of the compatibility utilities to facilitate machine translation to
SYCL, two aliases for errors are provided, <code class="docutils literal notranslate"><span class="pre">err0</span></code> and <code class="docutils literal notranslate"><span class="pre">err1</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">cast_double_to_int</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_high32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">cast_ints_to_double</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">high32</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low32</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">byte_level_permute</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ffs</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">match_any_over_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">match_all_over_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pred</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">select_from_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remote_local_id</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_left</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_right</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">permute_sub_group_by_xor</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">select_from_sub_group</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="w"> </span><span class="n">remote_local_id</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_left</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_right</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">permute_sub_group_by_xor</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycql</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace experimental</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="n">int_as_queue_ptr</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">using</span><span class="w"> </span><span class="n">err0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">generic_error_type</span><span class="o">&lt;</span><span class="k">struct</span><span class="w"> </span><span class="nc">err0_tag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">err1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">generic_error_type</span><span class="o">&lt;</span><span class="k">struct</span><span class="w"> </span><span class="nc">err1_tag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">args_selector</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">args_selector</span><span class="o">&lt;</span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">Ts</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Get the type of the ith argument of R(Ts...)</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">arg_type</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">tuple_element_t</span><span class="o">&lt;</span><span class="n">account_for_default_params</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// If kernel_params is nonnull, then args_selector will</span>
<span class="w">  </span><span class="c1">// extract arguments from kernel_params. Otherwise, it</span>
<span class="w">  </span><span class="c1">// will extract them from extra.</span>
<span class="w">  </span><span class="n">args_selector</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">kernel_params</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">kernel_params</span><span class="p">(</span><span class="n">kernel_params</span><span class="p">),</span><span class="w"> </span><span class="n">args_buffer</span><span class="p">(</span><span class="n">get_args_buffer</span><span class="p">(</span><span class="n">extra</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Get a reference to the i-th argument extracted from kernel_params</span>
<span class="w">  </span><span class="c1">// or extra.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">experimental::nd_range_barrier</span></code> synchronizes work items from all
work groups within a SYCL kernel. This is not officially supported by the SYCL
spec, and so should be used with caution.
<code class="docutils literal notranslate"><span class="pre">experimental::calculate_max_active_wg_per_xecore</span></code> and
<code class="docutils literal notranslate"><span class="pre">experimental::calculate_max_potential_wg</span></code> are used for occupancy calculation.
There is also an <code class="docutils literal notranslate"><span class="pre">experimental::logical_group</span></code> class which allows
<code class="docutils literal notranslate"><span class="pre">sycl::sub_group</span></code>s to be further subdivided into ‘logical’ groups to perform
sub-group level operations. This class provides methods to get the local &amp; group
id and range. <code class="docutils literal notranslate"><span class="pre">experimental::group_type</span></code>, <code class="docutils literal notranslate"><span class="pre">experimental::group</span></code> and
<code class="docutils literal notranslate"><span class="pre">experimental::group_base</span></code> are helper classes to manage the supported group
types.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>

<span class="cp">#if defined(__AMDGPU__) || defined(__NVPTX__)</span>
<span class="c1">// seq_cst currently not working for AMD nor Nvidia</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">nd_range_barrier</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">nd_range_barrier</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">logical_group</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">logical_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">group</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parent_group</span><span class="p">,</span>
<span class="w">                </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_local_linear_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_group_linear_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_local_linear_range</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_group_linear_range</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calculate_max_active_wg_per_xecore</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">num_wg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wg_size</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">slm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">sg_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_large_grf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calculate_max_potential_wg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">num_wg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">wg_size</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">max_wg_size_for_device_code</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">slm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sg_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_large_grf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="c1">// Supported group types</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">group_type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">work_group</span><span class="p">,</span><span class="w"> </span><span class="n">sub_group</span><span class="p">,</span><span class="w"> </span><span class="n">logical_group</span><span class="p">,</span><span class="w"> </span><span class="n">root_group</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// The group_base will dispatch the function call to the specific interface</span>
<span class="c1">// based on the group type.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">group_base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">group_base</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Returns the number of work-items in the group.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_linear_range</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Returns the index of the work-item within the group.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_linear_id</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Wait for all the elements within the group to complete their execution</span>
<span class="w">  </span><span class="c1">// before proceeding.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">barrier</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Container type that can store supported group_types.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GroupT</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">group</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">group_base</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">group</span><span class="p">(</span><span class="n">GroupT</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace experimental</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>To assist machine translation, helper aliases are provided for inlining and
alignment attributes. The class template declarations <code class="docutils literal notranslate"><span class="pre">sycl_compat_kernel_name</span></code>
and <code class="docutils literal notranslate"><span class="pre">sycl_compat_kernel_scalar</span></code> are used to assist automatic generation of
kernel names during machine translation.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_sycl_language_version</span></code> returns an integer representing the version of the
SYCL spec supported by the current SYCL compiler.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SYCLCOMPAT_CHECK_ERROR</span></code> macro encapsulates an error-handling mechanism for
expressions that might throw <code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> and <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code>. If no
exceptions are thrown, it returns <code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::SUCCESS</span></code>. If a
<code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> is caught, it returns <code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::BACKEND_ERROR</span></code>.
If a <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code> exception is caught,
<code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::DEFAULT_ERROR</span></code> is returned instead. For both cases, it
prints the error message to the standard error stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">syclcompat_kernel_name</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">syclcompat_kernel_scalar</span><span class="p">;</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#define __syclcompat_align__(n) __declspec(align(n))</span>
<span class="cp">#define __syclcompat_inline__ __forceinline</span>
<span class="cp">#else</span>
<span class="cp">#define __syclcompat_align__(n) __attribute__((aligned(n)))</span>
<span class="cp">#define __syclcompat_inline__ __inline__ __attribute__((always_inline))</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#define __syclcompat_noinline__ __declspec(noinline)</span>
<span class="cp">#else</span>
<span class="cp">#define __syclcompat_noinline__ __attribute__((noinline))</span>
<span class="cp">#endif</span>

<span class="cp">#define SYCLCOMPAT_COMPATIBILITY_TEMP (600)</span>

<span class="cp">#ifdef _WIN32</span>
<span class="cp">#define SYCLCOMPAT_EXPORT __declspec(dllexport)</span>
<span class="cp">#else</span>
<span class="cp">#define SYCLCOMPAT_EXPORT</span>
<span class="cp">#endif</span>


<span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">error_code</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">BACKEND_ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DEFAULT_ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>

<span class="cp">#define SYCLCOMPAT_CHECK_ERROR(expr)</span>

<span class="kt">int</span><span class="w"> </span><span class="n">get_sycl_language_version</span><span class="p">();</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
<section id="kernel-helper-functions">
<h3>Kernel Helper Functions<a class="headerlink" href="#kernel-helper-functions" title="Link to this heading">¶</a></h3>
<p>Kernel helper functions provide a structure <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> to keep SYCL
kernel information, and provide a utility function <code class="docutils literal notranslate"><span class="pre">get_kernel_function_info()</span></code>
to get the kernel information. Overloads are provided to allow either returning
a <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> object, or to return by pointer argument. In the
current version, <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> describes only maximum work-group size.</p>
<p>SYCLcompat also provides the <code class="docutils literal notranslate"><span class="pre">kernel_library</span></code> and <code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> classes.
<code class="docutils literal notranslate"><span class="pre">kernel_library</span></code> facilitates the loading and unloading of kernel libraries.
<code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> represents a specific kernel function within a loaded library
and can be invoked with specified arguments.
<code class="docutils literal notranslate"><span class="pre">load_kernel_library</span></code>, <code class="docutils literal notranslate"><span class="pre">load_kernel_library_mem</span></code>, and <code class="docutils literal notranslate"><span class="pre">unload_kernel_library</span></code>
are free functions to handle the loading and unloading of <code class="docutils literal notranslate"><span class="pre">kernel_library</span></code>
objects. <code class="docutils literal notranslate"><span class="pre">get_kernel_function</span></code>, and <code class="docutils literal notranslate"><span class="pre">invoke_kernel_function</span></code> offer a similar
functionality for <code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">kernel_function_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_kernel_function_info</span><span class="p">(</span><span class="n">kernel_function_info</span><span class="w"> </span><span class="o">*</span><span class="n">kernel_info</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">function</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">kernel_function_info</span><span class="w"> </span><span class="nf">get_kernel_function_info</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">function</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">kernel_library</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">kernel_library</span><span class="p">();</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">kernel_library</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="nf">load_kernel_library</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="nf">load_kernel_library_mem</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">image</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unload_kernel_library</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="o">&amp;</span><span class="n">library</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">kernel_function</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">kernel_function</span><span class="p">();</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">kernel_function</span><span class="p">(</span><span class="n">kernel_functor</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">kernel_function</span><span class="w"> </span><span class="nf">get_kernel_function</span><span class="p">(</span><span class="n">kernel_library</span><span class="w"> </span><span class="o">&amp;</span><span class="n">library</span><span class="p">,</span>
<span class="w">                                           </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">invoke_kernel_function</span><span class="p">(</span><span class="n">kernel_function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">group_range</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_range</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">kernel_params</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
<section id="math-functions">
<h3>Math Functions<a class="headerlink" href="#math-functions" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">funnelshift_*</span></code> APIs perform a concatenate-shift operation on two 32-bit
values, and return a 32-bit result. The two unsigned integer arguments (<code class="docutils literal notranslate"><span class="pre">low</span></code>
and <code class="docutils literal notranslate"><span class="pre">high</span></code>) are concatenated to a 64-bit value which is then shifted left or
right by <code class="docutils literal notranslate"><span class="pre">shift</span></code> bits. The functions then return either the least- or
most-significant 32 bits. The <code class="docutils literal notranslate"><span class="pre">_l*</span></code> variants shift <em>left</em> and return the <em>most</em>
significant 32 bits, while the <code class="docutils literal notranslate"><span class="pre">_r*</span></code> variants shift <em>right</em> and return the
<em>least</em> significant 32 bits. The <code class="docutils literal notranslate"><span class="pre">_l</span></code>/<code class="docutils literal notranslate"><span class="pre">_r</span></code> APIs differ from the <code class="docutils literal notranslate"><span class="pre">_lc</span></code>/<code class="docutils literal notranslate"><span class="pre">_rc</span></code> APIs
in how they clamp the <code class="docutils literal notranslate"><span class="pre">shift</span></code> argument: <code class="docutils literal notranslate"><span class="pre">funnelshift_l</span></code> and <code class="docutils literal notranslate"><span class="pre">funnelshift_r</span></code>
shift the result by <code class="docutils literal notranslate"><span class="pre">shift</span> <span class="pre">&amp;</span> <span class="pre">31</span></code> bits, whereas <code class="docutils literal notranslate"><span class="pre">funnelshift_lc</span></code> and
<code class="docutils literal notranslate"><span class="pre">funnelshift_rc</span></code> shift the result by <code class="docutils literal notranslate"><span class="pre">min(shift,</span> <span class="pre">32)</span></code> bits.</p>
<p><code class="docutils literal notranslate"><span class="pre">syclcompat::fast_length</span></code> provides a wrapper to SYCL’s
<code class="docutils literal notranslate"><span class="pre">fast_length(sycl::vec&lt;float,N&gt;)</span></code> that accepts arguments for a C++ array and a
length. <code class="docutils literal notranslate"><span class="pre">syclcompat::length</span></code> provides a templated version that wraps over
<code class="docutils literal notranslate"><span class="pre">sycl::length</span></code>. There are wrappers for <code class="docutils literal notranslate"><span class="pre">clamp</span></code>, <code class="docutils literal notranslate"><span class="pre">isnan</span></code>, <code class="docutils literal notranslate"><span class="pre">cbrt</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>,
<code class="docutils literal notranslate"><span class="pre">fmax_nan</span></code>, <code class="docutils literal notranslate"><span class="pre">fmin_nan</span></code>, and <code class="docutils literal notranslate"><span class="pre">pow</span></code>, as well as an implementation of <code class="docutils literal notranslate"><span class="pre">relu</span></code>
saturation is also provided.</p>
<p><code class="docutils literal notranslate"><span class="pre">compare</span></code>, <code class="docutils literal notranslate"><span class="pre">unordered_compare</span></code>, <code class="docutils literal notranslate"><span class="pre">compare_both</span></code>, <code class="docutils literal notranslate"><span class="pre">unordered_compare_both</span></code>,
<code class="docutils literal notranslate"><span class="pre">compare_mask</span></code>, and <code class="docutils literal notranslate"><span class="pre">unordered_compare_mask</span></code>, handle both ordered and unordered
comparisons.</p>
<p><code class="docutils literal notranslate"><span class="pre">vectorized_max</span></code> and <code class="docutils literal notranslate"><span class="pre">vectorized_min</span></code> are binary operations returning the
max/min of two arguments, where each argument is treated as a <code class="docutils literal notranslate"><span class="pre">sycl::vec</span></code> type.
<code class="docutils literal notranslate"><span class="pre">vectorized_isgreater</span></code> performs elementwise <code class="docutils literal notranslate"><span class="pre">isgreater</span></code>, treating each argument
as a vector of elements, and returning <code class="docutils literal notranslate"><span class="pre">0</span></code> for vector components for which
<code class="docutils literal notranslate"><span class="pre">isgreater</span></code> is false, and <code class="docutils literal notranslate"><span class="pre">-1</span></code> when true.
<code class="docutils literal notranslate"><span class="pre">vectorized_sum_abs_diff</span></code> calculates the absolute difference for two values
without modulo overflow for vector types.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">cmul</span></code>,<code class="docutils literal notranslate"><span class="pre">cdiv</span></code>,<code class="docutils literal notranslate"><span class="pre">cabs</span></code>, <code class="docutils literal notranslate"><span class="pre">cmul_add</span></code>, and <code class="docutils literal notranslate"><span class="pre">conj</span></code> define complex math
operations which accept <code class="docutils literal notranslate"><span class="pre">sycl::vec&lt;T,2&gt;</span></code> arguments representing complex values.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dp4a</span></code> function returns the 4-way 8-bit dot product accumulate for unsigned
and signed 32-bit integer values. The <code class="docutils literal notranslate"><span class="pre">dp2a_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">dp2a_hi</span></code> functions return the
two-way 16-bit to 8-bit dot product using the second and first 16 bits of the
second operand, respectively. These three APIs return a single 32-bit value with
the accumulated result, which is unsigned if both operands are <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> and
signed otherwise.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">funnelshift_l</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span>
<span class="w">                                  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span><span class="w"> </span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">funnelshift_lc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span><span class="w"> </span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">funnelshift_r</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span>
<span class="w">                                  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">funnelshift_rc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">high</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">fast_length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="nf">clamp</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">max_val</span><span class="p">);</span>

<span class="c1">// Determine whether 2 element value is NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">isnan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="c1">// cbrt function wrapper.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">cbrt</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">cbrt</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// For floating-point types, `float` or `double` arguments are acceptable.</span>
<span class="c1">// For integer types, `std::uint32_t`, `std::int32_t`, `std::uint64_t` or</span>
<span class="c1">// `std::int64_t` type arguments are acceptable.</span>
<span class="c1">// sycl::half supported as well.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">min</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">min</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">max</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">max</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Performs 2 elements comparison and returns the bigger one. If either of</span>
<span class="c1">// inputs is NaN, then return NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmax_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">fmax_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueU</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Performs 2 elements comparison and returns the smaller one. If either of</span>
<span class="c1">// inputs is NaN, then return NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmin_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">fmin_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueU</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">pown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">pown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Requires aspect::fp64, as it casts to double internally.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span>
<span class="n">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="c1">// The following definition is enabled when BinaryOperation(ValueT, ValueT) returns bool</span>
<span class="c1">// std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span>
<span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="c1">// The following definition is enabled when BinaryOperation(ValueT, ValueT) returns bool</span>
<span class="c1">// std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span>
<span class="n">unordered_compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">unordered_compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">compare_both</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">unordered_compare_both</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">compare_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">unordered_compare_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_min</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_isgreater</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_isgreater</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">ushort2</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_sum_abs_diff</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cdiv</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">cabs</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul_add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul_add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">conj</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">reverse_bits</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">dot_product_acc_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_unsigned_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_unsigned_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dp2a_lo</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dp2a_hi</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dp4a</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">dot_product_acc_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vectorized_binary</span></code> computes the <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code> for two operands,
with each value treated as a vector type. <code class="docutils literal notranslate"><span class="pre">vectorized_unary</span></code> offers the same
interface for operations with a single operand.
The implemented <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code>s are <code class="docutils literal notranslate"><span class="pre">abs_diff</span></code>, <code class="docutils literal notranslate"><span class="pre">add_sat</span></code>, <code class="docutils literal notranslate"><span class="pre">rhadd</span></code>, <code class="docutils literal notranslate"><span class="pre">hadd</span></code>,
<code class="docutils literal notranslate"><span class="pre">maximum</span></code>, <code class="docutils literal notranslate"><span class="pre">minimum</span></code>, and <code class="docutils literal notranslate"><span class="pre">sub_sat</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UnaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_unary</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UnaryOperation</span><span class="w"> </span><span class="n">unary_op</span><span class="p">);</span>

<span class="c1">// A sycl::abs wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">abs</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_binary</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="c1">// A sycl::abs_diff wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">abs_diff</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::add_sat wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">add_sat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::rhadd wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rhadd</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::hadd wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hadd</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::max wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">maximum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::min wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">minimum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::sub_sat wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sub_sat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>The math header provides a set of functions to extend 32-bit operations
to 33 bit, and handle sign extension internally. There is support for <code class="docutils literal notranslate"><span class="pre">add</span></code>,
<code class="docutils literal notranslate"><span class="pre">sub</span></code>, <code class="docutils literal notranslate"><span class="pre">absdiff</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> operations. Each operation provides overloads
to include a second, separate, <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code> after the first, and include
the <code class="docutils literal notranslate"><span class="pre">_sat</span></code> variation, determines if the returning value is saturated or not.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>
</pre></div>
</div>
<p>Another set of vectorized extend 32-bit operations is provided in the math
header.These APIs treat each of the 32-bit operands as 2-elements vector
(16-bits each) while handling sign extension to 17-bits internally. There is
support for <code class="docutils literal notranslate"><span class="pre">add</span></code>, <code class="docutils literal notranslate"><span class="pre">sub</span></code>, <code class="docutils literal notranslate"><span class="pre">absdiff</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> and <code class="docutils literal notranslate"><span class="pre">avg</span></code> binary operations.
Each operation provides has a <code class="docutils literal notranslate"><span class="pre">_sat</span></code> variat which determines if the returning
value is saturated or not, and a <code class="docutils literal notranslate"><span class="pre">_add</span></code> variant that computes the binary sum
of the the initial operation outputs and a third operand.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Compute vectorized addition of \p a and \p b, with each value treated as a</span>
<span class="c1">/// 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized addition of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized addition of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized addition of the two</span>
<span class="c1">/// values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized addition of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized addition of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b, with each value treated as</span>
<span class="c1">/// a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized subtraction of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b, with each value treated as</span>
<span class="c1">/// a 2 elements vector type and extend each element to 17 bit. Then add each</span>
<span class="c1">/// half of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized subtraction of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized subtraction of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized abs_diff of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized abs_diff of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized abs_diff of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized minimum of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized minimum of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized minimum of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized maximum of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized maximum of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized maximum of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized average of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b, with each value treated as a 2</span>
<span class="c1">/// elements vector type and extend each element to 17 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend average maximum of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 2 elements vector type and extend each element to 17 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized average of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg2_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>Similarly, a set of vectorized extend 32-bit operations is provided in the math
header treating each of the 32-bit operands as 4-elements vector (8-bits each)
while handling sign extension to 9-bits internally. There is support for <code class="docutils literal notranslate"><span class="pre">add</span></code>,
<code class="docutils literal notranslate"><span class="pre">sub</span></code>, <code class="docutils literal notranslate"><span class="pre">absdiff</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> and <code class="docutils literal notranslate"><span class="pre">avg</span></code> binary operations.
Each operation provides has a <code class="docutils literal notranslate"><span class="pre">_sat</span></code> variat which determines if the returning
value is saturated or not, and a <code class="docutils literal notranslate"><span class="pre">_add</span></code> variant that computes the binary sum
of the the initial operation outputs and a third operand.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Compute vectorized addition of \p a and \p b, with each value treated as a</span>
<span class="c1">/// 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized addition of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized addition of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized addition of the two</span>
<span class="c1">/// values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized addition of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized addition of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vadd4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b, with each value treated as</span>
<span class="c1">/// a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized subtraction of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b, with each value treated as</span>
<span class="c1">/// a 4 elements vector type and extend each element to 9 bit. Then add each</span>
<span class="c1">/// half of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized subtraction of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized subtraction of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized subtraction of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vsub4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized abs_diff of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized abs_diff of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized abs_diff of \p a and \p b with saturation, with each</span>
<span class="c1">/// value treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized abs_diff of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vabsdiff4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized minimum of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized minimum of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized minimum of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized minimum of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmin4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized maximum of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized maximum of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized maximum of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized maximum of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vmax4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized average of the two values</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b, with each value treated as a 4</span>
<span class="c1">/// elements vector type and extend each element to 9 bit. Then add each half</span>
<span class="c1">/// of the result and add with \p c.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The addition of each half of extend vectorized average of the</span>
<span class="c1">/// two values and the third value</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="c1">/// Compute vectorized average of \p a and \p b with saturation, with each value</span>
<span class="c1">/// treated as a 4 elements vector type and extend each element to 9 bit.</span>
<span class="c1">/// \tparam [in] RetT The type of the return value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \returns The extend vectorized average of the two values with saturation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_vavrg4_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
</pre></div>
</div>
<p>Vectorized comparison APIs also provided in the math header behave similarly
and support a <code class="docutils literal notranslate"><span class="pre">std</span></code> comparison operator parameter which can be <code class="docutils literal notranslate"><span class="pre">greater</span></code>,
<code class="docutils literal notranslate"><span class="pre">less</span></code>, <code class="docutils literal notranslate"><span class="pre">greater_equal</span></code>, <code class="docutils literal notranslate"><span class="pre">less_equal</span></code>, <code class="docutils literal notranslate"><span class="pre">equal_to</span></code> or <code class="docutils literal notranslate"><span class="pre">not_equal_to</span></code>. These APIs
cover both the 2-elements <em>(16-bits each)</em> and 4-elements <em>(8-bits each)</em>
variants, as well as an additional <code class="docutils literal notranslate"><span class="pre">_add</span></code> variant that computes the sum of the
2/4 output elements.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Extend \p a and \p b to 33 bit and vectorized compare input values using</span>
<span class="c1">/// specified comparison \p cmp .</span>
<span class="c1">///</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BinaryOperation The type of the compare operation</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] cmp The comparsion operator</span>
<span class="c1">/// \returns The comparison result of the two extended values.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">extend_vcompare2</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>

<span class="c1">/// Extend Inputs to 33 bit, and vectorized compare input values using specified</span>
<span class="c1">/// comparison \p cmp , then add the result with \p c .</span>
<span class="c1">///</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BinaryOperation The type of the compare operation</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \param [in] cmp The comparsion operator</span>
<span class="c1">/// \returns The comparison result of the two extended values, and add the</span>
<span class="c1">/// result with \p c .</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">extend_vcompare2_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>

<span class="c1">/// Extend \p a and \p b to 33 bit and vectorized compare input values using</span>
<span class="c1">/// specified comparison \p cmp .</span>
<span class="c1">///</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BinaryOperation The type of the compare operation</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] cmp The comparsion operator</span>
<span class="c1">/// \returns The comparison result of the two extended values.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">extend_vcompare4</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>

<span class="c1">/// Extend Inputs to 33 bit, and vectorized compare input values using specified</span>
<span class="c1">/// comparison \p cmp , then add the result with \p c .</span>
<span class="c1">///</span>
<span class="c1">/// \tparam [in] AT The type of the first value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BT The type of the second value, can only be 32 bit integer</span>
<span class="c1">/// \tparam [in] BinaryOperation The type of the compare operation</span>
<span class="c1">/// \param [in] a The first value</span>
<span class="c1">/// \param [in] b The second value</span>
<span class="c1">/// \param [in] c The third value</span>
<span class="c1">/// \param [in] cmp The comparsion operator</span>
<span class="c1">/// \returns The comparison result of the two extended values, and add the</span>
<span class="c1">/// result with \p c .</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">extend_vcompare4_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
</pre></div>
</div>
<p>The math header file provides APIs for bit-field insertion (<code class="docutils literal notranslate"><span class="pre">bfi_safe</span></code>) and
bit-field extraction (<code class="docutils literal notranslate"><span class="pre">bfe_safe</span></code>). These are bounds-checked variants of
underlying <code class="docutils literal notranslate"><span class="pre">detail</span></code> APIs (<code class="docutils literal notranslate"><span class="pre">detail::bfi</span></code>, <code class="docutils literal notranslate"><span class="pre">detail::bfe</span></code>) which, in future
releases, will be exposed to the user.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Bitfield-insert with boundary checking.</span>
<span class="c1">///</span>
<span class="c1">/// Align and insert a bit field from \param x into \param y . Source \param</span>
<span class="c1">/// bit_start gives the starting bit position for the insertion, and source</span>
<span class="c1">/// \param num_bits gives the bit field length in bits.</span>
<span class="c1">///</span>
<span class="c1">/// \tparam T The type of \param x and \param y , must be an unsigned integer.</span>
<span class="c1">/// \param x The source of the bitfield.</span>
<span class="c1">/// \param y The source where bitfield is inserted.</span>
<span class="c1">/// \param bit_start The position to start insertion.</span>
<span class="c1">/// \param num_bits The number of bits to insertion.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">bfi_safe</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bit_start</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_bits</span><span class="p">);</span>

<span class="c1">/// Bitfield-extract with boundary checking.</span>
<span class="c1">///</span>
<span class="c1">/// Extract bit field from \param source and return the zero or sign-extended</span>
<span class="c1">/// result. Source \param bit_start gives the bit field starting bit position,</span>
<span class="c1">/// and source \param num_bits gives the bit field length in bits.</span>
<span class="c1">///</span>
<span class="c1">/// The result is padded with the sign bit of the extracted field. If `num_bits`</span>
<span class="c1">/// is zero, the  result is zero. If the start position is beyond the msb of the</span>
<span class="c1">/// input, the result is filled with the replicated sign bit of the extracted</span>
<span class="c1">/// field.</span>
<span class="c1">///</span>
<span class="c1">/// \tparam T The type of \param source value, must be an integer.</span>
<span class="c1">/// \param source The source value to extracting.</span>
<span class="c1">/// \param bit_start The position to start extracting.</span>
<span class="c1">/// \param num_bits The number of bits to extracting.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">bfe_safe</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bit_start</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_bits</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="sample-code">
<h2>Sample Code<a class="headerlink" href="#sample-code" title="Link to this heading">¶</a></h2>
<p>Below is a simple linear algebra sample, which computes <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">mx</span> <span class="pre">+</span> <span class="pre">b</span></code> implemented
using this library:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;syclcompat.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * Slope intercept form of a straight line equation: Y = m * X + b</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">slope_intercept</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Block index</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">work_group_id</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Thread index</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">local_id</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tx</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// or  i = syclcompat::global_id::x();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">check_memory</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to allocate memory: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Program main</span>
<span class="cm"> */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Simple Kernel example&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5f</span><span class="p">;</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block_size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">get_current_device</span><span class="p">()</span>
<span class="w">                       </span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">max_work_group_size</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;block_size = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, n_points = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n_points</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate host memory for vectors X and Y</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_X</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;h_X allocation failed.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_Y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;h_Y allocation failed.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Alternative templated allocation for the expected output</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_expected</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Not enough for h_expected.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Initialize host memory &amp; expected output</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_points</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">h_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">h_expected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Allocate device memory</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">d_X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">d_Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d_X allocation failed.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d_Y allocation failed.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// copy host memory to device</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">h_X</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">);</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Computing result using SYCL Kernel... &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">slope_intercept</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">slope_intercept</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">wait</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DONE&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Async copy result from device to host</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">h_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Check output</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_points</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">h_Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h_expected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Clean up memory</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_X</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_Y</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_expected</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_X</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_Y</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="maintainers">
<h2>Maintainers<a class="headerlink" href="#maintainers" title="Link to this heading">¶</a></h2>
<p>To report problems with this library, please open a new issue with the [COMPAT]
tag at:</p>
<p><a class="reference external" href="https://github.com/intel/llvm/issues">https://github.com/intel/llvm/issues</a></p>
</section>
<section id="contributors">
<h2>Contributors<a class="headerlink" href="#contributors" title="Link to this heading">¶</a></h2>
<p>Alberto Cabrera, Codeplay <br />
Gordon Brown, Codeplay <br />
Joe Todd, Codeplay <br />
Pietro Ghiglio, Codeplay <br />
Ruyman Reyes, Codeplay/Intel</p>
</section>
<section id="contributions">
<h2>Contributions<a class="headerlink" href="#contributions" title="Link to this heading">¶</a></h2>
<p>This library is licensed under the Apache 2.0 license. If you have an idea for a
new sample, different build system integration or even a fix for something that
is broken, please get in contact.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html">CUDA crosslane vs OpenCL sub-groups</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../FAQ.html">Frequently Asked Questions</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>