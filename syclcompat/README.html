<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>SYCLcompat &#8212; oneAPI DPC++ Compiler  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css?v=e491ac2d" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Frequently Asked Questions" href="../FAQ.html" />
    <link rel="prev" title="CUDA crosslane vs OpenCL sub-groups" href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>oneAPI DPC++ Compiler  documentation</span></a></h1>
        <h2 class="heading"><span>SYCLcompat</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html">CUDA crosslane vs OpenCL sub-groups</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../FAQ.html">Frequently Asked Questions</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="syclcompat">
<h1>SYCLcompat<a class="headerlink" href="#syclcompat" title="Link to this heading">¶</a></h1>
<p>SYCLcompat is a header-only library that intends to help developers familiar
with other heterogeneous programming models (such as OpenMP, CUDA or HIP) to
familiarize themselves with the SYCL programming API while porting their
existing codes. Compatibility tools can also benefit from the reduced API size
when converting legacy codebases.</p>
<p>SYCLcompat provides:</p>
<ul class="simple">
<li><p>A high-level API that provides closer semantics to other programming models,
simplifying line by line conversions.</p></li>
<li><p>Alternative submission APIs that encapusulate SYCL-specific “queue” and
“event” APIs for easier reference.</p></li>
<li><p>Ability to gradually introduce other SYCL concepts as the user familiarises
themselves with the core SYCL API.</p></li>
<li><p>Clear distinction between core SYCL API and the compatibility interface via
separate namespaces.</p></li>
</ul>
<section id="important-disclaimer">
<h2>Important Disclaimer<a class="headerlink" href="#important-disclaimer" title="Link to this heading">¶</a></h2>
<p>SYCLcompat state is experimental. Its functionalities have been implemented but
are not assured to remain consistent in the future. The API is subject to
potential disruptions with new updates, so exercise caution when using it.</p>
</section>
<section id="notice">
<h2>Notice<a class="headerlink" href="#notice" title="Link to this heading">¶</a></h2>
<p>Copyright © 2023-2023 Codeplay Software Limited. All rights reserved.</p>
<p>Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks of
The Khronos Group Inc. OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.</p>
</section>
<section id="support">
<h2>Support<a class="headerlink" href="#support" title="Link to this heading">¶</a></h2>
<p>SYCLcompat depends on specific oneAPI DPC++ compiler extensions that may not be
available to all the SYCL 2020 specification implementations.</p>
<p>Specifically, this library depends on the following SYCL extensions:</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/0999c0bfbd428178cb701853a8d57be0/sycl_ext_oneapi_local_memory.asciidoc"><span class="xref download myst">sycl_ext_oneapi_local_memory</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/d519c283ec7dc492aa901f61d888cdb7/sycl_ext_oneapi_complex.asciidoc"><span class="xref download myst">sycl_ext_oneapi_complex</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/cd2e3ebabcf6d6094c5a3274d5a2ddb0/sycl_ext_oneapi_free_function_queries.asciidoc"><span class="xref download myst">sycl_ext_oneapi_free_function_queries</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/292bf929b84890cb56c6e35dc55dfc02/sycl_ext_oneapi_assert.asciidoc"><span class="xref download myst">sycl_ext_oneapi_assert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/e3cc36403d28a69692d6fe3db1525577/sycl_ext_oneapi_enqueue_barrier.asciidoc"><span class="xref download myst">sycl_ext_oneapi_enqueue_barrier</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/511cbbf41116faa3a2cb8f10ff6d90f5/sycl_ext_oneapi_usm_device_read_only.asciidoc"><span class="xref download myst">sycl_ext_oneapi_usm_device_read_only</span></a></p></li>
</ul>
<p>If available, the following extensions extend SYCLcompat functionality:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/supported/sycl_ext_intel_device_info.md">sycl_ext_intel_device_info</a> [Optional]</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/0d9e2f39b3cca9b1cb20bb5ccebe0adb/sycl_ext_oneapi_bfloat16_math_functions.asciidoc"><span class="xref download myst">sycl_ext_oneapi_bfloat16_math_functions</span></a> [Optional]</p></li>
</ul>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h2>
<p>All functionality is available under the <code class="docutils literal notranslate"><span class="pre">syclcompat::</span></code> namespace, imported
through the main header, <code class="docutils literal notranslate"><span class="pre">syclcompat.hpp</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">syclcompat.hpp</span></code> does not
import the &lt;sycl/sycl.hpp&gt; header.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;syclcompat.hpp&gt;</span>
</pre></div>
</div>
<p>This document presents the public API under the <a class="reference internal" href="#features">Features</a> section,
and provides a working <a class="reference internal" href="#sample-code">Sample code</a> using this library. Refer to
those to learn to use the library.</p>
</section>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Link to this heading">¶</a></h2>
<section id="dim3">
<h3>dim3<a class="headerlink" href="#dim3" title="Link to this heading">¶</a></h3>
<p>SYCLcompat provides a <code class="docutils literal notranslate"><span class="pre">dim3</span></code> class akin to that of CUDA or HIP programming
models. <code class="docutils literal notranslate"><span class="pre">dim3</span></code> encapsulates other languages iteration spaces that are
represented with coordinate letters (x, y, z).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">dim3</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">dim3</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">dim3</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">();</span>

<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Element-wise operators</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>In SYCL, the fastest-moving dimension is the one with the highest index, e.g. in
a SYCL 2D range iteration space, there are two dimensions, 0 and 1, and 1 will
be the one that “moves faster”. The compatibility headers for SYCL offer a
number of convenience functions that help the mapping between xyz-based
coordinates to SYCL iteration spaces in the different scopes available. In
addition to the global range, the following helper functions are also provided:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">local_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace local_id</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">local_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace local_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">work_group_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace work_group_id</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">work_group_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace work_group_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">global_range</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace global_range</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">global_id</span><span class="w"> </span><span class="p">{</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">x</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">y</span><span class="p">();</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">z</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace global_id</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>These translate any kernel dimensions from one convention to the other. An
example of an equivalent SYCL call for a 3D kernel using <code class="docutils literal notranslate"><span class="pre">compat</span></code> is
<code class="docutils literal notranslate"><span class="pre">syclcompat::global_id::x()</span> <span class="pre">==</span> <span class="pre">get_global_id(2)</span></code>.</p>
</section>
<section id="local-memory">
<h3>Local Memory<a class="headerlink" href="#local-memory" title="Link to this heading">¶</a></h3>
<p>When using <code class="docutils literal notranslate"><span class="pre">compat</span></code> functions, there are two distinct interfaces to allocate
device local memory. The first interface uses the <em>sycl_ext_oneapi_local_memory</em>
extension to leverage local memory defined at compile time.
<em>sycl_ext_oneapi_local_memory</em> is accessed through the following wrapper:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">AllocT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">local_mem</span><span class="p">();</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">syclcompat::local_mem&lt;AllocT&gt;()</span></code> can be used as illustrated in the example
below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sample kernel</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">local_mem_2d</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">d_A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Local memory extension wrapper, size defined at compile-time</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">As</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_mem</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="p">][</span><span class="n">BLOCK_SIZE</span><span class="p">]</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_id</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">local_id</span><span class="o">::</span><span class="n">y</span><span class="p">();</span>
<span class="w">  </span><span class="n">As</span><span class="p">[</span><span class="n">id_y</span><span class="p">][</span><span class="n">id_x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id_y</span><span class="p">;</span>
<span class="w">  </span><span class="n">wg_barrier</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">As</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">id_y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">id_x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="n">d_A</span><span class="p">[</span><span class="n">global_id</span><span class="o">::</span><span class="n">y</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">global_id</span><span class="o">::</span><span class="n">x</span><span class="p">()]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second interface allows users to allocate device local memory at runtime.
SYCLcompat provides this functionality through its kernel launch interface,
<code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code>, defined in the following section.</p>
</section>
<section id="launch">
<h3>launch<function><a class="headerlink" href="#launch" title="Link to this heading">¶</a></h3>
<p>SYCLcompat provides a kernel <code class="docutils literal notranslate"><span class="pre">launch</span></code> interface which accepts a function that
executes on the device (a.k.a “kernel”) instead of a lambda/functor. It can be
called either by using a pair of “teams”/”blocks” and “threads”, from
OpenMP/CUDA terminology, or using a <code class="docutils literal notranslate"><span class="pre">sycl::nd_range</span></code>. The interface accepts a
device <em>function</em> with the use of an <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">F</span></code> template parameter, and a variadic
<code class="docutils literal notranslate"><span class="pre">Args</span></code> for the function’s arguments.</p>
<p>Various overloads for <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> exist to permit the user to launch on a
specific <code class="docutils literal notranslate"><span class="pre">queue</span></code>, or to define dynamically sized device local memory.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span>
<span class="w">                   </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">launch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">dim3</span><span class="w"> </span><span class="o">&amp;</span><span class="n">threads</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>For example, if the user had an existing function named <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> to execute
on a device such as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vectorAdd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>using SYCLcompat, the user can call it as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>which would be equivalent to the following call using a <code class="docutils literal notranslate"><span class="pre">sycl::nd_range</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="n">blocksPerGrid</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span>
<span class="w">                               </span><span class="n">threadsPerBlock</span><span class="p">};</span>
<span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>For dynamic local memory allocation, <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> injects a pointer to a
local <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> accessor of <code class="docutils literal notranslate"><span class="pre">mem_size</span></code> as the last argument of the kernel
function. For example, the previous function named <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> can be modified
with the following signature, which adds a <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> pointer to access local
memory inside the kernel:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">vectorAdd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span>
<span class="w">               </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">local_mem</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">vectorAdd</span></code> can be launched like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">blocksPerGrid</span><span class="p">,</span><span class="w"> </span><span class="n">threadsPerBlock</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span>
<span class="w">                              </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>or this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span><span class="n">globalSize</span><span class="p">,</span><span class="w"> </span><span class="n">localSize</span><span class="p">};</span>
<span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">vectorAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">range</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">,</span><span class="w"> </span><span class="n">d_A</span><span class="p">,</span><span class="w"> </span><span class="n">d_B</span><span class="p">,</span><span class="w"> </span><span class="n">d_C</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">launch</span></code> interface allows users to define an internal memory pool, or
scratchpad, that can then be reinterpreted as the datatype required by the user
within the kernel function.</p>
</section>
<section id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Link to this heading">¶</a></h3>
<p>SYCLcompat introduces a set of utility functions designed to streamline the
usage of the library and its <code class="docutils literal notranslate"><span class="pre">launch&lt;function&gt;</span></code> mechanism.</p>
<p>The first utility function is <code class="docutils literal notranslate"><span class="pre">syclcompat::wg_barrier()</span></code>, which provides a
concise work-group barrier. <code class="docutils literal notranslate"><span class="pre">syclcompat::wg_barrier()</span></code> uses the
<em>SYCL_INTEL_free_function_queries</em> extension to provide this functionality.</p>
<p>The second utility function, <code class="docutils literal notranslate"><span class="pre">syclcompat::compute_nd_range</span></code>, ensures that the
provided global size and work group sizes are appropriate for a given
dimensionality, and that global size is rounded up to a multiple of the work
group size in each dimension.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wg_barrier</span><span class="p">();</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Dim</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compute_nd_range</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">global_size_in</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dim</span><span class="o">&gt;</span><span class="w"> </span><span class="n">work_group_size</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">compute_nd_range</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">global_size_in</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                          </span><span class="kt">int</span><span class="w"> </span><span class="n">work_group_size</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="queues">
<h3>Queues<a class="headerlink" href="#queues" title="Link to this heading">¶</a></h3>
<p>The design for this library assumes <em>in-order</em> queues
(<code class="docutils literal notranslate"><span class="pre">sycl::property::queue::in_order()</span></code>).</p>
<p>Many of the APIs accept an optional <code class="docutils literal notranslate"><span class="pre">queue</span></code> parameter, and this can be an
out-of-order queue, either created manually or retrieved via a call to
<code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue()</span></code>, specifying <code class="docutils literal notranslate"><span class="pre">false</span></code> for the <code class="docutils literal notranslate"><span class="pre">in_order</span></code> parameter.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>However, SYCLcompat does not implement any mechanisms to deal with this case.
The rationale for this is that a user wanting the full power of SYCL’s
dependency management shouldn’t be using the this library. As such, support for
out-of-order queues is very limited. The only way to safely use an out-of-order
queue at present is to explicitly <code class="docutils literal notranslate"><span class="pre">q.wait()</span></code> or <code class="docutils literal notranslate"><span class="pre">e.wait()</span></code> where <code class="docutils literal notranslate"><span class="pre">e</span></code> is the
<code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> returned through a <code class="docutils literal notranslate"><span class="pre">syclcompat::async</span></code> API.</p>
<p>To facilitate machine translation from other heterogeneous programming models to
SYCL, SYCLcompat provides the following pointer aliases for <code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> and
<code class="docutils literal notranslate"><span class="pre">sycl::queue</span></code>, and the function <code class="docutils literal notranslate"><span class="pre">destroy_event</span></code> which destroys an <code class="docutils literal notranslate"><span class="pre">event_ptr</span></code>
allocated on the heap.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">using</span><span class="w"> </span><span class="n">event_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>

<span class="k">using</span><span class="w"> </span><span class="n">queue_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy_event</span><span class="p">(</span><span class="n">event_ptr</span><span class="w"> </span><span class="n">event</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="memory-allocation">
<h3>Memory Allocation<a class="headerlink" href="#memory-allocation" title="Link to this heading">¶</a></h3>
<p>This library provides interfaces to allocate memory to be accessed within kernel
functions and on the host. The <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc</span></code> function allocates device
USM memory, the <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc_host</span></code> function allocates host USM memory,
and the <code class="docutils literal notranslate"><span class="pre">syclcompat::malloc_shared</span></code> function allocates shared USM memory.</p>
<p>In each case we provide a template and non-templated interface for allocating
memory, taking the number of elements or number of bytes respectively.</p>
<p>The interface includes both synchronous and asynchronous <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>,
<code class="docutils literal notranslate"><span class="pre">memset</span></code>, <code class="docutils literal notranslate"><span class="pre">fill</span></code>, and <code class="docutils literal notranslate"><span class="pre">free</span></code> operations.</p>
<p>There is a helper class <code class="docutils literal notranslate"><span class="pre">pointer_attributes</span></code> to query allocation type for memory
pointers using SYCLcompat, through <code class="docutils literal notranslate"><span class="pre">sycl::usm::alloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">sycl::get_pointer_device</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Expects number of elements</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc_host</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">malloc_shared</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Expects size of the memory in bytes</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc_host</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc_shared</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// 2D, 3D memory allocation wrappers</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">())</span>
<span class="n">pitched_data</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Blocking memcpy</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">to_pitch</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">from_pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memcpy</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_pos</span><span class="p">,</span>
<span class="w">            </span><span class="n">pitched_data</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">from_pos</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="c1">// Non-blocking memcpy</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">to_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">to_pitch</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">from_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">from_pitch</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memcpy_async</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">to</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_pos</span><span class="p">,</span>
<span class="w">                         </span><span class="n">pitched_data</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">from_pos</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="c1">// Fill</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">fill</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="n">fill_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Memset</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">            </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">memset</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                          </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dev_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span>
<span class="w">                         </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 2D matrix</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">memset_async</span><span class="p">(</span><span class="n">pitched_data</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                         </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span><span class="w"> </span><span class="c1">// 3D matrix</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="w"> </span><span class="nf">free_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pointers</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">event</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">events</span><span class="p">,</span>
<span class="w">                       </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Queries pointer allocation type</span>
<span class="k">class</span><span class="w"> </span><span class="nc">pointer_attributes</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">usm</span><span class="o">::</span><span class="n">alloc</span><span class="w"> </span><span class="nf">get_memory_type</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_device_pointer</span><span class="p">();</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_host_pointer</span><span class="p">();</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_memory_shared</span><span class="p">();</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_device_id</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>Finally, the class <code class="docutils literal notranslate"><span class="pre">pitched_data</span></code>, which manages memory allocation for 3D
spaces, padded to avoid uncoalesced memory accesses.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">pitched_data</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">pitched_data</span><span class="p">();</span>
<span class="w">  </span><span class="n">pitched_data</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get_data_ptr</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_pitch</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_x</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_y</span><span class="p">();</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_ptr</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_pitch</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">pitch</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_x</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_y</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>There are various helper classes and aliases defined within SYCLcompat to
encapsulate and define memory operations and objects. These classes and aliases
are primarily designed to assist with machine translation from other
heterogeneous programming models.</p>
<p>The wrapper class <code class="docutils literal notranslate"><span class="pre">device_memory</span></code> provides a unified representation for device
memory in various regions. The class provides methods to allocate memory for the
object (<code class="docutils literal notranslate"><span class="pre">init()</span></code>) and access the underlying memory in various ways (<code class="docutils literal notranslate"><span class="pre">get_ptr()</span></code>,
<code class="docutils literal notranslate"><span class="pre">get_access()</span></code>, <code class="docutils literal notranslate"><span class="pre">operator[]</span></code>). Aliases for global and USM shared specializations
are provided.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">memory_traits</span></code> class is provided as a traits helper for <code class="docutils literal notranslate"><span class="pre">device_memory</span></code>.
The <code class="docutils literal notranslate"><span class="pre">accessor</span></code> class template provides a 2D or 3D <code class="docutils literal notranslate"><span class="pre">sycl::accessor</span></code>-like wrapper
around raw pointers.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">memory_region</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">global</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="c1">// device global memory</span>
<span class="w">  </span><span class="n">constant</span><span class="p">,</span><span class="w">   </span><span class="c1">// device read-only memory</span>
<span class="w">  </span><span class="n">local</span><span class="p">,</span><span class="w">      </span><span class="c1">// device local memory</span>
<span class="w">  </span><span class="n">usm_shared</span><span class="p">,</span><span class="w"> </span><span class="c1">// memory which can be accessed by host and device</span>
<span class="p">};</span>

<span class="k">using</span><span class="w"> </span><span class="n">byte_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint8_t</span><span class="p">;</span>

<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">target</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">byte_t</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">memory_traits</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">asp</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">local_space</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">local</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">device</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="w"> </span><span class="n">mode</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="p">(</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">constant</span><span class="p">)</span>
<span class="w">          </span><span class="o">?</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read</span>
<span class="w">          </span><span class="o">:</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access_mode</span><span class="o">::</span><span class="n">read_write</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">type_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span><span class="n">Memory</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">remove_cv_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span>
<span class="w">      </span><span class="n">target</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">target</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">local_accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">device_memory</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">syclcompat_accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">();</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">,</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">init_list</span><span class="p">);</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">,</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">init_list</span><span class="p">);</span>

<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range_in</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Variadic constructor taking 1, 2 or 3 integers to be interpreted as a</span>
<span class="w">  </span><span class="c1">// sycl::range&lt;Dim&gt;.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">Arguments</span><span class="p">);</span>

<span class="w">  </span><span class="o">~</span><span class="n">device_memory</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Allocate memory with default queue, and init memory if has initial value.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Allocate memory with specified queue, and init memory if has initial</span>
<span class="w">  </span><span class="c1">// value.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The variable is assigned to a device pointer.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">assign</span><span class="p">(</span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get memory pointer of the memory object, which is virtual pointer when</span>
<span class="w">  </span><span class="c1">// usm is not used, and device pointer when usm is used.</span>
<span class="w">  </span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="nf">get_ptr</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Get memory pointer of the memory object, which is virtual pointer when</span>
<span class="w">  </span><span class="c1">// usm is not used, and device pointer when usm is used.</span>
<span class="w">  </span><span class="n">value_t</span><span class="w"> </span><span class="o">*</span><span class="nf">get_ptr</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get the device memory object size in bytes.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_size</span><span class="p">();</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get accessor with dimension info for the device memory object</span>
<span class="w">  </span><span class="c1">// when usm is used and dimension is greater than 1.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">D</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">syclcompat_accessor_t</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="w">  </span><span class="n">get_access</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">);</span>
<span class="p">};</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">base</span><span class="o">::</span><span class="n">value_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">value_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
<span class="w">  </span><span class="n">device_memory</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">global_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">constant_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">shared_memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_memory</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">usm_shared</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="p">;</span>


<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Dimension</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">memory_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">element_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">pointer_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="n">pointer_t</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">);</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>

<span class="w">  </span><span class="n">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">memory_region</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">accessor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">memory_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory_traits</span><span class="o">&lt;</span><span class="n">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">element_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">element_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pointer_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="n">pointer_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">memory_t</span><span class="o">::</span><span class="k">template</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="n">pointer_t</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">memory_region</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Memory</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">M</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">memory_region</span><span class="o">::</span><span class="n">local</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">);</span>
<span class="w">  </span><span class="n">accessor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">accessor_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in_range</span><span class="p">);</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">  </span><span class="n">pointer_t</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
</section>
<section id="device-information">
<h3>Device Information<a class="headerlink" href="#device-information" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sycl::device</span></code> properties are encapsulated using the <code class="docutils literal notranslate"><span class="pre">device_info</span></code> helper class.
The class is meant to be constructed and used through the extended device
implemented in SYCLcompat.</p>
<p>This is the synopsis of <code class="docutils literal notranslate"><span class="pre">device_info</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">device_info</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">get_name</span><span class="p">();</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_name</span><span class="p">();</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">WorkItemSizesTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_work_item_sizes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">WorkItemSizesTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">WorkItemSizesTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_work_item_sizes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_host_unified_memory</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_major_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_minor_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_integrated</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_clock_frequency</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_compute_units</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_sub_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_items_per_compute_unit</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_register_size_per_work_group</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">NDRangeSizeTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_nd_range_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">NDRangeSizeTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                 </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">NDRangeSizeTy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">get_max_nd_range_size</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_global_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_memory_clock_rate</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_memory_bus_width</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_device_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_uuid</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_global_mem_cache_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_work_item_sizes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_work_item_sizes</span><span class="p">);</span>
<span class="w">  </span><span class="p">[[</span><span class="n">deprecated</span><span class="p">]]</span><span class="w"> </span><span class="kt">void</span>
<span class="w">  </span><span class="n">set_max_work_item_sizes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_work_item_sizes</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_host_unified_memory</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">host_unified_memory</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_major_version</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">major</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_minor_version</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">minor</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_integrated</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">integrated</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_clock_frequency</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">frequency</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_compute_units</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_compute_units</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_global_mem_size</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">global_mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_local_mem_size</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_work_group_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_group_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_sub_group_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_sub_group_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">set_max_work_items_per_compute_unit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_items_per_compute_unit</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_max_nd_range_size</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_nd_range_size</span><span class="p">[]);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_memory_clock_rate</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">memory_clock_rate</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_memory_bus_width</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">memory_bus_width</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span>
<span class="w">  </span><span class="nf">set_max_register_size_per_work_group</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">max_register_size_per_work_group</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_device_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">device_id</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_uuid</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uuid</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_global_mem_cache_size</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">global_mem_cache_size</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="device-management">
<h3>Device Management<a class="headerlink" href="#device-management" title="Link to this heading">¶</a></h3>
<p>Multiple SYCL functionalities are exposed through utility functions to manage
the current <code class="docutils literal notranslate"><span class="pre">sycl::device</span></code>, <code class="docutils literal notranslate"><span class="pre">sycl::queue</span></code>, and <code class="docutils literal notranslate"><span class="pre">sycl::context</span></code>, exposed as
follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Util function to create a new queue for the current device</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// Util function to get the default queue of current device in</span>
<span class="c1">// device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="nf">get_default_queue</span><span class="p">();</span>

<span class="c1">// Util function to set the default queue of the current device in the</span>
<span class="c1">// device manager.</span>
<span class="c1">// If the device extension saved queue is the default queue, </span>
<span class="c1">// the previous saved queue will be overwritten as well.</span>
<span class="c1">// This function will be blocking if there are submitted kernels in the</span>
<span class="c1">// previous default queue.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_default_queue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>

<span class="c1">// Util function to wait for the queued kernels.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wait</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Util function to wait for the queued kernels and throw unhandled errors.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">wait_and_throw</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_default_queue</span><span class="p">());</span>

<span class="c1">// Util function to get the id of current device in</span>
<span class="c1">// device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_current_device_id</span><span class="p">();</span>

<span class="c1">// Util function to get the current device.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_current_device</span><span class="p">();</span>

<span class="c1">// Util function to get a device by id.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_device</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="c1">// Util function to get the context of the default queue of current</span>
<span class="c1">// device in device manager.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">context</span><span class="w"> </span><span class="nf">get_default_context</span><span class="p">();</span>

<span class="c1">// Util function to get a CPU device.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">device_ext</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">cpu_device</span><span class="p">();</span>

<span class="c1">// Util function to select a device by its id</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">select_device</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<p>The exposed functionalities include creation and destruction of queues, through
<code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue</span></code> and <code class="docutils literal notranslate"><span class="pre">syclcompat::destroy_queue</span></code>, and providing the
ability to wait for submitted kernels using <code class="docutils literal notranslate"><span class="pre">syclcompat::wait</span></code> or
<code class="docutils literal notranslate"><span class="pre">syclcompat::wait_and_throw</span></code>. Any async errors will be output to <code class="docutils literal notranslate"><span class="pre">stderr</span></code> if
<code class="docutils literal notranslate"><span class="pre">print_on_async_exceptions</span></code>, and will have the default behavior otherwise, which calls <code class="docutils literal notranslate"><span class="pre">std:terminate</span></code>. Synchronous exceptions have to be managed
by users independently of what is set in this parameter.</p>
<p>Devices are managed through a helper class, <code class="docutils literal notranslate"><span class="pre">device_ext</span></code>. The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> class
associates a vector of <code class="docutils literal notranslate"><span class="pre">sycl::queues</span></code> with its <code class="docutils literal notranslate"><span class="pre">sycl::device</span></code>. The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code>
destructor waits on a set of <code class="docutils literal notranslate"><span class="pre">sycl::event</span></code> which can be added to via
<code class="docutils literal notranslate"><span class="pre">add_event</span></code>. This is used, for example, to implement <code class="docutils literal notranslate"><span class="pre">syclcompat::free_async</span></code> to
schedule release of memory after a kernel or <code class="docutils literal notranslate"><span class="pre">mempcy</span></code>. SYCL device properties
can be queried through <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> as well.
<code class="docutils literal notranslate"><span class="pre">device_ext</span></code> also provides the <code class="docutils literal notranslate"><span class="pre">has_capability_or_fail</span></code> member function, which
throws a <code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> if the device does not have the specified list of
<code class="docutils literal notranslate"><span class="pre">sycl::aspect</span></code>.</p>
<p>Users can manage queues through the <code class="docutils literal notranslate"><span class="pre">syclcompat::set_default_queue(sycl::queue</span> <span class="pre">q)</span></code>
free function, and the <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> <code class="docutils literal notranslate"><span class="pre">set_saved_queue</span></code>, <code class="docutils literal notranslate"><span class="pre">set_default_queue</span></code>,
and <code class="docutils literal notranslate"><span class="pre">get_saved_queue</span></code> member functions.
<code class="docutils literal notranslate"><span class="pre">set_default_queue</span></code> is blocking, and
overwrites the previous default queue with a user defined one, waiting for any
submitted kernels to finish.
The <code class="docutils literal notranslate"><span class="pre">device_ext</span></code> automatically sets the saved queue to the default queue.
Therefore, it’s important to note that if the previous default queue was the
device’s saved queue, setting a new default queue will update the reference of
the saved queue to the new default one to keep the state of the class consistent.</p>
<p>The class is exposed as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">device_ext</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">device_ext</span><span class="p">();</span>
<span class="w">  </span><span class="n">device_ext</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">device</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">             </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="o">~</span><span class="n">device_ext</span><span class="p">();</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_native_host_atomic_supported</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_major_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_minor_version</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_compute_units</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_clock_frequency</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_integrated</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_sub_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_register_size_per_work_group</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_max_work_group_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_mem_base_addr_align</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_global_mem_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_memory_info</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">free_memory</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">total_memory</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_device_info</span><span class="p">(</span><span class="n">device_info</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="n">device_info</span><span class="w"> </span><span class="nf">get_device_info</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">default_queue</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_default_queue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">queues_wait_and_throw</span><span class="p">();</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">create_queue</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">print_on_async_exceptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">destroy_queue</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">queue</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_saved_queue</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="nf">get_saved_queue</span><span class="p">();</span>
<span class="w">  </span><span class="n">sycl</span><span class="o">::</span><span class="n">context</span><span class="w"> </span><span class="nf">get_context</span><span class="p">();</span>

<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">has_capability_or_fail</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">aspect</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">props</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// syclcompat</span>
</pre></div>
</div>
<section id="multiple-devices">
<h4>Multiple devices<a class="headerlink" href="#multiple-devices" title="Link to this heading">¶</a></h4>
<p>SYCLcompat allows you to manage multiple devices through
<code class="docutils literal notranslate"><span class="pre">syclcompat::select_device</span></code> and <code class="docutils literal notranslate"><span class="pre">syclcompat::create_queue</span></code>. The library uses the
default SYCL device (i.e. the device returned by <code class="docutils literal notranslate"><span class="pre">sycl::default_selector_v</span></code>) as
the default device, and exposes all other devices available on the system
through the <code class="docutils literal notranslate"><span class="pre">syclcompat::select_device(unsigned</span> <span class="pre">int</span> <span class="pre">id)</span></code> member function.</p>
<p>The interface uses the <code class="docutils literal notranslate"><span class="pre">syclcompat::device_ext::get_current_device_id()</span></code> to get
the current CPU thread, and returns the associated device stored internally as a
map with that thread. The map is constructed using calls to
<code class="docutils literal notranslate"><span class="pre">syclcompat::select_device(unsigned</span> <span class="pre">int</span> <span class="pre">id)</span></code>. Any thread which hasn’t used this
member function to select a device will be given the default device. Note that
this implies multiple threads on a single device by default.</p>
<p>Be aware that targetting multiple devices may lead to unintended behavior caused
by developers, as SYCLcompat does not implement a mechanism to warn when the
wrong queue is used as an argument in any of the member functions of the
<code class="docutils literal notranslate"><span class="pre">syclcompat</span></code> namespace.</p>
</section>
<section id="atomic-operations">
<h4>Atomic Operations<a class="headerlink" href="#atomic-operations" title="Link to this heading">¶</a></h4>
<p>SYCLcompat provides an interface for common atomic operations (<code class="docutils literal notranslate"><span class="pre">add</span></code>, <code class="docutils literal notranslate"><span class="pre">sub</span></code>,
<code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">xor</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">inc</span></code>, <code class="docutils literal notranslate"><span class="pre">dec</span></code>, <code class="docutils literal notranslate"><span class="pre">exchange</span></code>, <code class="docutils literal notranslate"><span class="pre">compare_exchange</span></code>).
While SYCL exposes atomic operations through member functions of
<code class="docutils literal notranslate"><span class="pre">sycl::atomic_ref</span></code>, this library provides access via functions taking a standard
pointer argument. Template arguments control the <code class="docutils literal notranslate"><span class="pre">sycl::memory_scope</span></code>,
<code class="docutils literal notranslate"><span class="pre">sycl::memory_order</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::access::address_space</span></code> of these atomic
operations. SYCLcompat also exposes overloads for these atomic functions which
take a runtime memoryScope argument. Every atomic operation is implemented via
an API function taking a raw pointer as the target. Additional overloads for
<code class="docutils literal notranslate"><span class="pre">syclcompat::compare_exchange_strong</span></code> are provided which take a
<code class="docutils literal notranslate"><span class="pre">sycl::multi_ptr</span></code> instead of a raw pointer. The type of the operand for most
atomic operations is defined as <code class="docutils literal notranslate"><span class="pre">syclcompat::type_identity_t&lt;T&gt;</span></code> to avoid
template deduction issues when an operand of a different type (e.g. double
literal) is supplied. Atomic addition and subtraction free functions make use of
<code class="docutils literal notranslate"><span class="pre">syclcompat::arith_t&lt;T&gt;</span></code> to differentiate between numeric and pointer
arithmetics.</p>
<p>The available operations are exposed as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">type_identity</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type_identity_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">arith</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">conditional_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">arith_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">arith</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_sub</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_and</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_or</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_xor</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_min</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_fetch_max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomic_fetch_compare_inc</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">atomic_fetch_compare_dec</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_exchange</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">type_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_compare_exchange_strong</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">multi_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="o">&gt;</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">addressSpace</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="n">atomic_compare_exchange_strong</span><span class="p">(</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">fail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">relaxed</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>SYCLcompat also provides an atomic class with the <code class="docutils literal notranslate"><span class="pre">store</span></code>, <code class="docutils literal notranslate"><span class="pre">load</span></code>, <code class="docutils literal notranslate"><span class="pre">exchange</span></code>,
<code class="docutils literal notranslate"><span class="pre">compare_exchange_weak</span></code>, <code class="docutils literal notranslate"><span class="pre">fetch_add</span></code>, and <code class="docutils literal notranslate"><span class="pre">fetch_sub</span></code> operations. The atomic
class wrapper supports int, unsigned int, long, unsigned long, long long,
unsigned long long, float, double and pointer datatypes.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">DefaultScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">system</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">,</span>
<span class="w">          </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="w"> </span><span class="n">Space</span><span class="w"> </span><span class="o">=</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">generic_space</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">atomic</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_read_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Space</span><span class="o">&gt;::</span><span class="n">default_read_order</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_write_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultOrder</span><span class="p">,</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Space</span><span class="o">&gt;::</span><span class="n">default_write_order</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">default_scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DefaultScope</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">DefaultOrder</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">atomic</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="n">atomic</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">store</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_write_order</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_order</span><span class="p">,</span>
<span class="w">         </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">exchange</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">             </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_weak</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">failure</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_weak</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_strong</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">success</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">failure</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">compare_exchange_strong</span><span class="p">(</span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">desired</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">      </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">fetch_add</span><span class="p">(</span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>

<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="nf">fetch_sub</span><span class="p">(</span><span class="n">arith_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">memoryOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_read_modify_write_order</span><span class="p">,</span>
<span class="w">              </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="w"> </span><span class="n">memoryScope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">default_scope</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
</section>
<section id="compatibility-utilities">
<h3>Compatibility Utilities<a class="headerlink" href="#compatibility-utilities" title="Link to this heading">¶</a></h3>
<p>This library provides a number of small compatibility utilities which exist to
facilitate machine translation of code from other programming models to SYCL.
These functions are part of the public API, but they are not expected to be
useful to developers writing their own code.</p>
<p>Functionality is provided to represent a pair of integers as a <code class="docutils literal notranslate"><span class="pre">double</span></code>.
<code class="docutils literal notranslate"><span class="pre">cast_ints_to_double(int,</span> <span class="pre">int)</span></code> returns a <code class="docutils literal notranslate"><span class="pre">double</span></code> containing the given integers
in the high &amp; low 32-bits respectively. <code class="docutils literal notranslate"><span class="pre">cast_double_to_int</span></code> casts the high or
low 32-bits back into an integer.</p>
<p><code class="docutils literal notranslate"><span class="pre">reverse_bits</span></code> reverses the bits of a 32-bit unsigned integer, <code class="docutils literal notranslate"><span class="pre">ffs</span></code> returns the
position of the first least significant set bit in an integer.
<code class="docutils literal notranslate"><span class="pre">byte_level_permute</span></code> returns a byte-permutation of two input unsigned integers,
with bytes selected according to a third unsigned integer argument.
<code class="docutils literal notranslate"><span class="pre">match_all_over_sub_group</span></code> and <code class="docutils literal notranslate"><span class="pre">match_any_over_sub_group</span></code> allows comparison of values
across work-items within a sub-group.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">select_from_sub_group</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_sub_group_left</span></code>,
<code class="docutils literal notranslate"><span class="pre">shift_sub_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">permute_sub_group_by_xor</span></code> provide equivalent
functionality to <code class="docutils literal notranslate"><span class="pre">sycl::select_from_group</span></code>, <code class="docutils literal notranslate"><span class="pre">sycl::shift_group_left</span></code>,
<code class="docutils literal notranslate"><span class="pre">sycl::shift_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">sycl::permute_group_by_xor</span></code>, respectively.
However, they provide an optional argument to represent the <code class="docutils literal notranslate"><span class="pre">logical_group</span></code> size
(default 32).</p>
<p><code class="docutils literal notranslate"><span class="pre">int_as_queue_ptr</span></code> helps with translation of code by reinterpret casting an
address to <code class="docutils literal notranslate"><span class="pre">sycl::queue</span> <span class="pre">*</span></code>, or returning a pointer to Syclcompat’s default queue
if the address is &lt;= 2.
<code class="docutils literal notranslate"><span class="pre">args_selector</span></code> is a helper class for extracting arguments from an array of
pointers to arguments or buffer of arguments to pass to a kernel function.
The class allows users to exclude parameters such as <code class="docutils literal notranslate"><span class="pre">sycl::nd_item</span></code>.
Experimental support for masked versions of <code class="docutils literal notranslate"><span class="pre">select_from_sub_group</span></code>,
<code class="docutils literal notranslate"><span class="pre">shift_sub_group_left</span></code>, <code class="docutils literal notranslate"><span class="pre">shift_sub_group_right</span></code> and <code class="docutils literal notranslate"><span class="pre">permute_sub_group_by_xor</span></code>
is provided only for SPIRV or cuda devices.</p>
<p>As part of the compatibility utilities to facilitate machine translation to SYCL,
two aliases for errors are provided, <code class="docutils literal notranslate"><span class="pre">err0</span></code> and <code class="docutils literal notranslate"><span class="pre">err1</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">cast_double_to_int</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_high32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">cast_ints_to_double</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">high32</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">low32</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">byte_level_permute</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ffs</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">match_any_over_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">match_all_over_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pred</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">select_from_sub_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remote_local_id</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_left</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_right</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">permute_sub_group_by_xor</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span>
<span class="w">                           </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">select_from_sub_group</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">int</span><span class="w"> </span><span class="n">remote_local_id</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_left</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">shift_sub_group_right</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="n">ValueT</span><span class="w"> </span><span class="n">permute_sub_group_by_xor</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">member_mask</span><span class="p">,</span><span class="w"> </span><span class="n">sycql</span><span class="o">::</span><span class="n">sub_group</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span>
<span class="w">                                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">logical_sub_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace experimental</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">*</span><span class="n">int_as_queue_ptr</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">using</span><span class="w"> </span><span class="n">err0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">generic_error_type</span><span class="o">&lt;</span><span class="k">struct</span><span class="w"> </span><span class="nc">err0_tag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">err1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">detail</span><span class="o">::</span><span class="n">generic_error_type</span><span class="o">&lt;</span><span class="k">struct</span><span class="w"> </span><span class="nc">err1_tag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">args_selector</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">args_selector</span><span class="o">&lt;</span><span class="n">n_nondefault_params</span><span class="p">,</span><span class="w"> </span><span class="n">n_default_params</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">Ts</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Get the type of the ith argument of R(Ts...)</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">arg_type</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">tuple_element_t</span><span class="o">&lt;</span><span class="n">account_for_default_params</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// If kernel_params is nonnull, then args_selector will</span>
<span class="w">  </span><span class="c1">// extract arguments from kernel_params. Otherwise, it</span>
<span class="w">  </span><span class="c1">// will extract them from extra.</span>
<span class="w">  </span><span class="n">args_selector</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">kernel_params</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">kernel_params</span><span class="p">(</span><span class="n">kernel_params</span><span class="p">),</span><span class="w"> </span><span class="n">args_buffer</span><span class="p">(</span><span class="n">get_args_buffer</span><span class="p">(</span><span class="n">extra</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Get a reference to the i-th argument extracted from kernel_params</span>
<span class="w">  </span><span class="c1">// or extra.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arg_type</span><span class="o">&lt;</span><span class="n">i</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">experimental::nd_range_barrier</span></code> synchronizes work items from all
work groups within a SYCL kernel. This is not officially supported by the SYCL
spec, and so should be used with caution.
<code class="docutils literal notranslate"><span class="pre">experimental::calculate_max_active_wg_per_xecore</span></code> and
<code class="docutils literal notranslate"><span class="pre">experimental::calculate_max_potential_wg</span></code> are used for occupancy calculation.
There is also an <code class="docutils literal notranslate"><span class="pre">experimental::logical_group</span></code> class which allows
<code class="docutils literal notranslate"><span class="pre">sycl::sub_group</span></code>s to be further subdivided into ‘logical’ groups to perform
sub-group level operations. This class provides methods to get the local &amp; group
id and range. <code class="docutils literal notranslate"><span class="pre">experimental::group_type</span></code>, <code class="docutils literal notranslate"><span class="pre">experimental::group</span></code> and
<code class="docutils literal notranslate"><span class="pre">experimental::group_base</span></code> are helper classes to manage the supported group
types.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">experimental</span><span class="w"> </span><span class="p">{</span>

<span class="cp">#if defined(__AMDGPU__) || defined(__NVPTX__)</span>
<span class="c1">// seq_cst currently not working for AMD nor Nvidia</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">acq_rel</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_order</span><span class="o">::</span><span class="n">seq_cst</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">nd_range_barrier</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">nd_range_barrier</span><span class="p">(</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span>
<span class="w">    </span><span class="n">sycl</span><span class="o">::</span><span class="n">atomic_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">barrier_memory_order</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">memory_scope</span><span class="o">::</span><span class="n">device</span><span class="p">,</span>
<span class="w">                     </span><span class="n">sycl</span><span class="o">::</span><span class="n">access</span><span class="o">::</span><span class="n">address_space</span><span class="o">::</span><span class="n">global_space</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">logical_group</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">logical_group</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">group</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parent_group</span><span class="p">,</span>
<span class="w">                </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_local_linear_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_group_linear_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_local_linear_range</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_group_linear_range</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calculate_max_active_wg_per_xecore</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">num_wg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wg_size</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">slm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">int</span><span class="w"> </span><span class="n">sg_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_large_grf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">calculate_max_potential_wg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">num_wg</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">wg_size</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">max_wg_size_for_device_code</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">int</span><span class="w"> </span><span class="n">slm_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sg_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_barrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_large_grf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="c1">// Supported group types</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">group_type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">work_group</span><span class="p">,</span><span class="w"> </span><span class="n">sub_group</span><span class="p">,</span><span class="w"> </span><span class="n">logical_group</span><span class="p">,</span><span class="w"> </span><span class="n">root_group</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// The group_base will dispatch the function call to the specific interface</span>
<span class="c1">// based on the group type.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">group_base</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">group_base</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Returns the number of work-items in the group.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_linear_range</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Returns the index of the work-item within the group.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_local_linear_id</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Wait for all the elements within the group to complete their execution</span>
<span class="w">  </span><span class="c1">// before proceeding.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">barrier</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// Container type that can store supported group_types.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GroupT</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">group</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">group_base</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">group</span><span class="p">(</span><span class="n">GroupT</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_item</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="n">item</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace experimental</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>To assist machine translation, helper aliases are provided for inlining and
alignment attributes. The class template declarations <code class="docutils literal notranslate"><span class="pre">sycl_compat_kernel_name</span></code>
and <code class="docutils literal notranslate"><span class="pre">sycl_compat_kernel_scalar</span></code> are used to assist automatic generation of
kernel names during machine translation.</p>
<p><code class="docutils literal notranslate"><span class="pre">get_sycl_language_version</span></code> returns an integer representing the version of the
SYCL spec supported by the current SYCL compiler.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">SYCLCOMPAT_CHECK_ERROR</span></code> macro encapsulates an error-handling mechanism for
expressions that might throw <code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> and <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code>.
If no exceptions are thrown, it returns <code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::SUCCESS</span></code>.
If a <code class="docutils literal notranslate"><span class="pre">sycl::exception</span></code> is caught, it returns <code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::BACKEND_ERROR</span></code>.
If a <code class="docutils literal notranslate"><span class="pre">std::runtime_error</span></code> exception is caught,</p>
<p><code class="docutils literal notranslate"><span class="pre">syclcompat::error_code::DEFAULT_ERROR</span></code> is returned instead. For both cases, it
prints the error message to the standard error stream.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">syclcompat_kernel_name</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">syclcompat_kernel_scalar</span><span class="p">;</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#define __syclcompat_align__(n) __declspec(align(n))</span>
<span class="cp">#define __syclcompat_inline__ __forceinline</span>
<span class="cp">#else</span>
<span class="cp">#define __syclcompat_align__(n) __attribute__((aligned(n)))</span>
<span class="cp">#define __syclcompat_inline__ __inline__ __attribute__((always_inline))</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(_MSC_VER)</span>
<span class="cp">#define __syclcompat_noinline__ __declspec(noinline)</span>
<span class="cp">#else</span>
<span class="cp">#define __syclcompat_noinline__ __attribute__((noinline))</span>
<span class="cp">#endif</span>

<span class="cp">#define SYCLCOMPAT_COMPATIBILITY_TEMP (600)</span>

<span class="cp">#ifdef _WIN32</span>
<span class="cp">#define SYCLCOMPAT_EXPORT __declspec(dllexport)</span>
<span class="cp">#else</span>
<span class="cp">#define SYCLCOMPAT_EXPORT</span>
<span class="cp">#endif</span>


<span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">error_code</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">SUCCESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">BACKEND_ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DEFAULT_ERROR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>

<span class="cp">#define SYCLCOMPAT_CHECK_ERROR(expr)</span>

<span class="kt">int</span><span class="w"> </span><span class="n">get_sycl_language_version</span><span class="p">();</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
<section id="kernel-helper-functions">
<h3>Kernel Helper Functions<a class="headerlink" href="#kernel-helper-functions" title="Link to this heading">¶</a></h3>
<p>Kernel helper functions provide a structure <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> to keep SYCL
kernel information, and provide a utility function <code class="docutils literal notranslate"><span class="pre">get_kernel_function_info()</span></code>
to get the kernel information. Overloads are provided to allow either returning
a <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> object, or to return by pointer argument. In the
current version, <code class="docutils literal notranslate"><span class="pre">kernel_function_info</span></code> describes only maximum work-group size.</p>
<p>SYCLcompat also provides the <code class="docutils literal notranslate"><span class="pre">kernel_library</span></code> and <code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> classes.
<code class="docutils literal notranslate"><span class="pre">kernel_library</span></code> facilitates the loading and unloading of kernel libraries.
<code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> represents a specific kernel function within a loaded librariy
and can be invoked with specified arguments.
<code class="docutils literal notranslate"><span class="pre">load_kernel_library</span></code>, <code class="docutils literal notranslate"><span class="pre">load_kernel_library_mem</span></code>, and <code class="docutils literal notranslate"><span class="pre">unload_kernel_library</span></code> are
free functions to handle the loading and unloading of <code class="docutils literal notranslate"><span class="pre">kernel_library</span></code> objects.
<code class="docutils literal notranslate"><span class="pre">get_kernel_function</span></code>, and <code class="docutils literal notranslate"><span class="pre">invoke_kernel_function</span></code> offer a similar functionality
for <code class="docutils literal notranslate"><span class="pre">kernel_function</span></code> objects.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">kernel_function_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">max_work_group_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_kernel_function_info</span><span class="p">(</span><span class="n">kernel_function_info</span><span class="w"> </span><span class="o">*</span><span class="n">kernel_info</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">function</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">kernel_function_info</span><span class="w"> </span><span class="nf">get_kernel_function_info</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">function</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">kernel_library</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">kernel_library</span><span class="p">();</span>
<span class="w">  </span><span class="n">kernel_library</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">  </span><span class="k">operator</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="nf">load_kernel_library</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="nf">load_kernel_library_mem</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">image</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">unload_kernel_library</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">kernel_library</span><span class="w"> </span><span class="o">&amp;</span><span class="n">library</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">kernel_function</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">kernel_function</span><span class="p">();</span>
<span class="w">    </span><span class="n">kernel_function</span><span class="p">(</span><span class="n">kernel_functor</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">nd_range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">kernel_function</span><span class="w"> </span><span class="nf">get_kernel_function</span><span class="p">(</span><span class="n">kernel_library</span><span class="w"> </span><span class="o">&amp;</span><span class="n">library</span><span class="p">,</span>
<span class="w">                                           </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">invoke_kernel_function</span><span class="p">(</span><span class="n">kernel_function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">group_range</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">sycl</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_range</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_mem_size</span><span class="p">,</span>
<span class="w">                                   </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">kernel_params</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">extra</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
</section>
<section id="math-functions">
<h3>Math Functions<a class="headerlink" href="#math-functions" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">syclcompat::fast_length</span></code> provides a wrapper to SYCL’s
<code class="docutils literal notranslate"><span class="pre">fast_length(sycl::vec&lt;float,N&gt;)</span></code> that accepts arguments for a C++ array and a
length. <code class="docutils literal notranslate"><span class="pre">syclcompat::length</span></code> provides a templated version that wraps over
<code class="docutils literal notranslate"><span class="pre">sycl::length</span></code>. There are wrappers for <code class="docutils literal notranslate"><span class="pre">clamp</span></code>, <code class="docutils literal notranslate"><span class="pre">isnan</span></code>, <code class="docutils literal notranslate"><span class="pre">cbrt</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>,
<code class="docutils literal notranslate"><span class="pre">fmax_nan</span></code>, <code class="docutils literal notranslate"><span class="pre">fmin_nan</span></code>, and <code class="docutils literal notranslate"><span class="pre">pow</span></code>, as well as an implementation of <code class="docutils literal notranslate"><span class="pre">relu</span></code>
saturation is also provided.</p>
<p><code class="docutils literal notranslate"><span class="pre">compare</span></code>, <code class="docutils literal notranslate"><span class="pre">unordered_compare</span></code>, <code class="docutils literal notranslate"><span class="pre">compare_both</span></code>, <code class="docutils literal notranslate"><span class="pre">unordered_compare_both</span></code>,
<code class="docutils literal notranslate"><span class="pre">compare_mask</span></code>, and <code class="docutils literal notranslate"><span class="pre">unordered_compare_mask</span></code>, handle both ordered and unordered
comparisons.</p>
<p><code class="docutils literal notranslate"><span class="pre">vectorized_max</span></code> and <code class="docutils literal notranslate"><span class="pre">vectorized_min</span></code> are binary operations returning the
max/min of two arguments, where each argument is treated as a <code class="docutils literal notranslate"><span class="pre">sycl::vec</span></code> type.
<code class="docutils literal notranslate"><span class="pre">vectorized_isgreater</span></code> performs elementwise <code class="docutils literal notranslate"><span class="pre">isgreater</span></code>, treating each argument
as a vector of elements, and returning <code class="docutils literal notranslate"><span class="pre">0</span></code> for vector components for which
<code class="docutils literal notranslate"><span class="pre">isgreater</span></code> is false, and <code class="docutils literal notranslate"><span class="pre">-1</span></code> when true.
<code class="docutils literal notranslate"><span class="pre">vectorized_sum_abs_diff</span></code> calculates the absolute difference for two values
without modulo overflow for vector types.</p>
<p>The functions <code class="docutils literal notranslate"><span class="pre">cmul</span></code>,<code class="docutils literal notranslate"><span class="pre">cdiv</span></code>,<code class="docutils literal notranslate"><span class="pre">cabs</span></code>, <code class="docutils literal notranslate"><span class="pre">cmul_add</span></code>, and <code class="docutils literal notranslate"><span class="pre">conj</span></code> define complex math operations
which accept <code class="docutils literal notranslate"><span class="pre">sycl::vec&lt;T,2&gt;</span></code> arguments representing complex values.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">fast_length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="nf">clamp</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">max_val</span><span class="p">);</span>

<span class="c1">// Determine whether 2 element value is NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="n">isnan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="c1">// cbrt function wrapper.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">cbrt</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">cbrt</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// For floating-point types, `float` or `double` arguments are acceptable.</span>
<span class="c1">// For integer types, `std::uint32_t`, `std::int32_t`, `std::uint64_t` or</span>
<span class="c1">// `std::int64_t` type arguments are acceptable.</span>
<span class="c1">// sycl::half supported as well.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">min</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">min</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">max</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                 </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;&gt;</span>
<span class="n">max</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Performs 2 elements comparison and returns the bigger one. If either of</span>
<span class="c1">// inputs is NaN, then return NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmax_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">fmax_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueU</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Performs 2 elements comparison and returns the smaller one. If either of</span>
<span class="c1">// inputs is NaN, then return NaN.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fmin_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                   </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">common_type_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="n">ValueU</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span>
<span class="n">fmin_nan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueU</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">pown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">pown</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="c1">// Requires aspect::fp64, as it casts to double internally.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueU</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span>
<span class="n">pow</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueU</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="o">||</span>
<span class="w">                            </span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">half</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                        </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span>
<span class="n">relu</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="c1">// The following definition is enabled when BinaryOperation(ValueT, ValueT) returns bool</span>
<span class="c1">// std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span>
<span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="c1">// The following definition is enabled when BinaryOperation(ValueT, ValueT) returns bool</span>
<span class="c1">// std::enable_if_t&lt;std::is_same_v&lt;std::invoke_result_t&lt;BinaryOperation, ValueT, ValueT&gt;, bool&gt;, bool&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span>
<span class="n">unordered_compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ValueT</span><span class="o">&gt;</span>
<span class="n">unordered_compare</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">compare_both</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="o">::</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">unordered_compare_both</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">compare_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">unordered_compare_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_max</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_min</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">vectorized_isgreater</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_isgreater</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">ushort2</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                                              </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_sum_abs_diff</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cdiv</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">cabs</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul_add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                     </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmul_add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">marray</span><span class="o">&lt;</span><span class="n">ValueT</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">conj</span><span class="p">(</span><span class="n">sycl</span><span class="o">::</span><span class="n">vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">reverse_bits</span><span class="p">(</span><span class="n">ValueT</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vectorized_binary</span></code> computes the <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code> for two operands,
with each value treated as a vector type. <code class="docutils literal notranslate"><span class="pre">vectorized_unary</span></code> offers the same
interface for operations with a single operand.
The implemented <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code>s are <code class="docutils literal notranslate"><span class="pre">abs_diff</span></code>, <code class="docutils literal notranslate"><span class="pre">add_sat</span></code>, <code class="docutils literal notranslate"><span class="pre">rhadd</span></code>, <code class="docutils literal notranslate"><span class="pre">hadd</span></code>,
<code class="docutils literal notranslate"><span class="pre">maximum</span></code>, <code class="docutils literal notranslate"><span class="pre">minimum</span></code>, and <code class="docutils literal notranslate"><span class="pre">sub_sat</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">syclcompat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UnaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_unary</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">UnaryOperation</span><span class="w"> </span><span class="n">unary_op</span><span class="p">);</span>

<span class="c1">// A sycl::abs wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">abs</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">VecT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">vectorized_binary</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">binary_op</span><span class="p">);</span>

<span class="c1">// A sycl::abs_diff wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">abs_diff</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::add_sat wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">add_sat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::rhadd wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rhadd</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::hadd wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hadd</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::max wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">maximum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::min wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">minimum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// A sycl::sub_sat wrapper functor.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sub_sat</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueT</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ValueT</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace syclcompat</span>
</pre></div>
</div>
<p>Finally, the math header provides a set of functions to extend 32-bit operations
to 33 bit, and handle sign extension internally. There is support for <code class="docutils literal notranslate"><span class="pre">add</span></code>,
<code class="docutils literal notranslate"><span class="pre">sub</span></code>, <code class="docutils literal notranslate"><span class="pre">absdiff</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> operations. Each operation provides overloads
to include a second, separate, <code class="docutils literal notranslate"><span class="pre">BinaryOperation</span></code> after the first, and include
the <code class="docutils literal notranslate"><span class="pre">_sat</span></code> variation, determines if the returning value is saturated or not.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_add_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_sub_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_absdiff_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_min_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">RetT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">AT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">BT</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">CT</span><span class="p">,</span>
<span class="w">          </span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOperation</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">RetT</span><span class="w"> </span><span class="n">extend_max_sat</span><span class="p">(</span><span class="n">AT</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">BT</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">CT</span><span class="w"> </span><span class="n">c</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">BinaryOperation</span><span class="w"> </span><span class="n">second_op</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="sample-code">
<h2>Sample Code<a class="headerlink" href="#sample-code" title="Link to this heading">¶</a></h2>
<p>Below is a simple linear algebra sample, which computes <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">mx</span> <span class="pre">+</span> <span class="pre">b</span></code> implemented
using this library:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;syclcompat.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sycl/sycl.hpp&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * Slope intercept form of a straight line equation: Y = m * X + b</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">slope_intercept</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Block index</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">work_group_id</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Thread index</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">local_id</span><span class="o">::</span><span class="n">x</span><span class="p">();</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BLOCK_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tx</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// or  i = syclcompat::global_id::x();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="w">    </span><span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">check_memory</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Failed to allocate memory: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Program main</span>
<span class="cm"> */</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Simple Kernel example&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5f</span><span class="p">;</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block_size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">get_current_device</span><span class="p">()</span>
<span class="w">                       </span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">sycl</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">max_work_group_size</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="n">block_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;block_size = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">block_size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, n_points = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n_points</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate host memory for vectors X and Y</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mem_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_X</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;h_X allocation failed.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_Y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;h_Y allocation failed.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Alternative templated allocation for the expected output</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">h_expected</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc_host</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">h_expected</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Not enough for h_expected.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Initialize host memory &amp; expected output</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_points</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">h_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">h_expected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Allocate device memory</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">d_X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">d_Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">syclcompat</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d_X allocation failed.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">check_memory</span><span class="p">(</span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;d_Y allocation failed.&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// copy host memory to device</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">h_X</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">);</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">grid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_points</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">block_size</span><span class="p">;</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Computing result using SYCL Kernel... &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">block_size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">slope_intercept</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">launch</span><span class="o">&lt;</span><span class="n">slope_intercept</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">threads</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_X</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">n_points</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">wait</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DONE&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Async copy result from device to host</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">memcpy_async</span><span class="p">(</span><span class="n">h_Y</span><span class="p">,</span><span class="w"> </span><span class="n">d_Y</span><span class="p">,</span><span class="w"> </span><span class="n">mem_size</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Check output</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_points</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">h_Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">h_expected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1e-6</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Clean up memory</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_X</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_Y</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">h_expected</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_X</span><span class="p">);</span>
<span class="w">  </span><span class="n">syclcompat</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">d_Y</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="maintainers">
<h2>Maintainers<a class="headerlink" href="#maintainers" title="Link to this heading">¶</a></h2>
<p>To report problems with this library, please open a new issue with the [COMPAT]
tag at:</p>
<p><a class="reference external" href="https://github.com/intel/llvm/issues">https://github.com/intel/llvm/issues</a></p>
</section>
<section id="contributors">
<h2>Contributors<a class="headerlink" href="#contributors" title="Link to this heading">¶</a></h2>
<p>Alberto Cabrera, Codeplay <br />
Gordon Brown, Codeplay <br />
Joe Todd, Codeplay <br />
Pietro Ghiglio, Codeplay <br />
Ruyman Reyes, Codeplay/Intel</p>
</section>
<section id="contributions">
<h2>Contributions<a class="headerlink" href="#contributions" title="Link to this heading">¶</a></h2>
<p>This library is licensed under the Apache 2.0 license. If you have an idea for a
new sample, different build system integration or even a fix for something that
is broken, please get in contact.</p>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../cuda/opencl-subgroup-vs-cuda-crosslane-op.html">CUDA crosslane vs OpenCL sub-groups</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../FAQ.html">Frequently Asked Questions</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Intel Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>