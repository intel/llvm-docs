<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ast_matchers::dynamic::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1ast__matchers.html">ast_matchers</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic.html">dynamic</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html">internal</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">clang::ast_matchers::dynamic::internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html">AdaptativeOverloadCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used to collect all the possible overloads of an argument adaptative matcher function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits.html">ArgTypeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template class to just from argument type to the right is/get functions in <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantValue.html" title="Variant value class.">VariantValue</a>.  <a href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01ast__matchers_1_1internal_1_1Matcher_3_01T_01_4_01_4.html">ArgTypeTraits&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01attr_1_1Kind_01_4.html">ArgTypeTraits&lt; attr::Kind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01bool_01_4.html">ArgTypeTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01CastKind_01_4.html">ArgTypeTraits&lt; CastKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01const_01T_01_6_01_4.html">ArgTypeTraits&lt; const T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01double_01_4.html">ArgTypeTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01llvm_1_1Regex_1_1RegexFlags_01_4.html">ArgTypeTraits&lt; llvm::Regex::RegexFlags &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01OpenMPClauseKind_01_4.html">ArgTypeTraits&lt; OpenMPClauseKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01std_1_1string_01_4.html">ArgTypeTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01StringRef_01_4.html">ArgTypeTraits&lt; StringRef &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01UnaryExprOrTypeTrait_01_4.html">ArgTypeTraits&lt; UnaryExprOrTypeTrait &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01unsigned_01_4.html">ArgTypeTraits&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector.html">BuildReturnTypeVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1cc40eb1dccb7d8196b0826e998b27b9e.html">BuildReturnTypeVector&lt; ast_matchers::internal::BindableMatcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1fdec462b476326a6db07c018c815c3f3.html">BuildReturnTypeVector&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html">DynCastAllOfMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CK_Trivial when appropriate for VariadicDynCastAllOfMatchers.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html">FixedArgCountMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple callback implementation.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfBuilderDescriptor.html">MapAnyOfBuilderDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfMatcherDescriptor.html">MapAnyOfMatcherDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor interface.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptorPtr.html">MatcherDescriptorPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart (owning) pointer for <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html" title="Matcher descriptor interface.">MatcherDescriptor</a>.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptorPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html">OverloadedMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html" title="Matcher descriptor interface.">MatcherDescriptor</a> that wraps multiple "overloads" of the same matcher.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1RegexMatcherDescriptor.html">RegexMatcherDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html">VariadicFuncMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor for variadic functions.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html">VariadicOperatorMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator marshaller function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab2e2f1bb0c7c50fff0d24ea386e09770">isRetKindConvertibleTo</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; RetKinds, <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> Kind, <a class="el" href="classunsigned.html">unsigned</a> *Specificity, <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> *LeastDerivedKind)</td></tr>
<tr class="separator:ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher &gt; </td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a611d85ec910e5e626f593c5190fa8587">mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, ast_matchers::internal::EmptyTypeList)</td></tr>
<tr class="memdesc:a611d85ec910e5e626f593c5190fa8587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper methods to extract and merge all possible typed matchers out of the polymorphic object.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a611d85ec910e5e626f593c5190fa8587">More...</a><br /></td></tr>
<tr class="separator:a611d85ec910e5e626f593c5190fa8587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher , class TypeList &gt; </td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7a69f6ac494daf92d4faa12d47b3515">mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, TypeList)</td></tr>
<tr class="separator:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572949cd07e77a61658f87dddb278eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a572949cd07e77a61658f87dddb278eb2">outvalueToVariantMatcher</a> (const DynTypedMatcher &amp;Matcher)</td></tr>
<tr class="memdesc:a572949cd07e77a61658f87dddb278eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the return values of the functions into a <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html" title="A variant matcher object.">VariantMatcher</a>.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a572949cd07e77a61658f87dddb278eb2">More...</a><br /></td></tr>
<tr class="separator:a572949cd07e77a61658f87dddb278eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af35023ff5e5cf5dc47918e816175c10b">outvalueToVariantMatcher</a> (const T &amp;PolyMatcher, typename T::ReturnTypes *=nullptr)</td></tr>
<tr class="separator:af35023ff5e5cf5dc47918e816175c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac8312641563547ae80af4c2e0cafd0e2">buildReturnTypeVectorFromTypeList</a> (std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac8312641563547ae80af4c2e0cafd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7897d5c8cdea71d71d9996e00c7f9aa">buildReturnTypeVectorFromTypeList&lt; ast_matchers::internal::EmptyTypeList &gt;</a> (std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a5d99dffd67a0a3b394f6cb2937a86d93">variadicMatcherDescriptor</a> (StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a5d99dffd67a0a3b394f6cb2937a86d93">More...</a><br /></td></tr>
<tr class="separator:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a932fbeb8822576c997993bf764ceb996">matcherMarshall0</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a932fbeb8822576c997993bf764ceb996"><td class="mdescLeft">&#160;</td><td class="mdescRight">0-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a932fbeb8822576c997993bf764ceb996">More...</a><br /></td></tr>
<tr class="separator:a932fbeb8822576c997993bf764ceb996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab4dd575adf88d03c6513970fe28ad34c">matcherMarshall1</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:ab4dd575adf88d03c6513970fe28ad34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab4dd575adf88d03c6513970fe28ad34c">More...</a><br /></td></tr>
<tr class="separator:ab4dd575adf88d03c6513970fe28ad34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a24f86276188da48e75eecc3fd5a6d510">matcherMarshall2</a> (void(*Func)(), StringRef MatcherName, <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a> NameRange, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt; Args, <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *Error)</td></tr>
<tr class="memdesc:a24f86276188da48e75eecc3fd5a6d510"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a24f86276188da48e75eecc3fd5a6d510">More...</a><br /></td></tr>
<tr class="separator:a24f86276188da48e75eecc3fd5a6d510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a1a7cc8d7751f25ed2fad1ef81a6244ce">makeMatcherAutoMarshall</a> (ReturnType(*Func)(), StringRef MatcherName)</td></tr>
<tr class="memdesc:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to select the appropriate marshaller functions.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a1a7cc8d7751f25ed2fad1ef81a6244ce">More...</a><br /></td></tr>
<tr class="separator:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53af03e6214f47260f31932d97ef7606"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:a53af03e6214f47260f31932d97ef7606"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a53af03e6214f47260f31932d97ef7606">makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1), StringRef MatcherName)</td></tr>
<tr class="memdesc:a53af03e6214f47260f31932d97ef7606"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg overload  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a53af03e6214f47260f31932d97ef7606">More...</a><br /></td></tr>
<tr class="separator:a53af03e6214f47260f31932d97ef7606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261edbfac3cd1c8d5226272640b60d07"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a261edbfac3cd1c8d5226272640b60d07"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a261edbfac3cd1c8d5226272640b60d07">makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1, ArgType2), StringRef MatcherName)</td></tr>
<tr class="memdesc:a261edbfac3cd1c8d5226272640b60d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg overload  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a261edbfac3cd1c8d5226272640b60d07">More...</a><br /></td></tr>
<tr class="separator:a261edbfac3cd1c8d5226272640b60d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dade117165af72bdafbb13e1899060"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a49dade117165af72bdafbb13e1899060"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a49dade117165af72bdafbb13e1899060">makeMatcherRegexMarshall</a> (ReturnType(*FuncFlags)(llvm::StringRef, llvm::Regex::RegexFlags), ReturnType(*Func)(llvm::StringRef))</td></tr>
<tr class="separator:a49dade117165af72bdafbb13e1899060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae425c030a20e8cada935fcc3c11290ca"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:ae425c030a20e8cada935fcc3c11290ca"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ae425c030a20e8cada935fcc3c11290ca">makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicFunction&lt; ResultT, ArgT, Func &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:ae425c030a20e8cada935fcc3c11290ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ae425c030a20e8cada935fcc3c11290ca">More...</a><br /></td></tr>
<tr class="separator:ae425c030a20e8cada935fcc3c11290ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90edf675474e6863618a7a1d10fee3"><td class="memTemplParams" colspan="2">template&lt;typename BaseT , typename DerivedT &gt; </td></tr>
<tr class="memitem:a0d90edf675474e6863618a7a1d10fee3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a0d90edf675474e6863618a7a1d10fee3">makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicDynCastAllOfMatcher&lt; BaseT, DerivedT &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:a0d90edf675474e6863618a7a1d10fee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for VariadicDynCastAllOfMatchers.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a0d90edf675474e6863618a7a1d10fee3">More...</a><br /></td></tr>
<tr class="separator:a0d90edf675474e6863618a7a1d10fee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a51b35f3fd855f4767738bba7830b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename FromTypes , typename ToTypes &gt; </td></tr>
<tr class="memitem:af66a51b35f3fd855f4767738bba7830b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af66a51b35f3fd855f4767738bba7830b">makeMatcherAutoMarshall</a> (ast_matchers::internal::ArgumentAdaptingMatcherFunc&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;, StringRef MatcherName)</td></tr>
<tr class="memdesc:af66a51b35f3fd855f4767738bba7830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument adaptative overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af66a51b35f3fd855f4767738bba7830b">More...</a><br /></td></tr>
<tr class="separator:af66a51b35f3fd855f4767738bba7830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memTemplParams" colspan="2">template&lt;unsigned MinCount, unsigned MaxCount&gt; </td></tr>
<tr class="memitem:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7c1be10042a014f47b4f53f3fc715e8">makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicOperatorMatcherFunc&lt; MinCount, MaxCount &gt; Func, StringRef MatcherName)</td></tr>
<tr class="memdesc:ac7c1be10042a014f47b4f53f3fc715e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7c1be10042a014f47b4f53f3fc715e8">More...</a><br /></td></tr>
<tr class="separator:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memTemplParams" colspan="2">template&lt;typename CladeType , typename... MatcherT&gt; </td></tr>
<tr class="memitem:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a4e50a3b4bf4dda20fad2d18f20ee5dcc">makeMatcherAutoMarshall</a> (ast_matchers::internal::MapAnyOfMatcherImpl&lt; CladeType, MatcherT... &gt;, StringRef MatcherName)</td></tr>
<tr class="separator:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac8312641563547ae80af4c2e0cafd0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8312641563547ae80af4c2e0cafd0e2">&#9670;&nbsp;</a></span>buildReturnTypeVectorFromTypeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>RetTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00458">458</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ac7897d5c8cdea71d71d9996e00c7f9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7897d5c8cdea71d71d9996e00c7f9aa">&#9670;&nbsp;</a></span>buildReturnTypeVectorFromTypeList&lt; ast_matchers::internal::EmptyTypeList &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac8312641563547ae80af4c2e0cafd0e2">clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList</a>&lt; ast_matchers::internal::EmptyTypeList &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>RetTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00465">465</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ab2e2f1bb0c7c50fff0d24ea386e09770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e2f1bb0c7c50fff0d24ea386e09770">&#9670;&nbsp;</a></span>isRetKindConvertibleTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ast_matchers::dynamic::internal::isRetKindConvertibleTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> &gt;&#160;</td>
          <td class="paramname"><em>RetKinds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Specificity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTNodeKind.html">ASTNodeKind</a> *&#160;</td>
          <td class="paramname"><em>LeastDerivedKind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00352">352</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="VariantValue_8h_source.html#l00048">clang::ast_matchers::dynamic::ArgKind::MakeMatcherArg()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Marshallers_8h_source.html#l00408">clang::ast_matchers::dynamic::internal::FixedArgCountMatcherDescriptor::isConvertibleTo()</a>, <a class="el" href="Marshallers_8h_source.html#l00573">clang::ast_matchers::dynamic::internal::VariadicFuncMatcherDescriptor::isConvertibleTo()</a>, and <a class="el" href="Marshallers_8h_source.html#l00816">clang::ast_matchers::dynamic::internal::RegexMatcherDescriptor&lt; ReturnType &gt;::isConvertibleTo()</a>.</p>

</div>
</div>
<a id="af66a51b35f3fd855f4767738bba7830b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66a51b35f3fd855f4767738bba7830b">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename FromTypes , typename ToTypes &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ast_matchers::internal::ArgumentAdaptingMatcherFunc&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Argument adaptative overload. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01126">1126</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="a4e50a3b4bf4dda20fad2d18f20ee5dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e50a3b4bf4dda20fad2d18f20ee5dcc">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CladeType , typename... MatcherT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ast_matchers::internal::MapAnyOfMatcherImpl&lt; CladeType, MatcherT... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01157">1157</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="a0d90edf675474e6863618a7a1d10fee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d90edf675474e6863618a7a1d10fee3">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseT , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ast_matchers::internal::VariadicDynCastAllOfMatcher&lt; BaseT, DerivedT &gt;&#160;</td>
          <td class="paramname"><em>VarFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for VariadicDynCastAllOfMatchers. </p>
<p>Not strictly necessary, but <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html" title="Return CK_Trivial when appropriate for VariadicDynCastAllOfMatchers.">DynCastAllOfMatcherDescriptor</a> gives us better completion results for that type of matcher. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01116">1116</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ae425c030a20e8cada935fcc3c11290ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae425c030a20e8cada935fcc3c11290ca">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ast_matchers::internal::VariadicFunction&lt; ResultT, ArgT, Func &gt;&#160;</td>
          <td class="paramname"><em>VarFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic overload. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01105">1105</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ac7c1be10042a014f47b4f53f3fc715e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c1be10042a014f47b4f53f3fc715e8">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned MinCount, unsigned MaxCount&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ast_matchers::internal::VariadicOperatorMatcherFunc&lt; MinCount, MaxCount &gt;&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic operator overload. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01148">1148</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="a1a7cc8d7751f25ed2fad1ef81a6244ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7cc8d7751f25ed2fad1ef81a6244ce">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)()&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper functions to select the appropriate marshaller functions. </p>
<p>They detect the number of arguments, arguments types and return type. 0-arg overload </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01058">1058</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00470">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;::build()</a>.</p>

</div>
</div>
<a id="a53af03e6214f47260f31932d97ef7606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53af03e6214f47260f31932d97ef7606">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename ArgType1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(ArgType1)&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1-arg overload </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01069">1069</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00470">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;::build()</a>, and <a class="el" href="DeclBase_8cpp_source.html#l01007">getKind()</a>.</p>

</div>
</div>
<a id="a261edbfac3cd1c8d5226272640b60d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261edbfac3cd1c8d5226272640b60d07">&#9670;&nbsp;</a></span>makeMatcherAutoMarshall() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(ArgType1, ArgType2)&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-arg overload </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01081">1081</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00470">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;::build()</a>, and <a class="el" href="DeclBase_8cpp_source.html#l01007">getKind()</a>.</p>

</div>
</div>
<a id="a49dade117165af72bdafbb13e1899060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dade117165af72bdafbb13e1899060">&#9670;&nbsp;</a></span>makeMatcherRegexMarshall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">MatcherDescriptor</a>&gt; clang::ast_matchers::dynamic::internal::makeMatcherRegexMarshall </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(llvm::StringRef, llvm::Regex::RegexFlags)&#160;</td>
          <td class="paramname"><em>FuncFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnType(*)(llvm::StringRef)&#160;</td>
          <td class="paramname"><em>Func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l01093">1093</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00470">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;::build()</a>.</p>

</div>
</div>
<a id="a932fbeb8822576c997993bf764ceb996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932fbeb8822576c997993bf764ceb996">&#9670;&nbsp;</a></span>matcherMarshall0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::matcherMarshall0 </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a>&#160;</td>
          <td class="paramname"><em>NameRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt;&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *&#160;</td>
          <td class="paramname"><em>Error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>0-arg marshaller function. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00652">652</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00623">CHECK_ARG_COUNT</a>, and <a class="el" href="Marshallers_8h_source.html#l00442">outvalueToVariantMatcher()</a>.</p>

</div>
</div>
<a id="ab4dd575adf88d03c6513970fe28ad34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4dd575adf88d03c6513970fe28ad34c">&#9670;&nbsp;</a></span>matcherMarshall1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename ArgType1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::matcherMarshall1 </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a>&#160;</td>
          <td class="paramname"><em>NameRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt;&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *&#160;</td>
          <td class="paramname"><em>Error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-arg marshaller function. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00663">663</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00623">CHECK_ARG_COUNT</a>, <a class="el" href="Marshallers_8h_source.html#l00630">CHECK_ARG_TYPE</a>, and <a class="el" href="Marshallers_8h_source.html#l00442">outvalueToVariantMatcher()</a>.</p>

</div>
</div>
<a id="a24f86276188da48e75eecc3fd5a6d510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f86276188da48e75eecc3fd5a6d510">&#9670;&nbsp;</a></span>matcherMarshall2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::matcherMarshall2 </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>Func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a>&#160;</td>
          <td class="paramname"><em>NameRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt;&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *&#160;</td>
          <td class="paramname"><em>Error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-arg marshaller function. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00676">676</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00623">CHECK_ARG_COUNT</a>, <a class="el" href="Marshallers_8h_source.html#l00630">CHECK_ARG_TYPE</a>, and <a class="el" href="Marshallers_8h_source.html#l00442">outvalueToVariantMatcher()</a>.</p>

</div>
</div>
<a id="a611d85ec910e5e626f593c5190fa8587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d85ec910e5e626f593c5190fa8587">&#9670;&nbsp;</a></span>mergePolyMatchers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyMatcher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::ast_matchers::dynamic::internal::mergePolyMatchers </td>
          <td>(</td>
          <td class="paramtype">const PolyMatcher &amp;&#160;</td>
          <td class="paramname"><em>Poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DynTypedMatcher &gt; &amp;&#160;</td>
          <td class="paramname"><em>Out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ast_matchers::internal::EmptyTypeList&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper methods to extract and merge all possible typed matchers out of the polymorphic object. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00425">425</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Marshallers_8h_source.html#l00430">mergePolyMatchers()</a>.</p>

</div>
</div>
<a id="ac7a69f6ac494daf92d4faa12d47b3515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a69f6ac494daf92d4faa12d47b3515">&#9670;&nbsp;</a></span>mergePolyMatchers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PolyMatcher , class TypeList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::ast_matchers::dynamic::internal::mergePolyMatchers </td>
          <td>(</td>
          <td class="paramtype">const PolyMatcher &amp;&#160;</td>
          <td class="paramname"><em>Poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DynTypedMatcher &gt; &amp;&#160;</td>
          <td class="paramname"><em>Out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeList&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00430">430</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8h_source.html#l00425">mergePolyMatchers()</a>.</p>

</div>
</div>
<a id="a572949cd07e77a61658f87dddb278eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572949cd07e77a61658f87dddb278eb2">&#9670;&nbsp;</a></span>outvalueToVariantMatcher() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher </td>
          <td>(</td>
          <td class="paramtype">const DynTypedMatcher &amp;&#160;</td>
          <td class="paramname"><em>Matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the return values of the functions into a <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html" title="A variant matcher object.">VariantMatcher</a>. </p>
<p>There are 2 cases right now: The return value is a Matcher&lt;T&gt; or is a polymorphic matcher. For the former, we just construct the <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html" title="A variant matcher object.">VariantMatcher</a>. For the latter, we instantiate all the possible Matcher&lt;T&gt; of the poly matcher. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00442">442</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Marshallers_8h_source.html#l00822">clang::ast_matchers::dynamic::internal::RegexMatcherDescriptor&lt; ReturnType &gt;::create()</a>, <a class="el" href="Marshallers_8h_source.html#l00652">matcherMarshall0()</a>, <a class="el" href="Marshallers_8h_source.html#l00663">matcherMarshall1()</a>, <a class="el" href="Marshallers_8h_source.html#l00676">matcherMarshall2()</a>, and <a class="el" href="Marshallers_8h_source.html#l00493">variadicMatcherDescriptor()</a>.</p>

</div>
</div>
<a id="af35023ff5e5cf5dc47918e816175c10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35023ff5e5cf5dc47918e816175c10b">&#9670;&nbsp;</a></span>outvalueToVariantMatcher() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>PolyMatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename T::ReturnTypes *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00447">447</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="a5d99dffd67a0a3b394f6cb2937a86d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d99dffd67a0a3b394f6cb2937a86d93">&#9670;&nbsp;</a></span>variadicMatcherDescriptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html">VariantMatcher</a> clang::ast_matchers::dynamic::internal::variadicMatcherDescriptor </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>MatcherName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1SourceRange.html">SourceRange</a>&#160;</td>
          <td class="paramname"><em>NameRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1ParserValue.html">ParserValue</a> &gt;&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1Diagnostics.html">Diagnostics</a> *&#160;</td>
          <td class="paramname"><em>Error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic marshaller function. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00493">493</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

<p class="reference">References <a class="el" href="Marshallers_8cpp_source.html#l00017">getBestGuess()</a>, <a class="el" href="DeclBase_8cpp_source.html#l01007">getKind()</a>, <a class="el" href="Marshallers_8h_source.html#l00442">outvalueToVariantMatcher()</a>, <a class="el" href="Diagnostics_8h_source.html#l00045">clang::ast_matchers::dynamic::ParserValue::Range</a>, and <a class="el" href="Diagnostics_8h_source.html#l00046">clang::ast_matchers::dynamic::ParserValue::Value</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:26 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
