<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/ASTMatchers/Dynamic/Marshallers.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">19.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_db8107f59e31a4b90f4f59a836476962.html">ASTMatchers</a></li><li class="navelem"><a class="el" href="dir_5def9e738340f8db2b57571724273d51.html">Dynamic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Marshallers.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions templates and classes to wrap matcher construct functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ASTTypeTraits_8h_source.html">clang/AST/ASTTypeTraits.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OperationKinds_8h_source.html">clang/AST/OperationKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ASTMatchersInternal_8h_source.html">clang/ASTMatchers/ASTMatchersInternal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Diagnostics_8h_source.html">clang/ASTMatchers/Dynamic/Diagnostics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VariantValue_8h_source.html">clang/ASTMatchers/Dynamic/VariantValue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AttrKinds_8h_source.html">clang/Basic/AttrKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVM_8h_source.html">clang/Basic/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpenMPKinds_8h_source.html">clang/Basic/OpenMPKinds.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeTraits_8h_source.html">clang/Basic/TypeTraits.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/ArrayRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringRef.h&quot;</code><br />
<code>#include &quot;llvm/ADT/StringSwitch.h&quot;</code><br />
<code>#include &quot;llvm/ADT/Twine.h&quot;</code><br />
<code>#include &quot;llvm/Support/Regex.h&quot;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;clang/Basic/AttrList.inc&quot;</code><br />
<code>#include &quot;clang/AST/OperationKinds.def&quot;</code><br />
<code>#include &quot;llvm/Frontend/OpenMP/OMP.inc&quot;</code><br />
<code>#include &quot;clang/Basic/TokenKinds.def&quot;</code><br />
</div>
<p><a href="Marshallers_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01const_01T_01_6_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; const T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01std_1_1string_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01StringRef_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; StringRef &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01ast__matchers_1_1internal_1_1Matcher_3_01T_01_4_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01bool_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01double_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01unsigned_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01attr_1_1Kind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; attr::Kind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01CastKind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; CastKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01llvm_1_1Regex_1_1RegexFlags_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; llvm::Regex::RegexFlags &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01OpenMPClauseKind_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; OpenMPClauseKind &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1ArgTypeTraits_3_01UnaryExprOrTypeTrait_01_4.html">clang::ast_matchers::dynamic::internal::ArgTypeTraits&lt; UnaryExprOrTypeTrait &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html">clang::ast_matchers::dynamic::internal::MatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor interface.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::FixedArgCountMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple callback implementation.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1FixedArgCountMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1fdec462b476326a6db07c018c815c3f3.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; ast_matchers::internal::Matcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1BuildReturnTypeVector_3_01ast__matchers_1cc40eb1dccb7d8196b0826e998b27b9e.html">clang::ast_matchers::dynamic::internal::BuildReturnTypeVector&lt; ast_matchers::internal::BindableMatcher&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::VariadicFuncMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher descriptor for variadic functions.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicFuncMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::DynCastAllOfMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return CK_Trivial when appropriate for VariadicDynCastAllOfMatchers.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1DynCastAllOfMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html">clang::ast_matchers::dynamic::internal::AdaptativeOverloadCollector&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used to collect all the possible overloads of an argument adaptative matcher function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1AdaptativeOverloadCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::OverloadedMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MatcherDescriptor.html" title="Matcher descriptor interface.">MatcherDescriptor</a> that wraps multiple "overloads" of the same matcher.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1OverloadedMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1RegexMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::RegexMatcherDescriptor&lt; ReturnType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::VariadicOperatorMatcherDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator marshaller function.  <a href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1VariadicOperatorMatcherDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfMatcherDescriptor.html">clang::ast_matchers::dynamic::internal::MapAnyOfMatcherDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1internal_1_1MapAnyOfBuilderDescriptor.html">clang::ast_matchers::dynamic::internal::MapAnyOfBuilderDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceclang"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang.html">clang</a></td></tr>
<tr class="memdesc:namespaceclang"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JSON file list parser is used to communicate input to InstallAPI. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceclang_1_1ast__matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html">clang::ast_matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceclang_1_1ast__matchers_1_1dynamic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic.html">clang::ast_matchers::dynamic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html">clang::ast_matchers::dynamic::internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ada2b318e6a7f4de87f18987b5f3b4859"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#ada2b318e6a7f4de87f18987b5f3b4859">ATTR</a>(<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>)&#160;&#160;&#160;.Case(#<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>, <a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">attr::X</a>)</td></tr>
<tr class="separator:ada2b318e6a7f4de87f18987b5f3b4859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6796f43d0f5e6dfa0eb95157e2a436f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#aa6796f43d0f5e6dfa0eb95157e2a436f">CAST_OPERATION</a>(Name)&#160;&#160;&#160;.Case(#Name, CK_##Name)</td></tr>
<tr class="separator:aa6796f43d0f5e6dfa0eb95157e2a436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c01d19d8da079646c91a83b77a07a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#a74c01d19d8da079646c91a83b77a07a8">GEN_CLANG_CLAUSE_CLASS</a></td></tr>
<tr class="separator:a74c01d19d8da079646c91a83b77a07a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bad911a6488fa2115dc9be0a0d4f60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#ad6bad911a6488fa2115dc9be0a0d4f60">CLAUSE_CLASS</a>(Enum,  Str,  Class)&#160;&#160;&#160;.Case(#Enum, llvm::omp::Clause::Enum)</td></tr>
<tr class="separator:ad6bad911a6488fa2115dc9be0a0d4f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04236156b580f429d41637c375bcb6ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#a04236156b580f429d41637c375bcb6ba">UNARY_EXPR_OR_TYPE_TRAIT</a>(Spelling,  Name,  Key)&#160;&#160;&#160;.Case(#Name, UETT_##Name)</td></tr>
<tr class="separator:a04236156b580f429d41637c375bcb6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f465c0c7870b710f3f13e880f6a20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#ae76f465c0c7870b710f3f13e880f6a20">CXX11_UNARY_EXPR_OR_TYPE_TRAIT</a>(Spelling,  Name,  Key)&#160;&#160;&#160;  .Case(#Name, UETT_##Name)</td></tr>
<tr class="separator:ae76f465c0c7870b710f3f13e880f6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82801a20b786614a3ca52da901055ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#ac82801a20b786614a3ca52da901055ec">CHECK_ARG_COUNT</a>(count)</td></tr>
<tr class="memdesc:ac82801a20b786614a3ca52da901055ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macros to check the arguments on all marshaller functions.  <a href="Marshallers_8h.html#ac82801a20b786614a3ca52da901055ec">More...</a><br /></td></tr>
<tr class="separator:ac82801a20b786614a3ca52da901055ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bdc295f29b7aff6cf6c808731748cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Marshallers_8h.html#ae8bdc295f29b7aff6cf6c808731748cc">CHECK_ARG_TYPE</a>(index,  type)</td></tr>
<tr class="separator:ae8bdc295f29b7aff6cf6c808731748cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab2e2f1bb0c7c50fff0d24ea386e09770">clang::ast_matchers::dynamic::internal::isRetKindConvertibleTo</a> (ArrayRef&lt; ASTNodeKind &gt; RetKinds, ASTNodeKind Kind, <a class="el" href="classunsigned.html">unsigned</a> *Specificity, ASTNodeKind *LeastDerivedKind)</td></tr>
<tr class="separator:ab2e2f1bb0c7c50fff0d24ea386e09770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher &gt; </td></tr>
<tr class="memitem:a611d85ec910e5e626f593c5190fa8587"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a611d85ec910e5e626f593c5190fa8587">clang::ast_matchers::dynamic::internal::mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, ast_matchers::internal::EmptyTypeList)</td></tr>
<tr class="memdesc:a611d85ec910e5e626f593c5190fa8587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper methods to extract and merge all possible typed matchers out of the polymorphic object.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a611d85ec910e5e626f593c5190fa8587">More...</a><br /></td></tr>
<tr class="separator:a611d85ec910e5e626f593c5190fa8587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplParams" colspan="2">template&lt;class PolyMatcher , class TypeList &gt; </td></tr>
<tr class="memitem:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7a69f6ac494daf92d4faa12d47b3515">clang::ast_matchers::dynamic::internal::mergePolyMatchers</a> (const PolyMatcher &amp;Poly, std::vector&lt; DynTypedMatcher &gt; &amp;Out, TypeList)</td></tr>
<tr class="separator:ac7a69f6ac494daf92d4faa12d47b3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572949cd07e77a61658f87dddb278eb2"><td class="memItemLeft" align="right" valign="top">VariantMatcher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a572949cd07e77a61658f87dddb278eb2">clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher</a> (const DynTypedMatcher &amp;Matcher)</td></tr>
<tr class="memdesc:a572949cd07e77a61658f87dddb278eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the return values of the functions into a <a class="el" href="classclang_1_1ast__matchers_1_1dynamic_1_1VariantMatcher.html" title="A variant matcher object.">VariantMatcher</a>.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a572949cd07e77a61658f87dddb278eb2">More...</a><br /></td></tr>
<tr class="separator:a572949cd07e77a61658f87dddb278eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af35023ff5e5cf5dc47918e816175c10b"><td class="memTemplItemLeft" align="right" valign="top">static VariantMatcher&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af35023ff5e5cf5dc47918e816175c10b">clang::ast_matchers::dynamic::internal::outvalueToVariantMatcher</a> (const T &amp;PolyMatcher, typename T::ReturnTypes *=nullptr)</td></tr>
<tr class="separator:af35023ff5e5cf5dc47918e816175c10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8312641563547ae80af4c2e0cafd0e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac8312641563547ae80af4c2e0cafd0e2">clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList</a> (std::vector&lt; ASTNodeKind &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac8312641563547ae80af4c2e0cafd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7897d5c8cdea71d71d9996e00c7f9aa">clang::ast_matchers::dynamic::internal::buildReturnTypeVectorFromTypeList&lt; ast_matchers::internal::EmptyTypeList &gt;</a> (std::vector&lt; ASTNodeKind &gt; &amp;RetTypes)</td></tr>
<tr class="separator:ac7897d5c8cdea71d71d9996e00c7f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memTemplItemLeft" align="right" valign="top">VariantMatcher&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a5d99dffd67a0a3b394f6cb2937a86d93">clang::ast_matchers::dynamic::internal::variadicMatcherDescriptor</a> (StringRef MatcherName, SourceRange NameRange, ArrayRef&lt; ParserValue &gt; Args, Diagnostics *Error)</td></tr>
<tr class="memdesc:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a5d99dffd67a0a3b394f6cb2937a86d93">More...</a><br /></td></tr>
<tr class="separator:a5d99dffd67a0a3b394f6cb2937a86d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a932fbeb8822576c997993bf764ceb996"><td class="memTemplItemLeft" align="right" valign="top">static VariantMatcher&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a932fbeb8822576c997993bf764ceb996">clang::ast_matchers::dynamic::internal::matcherMarshall0</a> (void(*Func)(), StringRef MatcherName, SourceRange NameRange, ArrayRef&lt; ParserValue &gt; Args, Diagnostics *Error)</td></tr>
<tr class="memdesc:a932fbeb8822576c997993bf764ceb996"><td class="mdescLeft">&#160;</td><td class="mdescRight">0-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a932fbeb8822576c997993bf764ceb996">More...</a><br /></td></tr>
<tr class="separator:a932fbeb8822576c997993bf764ceb996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:ab4dd575adf88d03c6513970fe28ad34c"><td class="memTemplItemLeft" align="right" valign="top">static VariantMatcher&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab4dd575adf88d03c6513970fe28ad34c">clang::ast_matchers::dynamic::internal::matcherMarshall1</a> (void(*Func)(), StringRef MatcherName, SourceRange NameRange, ArrayRef&lt; ParserValue &gt; Args, Diagnostics *Error)</td></tr>
<tr class="memdesc:ab4dd575adf88d03c6513970fe28ad34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ab4dd575adf88d03c6513970fe28ad34c">More...</a><br /></td></tr>
<tr class="separator:ab4dd575adf88d03c6513970fe28ad34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a24f86276188da48e75eecc3fd5a6d510"><td class="memTemplItemLeft" align="right" valign="top">static VariantMatcher&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a24f86276188da48e75eecc3fd5a6d510">clang::ast_matchers::dynamic::internal::matcherMarshall2</a> (void(*Func)(), StringRef MatcherName, SourceRange NameRange, ArrayRef&lt; ParserValue &gt; Args, Diagnostics *Error)</td></tr>
<tr class="memdesc:a24f86276188da48e75eecc3fd5a6d510"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg marshaller function.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a24f86276188da48e75eecc3fd5a6d510">More...</a><br /></td></tr>
<tr class="separator:a24f86276188da48e75eecc3fd5a6d510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a1a7cc8d7751f25ed2fad1ef81a6244ce">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(), StringRef MatcherName)</td></tr>
<tr class="memdesc:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to select the appropriate marshaller functions.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a1a7cc8d7751f25ed2fad1ef81a6244ce">More...</a><br /></td></tr>
<tr class="separator:a1a7cc8d7751f25ed2fad1ef81a6244ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53af03e6214f47260f31932d97ef7606"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 &gt; </td></tr>
<tr class="memitem:a53af03e6214f47260f31932d97ef7606"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a53af03e6214f47260f31932d97ef7606">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1), StringRef MatcherName)</td></tr>
<tr class="memdesc:a53af03e6214f47260f31932d97ef7606"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-arg overload  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a53af03e6214f47260f31932d97ef7606">More...</a><br /></td></tr>
<tr class="separator:a53af03e6214f47260f31932d97ef7606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261edbfac3cd1c8d5226272640b60d07"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename ArgType1 , typename ArgType2 &gt; </td></tr>
<tr class="memitem:a261edbfac3cd1c8d5226272640b60d07"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a261edbfac3cd1c8d5226272640b60d07">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ReturnType(*Func)(ArgType1, ArgType2), StringRef MatcherName)</td></tr>
<tr class="memdesc:a261edbfac3cd1c8d5226272640b60d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-arg overload  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a261edbfac3cd1c8d5226272640b60d07">More...</a><br /></td></tr>
<tr class="separator:a261edbfac3cd1c8d5226272640b60d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dade117165af72bdafbb13e1899060"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a49dade117165af72bdafbb13e1899060"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a49dade117165af72bdafbb13e1899060">clang::ast_matchers::dynamic::internal::makeMatcherRegexMarshall</a> (ReturnType(*FuncFlags)(llvm::StringRef, llvm::Regex::RegexFlags), ReturnType(*Func)(llvm::StringRef))</td></tr>
<tr class="separator:a49dade117165af72bdafbb13e1899060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae425c030a20e8cada935fcc3c11290ca"><td class="memTemplParams" colspan="2">template&lt;typename ResultT , typename ArgT , ResultT(*)(ArrayRef&lt; const ArgT * &gt;) Func&gt; </td></tr>
<tr class="memitem:ae425c030a20e8cada935fcc3c11290ca"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ae425c030a20e8cada935fcc3c11290ca">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicFunction&lt; ResultT, ArgT, Func &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:ae425c030a20e8cada935fcc3c11290ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ae425c030a20e8cada935fcc3c11290ca">More...</a><br /></td></tr>
<tr class="separator:ae425c030a20e8cada935fcc3c11290ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d90edf675474e6863618a7a1d10fee3"><td class="memTemplParams" colspan="2">template&lt;typename BaseT , typename DerivedT &gt; </td></tr>
<tr class="memitem:a0d90edf675474e6863618a7a1d10fee3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a0d90edf675474e6863618a7a1d10fee3">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicDynCastAllOfMatcher&lt; BaseT, DerivedT &gt; VarFunc, StringRef MatcherName)</td></tr>
<tr class="memdesc:a0d90edf675474e6863618a7a1d10fee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for VariadicDynCastAllOfMatchers.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a0d90edf675474e6863618a7a1d10fee3">More...</a><br /></td></tr>
<tr class="separator:a0d90edf675474e6863618a7a1d10fee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66a51b35f3fd855f4767738bba7830b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename FromTypes , typename ToTypes &gt; </td></tr>
<tr class="memitem:af66a51b35f3fd855f4767738bba7830b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af66a51b35f3fd855f4767738bba7830b">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::ArgumentAdaptingMatcherFunc&lt; ArgumentAdapterT, FromTypes, ToTypes &gt;, StringRef MatcherName)</td></tr>
<tr class="memdesc:af66a51b35f3fd855f4767738bba7830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument adaptative overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#af66a51b35f3fd855f4767738bba7830b">More...</a><br /></td></tr>
<tr class="separator:af66a51b35f3fd855f4767738bba7830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memTemplParams" colspan="2">template&lt;unsigned MinCount, unsigned MaxCount&gt; </td></tr>
<tr class="memitem:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7c1be10042a014f47b4f53f3fc715e8">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::VariadicOperatorMatcherFunc&lt; MinCount, MaxCount &gt; Func, StringRef MatcherName)</td></tr>
<tr class="memdesc:ac7c1be10042a014f47b4f53f3fc715e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic operator overload.  <a href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#ac7c1be10042a014f47b4f53f3fc715e8">More...</a><br /></td></tr>
<tr class="separator:ac7c1be10042a014f47b4f53f3fc715e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memTemplParams" colspan="2">template&lt;typename CladeType , typename... MatcherT&gt; </td></tr>
<tr class="memitem:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatcherDescriptor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic_1_1internal.html#a4e50a3b4bf4dda20fad2d18f20ee5dcc">clang::ast_matchers::dynamic::internal::makeMatcherAutoMarshall</a> (ast_matchers::internal::MapAnyOfMatcherImpl&lt; CladeType, MatcherT... &gt;, StringRef MatcherName)</td></tr>
<tr class="separator:a4e50a3b4bf4dda20fad2d18f20ee5dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions templates and classes to wrap matcher construct functions. </p>
<p>A collection of template function and classes that provide a generic marshalling layer on top of matcher construct functions. These are used by the registry to export all marshaller constructors with the same generic interface. </p>

<p class="definition">Definition in file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ada2b318e6a7f4de87f18987b5f3b4859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2b318e6a7f4de87f18987b5f3b4859">&#9670;&nbsp;</a></span>ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ATTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a></td><td>)</td>
          <td>&#160;&#160;&#160;.Case(#<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>, <a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">attr::X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6796f43d0f5e6dfa0eb95157e2a436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6796f43d0f5e6dfa0eb95157e2a436f">&#9670;&nbsp;</a></span>CAST_OPERATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAST_OPERATION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name</td><td>)</td>
          <td>&#160;&#160;&#160;.Case(#Name, CK_##Name)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac82801a20b786614a3ca52da901055ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82801a20b786614a3ca52da901055ec">&#9670;&nbsp;</a></span>CHECK_ARG_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ARG_COUNT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (Args.size() != count) {                                                  \</div>
<div class="line">    Error-&gt;addError(NameRange, <a class="code" href="namespaceclang_1_1serialized__diags.html#aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a">Error</a>-&gt;ET_RegistryWrongArgCount)                \</div>
<div class="line">        &lt;&lt; count &lt;&lt; Args.size();                                               \</div>
<div class="line">    return VariantMatcher();                                                   \</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceclang_1_1serialized__diags_html_aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a"><div class="ttname"><a href="namespaceclang_1_1serialized__diags.html#aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a">clang::serialized_diags::Error</a></div><div class="ttdeci">@ Error</div><div class="ttdef"><b>Definition:</b> <a href="SerializedDiagnostics_8h_source.html#l00047">SerializedDiagnostics.h:47</a></div></div>
</div><!-- fragment -->
<p>Helper macros to check the arguments on all marshaller functions. </p>

<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00623">623</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ae8bdc295f29b7aff6cf6c808731748cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8bdc295f29b7aff6cf6c808731748cc">&#9670;&nbsp;</a></span>CHECK_ARG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ARG_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (!ArgTypeTraits&lt;type&gt;::hasCorrectType(Args[index].<a class="code" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {               \</div>
<div class="line">    Error-&gt;addError(Args[index].Range, <a class="code" href="namespaceclang_1_1serialized__diags.html#aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a">Error</a>-&gt;ET_RegistryWrongArgType)         \</div>
<div class="line">        &lt;&lt; (index + 1) &lt;&lt; <a class="code" href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">ArgTypeTraits&lt;type&gt;::getKind</a>().asString()            \</div>
<div class="line">        &lt;&lt; Args[index].Value.getTypeAsString();                                \</div>
<div class="line">    return VariantMatcher();                                                   \</div>
<div class="line">  }                                                                            \</div>
<div class="line">  if (!ArgTypeTraits&lt;type&gt;::hasCorrectValue(Args[index].<a class="code" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {              \</div>
<div class="line">    if (std::optional&lt;std::string&gt; BestGuess =                                 \</div>
<div class="line">            <a class="code" href="Marshallers_8cpp.html#a7716e9a05b9267dd57816ac08873144f">ArgTypeTraits&lt;type&gt;::getBestGuess</a>(Args[index].<a class="code" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)) {            \</div>
<div class="line">      Error-&gt;addError(Args[index].Range,                                       \</div>
<div class="line">                      <a class="code" href="namespaceclang_1_1serialized__diags.html#aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a">Error</a>-&gt;ET_RegistryUnknownEnumWithReplace)                \</div>
<div class="line">          &lt;&lt; index + 1 &lt;&lt; Args[index].Value.getString() &lt;&lt; *BestGuess;         \</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Args[index].<a class="code" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>.isString()) {                                 \</div>
<div class="line">      Error-&gt;addError(Args[index].Range, <a class="code" href="namespaceclang_1_1serialized__diags.html#aff3d77d6832f7e576d1f410a478997aaa80e1ee2e932f8555c5da782eef614c0a">Error</a>-&gt;ET_RegistryValueNotFound)      \</div>
<div class="line">          &lt;&lt; Args[index].Value.getString();                                    \</div>
<div class="line">    }                                                                          \</div>
<div class="line">    return VariantMatcher();                                                   \</div>
<div class="line">  }</div>
<div class="ttc" id="aDeclBase_8cpp_html_a37d13911f1772d0ed90b6b2e89cf3c60"><div class="ttname"><a href="DeclBase_8cpp.html#a37d13911f1772d0ed90b6b2e89cf3c60">getKind</a></div><div class="ttdeci">static Decl::Kind getKind(const Decl *D)</div><div class="ttdef"><b>Definition:</b> <a href="DeclBase_8cpp_source.html#l01109">DeclBase.cpp:1109</a></div></div>
<div class="ttc" id="aMarshallers_8cpp_html_a7716e9a05b9267dd57816ac08873144f"><div class="ttname"><a href="Marshallers_8cpp.html#a7716e9a05b9267dd57816ac08873144f">getBestGuess</a></div><div class="ttdeci">static std::optional&lt; std::string &gt; getBestGuess(llvm::StringRef Search, llvm::ArrayRef&lt; llvm::StringRef &gt; Allowed, llvm::StringRef DropPrefix=&quot;&quot;, unsigned MaxEditDistance=3)</div><div class="ttdef"><b>Definition:</b> <a href="Marshallers_8cpp_source.html#l00017">Marshallers.cpp:17</a></div></div>
<div class="ttc" id="aUninitializedValues_8cpp_html_a896c037a32087c5c20d97e64a1786880"><div class="ttname"><a href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a></div><div class="ttdeci">Value</div><div class="ttdef"><b>Definition:</b> <a href="UninitializedValues_8cpp_source.html#l00120">UninitializedValues.cpp:120</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Marshallers_8h_source.html#l00630">630</a> of file <a class="el" href="Marshallers_8h_source.html">Marshallers.h</a>.</p>

</div>
</div>
<a id="ad6bad911a6488fa2115dc9be0a0d4f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bad911a6488fa2115dc9be0a0d4f60">&#9670;&nbsp;</a></span>CLAUSE_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLAUSE_CLASS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Enum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;.Case(#Enum, llvm::omp::Clause::Enum)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae76f465c0c7870b710f3f13e880f6a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f465c0c7870b710f3f13e880f6a20">&#9670;&nbsp;</a></span>CXX11_UNARY_EXPR_OR_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CXX11_UNARY_EXPR_OR_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Spelling, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Key&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  .Case(#Name, UETT_##Name)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74c01d19d8da079646c91a83b77a07a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c01d19d8da079646c91a83b77a07a8">&#9670;&nbsp;</a></span>GEN_CLANG_CLAUSE_CLASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_CLANG_CLAUSE_CLASS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04236156b580f429d41637c375bcb6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04236156b580f429d41637c375bcb6ba">&#9670;&nbsp;</a></span>UNARY_EXPR_OR_TYPE_TRAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNARY_EXPR_OR_TYPE_TRAIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Spelling, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Key&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;.Case(#Name, UETT_##Name)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2024 01:35:26 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
