<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::CodeGen::TargetCodeGenInfo Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1CodeGen.html">CodeGen</a></li><li class="navelem"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html">TargetCodeGenInfo</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clang::CodeGen::TargetCodeGenInfo Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html" title="TargetCodeGenInfo - This class organizes various target-specific codegeneration issues,...">TargetCodeGenInfo</a> - This class organizes various target-specific codegeneration issues, like target-specific attributes, builtins and so on.  
 <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">/home/runner/work/llvm/llvm/repo/clang/lib/CodeGen/TargetInfo.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo_1_1TargetOpenCLBlockHelper.html">TargetOpenCLBlockHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for filling custom fields of a block literal for OpenCL.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo_1_1TargetOpenCLBlockHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec388b2d5671165a2d2542500a39321c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aec388b2d5671165a2d2542500a39321c">TargetCodeGenInfo</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1CodeGen_1_1ABIInfo.html">ABIInfo</a> &gt; Info)</td></tr>
<tr class="separator:aec388b2d5671165a2d2542500a39321c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad839224472888260e603a6e733344cae"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ad839224472888260e603a6e733344cae">~TargetCodeGenInfo</a> ()</td></tr>
<tr class="separator:ad839224472888260e603a6e733344cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e13b7a96c26ee3098483794932a7f7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1CodeGen_1_1ABIInfo.html">ABIInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a2e13b7a96c26ee3098483794932a7f7a">getABIInfo</a> () const</td></tr>
<tr class="memdesc:a2e13b7a96c26ee3098483794932a7f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a2e13b7a96c26ee3098483794932a7f7a" title="getABIInfo() - Returns ABI info helper for the target.">getABIInfo()</a> - Returns ABI info helper for the target.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a2e13b7a96c26ee3098483794932a7f7a">More...</a><br /></td></tr>
<tr class="separator:a2e13b7a96c26ee3098483794932a7f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95365f6f2ab5ccb1ba000b690fb927b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a95365f6f2ab5ccb1ba000b690fb927b0">setTargetAttributes</a> (const <a class="el" href="classclang_1_1Decl.html">Decl</a> *D, llvm::GlobalValue *GV, <a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;M) const</td></tr>
<tr class="memdesc:a95365f6f2ab5ccb1ba000b690fb927b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">setTargetAttributes - Provides a convenient hook to handle extra target-specific attributes for the given global.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a95365f6f2ab5ccb1ba000b690fb927b0">More...</a><br /></td></tr>
<tr class="separator:a95365f6f2ab5ccb1ba000b690fb927b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab541b2952c1b9421abeedde729cc3077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab541b2952c1b9421abeedde729cc3077">emitTargetMetadata</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;CGM, const llvm::MapVector&lt; <a class="el" href="classclang_1_1GlobalDecl.html">GlobalDecl</a>, StringRef &gt; &amp;MangledDeclNames) const</td></tr>
<tr class="memdesc:ab541b2952c1b9421abeedde729cc3077"><td class="mdescLeft">&#160;</td><td class="mdescRight">emitTargetMetadata - Provides a convenient hook to handle extra target-specific metadata for the given globals.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab541b2952c1b9421abeedde729cc3077">More...</a><br /></td></tr>
<tr class="separator:ab541b2952c1b9421abeedde729cc3077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9f9f966aca5e0858b4a218fa0424c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#abed9f9f966aca5e0858b4a218fa0424c">checkFunctionCallABI</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;CGM, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> CallLoc, const <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> *Caller, const <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> *Callee, const <a class="el" href="classclang_1_1CodeGen_1_1CallArgList.html">CallArgList</a> &amp;Args) const</td></tr>
<tr class="memdesc:abed9f9f966aca5e0858b4a218fa0424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any further codegen related checks that need to be done on a function call in a target specific manner.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#abed9f9f966aca5e0858b4a218fa0424c">More...</a><br /></td></tr>
<tr class="separator:abed9f9f966aca5e0858b4a218fa0424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d75a245f206ac18d6f95c4d09de933"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a19d75a245f206ac18d6f95c4d09de933">getSizeOfUnwindException</a> () const</td></tr>
<tr class="memdesc:a19d75a245f206ac18d6f95c4d09de933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the size of struct <a class="el" href="struct__Unwind__Exception.html">_Unwind_Exception</a> on this platform, in 8-bit units.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a19d75a245f206ac18d6f95c4d09de933">More...</a><br /></td></tr>
<tr class="separator:a19d75a245f206ac18d6f95c4d09de933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8312bc69339a157dc4db9c70d96adf3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa8312bc69339a157dc4db9c70d96adf3">extendPointerWithSExt</a> () const</td></tr>
<tr class="memdesc:aa8312bc69339a157dc4db9c70d96adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether __builtin_extend_pointer should sign-extend pointers to uint64_t or zero-extend them (the default).  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa8312bc69339a157dc4db9c70d96adf3">More...</a><br /></td></tr>
<tr class="separator:aa8312bc69339a157dc4db9c70d96adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a03b3087d790e5af725324b6d4365b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab3a03b3087d790e5af725324b6d4365b">getDwarfEHStackPointer</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;M) const</td></tr>
<tr class="memdesc:ab3a03b3087d790e5af725324b6d4365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the DWARF register number for the stack pointer, for exception-handling purposes.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab3a03b3087d790e5af725324b6d4365b">More...</a><br /></td></tr>
<tr class="separator:ab3a03b3087d790e5af725324b6d4365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c15224c3d2932d0edd1e1ecd632872"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a79c15224c3d2932d0edd1e1ecd632872">initDwarfEHRegSizeTable</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, llvm::Value *<a class="el" href="classclang_1_1CodeGen_1_1Address.html">Address</a>) const</td></tr>
<tr class="memdesc:a79c15224c3d2932d0edd1e1ecd632872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the given DWARF EH register-size table, a char*.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a79c15224c3d2932d0edd1e1ecd632872">More...</a><br /></td></tr>
<tr class="separator:a79c15224c3d2932d0edd1e1ecd632872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451663d7a8d2ca1bb97dd2d2842a168d"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a451663d7a8d2ca1bb97dd2d2842a168d">decodeReturnAddress</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, llvm::Value *<a class="el" href="classclang_1_1CodeGen_1_1Address.html">Address</a>) const</td></tr>
<tr class="memdesc:a451663d7a8d2ca1bb97dd2d2842a168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the code-generation required to convert a return address as stored by the system into the actual address of the next instruction that will be executed.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a451663d7a8d2ca1bb97dd2d2842a168d">More...</a><br /></td></tr>
<tr class="separator:a451663d7a8d2ca1bb97dd2d2842a168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e8c9b856d315787f7db8272496e52"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a719e8c9b856d315787f7db8272496e52">encodeReturnAddress</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, llvm::Value *<a class="el" href="classclang_1_1CodeGen_1_1Address.html">Address</a>) const</td></tr>
<tr class="memdesc:a719e8c9b856d315787f7db8272496e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the code-generation required to convert the address of an instruction into a return address suitable for storage by the system in a return slot.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a719e8c9b856d315787f7db8272496e52">More...</a><br /></td></tr>
<tr class="separator:a719e8c9b856d315787f7db8272496e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabdeb61f6075ef5d35778612c02847c"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#afabdeb61f6075ef5d35778612c02847c">testFPKind</a> (llvm::Value *<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <a class="el" href="classunsigned.html">unsigned</a> BuiltinID, <a class="el" href="classclang_1_1CodeGen_1_1CGBuilderTy.html">CGBuilderTy</a> &amp;Builder, <a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;CGM) const</td></tr>
<tr class="memdesc:afabdeb61f6075ef5d35778612c02847c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a target specific test of a floating point value for things like IsNaN, Infinity, ...  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#afabdeb61f6075ef5d35778612c02847c">More...</a><br /></td></tr>
<tr class="separator:afabdeb61f6075ef5d35778612c02847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe22e867216e253b4e7b6ec19ff4f10"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#afbe22e867216e253b4e7b6ec19ff4f10">adjustInlineAsmType</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, StringRef Constraint, llvm::Type *Ty) const</td></tr>
<tr class="memdesc:afbe22e867216e253b4e7b6ec19ff4f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the low-level LLVM type for a given constraint and "usual" type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#afbe22e867216e253b4e7b6ec19ff4f10">More...</a><br /></td></tr>
<tr class="separator:afbe22e867216e253b4e7b6ec19ff4f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c79e13ea76b7c82bac2e8dc51463eff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a9c79e13ea76b7c82bac2e8dc51463eff">isScalarizableAsmOperand</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, llvm::Type *Ty) const</td></tr>
<tr class="memdesc:a9c79e13ea76b7c82bac2e8dc51463eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Target hook to decide whether an inline asm operand can be passed by value.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a9c79e13ea76b7c82bac2e8dc51463eff">More...</a><br /></td></tr>
<tr class="separator:a9c79e13ea76b7c82bac2e8dc51463eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09753470b5c4c5ee961799b4b5d4b35c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a09753470b5c4c5ee961799b4b5d4b35c">addReturnRegisterOutputs</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">CodeGen::LValue</a> ReturnValue, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &amp;Constraints, std::vector&lt; llvm::Type * &gt; &amp;ResultRegTypes, std::vector&lt; llvm::Type * &gt; &amp;ResultTruncRegTypes, std::vector&lt; <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">CodeGen::LValue</a> &gt; &amp;ResultRegDests, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &amp;AsmString, <a class="el" href="classunsigned.html">unsigned</a> NumOutputs) const</td></tr>
<tr class="memdesc:a09753470b5c4c5ee961799b4b5d4b35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints and types for result registers.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a09753470b5c4c5ee961799b4b5d4b35c">More...</a><br /></td></tr>
<tr class="separator:a09753470b5c4c5ee961799b4b5d4b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d70627ad0b5d992b02c9f0d8b6b570"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a24d70627ad0b5d992b02c9f0d8b6b570">doesReturnSlotInterfereWithArgs</a> () const</td></tr>
<tr class="memdesc:a24d70627ad0b5d992b02c9f0d8b6b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">doesReturnSlotInterfereWithArgs - Return true if the target uses an argument slot for an 'sret' type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a24d70627ad0b5d992b02c9f0d8b6b570">More...</a><br /></td></tr>
<tr class="separator:a24d70627ad0b5d992b02c9f0d8b6b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1f3b6f27298e5651b36524383f6402"><td class="memItemLeft" align="right" valign="top">virtual StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a3f1f3b6f27298e5651b36524383f6402">getARCRetainAutoreleasedReturnValueMarker</a> () const</td></tr>
<tr class="memdesc:a3f1f3b6f27298e5651b36524383f6402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the address of a function to call immediately before calling objc_retainAutoreleasedReturnValue.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a3f1f3b6f27298e5651b36524383f6402">More...</a><br /></td></tr>
<tr class="separator:a3f1f3b6f27298e5651b36524383f6402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21ba388f8aae80cb7f45f8217807a83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ad21ba388f8aae80cb7f45f8217807a83">markARCOptimizedReturnCallsAsNoTail</a> () const</td></tr>
<tr class="memdesc:ad21ba388f8aae80cb7f45f8217807a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a call to objc_retainAutoreleasedReturnValue or objc_unsafeClaimAutoreleasedReturnValue should be marked as 'notail'.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ad21ba388f8aae80cb7f45f8217807a83">More...</a><br /></td></tr>
<tr class="separator:ad21ba388f8aae80cb7f45f8217807a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34527c899ba69518dd4c62079cb4a60c"><td class="memItemLeft" align="right" valign="top">virtual llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a34527c899ba69518dd4c62079cb4a60c">getUBSanFunctionSignature</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;CGM) const</td></tr>
<tr class="memdesc:a34527c899ba69518dd4c62079cb4a60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant used by UBSan as a signature to identify functions possessing type information, or 0 if the platform is unsupported.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a34527c899ba69518dd4c62079cb4a60c">More...</a><br /></td></tr>
<tr class="separator:a34527c899ba69518dd4c62079cb4a60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b0ae7603ff89e149fab5ebcf14b405"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#af0b0ae7603ff89e149fab5ebcf14b405">isNoProtoCallVariadic</a> (const <a class="el" href="classclang_1_1CodeGen_1_1CallArgList.html">CodeGen::CallArgList</a> &amp;args, const <a class="el" href="classclang_1_1FunctionNoProtoType.html">FunctionNoProtoType</a> *fnType) const</td></tr>
<tr class="memdesc:af0b0ae7603ff89e149fab5ebcf14b405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a call to an unprototyped functions under the given calling convention should use the variadic convention or the non-variadic convention.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#af0b0ae7603ff89e149fab5ebcf14b405">More...</a><br /></td></tr>
<tr class="separator:af0b0ae7603ff89e149fab5ebcf14b405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300565d01ca6267bfa317e7ae1847a78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a300565d01ca6267bfa317e7ae1847a78">getDependentLibraryOption</a> (llvm::StringRef Lib, <a class="el" href="classllvm_1_1SmallString.html">llvm::SmallString</a>&lt; 24 &gt; &amp;Opt) const</td></tr>
<tr class="memdesc:a300565d01ca6267bfa317e7ae1847a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the linker options necessary to link a dependent library on this platform.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a300565d01ca6267bfa317e7ae1847a78">More...</a><br /></td></tr>
<tr class="separator:a300565d01ca6267bfa317e7ae1847a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add958d999552c2ce66574ab41b52b8e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#add958d999552c2ce66574ab41b52b8e7">getDetectMismatchOption</a> (llvm::StringRef Name, llvm::StringRef <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>, <a class="el" href="classllvm_1_1SmallString.html">llvm::SmallString</a>&lt; 32 &gt; &amp;Opt) const</td></tr>
<tr class="memdesc:add958d999552c2ce66574ab41b52b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the linker options necessary to detect object file mismatches on this platform.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#add958d999552c2ce66574ab41b52b8e7">More...</a><br /></td></tr>
<tr class="separator:add958d999552c2ce66574ab41b52b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4976bbfa9a33d4ac362e9a9ad14000"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a7a4976bbfa9a33d4ac362e9a9ad14000">getOpenCLKernelCallingConv</a> () const</td></tr>
<tr class="memdesc:a7a4976bbfa9a33d4ac362e9a9ad14000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LLVM calling convention for OpenCL kernel.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a7a4976bbfa9a33d4ac362e9a9ad14000">More...</a><br /></td></tr>
<tr class="separator:a7a4976bbfa9a33d4ac362e9a9ad14000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8623eb78fbf30f4f9dc4c3f20c44250"><td class="memItemLeft" align="right" valign="top">virtual llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa8623eb78fbf30f4f9dc4c3f20c44250">getNullPointer</a> (const <a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;CGM, llvm::PointerType *T, <a class="el" href="classclang_1_1QualType.html">QualType</a> QT) const</td></tr>
<tr class="memdesc:aa8623eb78fbf30f4f9dc4c3f20c44250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target specific null pointer.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa8623eb78fbf30f4f9dc4c3f20c44250">More...</a><br /></td></tr>
<tr class="separator:aa8623eb78fbf30f4f9dc4c3f20c44250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d77d4354abf4c16b16ee573c76283"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a7e9d77d4354abf4c16b16ee573c76283">getGlobalVarAddressSpace</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;CGM, const <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> *D) const</td></tr>
<tr class="memdesc:a7e9d77d4354abf4c16b16ee573c76283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target favored AST address space of a global variable for languages other than OpenCL and CUDA.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a7e9d77d4354abf4c16b16ee573c76283">More...</a><br /></td></tr>
<tr class="separator:a7e9d77d4354abf4c16b16ee573c76283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38fbe04b7f58aa0728606d4a213eedb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab38fbe04b7f58aa0728606d4a213eedb">getASTAllocaAddressSpace</a> () const</td></tr>
<tr class="memdesc:ab38fbe04b7f58aa0728606d4a213eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the AST address space for alloca.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ab38fbe04b7f58aa0728606d4a213eedb">More...</a><br /></td></tr>
<tr class="separator:ab38fbe04b7f58aa0728606d4a213eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903374d4aa49a025dbfda983427c6876"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a903374d4aa49a025dbfda983427c6876">performAddrSpaceCast</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;CGF, llvm::Value *<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> SrcAddr, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> DestAddr, llvm::Type *DestTy, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsNonNull=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>) const</td></tr>
<tr class="memdesc:a903374d4aa49a025dbfda983427c6876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform address space cast of an expression of pointer type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a903374d4aa49a025dbfda983427c6876">More...</a><br /></td></tr>
<tr class="separator:a903374d4aa49a025dbfda983427c6876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af454b43005b1035a25a72beaf5a8d1cb"><td class="memItemLeft" align="right" valign="top">virtual llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#af454b43005b1035a25a72beaf5a8d1cb">performAddrSpaceCast</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;CGM, llvm::Constant *<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> SrcAddr, <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> DestAddr, llvm::Type *DestTy) const</td></tr>
<tr class="memdesc:af454b43005b1035a25a72beaf5a8d1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform address space cast of a constant expression of pointer type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#af454b43005b1035a25a72beaf5a8d1cb">More...</a><br /></td></tr>
<tr class="separator:af454b43005b1035a25a72beaf5a8d1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a1ab6d89e1232f40aeb9a6099fdb4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa7a1ab6d89e1232f40aeb9a6099fdb4e">getAddrSpaceOfCxaAtexitPtrParam</a> () const</td></tr>
<tr class="memdesc:aa7a1ab6d89e1232f40aeb9a6099fdb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address space of pointer parameter for __cxa_atexit.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aa7a1ab6d89e1232f40aeb9a6099fdb4e">More...</a><br /></td></tr>
<tr class="separator:aa7a1ab6d89e1232f40aeb9a6099fdb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a26ef47350911460521a9c177326524"><td class="memItemLeft" align="right" valign="top">virtual llvm::SyncScope::ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a6a26ef47350911460521a9c177326524">getLLVMSyncScopeID</a> (const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, <a class="el" href="namespaceclang.html#acd33afeb44f0f299dd21f388847d22d8">SyncScope</a> <a class="el" href="classclang_1_1Scope.html">Scope</a>, llvm::AtomicOrdering Ordering, llvm::LLVMContext &amp;Ctx) const</td></tr>
<tr class="memdesc:a6a26ef47350911460521a9c177326524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the syncscope used in LLVM IR.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a6a26ef47350911460521a9c177326524">More...</a><br /></td></tr>
<tr class="separator:a6a26ef47350911460521a9c177326524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93bf582043aaf2081800ef49bef3fb0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo_1_1TargetOpenCLBlockHelper.html">TargetOpenCLBlockHelper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#ad93bf582043aaf2081800ef49bef3fb0">getTargetOpenCLBlockHelper</a> () const</td></tr>
<tr class="separator:ad93bf582043aaf2081800ef49bef3fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d4c8ca399dc31a9ae7ac2578ba3a86"><td class="memItemLeft" align="right" valign="top">virtual llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a42d4c8ca399dc31a9ae7ac2578ba3a86">createEnqueuedBlockKernel</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;CGF, llvm::Function *BlockInvokeFunc, llvm::Type *BlockTy) const</td></tr>
<tr class="memdesc:a42d4c8ca399dc31a9ae7ac2578ba3a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenCL kernel for an enqueued block.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a42d4c8ca399dc31a9ae7ac2578ba3a86">More...</a><br /></td></tr>
<tr class="separator:a42d4c8ca399dc31a9ae7ac2578ba3a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac15ddd7aeaa0814ae853a693259920"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#aeac15ddd7aeaa0814ae853a693259920">shouldEmitStaticExternCAliases</a> () const</td></tr>
<tr class="separator:aeac15ddd7aeaa0814ae853a693259920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d11ede0b770f64d12d1a5967cf10da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a27d11ede0b770f64d12d1a5967cf10da">setCUDAKernelCallingConvention</a> (const <a class="el" href="classclang_1_1FunctionType.html">FunctionType</a> *&amp;FT) const</td></tr>
<tr class="separator:a27d11ede0b770f64d12d1a5967cf10da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46faa723cc5acbce2967bcc6c8cc2d54"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a46faa723cc5acbce2967bcc6c8cc2d54">getCUDADeviceBuiltinSurfaceDeviceType</a> () const</td></tr>
<tr class="memdesc:a46faa723cc5acbce2967bcc6c8cc2d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device-side type for the CUDA device builtin surface type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a46faa723cc5acbce2967bcc6c8cc2d54">More...</a><br /></td></tr>
<tr class="separator:a46faa723cc5acbce2967bcc6c8cc2d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86532dc68cf994c8515b0d29b7dcad43"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a86532dc68cf994c8515b0d29b7dcad43">getCUDADeviceBuiltinTextureDeviceType</a> () const</td></tr>
<tr class="memdesc:a86532dc68cf994c8515b0d29b7dcad43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device-side type for the CUDA device builtin texture type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a86532dc68cf994c8515b0d29b7dcad43">More...</a><br /></td></tr>
<tr class="separator:a86532dc68cf994c8515b0d29b7dcad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdab053ccd85d77bd2efd8916e78ddc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a0bdab053ccd85d77bd2efd8916e78ddc">emitCUDADeviceBuiltinSurfaceDeviceCopy</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;CGF, <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a> Dst, <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a> Src) const</td></tr>
<tr class="memdesc:a0bdab053ccd85d77bd2efd8916e78ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the device-side copy of the builtin surface type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a0bdab053ccd85d77bd2efd8916e78ddc">More...</a><br /></td></tr>
<tr class="separator:a0bdab053ccd85d77bd2efd8916e78ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f2f416c3c0645c7e259fb21aa04eb1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a23f2f416c3c0645c7e259fb21aa04eb1">emitCUDADeviceBuiltinTextureDeviceCopy</a> (<a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;CGF, <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a> Dst, <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a> Src) const</td></tr>
<tr class="memdesc:a23f2f416c3c0645c7e259fb21aa04eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit the device-side copy of the builtin texture type.  <a href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a23f2f416c3c0645c7e259fb21aa04eb1">More...</a><br /></td></tr>
<tr class="separator:a23f2f416c3c0645c7e259fb21aa04eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html" title="TargetCodeGenInfo - This class organizes various target-specific codegeneration issues,...">TargetCodeGenInfo</a> - This class organizes various target-specific codegeneration issues, like target-specific attributes, builtins and so on. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00045">45</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aec388b2d5671165a2d2542500a39321c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec388b2d5671165a2d2542500a39321c">&#9670;&nbsp;</a></span>TargetCodeGenInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">clang::CodeGen::TargetCodeGenInfo::TargetCodeGenInfo </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1CodeGen_1_1ABIInfo.html">ABIInfo</a> &gt;&#160;</td>
          <td class="paramname"><em>Info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00049">49</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="ad839224472888260e603a6e733344cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad839224472888260e603a6e733344cae">&#9670;&nbsp;</a></span>~TargetCodeGenInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetCodeGenInfo::~TargetCodeGenInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09753470b5c4c5ee961799b4b5d4b35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09753470b5c4c5ee961799b4b5d4b35c">&#9670;&nbsp;</a></span>addReturnRegisterOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::addReturnRegisterOutputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1LValue.html">CodeGen::LValue</a>&#160;</td>
          <td class="paramname"><em>ReturnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>Constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ResultRegTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ResultTruncRegTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classclang_1_1CodeGen_1_1LValue.html">CodeGen::LValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ResultRegDests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>AsmString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>NumOutputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds constraints and types for result registers. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00158">158</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="afbe22e867216e253b4e7b6ec19ff4f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe22e867216e253b4e7b6ec19ff4f10">&#9670;&nbsp;</a></span>adjustInlineAsmType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* clang::CodeGen::TargetCodeGenInfo::adjustInlineAsmType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Corrects the low-level LLVM type for a given constraint and "usual" type. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new LLVM type, possibly the same as the original on success; 0 on failure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00144">144</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="abed9f9f966aca5e0858b4a218fa0424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed9f9f966aca5e0858b4a218fa0424c">&#9670;&nbsp;</a></span>checkFunctionCallABI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::checkFunctionCallABI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>CallLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> *&#160;</td>
          <td class="paramname"><em>Caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> *&#160;</td>
          <td class="paramname"><em>Callee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CodeGen_1_1CallArgList.html">CallArgList</a> &amp;&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Any further codegen related checks that need to be done on a function call in a target specific manner. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00068">68</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGCall_8cpp_source.html#l04697">clang::CodeGen::CodeGenFunction::EmitCall()</a>.</p>

</div>
</div>
<a id="a42d4c8ca399dc31a9ae7ac2578ba3a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4c8ca399dc31a9ae7ac2578ba3a86">&#9670;&nbsp;</a></span>createEnqueuedBlockKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function * TargetCodeGenInfo::createEnqueuedBlockKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>Invoke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>BlockTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an OpenCL kernel for an enqueued block. </p>
<p>The kernel function is a wrapper for the block invoke function with target-specific calling convention and ABI as an OpenCL kernel. The wrapper function accepts block context and block arguments in target-specific way and calls the original block invoke function.</p>
<p>The kernel has the same function type as the block invoke function. Its name is the name of the block invoke function postfixed with "_kernel". It simply calls the block invoke function then returns. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l11680">11680</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodeGenFunction_8h_source.html#l02023">clang::CodeGen::CodeGenFunction::getLLVMContext()</a>, and <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGOpenCLRuntime_8cpp_source.html#l00201">clang::CodeGen::CGOpenCLRuntime::emitOpenCLEnqueuedBlock()</a>.</p>

</div>
</div>
<a id="a451663d7a8d2ca1bb97dd2d2842a168d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451663d7a8d2ca1bb97dd2d2842a168d">&#9670;&nbsp;</a></span>decodeReturnAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value* clang::CodeGen::TargetCodeGenInfo::decodeReturnAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the code-generation required to convert a return address as stored by the system into the actual address of the next instruction that will be executed. </p>
<p>Used by __builtin_extract_return_addr(). </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00114">114</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="a24d70627ad0b5d992b02c9f0d8b6b570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d70627ad0b5d992b02c9f0d8b6b570">&#9670;&nbsp;</a></span>doesReturnSlotInterfereWithArgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::doesReturnSlotInterfereWithArgs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>doesReturnSlotInterfereWithArgs - Return true if the target uses an argument slot for an 'sret' type. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00167">167</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGCall_8cpp_source.html#l01572">clang::CodeGen::CodeGenModule::ReturnSlotInterferesWithArgs()</a>.</p>

</div>
</div>
<a id="a0bdab053ccd85d77bd2efd8916e78ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdab053ccd85d77bd2efd8916e78ddc">&#9670;&nbsp;</a></span>emitCUDADeviceBuiltinSurfaceDeviceCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::emitCUDADeviceBuiltinSurfaceDeviceCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a>&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a>&#160;</td>
          <td class="paramname"><em>Src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit the device-side copy of the builtin surface type. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00353">353</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="a23f2f416c3c0645c7e259fb21aa04eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f2f416c3c0645c7e259fb21aa04eb1">&#9670;&nbsp;</a></span>emitCUDADeviceBuiltinTextureDeviceCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::emitCUDADeviceBuiltinTextureDeviceCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a>&#160;</td>
          <td class="paramname"><em>Dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1LValue.html">LValue</a>&#160;</td>
          <td class="paramname"><em>Src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit the device-side copy of the builtin texture type. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00360">360</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="ab541b2952c1b9421abeedde729cc3077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab541b2952c1b9421abeedde729cc3077">&#9670;&nbsp;</a></span>emitTargetMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::emitTargetMetadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::MapVector&lt; <a class="el" href="classclang_1_1GlobalDecl.html">GlobalDecl</a>, StringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>MangledDeclNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>emitTargetMetadata - Provides a convenient hook to handle extra target-specific metadata for the given globals. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00062">62</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="a719e8c9b856d315787f7db8272496e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e8c9b856d315787f7db8272496e52">&#9670;&nbsp;</a></span>encodeReturnAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value* clang::CodeGen::TargetCodeGenInfo::encodeReturnAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the code-generation required to convert the address of an instruction into a return address suitable for storage by the system in a return slot. </p>
<p>Used by __builtin_frob_return_addr(). </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00124">124</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="aa8312bc69339a157dc4db9c70d96adf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8312bc69339a157dc4db9c70d96adf3">&#9670;&nbsp;</a></span>extendPointerWithSExt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::extendPointerWithSExt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Controls whether __builtin_extend_pointer should sign-extend pointers to uint64_t or zero-extend them (the default). </p>
<p>Has no effect for targets:</p><ul>
<li>that have 64-bit pointers, or</li>
<li>that cannot address through registers larger than pointers, or</li>
<li>that implicitly ignore/truncate the top bits when addressing through such registers. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00090">90</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="a2e13b7a96c26ee3098483794932a7f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e13b7a96c26ee3098483794932a7f7a">&#9670;&nbsp;</a></span>getABIInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1CodeGen_1_1ABIInfo.html">ABIInfo</a>&amp; clang::CodeGen::TargetCodeGenInfo::getABIInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo.html#a2e13b7a96c26ee3098483794932a7f7a" title="getABIInfo() - Returns ABI info helper for the target.">getABIInfo()</a> - Returns ABI info helper for the target. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00053">53</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00022">getSwiftABIInfo()</a>.</p>

</div>
</div>
<a id="aa7a1ab6d89e1232f40aeb9a6099fdb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a1ab6d89e1232f40aeb9a6099fdb4e">&#9670;&nbsp;</a></span>getAddrSpaceOfCxaAtexitPtrParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> clang::CodeGen::TargetCodeGenInfo::getAddrSpaceOfCxaAtexitPtrParam </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get address space of pointer parameter for __cxa_atexit. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00293">293</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793aa7a1920d61156abc05a60135aefe8bc67">clang::Default</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGDeclCXX_8cpp_source.html#l00072">EmitDeclDestroy()</a>.</p>

</div>
</div>
<a id="a3f1f3b6f27298e5651b36524383f6402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1f3b6f27298e5651b36524383f6402">&#9670;&nbsp;</a></span>getARCRetainAutoreleasedReturnValueMarker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual StringRef clang::CodeGen::TargetCodeGenInfo::getARCRetainAutoreleasedReturnValueMarker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the address of a function to call immediately before calling objc_retainAutoreleasedReturnValue. </p>
<p>The implementation of objc_autoreleaseReturnValue sniffs the instruction stream following its return address to decide whether it's a call to objc_retainAutoreleasedReturnValue. This can be prohibitively expensive, depending on the relocation model, and so on some targets it instead sniffs for a particular instruction sequence. This functions returns that instruction sequence in inline assembly, which will be empty if none is required. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00179">179</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGObjC_8cpp_source.html#l02299">emitAutoreleasedReturnValueMarker()</a>.</p>

</div>
</div>
<a id="ab38fbe04b7f58aa0728606d4a213eedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38fbe04b7f58aa0728606d4a213eedb">&#9670;&nbsp;</a></span>getASTAllocaAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> clang::CodeGen::TargetCodeGenInfo::getASTAllocaAddressSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the AST address space for alloca. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00269">269</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793aa7a1920d61156abc05a60135aefe8bc67">clang::Default</a>.</p>

</div>
</div>
<a id="a46faa723cc5acbce2967bcc6c8cc2d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46faa723cc5acbce2967bcc6c8cc2d54">&#9670;&nbsp;</a></span>getCUDADeviceBuiltinSurfaceDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* clang::CodeGen::TargetCodeGenInfo::getCUDADeviceBuiltinSurfaceDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device-side type for the CUDA device builtin surface type. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00342">342</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenTypes_8cpp_source.html#l00401">clang::CodeGen::CodeGenTypes::ConvertType()</a>.</p>

</div>
</div>
<a id="a86532dc68cf994c8515b0d29b7dcad43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86532dc68cf994c8515b0d29b7dcad43">&#9670;&nbsp;</a></span>getCUDADeviceBuiltinTextureDeviceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* clang::CodeGen::TargetCodeGenInfo::getCUDADeviceBuiltinTextureDeviceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device-side type for the CUDA device builtin texture type. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00347">347</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenTypes_8cpp_source.html#l00401">clang::CodeGen::CodeGenTypes::ConvertType()</a>.</p>

</div>
</div>
<a id="a300565d01ca6267bfa317e7ae1847a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300565d01ca6267bfa317e7ae1847a78">&#9670;&nbsp;</a></span>getDependentLibraryOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TargetCodeGenInfo::getDependentLibraryOption </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>Lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallString.html">llvm::SmallString</a>&lt; 24 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the linker options necessary to link a dependent library on this platform. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00465">465</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenModule_8cpp_source.html#l02498">clang::CodeGen::CodeGenModule::AddDependentLib()</a>, and <a class="el" href="CodeGenModule_8cpp_source.html#l02514">addLinkOptionsPostorder()</a>.</p>

</div>
</div>
<a id="add958d999552c2ce66574ab41b52b8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add958d999552c2ce66574ab41b52b8e7">&#9670;&nbsp;</a></span>getDetectMismatchOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::getDetectMismatchOption </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>Value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallString.html">llvm::SmallString</a>&lt; 32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the linker options necessary to detect object file mismatches on this platform. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00246">246</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="ab3a03b3087d790e5af725324b6d4365b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a03b3087d790e5af725324b6d4365b">&#9670;&nbsp;</a></span>getDwarfEHStackPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::CodeGen::TargetCodeGenInfo::getDwarfEHStackPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the DWARF register number for the stack pointer, for exception-handling purposes. </p>
<p>Implements __builtin_dwarf_sp_column.</p>
<p>Returns -1 if the operation is unsupported by this target. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00096">96</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="a7e9d77d4354abf4c16b16ee573c76283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9d77d4354abf4c16b16ee573c76283">&#9670;&nbsp;</a></span>getGlobalVarAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a> TargetCodeGenInfo::getGlobalVarAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get target favored AST address space of a global variable for languages other than OpenCL and CUDA. </p>
<p>If <code>D</code> is nullptr, returns the default target favored address space for global variable. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00493">493</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793aa7a1920d61156abc05a60135aefe8bc67">clang::Default</a>, <a class="el" href="Type_8h_source.html#l06623">clang::QualType::getAddressSpace()</a>, <a class="el" href="CodeGenModule_8h_source.html#l00702">clang::CodeGen::CodeGenModule::getLangOpts()</a>, and <a class="el" href="Decl_8h_source.html#l00686">clang::ValueDecl::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenModule_8cpp_source.html#l04615">clang::CodeGen::CodeGenModule::GetGlobalVarAddressSpace()</a>.</p>

</div>
</div>
<a id="a6a26ef47350911460521a9c177326524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a26ef47350911460521a9c177326524">&#9670;&nbsp;</a></span>getLLVMSyncScopeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SyncScope::ID TargetCodeGenInfo::getLLVMSyncScopeID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LangOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#acd33afeb44f0f299dd21f388847d22d8">SyncScope</a>&#160;</td>
          <td class="paramname"><em>Scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::AtomicOrdering&#160;</td>
          <td class="paramname"><em>Ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>Ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the syncscope used in LLVM IR. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00523">523</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGAtomic_8cpp_source.html#l00723">EmitAtomicOp()</a>.</p>

</div>
</div>
<a id="aa8623eb78fbf30f4f9dc4c3f20c44250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8623eb78fbf30f4f9dc4c3f20c44250">&#9670;&nbsp;</a></span>getNullPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * TargetCodeGenInfo::getNullPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::PointerType *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname"><em>QT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get target specific null pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is the LLVM type of the null pointer. </td></tr>
    <tr><td class="paramname">QT</td><td>is the clang <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> of the null pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ConstantPointerNull with the given type <code>T</code>. Each target can override it to return its own desired constant value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00488">488</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGExprConstant_8cpp_source.html#l01738">clang::CodeGen::CodeGenModule::getNullPointer()</a>.</p>

</div>
</div>
<a id="a7a4976bbfa9a33d4ac362e9a9ad14000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4976bbfa9a33d4ac362e9a9ad14000">&#9670;&nbsp;</a></span>getOpenCLKernelCallingConv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetCodeGenInfo::getOpenCLKernelCallingConv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get LLVM calling convention for OpenCL kernel. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00474">474</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGCall_8cpp_source.html#l00048">clang::CodeGen::CodeGenTypes::ClangCallConvToLLVMCallConv()</a>.</p>

</div>
</div>
<a id="a19d75a245f206ac18d6f95c4d09de933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d75a245f206ac18d6f95c4d09de933">&#9670;&nbsp;</a></span>getSizeOfUnwindException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> TargetCodeGenInfo::getSizeOfUnwindException </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the size of struct <a class="el" href="struct__Unwind__Exception.html">_Unwind_Exception</a> on this platform, in 8-bit units. </p>
<p>The Itanium ABI defines this as: struct <a class="el" href="struct__Unwind__Exception.html">_Unwind_Exception</a> { uint64 exception_class; _Unwind_Exception_Cleanup_Fn exception_cleanup; uint64 private_1; uint64 private_2; }; </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00445">445</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGen_2ItaniumCXXABI_8cpp_source.html#l04427">InitCatchParam()</a>.</p>

</div>
</div>
<a id="ad93bf582043aaf2081800ef49bef3fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93bf582043aaf2081800ef49bef3fb0">&#9670;&nbsp;</a></span>getTargetOpenCLBlockHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classclang_1_1CodeGen_1_1TargetCodeGenInfo_1_1TargetOpenCLBlockHelper.html">TargetOpenCLBlockHelper</a>* clang::CodeGen::TargetCodeGenInfo::getTargetOpenCLBlockHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00320">320</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGBlocks_8cpp_source.html#l01314">buildGlobalBlock()</a>, <a class="el" href="CGBlocks_8cpp_source.html#l00572">computeBlockInfo()</a>, <a class="el" href="CGBlocks_8cpp_source.html#l01148">clang::CodeGen::CodeGenModule::getGenericBlockLiteralType()</a>, and <a class="el" href="CGBlocks_8cpp_source.html#l00498">initializeForBlockHeader()</a>.</p>

</div>
</div>
<a id="a34527c899ba69518dd4c62079cb4a60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34527c899ba69518dd4c62079cb4a60c">&#9670;&nbsp;</a></span>getUBSanFunctionSignature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Constant* clang::CodeGen::TargetCodeGenInfo::getUBSanFunctionSignature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a constant used by UBSan as a signature to identify functions possessing type information, or 0 if the platform is unsupported. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00190">190</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGExpr_8cpp_source.html#l05253">clang::CodeGen::CodeGenFunction::EmitCall()</a>, and <a class="el" href="CodeGenFunction_8cpp_source.html#l00829">getPrologueSignature()</a>.</p>

</div>
</div>
<a id="a79c15224c3d2932d0edd1e1ecd632872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c15224c3d2932d0edd1e1ecd632872">&#9670;&nbsp;</a></span>initDwarfEHRegSizeTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::initDwarfEHRegSizeTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the given DWARF EH register-size table, a char*. </p>
<p>Implements __builtin_init_dwarf_reg_size_table.</p>
<p>Returns true if the operation is unsupported by this target. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00104">104</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="af0b0ae7603ff89e149fab5ebcf14b405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b0ae7603ff89e149fab5ebcf14b405">&#9670;&nbsp;</a></span>isNoProtoCallVariadic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> TargetCodeGenInfo::isNoProtoCallVariadic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CodeGen_1_1CallArgList.html">CodeGen::CallArgList</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionNoProtoType.html">FunctionNoProtoType</a> *&#160;</td>
          <td class="paramname"><em>fnType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a call to an unprototyped functions under the given calling convention should use the variadic convention or the non-variadic convention. </p>
<p>There's a good reason to make a platform's variadic calling convention be different from its non-variadic calling convention: the non-variadic arguments can be passed in registers (better for performance), and the variadic arguments can be passed on the stack (also better for performance). If this is done, however, unprototyped functions <em>must</em> use the non-variadic convention, because C99 states that a call through an unprototyped function type must succeed if the function was defined with a non-variadic prototype with compatible parameters. Therefore, splitting the conventions makes it impossible to call a variadic function through an unprototyped type. Since function prototypes came out in the late 1970s, this is probably an acceptable trade-off. Nonetheless, not all platforms are willing to make it, and in particularly x86-64 bends over backwards to make the conventions compatible.</p>
<p>The default is false. This is correct whenever:</p><ul>
<li>the conventions are exactly the same, because it does not matter and the resulting IR will be somewhat prettier in certain cases; or</li>
<li>the conventions are substantively different in how they pass arguments, because in this case using the variadic convention will lead to C99 violations.</li>
</ul>
<p>However, some platforms make the conventions identical except for passing additional out-of-band information to a variadic function: for example, x86-64 passes the number of SSE arguments in al. On these platforms, it is desirable to call unprototyped functions using the variadic convention so that unprototyped calls to varargs functions still succeed.</p>
<p>Relatedly, platforms which pass the fixed arguments to this: A foo(B, C, D); differently than they would pass them to this: A foo(B, C, D, ...); may need to adjust the debugger-support code in <a class="el" href="classclang_1_1Sema.html" title="Sema - This implements semantic analysis and AST building for C.">Sema</a> to do the right thing when calling a function with no know signature. </p>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00455">455</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGCall_8cpp_source.html#l00568">arrangeFreeFunctionLikeCall()</a>.</p>

</div>
</div>
<a id="a9c79e13ea76b7c82bac2e8dc51463eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c79e13ea76b7c82bac2e8dc51463eff">&#9670;&nbsp;</a></span>isScalarizableAsmOperand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::isScalarizableAsmOperand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Target hook to decide whether an inline asm operand can be passed by value. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00152">152</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="ad21ba388f8aae80cb7f45f8217807a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21ba388f8aae80cb7f45f8217807a83">&#9670;&nbsp;</a></span>markARCOptimizedReturnCallsAsNoTail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::markARCOptimizedReturnCallsAsNoTail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a call to objc_retainAutoreleasedReturnValue or objc_unsafeClaimAutoreleasedReturnValue should be marked as 'notail'. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00185">185</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGObjC_8cpp_source.html#l02338">emitOptimizedARCReturnCall()</a>.</p>

</div>
</div>
<a id="a903374d4aa49a025dbfda983427c6876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903374d4aa49a025dbfda983427c6876">&#9670;&nbsp;</a></span>performAddrSpaceCast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value * TargetCodeGenInfo::performAddrSpaceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenFunction.html">CodeGen::CodeGenFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>CGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td>
          <td class="paramname"><em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsNonNull</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform address space cast of an expression of pointer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>is the LLVM value to be casted to another address space. </td></tr>
    <tr><td class="paramname">SrcAddr</td><td>is the language address space of <code>V</code>. </td></tr>
    <tr><td class="paramname">DestAddr</td><td>is the targeted language address space. </td></tr>
    <tr><td class="paramname">DestTy</td><td>is the destination LLVM pointer type. </td></tr>
    <tr><td class="paramname">IsNonNull</td><td>is the flag indicating <code>V</code> is known to be non null. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00501">501</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="CodeGenFunction_8h_source.html#l00269">clang::CodeGen::CodeGenFunction::Builder</a>, <a class="el" href="CodeGenFunction_8h_source.html#l00261">clang::CodeGen::CodeGenFunction::CGM</a>, and <a class="el" href="CGBuilder_8h_source.html#l00173">clang::CodeGen::CGBuilderTy::CreatePointerBitCastOrAddrSpaceCast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CodeGenModule_8cpp_source.html#l04686">castStringLiteralToDefaultAddressSpace()</a>, <a class="el" href="CGAtomic_8cpp_source.html#l00806">clang::CodeGen::CodeGenFunction::EmitAtomicExpr()</a>, <a class="el" href="CGCall_8cpp_source.html#l04697">clang::CodeGen::CodeGenFunction::EmitCall()</a>, <a class="el" href="CGExpr_8cpp_source.html#l04715">clang::CodeGen::CodeGenFunction::EmitCastLValue()</a>, <a class="el" href="CGClass_8cpp_source.html#l02079">clang::CodeGen::CodeGenFunction::EmitCXXConstructorCall()</a>, and <a class="el" href="CGExprCXX_8cpp_source.html#l00094">clang::CodeGen::CodeGenFunction::EmitCXXDestructorCall()</a>.</p>

</div>
</div>
<a id="af454b43005b1035a25a72beaf5a8d1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af454b43005b1035a25a72beaf5a8d1cb">&#9670;&nbsp;</a></span>performAddrSpaceCast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Constant * TargetCodeGenInfo::performAddrSpaceCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Constant *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td>
          <td class="paramname"><em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#aa3eb18d56ff745e83217cde4d647793a">LangAS</a>&#160;</td>
          <td class="paramname"><em>DestAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>DestTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform address space cast of a constant expression of pointer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>is the LLVM constant to be casted to another address space. </td></tr>
    <tr><td class="paramname">SrcAddr</td><td>is the language address space of <code>V</code>. </td></tr>
    <tr><td class="paramname">DestAddr</td><td>is the targeted language address space. </td></tr>
    <tr><td class="paramname">DestTy</td><td>is the destination LLVM pointer type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html#l00514">514</a> of file <a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a>.</p>

</div>
</div>
<a id="a27d11ede0b770f64d12d1a5967cf10da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d11ede0b770f64d12d1a5967cf10da">&#9670;&nbsp;</a></span>setCUDAKernelCallingConvention()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::setCUDAKernelCallingConvention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FunctionType.html">FunctionType</a> *&amp;&#160;</td>
          <td class="paramname"><em>FT</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00339">339</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGCall_8cpp_source.html#l00270">setCUDAKernelCallingConvention()</a>.</p>

</div>
</div>
<a id="a95365f6f2ab5ccb1ba000b690fb927b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95365f6f2ab5ccb1ba000b690fb927b0">&#9670;&nbsp;</a></span>setTargetAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void clang::CodeGen::TargetCodeGenInfo::setTargetAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Decl.html">Decl</a> *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::GlobalValue *&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGen::CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>setTargetAttributes - Provides a convenient hook to handle extra target-specific attributes for the given global. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00057">57</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="aeac15ddd7aeaa0814ae853a693259920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac15ddd7aeaa0814ae853a693259920">&#9670;&nbsp;</a></span>shouldEmitStaticExternCAliases()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::CodeGen::TargetCodeGenInfo::shouldEmitStaticExternCAliases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the target supports alias from the unmangled name to the mangled name of functions declared within an extern "C" region and marked as 'used', and having internal linkage. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00337">337</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<a id="afabdeb61f6075ef5d35778612c02847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabdeb61f6075ef5d35778612c02847c">&#9670;&nbsp;</a></span>testFPKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value* clang::CodeGen::TargetCodeGenInfo::testFPKind </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BuiltinID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CGBuilderTy.html">CGBuilderTy</a> &amp;&#160;</td>
          <td class="paramname"><em>Builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1CodeGen_1_1CodeGenModule.html">CodeGenModule</a> &amp;&#160;</td>
          <td class="paramname"><em>CGM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a target specific test of a floating point value for things like IsNaN, Infinity, ... </p>
<p>Nullptr is returned if no implementation exists. </p>

<p class="definition">Definition at line <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html#l00133">133</a> of file <a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/CodeGen/<a class="el" href="lib_2CodeGen_2TargetInfo_8h_source.html">TargetInfo.h</a></li>
<li>lib/CodeGen/<a class="el" href="CodeGen_2TargetInfo_8cpp_source.html">TargetInfo.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:28 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
