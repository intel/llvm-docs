<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::syntax Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1syntax.html">syntax</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">clang::syntax Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory arena for syntax trees.  <a href="classclang_1_1syntax_1_1Arena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ArraySubscript.html">ArraySubscript</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array size specified inside a declarator.  <a href="classclang_1_1syntax_1_1ArraySubscript.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1BinaryOperatorExpression.html">BinaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;lhs&gt; &lt;operator&gt; &lt;rhs&gt;  <a href="classclang_1_1syntax_1_1BinaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1BreakStatement.html">BreakStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">break;  <a href="classclang_1_1syntax_1_1BreakStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CallArguments.html">CallArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models arguments of a function call.  <a href="classclang_1_1syntax_1_1CallArguments.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CaseStatement.html">CaseStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">case : &lt;body&gt;  <a href="classclang_1_1syntax_1_1CaseStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1CompoundStatement.html">CompoundStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">{ statement1; statement2; â€¦ }  <a href="classclang_1_1syntax_1_1CompoundStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ContinueStatement.html">ContinueStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">continue;  <a href="classclang_1_1syntax_1_1ContinueStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Declaration.html">Declaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A declaration that can appear at the top-level.  <a href="classclang_1_1syntax_1_1Declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DeclarationStatement.html">DeclarationStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">E.g. 'int a, b = 10;'.  <a href="classclang_1_1syntax_1_1DeclarationStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Declarator.html">Declarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covers a name, an initializer and a part of the type outside declaration specifiers.  <a href="classclang_1_1syntax_1_1Declarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DeclaratorList.html">DeclaratorList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1DefaultStatement.html">DefaultStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default: &lt;body&gt;  <a href="classclang_1_1syntax_1_1DefaultStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1EmptyDeclaration.html">EmptyDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semicolon in the top-level context. Does not declare anything.  <a href="classclang_1_1syntax_1_1EmptyDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">EmptyStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The no-op statement, i.e. ';'.  <a href="classclang_1_1syntax_1_1EmptyStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ExplicitTemplateInstantiation.html">ExplicitTemplateInstantiation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;declaration&gt; Examples: template struct X&lt;int&gt; template void foo&lt;int&gt;() template int var&lt;double&gt;  <a href="classclang_1_1syntax_1_1ExplicitTemplateInstantiation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ExpressionStatement.html">ExpressionStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classExpression.html">Expression</a> in a statement position, e.g.  <a href="classclang_1_1syntax_1_1ExpressionStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1FactoryImpl.html">FactoryImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes private syntax tree APIs required to implement node synthesis.  <a href="classclang_1_1syntax_1_1FactoryImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A half-open character range inside a particular file, the start offset is included and the end offset is excluded from the range.  <a href="structclang_1_1syntax_1_1FileRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ForStatement.html">ForStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">for (&lt;init&gt;; &lt;cond&gt;; &lt;increment&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1ForStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1IfStatement.html">IfStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">if (cond) &lt;then-statement&gt; else &lt;else-statement&gt; FIXME: add condition that models 'expression or variable declaration'  <a href="classclang_1_1syntax_1_1IfStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">Leaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A leaf node points to a single token inside the expanded token stream.  <a href="classclang_1_1syntax_1_1Leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1LinkageSpecificationDeclaration.html">LinkageSpecificationDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extern &lt;string-literal&gt; declaration extern &lt;string-literal&gt; { &lt;decls&gt; }  <a href="classclang_1_1syntax_1_1LinkageSpecificationDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1List.html">List</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of Elements separated or terminated by a fixed token.  <a href="classclang_1_1syntax_1_1List.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1MemberPointer.html">MemberPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member pointer inside a declarator E.g.  <a href="classclang_1_1syntax_1_1MemberPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyntax_1_1MutationsImpl.html">MutationsImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NamespaceAliasDefinition.html">NamespaceAliasDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace &lt;name&gt; = &lt;namespace-reference&gt;  <a href="classclang_1_1syntax_1_1NamespaceAliasDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NamespaceDefinition.html">NamespaceDefinition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace &lt;name&gt; { &lt;decls&gt; }  <a href="classclang_1_1syntax_1_1NamespaceDefinition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1NestedNameSpecifier.html">NestedNameSpecifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a <code>nested-name-specifier</code>.  <a href="classclang_1_1syntax_1_1NestedNameSpecifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in a syntax tree.  <a href="classclang_1_1syntax_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParameterDeclarationList.html">ParameterDeclarationList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a <code>parameter-declaration-list</code> which appears within <code>parameters-and-qualifiers</code>.  <a href="classclang_1_1syntax_1_1ParameterDeclarationList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParametersAndQualifiers.html">ParametersAndQualifiers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter list for a function type and a trailing return type, if the function has one.  <a href="classclang_1_1syntax_1_1ParametersAndQualifiers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ParenDeclarator.html">ParenDeclarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Declarator.html" title="Covers a name, an initializer and a part of the type outside declaration specifiers.">Declarator</a> inside parentheses.  <a href="classclang_1_1syntax_1_1ParenDeclarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1PostfixUnaryOperatorExpression.html">PostfixUnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;operand&gt; &lt;operator&gt;  <a href="classclang_1_1syntax_1_1PostfixUnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1PrefixUnaryOperatorExpression.html">PrefixUnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;operator&gt; &lt;operand&gt;  <a href="classclang_1_1syntax_1_1PrefixUnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1RangeBasedForStatement.html">RangeBasedForStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">for (&lt;decl&gt; : &lt;init&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1RangeBasedForStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1ReturnStatement.html">ReturnStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return &lt;expr&gt;; return;  <a href="classclang_1_1syntax_1_1ReturnStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SimpleDeclaration.html">SimpleDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups multiple declarators (e.g.  <a href="classclang_1_1syntax_1_1SimpleDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SimpleDeclarator.html">SimpleDeclarator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A top-level declarator without parentheses.  <a href="classclang_1_1syntax_1_1SimpleDeclarator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract node for C++ statements, e.g.  <a href="classclang_1_1syntax_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1StaticAssertDeclaration.html">StaticAssertDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static_assert(&lt;condition&gt;, &lt;message&gt;) static_assert(&lt;condition&gt;)  <a href="classclang_1_1syntax_1_1StaticAssertDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1SwitchStatement.html">SwitchStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch (&lt;cond&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1SwitchStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TemplateDeclaration.html">TemplateDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template &lt;template-parameters&gt; &lt;declaration&gt;  <a href="classclang_1_1syntax_1_1TemplateDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token coming directly from a file or from a macro invocation.  <a href="classclang_1_1syntax_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">TokenBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of tokens obtained by preprocessing a text buffer and operations to map between the expanded and spelled tokens, i.e.  <a href="classclang_1_1syntax_1_1TokenBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TokenCollector.html">TokenCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects tokens for the main file while running the frontend action.  <a href="classclang_1_1syntax_1_1TokenCollector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TrailingReturnType.html">TrailingReturnType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trailing return type after the parameter list, including the arrow token.  <a href="classclang_1_1syntax_1_1TrailingReturnType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that has children and represents a syntactic language construct.  <a href="classclang_1_1syntax_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsyntax_1_1TreeBuilder.html">TreeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for constructing the syntax tree while traversing a clang AST.  <a href="classsyntax_1_1TreeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1TypeAliasDeclaration.html">TypeAliasDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using &lt;name&gt; = &lt;type&gt;  <a href="classclang_1_1syntax_1_1TypeAliasDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnaryOperatorExpression.html">UnaryOperatorExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for prefix and postfix unary operators.  <a href="classclang_1_1syntax_1_1UnaryOperatorExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownDeclaration.html">UnknownDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classclang_1_1syntax_1_1Declaration.html" title="A declaration that can appear at the top-level.">Declaration</a> of an unknown kind, e.g. not yet supported in syntax trees.  <a href="classclang_1_1syntax_1_1UnknownDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownExpression.html">UnknownExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression of an unknown kind, i.e.  <a href="classclang_1_1syntax_1_1UnknownExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnknownStatement.html">UnknownStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A statement of an unknown kind, i.e.  <a href="classclang_1_1syntax_1_1UnknownStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UnqualifiedId.html">UnqualifiedId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models an <code>unqualified-id</code>.  <a href="classclang_1_1syntax_1_1UnqualifiedId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UsingDeclaration.html">UsingDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using &lt;scope&gt;::&lt;name&gt; using typename &lt;scope&gt;::&lt;name&gt;  <a href="classclang_1_1syntax_1_1UsingDeclaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1UsingNamespaceDirective.html">UsingNamespaceDirective</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">using namespace &lt;name&gt;  <a href="classclang_1_1syntax_1_1UsingNamespaceDirective.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1syntax_1_1WhileStatement.html">WhileStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">while (&lt;cond&gt;) &lt;body&gt;  <a href="classclang_1_1syntax_1_1WhileStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a81b5b8b797bac504f7538749a7bb0a2a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a> : uint16_t { <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2aa26c550fe2b08ea192795846db6b692cb">NodeKind::CONCRETE_NODE</a>
 }</td></tr>
<tr class="memdesc:a81b5b8b797bac504f7538749a7bb0a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A kind of a syntax node, used for implementing casts.  <a href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">More...</a><br /></td></tr>
<tr class="separator:a81b5b8b797bac504f7538749a7bb0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d10149d69e32e3c86140b4d325925e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8">NodeRole::Detached</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e">NodeRole::Unknown</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f">NodeRole::OpenParen</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd">NodeRole::CloseParen</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea">NodeRole::IntroducerKeyword</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5">NodeRole::LiteralToken</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377">NodeRole::ArrowToken</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787">NodeRole::ExternKeyword</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb">NodeRole::TemplateKeyword</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d">NodeRole::BodyStatement</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7">NodeRole::ListElement</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8">NodeRole::ListDelimiter</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23">NodeRole::OperatorToken</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4">NodeRole::Operand</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078">NodeRole::LeftHandSide</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623">NodeRole::RightHandSide</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18">NodeRole::ReturnValue</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34">NodeRole::CaseValue</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b">NodeRole::ThenStatement</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183">NodeRole::ElseKeyword</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6">NodeRole::ElseStatement</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043">NodeRole::Expression</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f">NodeRole::Statement</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde">NodeRole::Condition</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4">NodeRole::Message</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2">NodeRole::Declarator</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a">NodeRole::Declaration</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">NodeRole::Size</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c">NodeRole::Parameters</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941">NodeRole::TrailingReturn</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536">NodeRole::UnqualifiedId</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f">NodeRole::Qualifier</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac">NodeRole::SubExpression</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b">NodeRole::Object</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9">NodeRole::AccessToken</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d">NodeRole::Member</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816">NodeRole::Callee</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e">NodeRole::Arguments</a>, 
<a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5">NodeRole::Declarators</a>
<br />
 }</td></tr>
<tr class="memdesc:a0d10149d69e32e3c86140b4d325925e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A relation between a parent and child node, e.g.  <a href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">More...</a><br /></td></tr>
<tr class="separator:a0d10149d69e32e3c86140b4d325925e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f256ced784108d3fb273d242929676a"><td class="memItemLeft" align="right" valign="top">syntax::TranslationUnit *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a4f256ced784108d3fb273d242929676a">buildSyntaxTree</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;A, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:a4f256ced784108d3fb273d242929676a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a syntax tree for the main file.  <a href="namespaceclang_1_1syntax.html#a4f256ced784108d3fb273d242929676a">More...</a><br /></td></tr>
<tr class="separator:a4f256ced784108d3fb273d242929676a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026e95f11b1e39147fa801cd73830da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a026e95f11b1e39147fa801cd73830da6">createLeaf</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a> K, StringRef Spelling)</td></tr>
<tr class="memdesc:a026e95f11b1e39147fa801cd73830da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from token with <code>Spelling</code> and assert it has the desired <code>TokenKind</code>.  <a href="namespaceclang_1_1syntax.html#a026e95f11b1e39147fa801cd73830da6">More...</a><br /></td></tr>
<tr class="separator:a026e95f11b1e39147fa801cd73830da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#afbc11ae1ecbd0919a1c725b58b2d9fa0">createLeaf</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a> K)</td></tr>
<tr class="memdesc:afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the token spelling from its <code>TokenKind</code>, then create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from this token.  <a href="namespaceclang_1_1syntax.html#afbc11ae1ecbd0919a1c725b58b2d9fa0">More...</a><br /></td></tr>
<tr class="separator:afbc11ae1ecbd0919a1c725b58b2d9fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d843e69f183e006bb3c2c0927cbfcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Tree.html">syntax::Tree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a53d843e69f183e006bb3c2c0927cbfcc">createTree</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">syntax::NodeRole</a> &gt;&gt; Children, <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a> K)</td></tr>
<tr class="memdesc:a53d843e69f183e006bb3c2c0927cbfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the concrete syntax node according to the specified <code>NodeKind</code> <code>K</code>.  <a href="namespaceclang_1_1syntax.html#a53d843e69f183e006bb3c2c0927cbfcc">More...</a><br /></td></tr>
<tr class="separator:a53d843e69f183e006bb3c2c0927cbfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7faebfdbba7ac8862370fd2cee2bd90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">syntax::EmptyStatement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a7faebfdbba7ac8862370fd2cee2bd90a">createEmptyStatement</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A)</td></tr>
<tr class="separator:a7faebfdbba7ac8862370fd2cee2bd90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd89f9a47c39ff754698c8714df181f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#abd89f9a47c39ff754698c8714df181f1">deepCopyExpandingMacros</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, const <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *N)</td></tr>
<tr class="memdesc:abd89f9a47c39ff754698c8714df181f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a completely independent copy of <code>N</code> with its macros expanded.  <a href="namespaceclang_1_1syntax.html#abd89f9a47c39ff754698c8714df181f1">More...</a><br /></td></tr>
<tr class="separator:abd89f9a47c39ff754698c8714df181f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715c345b92c4d49b98a4b0d71cce07df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a715c345b92c4d49b98a4b0d71cce07df">computeReplacements</a> (const <a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;A, const syntax::TranslationUnit &amp;TU)</td></tr>
<tr class="memdesc:a715c345b92c4d49b98a4b0d71cce07df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes textual replacements required to mimic the tree modifications made to the syntax tree.  <a href="namespaceclang_1_1syntax.html#a715c345b92c4d49b98a4b0d71cce07df">More...</a><br /></td></tr>
<tr class="separator:a715c345b92c4d49b98a4b0d71cce07df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac945be75b2e1a63c6fc656f3418fe455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#ac945be75b2e1a63c6fc656f3418fe455">removeStatement</a> (<a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;A, <a class="el" href="classclang_1_1syntax_1_1Statement.html">syntax::Statement</a> *S)</td></tr>
<tr class="memdesc:ac945be75b2e1a63c6fc656f3418fe455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a statement or replaces it with an empty statement where one is required syntactically.  <a href="namespaceclang_1_1syntax.html#ac945be75b2e1a63c6fc656f3418fe455">More...</a><br /></td></tr>
<tr class="separator:ac945be75b2e1a63c6fc656f3418fe455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9773dfd304fc990b06ed6a7a8711e6f8"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a9773dfd304fc990b06ed6a7a8711e6f8">operator&lt;&lt;</a> (raw_ostream &amp;OS, <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a> K)</td></tr>
<tr class="memdesc:a9773dfd304fc990b06ed6a7a8711e6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <a href="namespaceclang_1_1syntax.html#a9773dfd304fc990b06ed6a7a8711e6f8">More...</a><br /></td></tr>
<tr class="separator:a9773dfd304fc990b06ed6a7a8711e6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#ab327bf8bd6ce7e2ebe105061d44fd7cb">operator&lt;&lt;</a> (raw_ostream &amp;OS, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a> R)</td></tr>
<tr class="memdesc:ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <a href="namespaceclang_1_1syntax.html#ab327bf8bd6ce7e2ebe105061d44fd7cb">More...</a><br /></td></tr>
<tr class="separator:ab327bf8bd6ce7e2ebe105061d44fd7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a4aa2f5330bffd313bb05c4d4ed8d6042">operator&lt;&lt;</a> (llvm::raw_ostream &amp;OS, const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;R)</td></tr>
<tr class="memdesc:a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes.  <a href="namespaceclang_1_1syntax.html#a4aa2f5330bffd313bb05c4d4ed8d6042">More...</a><br /></td></tr>
<tr class="separator:a4aa2f5330bffd313bb05c4d4ed8d6042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee22380c758acfc7dc72398d4312bcfc"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#aee22380c758acfc7dc72398d4312bcfc">operator&lt;&lt;</a> (llvm::raw_ostream &amp;OS, const <a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a> &amp;T)</td></tr>
<tr class="memdesc:aee22380c758acfc7dc72398d4312bcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debugging purposes. Equivalent to a call to <a class="el" href="classclang_1_1syntax_1_1Token.html#a10e327aee703a9281dd146fb9816b939" title="For debugging purposes.">Token::str()</a>.  <a href="namespaceclang_1_1syntax.html#aee22380c758acfc7dc72398d4312bcfc">More...</a><br /></td></tr>
<tr class="separator:aee22380c758acfc7dc72398d4312bcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff502ef26cb84b374c72f21c9b44236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#afff502ef26cb84b374c72f21c9b44236">spelledTokensTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;Tokens)</td></tr>
<tr class="memdesc:afff502ef26cb84b374c72f21c9b44236"><td class="mdescLeft">&#160;</td><td class="mdescRight">The spelled tokens that overlap or touch a spelling location Loc.  <a href="namespaceclang_1_1syntax.html#afff502ef26cb84b374c72f21c9b44236">More...</a><br /></td></tr>
<tr class="separator:afff502ef26cb84b374c72f21c9b44236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793cf39170ae045357f2299a8ad5d1ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a793cf39170ae045357f2299a8ad5d1ee">spelledTokensTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Tokens)</td></tr>
<tr class="separator:a793cf39170ae045357f2299a8ad5d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4717e9f6a8df9c77f1bd3aedb282169e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a4717e9f6a8df9c77f1bd3aedb282169e">spelledIdentifierTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; Tokens)</td></tr>
<tr class="memdesc:a4717e9f6a8df9c77f1bd3aedb282169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identifier token that overlaps or touches a spelling location Loc.  <a href="namespaceclang_1_1syntax.html#a4717e9f6a8df9c77f1bd3aedb282169e">More...</a><br /></td></tr>
<tr class="separator:a4717e9f6a8df9c77f1bd3aedb282169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5495e074677ac58e95e398b46e079cb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a5495e074677ac58e95e398b46e079cb2">spelledIdentifierTouching</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;Tokens)</td></tr>
<tr class="separator:a5495e074677ac58e95e398b46e079cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab6237c208ae112ad2abd4e003235b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a74ab6237c208ae112ad2abd4e003235b">tokenize</a> (<a class="el" href="classclang_1_1FileID.html">FileID</a> FID, const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;<a class="el" href="AnalysisBasedWarnings_8cpp.html#afe4356a77609114d8df0bfc9c2b8701f">SM</a>, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LO)</td></tr>
<tr class="memdesc:a74ab6237c208ae112ad2abd4e003235b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lex the text buffer, corresponding to <code>FID</code>, in raw mode and record the resulting spelled tokens.  <a href="namespaceclang_1_1syntax.html#a74ab6237c208ae112ad2abd4e003235b">More...</a><br /></td></tr>
<tr class="separator:a74ab6237c208ae112ad2abd4e003235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a1ffeac5053cf3f2a36f48251ce417"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1syntax.html#a24a1ffeac5053cf3f2a36f48251ce417">tokenize</a> (const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;FR, const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;<a class="el" href="AnalysisBasedWarnings_8cpp.html#afe4356a77609114d8df0bfc9c2b8701f">SM</a>, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LO)</td></tr>
<tr class="memdesc:a24a1ffeac5053cf3f2a36f48251ce417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to one above, instead of whole file tokenizes a part of it.  <a href="namespaceclang_1_1syntax.html#a24a1ffeac5053cf3f2a36f48251ce417">More...</a><br /></td></tr>
<tr class="separator:a24a1ffeac5053cf3f2a36f48251ce417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a81b5b8b797bac504f7538749a7bb0a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b5b8b797bac504f7538749a7bb0a2a">&#9670;&nbsp;</a></span>NodeKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">clang::syntax::NodeKind</a> : uint16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A kind of a syntax node, used for implementing casts. </p>
<p>The ordering and blocks of enumerator constants must correspond to the inheritance hierarchy of <a class="el" href="classclang_1_1syntax_1_1Node.html" title="A node in a syntax tree.">syntax::Node</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a81b5b8b797bac504f7538749a7bb0a2aa26c550fe2b08ea192795846db6b692cb"></a>CONCRETE_NODE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Nodes_8h_source.html#l00037">37</a> of file <a class="el" href="Nodes_8h_source.html">Nodes.h</a>.</p>

</div>
</div>
<a id="a0d10149d69e32e3c86140b4d325925e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d10149d69e32e3c86140b4d325925e5">&#9670;&nbsp;</a></span>NodeRole</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">clang::syntax::NodeRole</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A relation between a parent and child node, e.g. </p>
<p>'left-hand-side of a binary expression'. Used for implementing accessors.</p>
<p>In general <code>NodeRole</code>s should be named the same as their accessors.</p>
<p>Some roles describe parent/child relations that occur multiple times in language grammar. We define only one role to describe all instances of such recurring relations. For example, grammar for both "if" and "while" statements requires an opening paren and a closing paren. The opening paren token is assigned the OpenParen role regardless of whether it appears as a child of <a class="el" href="classclang_1_1syntax_1_1IfStatement.html" title="if (cond) &lt;then-statement&gt; else &lt;else-statement&gt; FIXME: add condition that models &#39;expression or vari...">IfStatement</a> or <a class="el" href="classclang_1_1syntax_1_1WhileStatement.html" title="while (&lt;cond&gt;) &lt;body&gt;">WhileStatement</a> node. More generally, when grammar requires a certain fixed token (like a specific keyword, or an opening paren), we define a role for this token and use it across all grammar rules with the same requirement. Names of such reusable roles end with a ~Token or a ~Keyword suffix. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8"></a>Detached&#160;</td><td class="fielddoc"><p>A node without a parent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>Children of an unknown semantic nature, e.g. skipped tokens, comments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f"></a>OpenParen&#160;</td><td class="fielddoc"><p>An opening parenthesis in argument lists and blocks, e.g. '{', '(', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd"></a>CloseParen&#160;</td><td class="fielddoc"><p>A closing parenthesis in argument lists and blocks, e.g. '}', ')', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea"></a>IntroducerKeyword&#160;</td><td class="fielddoc"><p>A keywords that introduces some grammar construct, e.g. 'if', 'try', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5"></a>LiteralToken&#160;</td><td class="fielddoc"><p>A token that represents a literal, e.g. 'nullptr', '1', 'true', etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377"></a>ArrowToken&#160;</td><td class="fielddoc"><p>Tokens or Keywords. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787"></a>ExternKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb"></a>TemplateKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d"></a>BodyStatement&#160;</td><td class="fielddoc"><p>An inner statement for those that have only a single child of kind statement, e.g. </p>
<p>loop body for while, for, etc; inner statement for case, default, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7"></a>ListElement&#160;</td><td class="fielddoc"><p><a class="el" href="classclang_1_1syntax_1_1List.html" title="A list of Elements separated or terminated by a fixed token.">List</a> API roles. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8"></a>ListDelimiter&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23"></a>OperatorToken&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4"></a>Operand&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078"></a>LeftHandSide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623"></a>RightHandSide&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18"></a>ReturnValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34"></a>CaseValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b"></a>ThenStatement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183"></a>ElseKeyword&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6"></a>ElseStatement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043"></a>Expression&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f"></a>Statement&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde"></a>Condition&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4"></a>Message&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2"></a>Declarator&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a"></a>Declaration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719"></a>Size&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c"></a>Parameters&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941"></a>TrailingReturn&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536"></a>UnqualifiedId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f"></a>Qualifier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac"></a>SubExpression&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b"></a>Object&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9"></a>AccessToken&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d"></a>Member&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816"></a>Callee&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e"></a>Arguments&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5"></a>Declarators&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Nodes_8h_source.html#l00059">59</a> of file <a class="el" href="Nodes_8h_source.html">Nodes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4f256ced784108d3fb273d242929676a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f256ced784108d3fb273d242929676a">&#9670;&nbsp;</a></span>buildSyntaxTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">syntax::TranslationUnit * clang::syntax::buildSyntaxTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a syntax tree for the main file. </p>
<p>This usually covers the whole <a class="el" href="classclang_1_1TranslationUnitDecl.html" title="The top declaration context.">TranslationUnitDecl</a>, but can be restricted by the <a class="el" href="classclang_1_1ASTContext.html" title="Holds long-lived AST nodes (such as types and decls) that can be referred to throughout the semantic ...">ASTContext</a>'s traversal scope. </p>

<p class="definition">Definition at line <a class="el" href="BuildTree_8cpp_source.html#l01747">1747</a> of file <a class="el" href="BuildTree_8cpp_source.html">BuildTree.cpp</a>.</p>

</div>
</div>
<a id="a715c345b92c4d49b98a4b0d71cce07df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715c345b92c4d49b98a4b0d71cce07df">&#9670;&nbsp;</a></span>computeReplacements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1tooling_1_1Replacements.html">tooling::Replacements</a> clang::syntax::computeReplacements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Arena.html">Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const syntax::TranslationUnit &amp;&#160;</td>
          <td class="paramname"><em>TU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes textual replacements required to mimic the tree modifications made to the syntax tree. </p>

<p class="definition">Definition at line <a class="el" href="ComputeReplacements_8cpp_source.html#l00086">86</a> of file <a class="el" href="ComputeReplacements_8cpp_source.html">ComputeReplacements.cpp</a>.</p>

<p class="reference">References <a class="el" href="Replacement_8cpp_source.html#l00245">clang::tooling::Replacements::add()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l10527">emitReplacement()</a>, <a class="el" href="Tree_8h_source.html#l00046">clang::syntax::Arena::getSourceManager()</a>, <a class="el" href="Tree_8cpp_source.html#l00040">clang::syntax::Arena::getTokenBuffer()</a>, <a class="el" href="Basic_2Cuda_8cpp_source.html#l00081">SM</a>, and <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="a7faebfdbba7ac8862370fd2cee2bd90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7faebfdbba7ac8862370fd2cee2bd90a">&#9670;&nbsp;</a></span>createEmptyStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1EmptyStatement.html">syntax::EmptyStatement</a> * clang::syntax::createEmptyStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00227">227</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00197">createTree()</a>, and <a class="el" href="OperatorPrecedence_8h_source.html#l00027">clang::prec::Unknown</a>.</p>

</div>
</div>
<a id="afbc11ae1ecbd0919a1c725b58b2d9fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc11ae1ecbd0919a1c725b58b2d9fa0">&#9670;&nbsp;</a></span>createLeaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> * clang::syntax::createLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the token spelling from its <code>TokenKind</code>, then create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from this token. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00052">52</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, <a class="el" href="TokenKinds_8cpp_source.html#l00040">clang::tok::getKeywordSpelling()</a>, and <a class="el" href="TokenKinds_8cpp_source.html#l00031">clang::tok::getPunctuatorSpelling()</a>.</p>

</div>
</div>
<a id="a026e95f11b1e39147fa801cd73830da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026e95f11b1e39147fa801cd73830da6">&#9670;&nbsp;</a></span>createLeaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Leaf.html">syntax::Leaf</a> * clang::syntax::createLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1tok.html#a9468a30b60853d1e39187d0905b9b588">tok::TokenKind</a>&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Spelling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <code><a class="el" href="classclang_1_1syntax_1_1Leaf.html" title="A leaf node points to a single token inside the expanded token stream.">Leaf</a></code> from token with <code>Spelling</code> and assert it has the desired <code>TokenKind</code>. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00037">37</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Synthesis_8cpp_source.html#l00227">createEmptyStatement()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00052">createLeaf()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>.</p>

</div>
</div>
<a id="a53d843e69f183e006bb3c2c0927cbfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d843e69f183e006bb3c2c0927cbfcc">&#9670;&nbsp;</a></span>createTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Tree.html">syntax::Tree</a> * clang::syntax::createTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">syntax::NodeRole</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>Children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">syntax::NodeKind</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the concrete syntax node according to the specified <code>NodeKind</code> <code>K</code>. </p>
<p>Returns it as a pointer to the base class <code><a class="el" href="classclang_1_1syntax_1_1Tree.html" title="A node that has children and represents a syntactic language construct.">Tree</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00197">197</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Synthesis_8cpp_source.html#l00227">createEmptyStatement()</a>, and <a class="el" href="Synthesis_8cpp_source.html#l00210">deepCopyExpandingMacros()</a>.</p>

</div>
</div>
<a id="abd89f9a47c39ff754698c8714df181f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd89f9a47c39ff754698c8714df181f1">&#9670;&nbsp;</a></span>deepCopyExpandingMacros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> * clang::syntax::deepCopyExpandingMacros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Node.html">syntax::Node</a> *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a completely independent copy of <code>N</code> with its macros expanded. </p>
<p>The copy is:</p><ul>
<li>Detached, i.e. <code>Parent == NextSibling == nullptr</code> and <code>Role == Detached</code>.</li>
<li>Synthesized, i.e. <code>Original == false</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Synthesis_8cpp_source.html#l00210">210</a> of file <a class="el" href="Synthesis_8cpp_source.html">Synthesis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Synthesis_8cpp_source.html#l00037">createLeaf()</a>, <a class="el" href="Synthesis_8cpp_source.html#l00197">createTree()</a>, <a class="el" href="Tree_8h_source.html#l00096">clang::syntax::Node::getKind()</a>, and <a class="el" href="Tree_8h_source.html#l00046">clang::syntax::Arena::getSourceManager()</a>.</p>

</div>
</div>
<a id="a4aa2f5330bffd313bb05c4d4ed8d6042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa2f5330bffd313bb05c4d4ed8d6042">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00169">169</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8h_source.html#l00064">clang::syntax::FileRange::beginOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00066">clang::syntax::FileRange::endOffset()</a>, <a class="el" href="Tokens_8h_source.html#l00062">clang::syntax::FileRange::file()</a>, and <a class="el" href="SourceLocation_8h_source.html#l00055">clang::FileID::getHashValue()</a>.</p>

</div>
</div>
<a id="aee22380c758acfc7dc72398d4312bcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee22380c758acfc7dc72398d4312bcfc">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1Token.html">Token</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. Equivalent to a call to <a class="el" href="classclang_1_1syntax_1_1Token.html#a10e327aee703a9281dd146fb9816b939" title="For debugging purposes.">Token::str()</a>. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00138">138</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tokens_8cpp_source.html#l00857">clang::syntax::Token::str()</a>.</p>

</div>
</div>
<a id="a9773dfd304fc990b06ed6a7a8711e6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9773dfd304fc990b06ed6a7a8711e6f8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1syntax.html#a81b5b8b797bac504f7538749a7bb0a2a">NodeKind</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Nodes_8cpp_source.html#l00013">13</a> of file <a class="el" href="Nodes_8cpp_source.html">Nodes.cpp</a>.</p>

</div>
</div>
<a id="ab327bf8bd6ce7e2ebe105061d44fd7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab327bf8bd6ce7e2ebe105061d44fd7cb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; clang::syntax::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5">NodeRole</a>&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="Nodes_8cpp_source.html#l00023">23</a> of file <a class="el" href="Nodes_8cpp_source.html">Nodes.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a61e00b7ad470c7b8638b10803d4d67c9">AccessToken</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad637f66d25c9ff757bed6f168c73856e">Arguments</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ae4ed9e8e60aa25c2496ee227f54f9377">ArrowToken</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa8ef626e9c0eafe3e8c568c0c7ef310d">BodyStatement</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac8ff9e15a93f800c74c05e7b37364816">Callee</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a0290b73cde0025b5a093756176463f34">CaseValue</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a56f5ae57e2b58737187d503944cab6cd">CloseParen</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a9e2941b3c81256fac10392aaca4ccfde">Condition</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6246655a4c0a99b49f104cd87a0a7a7a">Declaration</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aae1289ec5221a0ecb07a1440f3cc97c2">Declarator</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ab12a6228ac45af311c53602432f606b5">Declarators</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a41cc07ca5bb4a5988322245a665a16f8">Detached</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a693581a349737568c6eed825bc9e8183">ElseKeyword</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5affe69b660ba55a5f2d68e56ac13f31c6">ElseStatement</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa1a6657be79cc0fc1e9b23b9e108f043">Expression</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ab40269cdb76e2169dc4c0e35d8486787">ExternKeyword</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a7547a0ac0bd2577afe9388dfc89805ea">IntroducerKeyword</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a9519654199c7499bb8864adb16bd8078">LeftHandSide</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad2b105a9154e8e15b3153249cf3a8aa8">ListDelimiter</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a22b39e80e2066739f3396c06a3f009e7">ListElement</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a28f0b8951a3d115abc20f68762316ca5">LiteralToken</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a858ba4765e53c712ef672a9570474b1d">Member</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a4c2a8fe7eaf24721cc7a9f0175115bd4">Message</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a497031794414a552435f90151ac3b54b">Object</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ad5b985fa59b8b23c9f237e8c9df0349f">OpenParen</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a1b488933c47964ca059d24f978f094e4">Operand</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a83c0b4306ec14cf15baa9d1cd377af23">OperatorToken</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a3225a10b07f1580f10dee4abc3779e6c">Parameters</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a75a47e1c183d2fea32df2a5e573ed35f">Qualifier</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aef075575efe2059289041f1118338f18">ReturnValue</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a2e07cec0197c7aea8c2354d4d06c6623">RightHandSide</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">Size</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a2af6fd9ec72aee193ee7ffe09638e08f">Statement</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac37f67826c216dfcf8ef24375fa263ac">SubExpression</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5ac254d57618c58574efba31bb528124fb">TemplateKeyword</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a7cad0f174fa8345d623d0a7f8f70e62b">ThenStatement</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a095a2910571dda799078657b7d11a941">TrailingReturn</a>, <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>, and <a class="el" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5aa43d0e23c5b5a3c83e986a71d0203536">UnqualifiedId</a>.</p>

</div>
</div>
<a id="ac945be75b2e1a63c6fc656f3418fe455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac945be75b2e1a63c6fc656f3418fe455">&#9670;&nbsp;</a></span>removeStatement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clang::syntax::removeStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Arena.html">syntax::Arena</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1syntax_1_1Statement.html">syntax::Statement</a> *&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a statement or replaces it with an empty statement where one is required syntactically. </p>
<p>E.g., in the following example: if (cond) { foo(); } else bar(); One can remove <code>foo();</code> completely and to remove <code>bar();</code> we would need to replace it with an empty statement. EXPECTS: S-&gt;canModify() == true </p>

<p class="definition">Definition at line <a class="el" href="Mutations_8cpp_source.html#l00080">80</a> of file <a class="el" href="Mutations_8cpp_source.html">Mutations.cpp</a>.</p>

</div>
</div>
<a id="a5495e074677ac58e95e398b46e079cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5495e074677ac58e95e398b46e079cb2">&#9670;&nbsp;</a></span>spelledIdentifierTouching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> * clang::syntax::spelledIdentifierTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>Tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00508">508</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="a4717e9f6a8df9c77f1bd3aedb282169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4717e9f6a8df9c77f1bd3aedb282169e">&#9670;&nbsp;</a></span>spelledIdentifierTouching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> * clang::syntax::spelledIdentifierTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td>
          <td class="paramname"><em>Tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The identifier token that overlaps or touches a spelling location Loc. </p>
<p>If there is none, returns nullptr. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00498">498</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="afff502ef26cb84b374c72f21c9b44236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff502ef26cb84b374c72f21c9b44236">&#9670;&nbsp;</a></span>spelledTokensTouching() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::spelledTokensTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1syntax_1_1TokenBuffer.html">syntax::TokenBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>Tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The spelled tokens that overlap or touch a spelling location Loc. </p>
<p>This always returns 0-2 tokens. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00491">491</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="a793cf39170ae045357f2299a8ad5d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793cf39170ae045357f2299a8ad5d1ee">&#9670;&nbsp;</a></span>spelledTokensTouching() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::spelledTokensTouching </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt;&#160;</td>
          <td class="paramname"><em>Tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00477">477</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="a24a1ffeac5053cf3f2a36f48251ce417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a1ffeac5053cf3f2a36f48251ce417">&#9670;&nbsp;</a></span>tokenize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::tokenize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1syntax_1_1FileRange.html">FileRange</a> &amp;&#160;</td>
          <td class="paramname"><em>FR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>SM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to one above, instead of whole file tokenizes a part of it. </p>
<p>Note that, the first token might be incomplete if FR.startOffset is not at the beginning of a token, and the last token returned will start before the FR.endOffset but might end after it. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00529">529</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

</div>
</div>
<a id="a74ab6237c208ae112ad2abd4e003235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ab6237c208ae112ad2abd4e003235b">&#9670;&nbsp;</a></span>tokenize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classclang_1_1syntax_1_1Token.html">syntax::Token</a> &gt; clang::syntax::tokenize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td>
          <td class="paramname"><em>FID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>SM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lex the text buffer, corresponding to <code>FID</code>, in raw mode and record the resulting spelled tokens. </p>
<p>Does minimal post-processing on raw identifiers, setting the appropriate token kind (instead of the raw_identifier reported by lexer in raw mode). This is a very low-level function, most users should prefer to use <a class="el" href="classclang_1_1syntax_1_1TokenCollector.html" title="Collects tokens for the main file while running the frontend action.">TokenCollector</a>. Lexing in raw mode produces wildly different results from what one might expect when running a C++ frontend, e.g. preprocessor does not run at all. The result will <em>not</em> have a 'eof' token at the end. </p>

<p class="definition">Definition at line <a class="el" href="Tokens_8cpp_source.html#l00562">562</a> of file <a class="el" href="Tokens_8cpp_source.html">Tokens.cpp</a>.</p>

<p class="reference">References <a class="el" href="Basic_2Cuda_8cpp_source.html#l00081">SM</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:33 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
