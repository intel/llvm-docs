<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: lib/Headers/avx2intrin.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">19.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_32af269ab941e393bd1c05d50cd12728.html">Headers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">avx2intrin.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="avx2intrin_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9c3364b71a7fe0439ba73567fc303fcc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a></td></tr>
<tr class="separator:a9c3364b71a7fe0439ba73567fc303fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5269551cf777adb9ce7ae4726145df2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a></td></tr>
<tr class="separator:aa5269551cf777adb9ce7ae4726145df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139092f30e8322e5d76257b5bac2886"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a>(<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>,  Y,  M)</td></tr>
<tr class="memdesc:ac139092f30e8322e5d76257b5bac2886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers from the 256-bit integer vectors <em>X</em> and <em>Y</em>.  <a href="avx2intrin_8h.html#ac139092f30e8322e5d76257b5bac2886">More...</a><br /></td></tr>
<tr class="separator:ac139092f30e8322e5d76257b5bac2886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3521900e672c4655149ced8682d05"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a>(a,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>,  n)</td></tr>
<tr class="memdesc:a8fe3521900e672c4655149ced8682d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the lower half of the 256-bit vector <em>a</em> as the upper half of a temporary 256-bit value, and the lower half of the 256-bit vector <em>b</em> as the lower half of the temporary value.  <a href="avx2intrin_8h.html#a8fe3521900e672c4655149ced8682d05">More...</a><br /></td></tr>
<tr class="separator:a8fe3521900e672c4655149ced8682d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad018a82854ddb7a5c81d00ea72140972"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:ad018a82854ddb7a5c81d00ea72140972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 16-bit integer values from either of the two 256-bit vectors <em>V1</em> or <em>V2</em>, as specified by the immediate integer operand <em>M</em>, and returns the resulting 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#ad018a82854ddb7a5c81d00ea72140972">More...</a><br /></td></tr>
<tr class="separator:ad018a82854ddb7a5c81d00ea72140972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e537a750e453f44a0ed29eeeba6c88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshufd256((__v8si)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:ac0e537a750e453f44a0ed29eeeba6c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result.  <a href="avx2intrin_8h.html#ac0e537a750e453f44a0ed29eeeba6c88">More...</a><br /></td></tr>
<tr class="separator:ac0e537a750e453f44a0ed29eeeba6c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067971162dbcfead4d820ccda94fc850"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshufhw256((__v16hi)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:a067971162dbcfead4d820ccda94fc850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result.  <a href="avx2intrin_8h.html#a067971162dbcfead4d820ccda94fc850">More...</a><br /></td></tr>
<tr class="separator:a067971162dbcfead4d820ccda94fc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshuflw256((__v16hi)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit [16 x i16] result.  <a href="avx2intrin_8h.html#ad3ebb6cfdddfb1692373d6cf70ac8ccf">More...</a><br /></td></tr>
<tr class="separator:ad3ebb6cfdddfb1692373d6cf70ac8ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f1212570d0e3dee4a64ef6e8a19693"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:ac2f1212570d0e3dee4a64ef6e8a19693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <a href="avx2intrin_8h.html#ac2f1212570d0e3dee4a64ef6e8a19693">More...</a><br /></td></tr>
<tr class="separator:ac2f1212570d0e3dee4a64ef6e8a19693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adabedfb750d899e60f3685b434c6ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:a0adabedfb750d899e60f3685b434c6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <a href="avx2intrin_8h.html#a0adabedfb750d899e60f3685b434c6ad">More...</a><br /></td></tr>
<tr class="separator:a0adabedfb750d899e60f3685b434c6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a707f6f1a0cc3039cacb54fb420d4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:a59a707f6f1a0cc3039cacb54fb420d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <a href="avx2intrin_8h.html#a59a707f6f1a0cc3039cacb54fb420d4b">More...</a><br /></td></tr>
<tr class="separator:a59a707f6f1a0cc3039cacb54fb420d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf654837b8bfee81dbdcae53b79e7961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a>(a,  imm)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td></tr>
<tr class="memdesc:acf654837b8bfee81dbdcae53b79e7961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result.  <a href="avx2intrin_8h.html#acf654837b8bfee81dbdcae53b79e7961">More...</a><br /></td></tr>
<tr class="separator:acf654837b8bfee81dbdcae53b79e7961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7c90e2a3c140bd5828be66dd00450c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2c7c90e2a3c140bd5828be66dd00450c">_mm_broadcastsi128_si256</a>(<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>)&#160;&#160;&#160;<a class="el" href="avx2intrin_8h.html#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a>(<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>)</td></tr>
<tr class="separator:a2c7c90e2a3c140bd5828be66dd00450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in <em>V1</em> or <em>V2</em> to the result's 128-bit vector of [4 x i32], as specified by the immediate integer operand <em>M</em>.  <a href="avx2intrin_8h.html#a51a2ff86a16a4fc5a9e3c94a817064ea">More...</a><br /></td></tr>
<tr class="separator:a51a2ff86a16a4fc5a9e3c94a817064ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in <em>V1</em> or <em>V2</em> to return a 256-bit vector of [8 x i32], as specified by the immediate integer operand <em>M</em>.  <a href="avx2intrin_8h.html#a5f8fd952a7c88dfb5b9437f0cd94b9db">More...</a><br /></td></tr>
<tr class="separator:a5f8fd952a7c88dfb5b9437f0cd94b9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e712383837346afed6b8bb7980d1ed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)&#160;&#160;&#160;  ((__m256d)__builtin_ia32_permdf256((__v4df)(__m256d)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td></tr>
<tr class="memdesc:a6e712383837346afed6b8bb7980d1ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x double] in <em>V</em> as specified by the immediate value <em>M</em>.  <a href="avx2intrin_8h.html#a6e712383837346afed6b8bb7980d1ed1">More...</a><br /></td></tr>
<tr class="separator:a6e712383837346afed6b8bb7980d1ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68537aee7b7c35974ea46b32d6be8539"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_permdi256((__v4di)(__m256i)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td></tr>
<tr class="memdesc:a68537aee7b7c35974ea46b32d6be8539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [4 x i64] in <em>V</em> as specified by the immediate value <em>M</em>.  <a href="avx2intrin_8h.html#a68537aee7b7c35974ea46b32d6be8539">More...</a><br /></td></tr>
<tr class="separator:a68537aee7b7c35974ea46b32d6be8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a>(V1,  V2,  M)&#160;&#160;&#160;  ((__m256i)__builtin_ia32_permti256((__m256i)(V1), (__m256i)(V2), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td></tr>
<tr class="memdesc:aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of the 256-bit vectors <em>V1</em> and <em>V2</em>, as specified by the immediate value <em>M</em>.  <a href="avx2intrin_8h.html#aa42c8a9ffd50a4d2e392dc16043f3be2">More...</a><br /></td></tr>
<tr class="separator:aa42c8a9ffd50a4d2e392dc16043f3be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad58b51492bbbb175bcafd021585d930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a>(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>,  M)&#160;&#160;&#160;  ((__m128i)__builtin_ia32_extract128i256((__v4di)(__m256i)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td></tr>
<tr class="memdesc:aad58b51492bbbb175bcafd021585d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts half of the 256-bit vector <em>V</em> to the 128-bit result.  <a href="avx2intrin_8h.html#aad58b51492bbbb175bcafd021585d930">More...</a><br /></td></tr>
<tr class="separator:aad58b51492bbbb175bcafd021585d930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406778aad3e2dac47927d38a6689714"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a>(V1,  V2,  M)</td></tr>
<tr class="memdesc:a8406778aad3e2dac47927d38a6689714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the 256-bit vector <em>V1</em> to the result, then overwrites half of the result with the 128-bit vector <em>V2</em>.  <a href="avx2intrin_8h.html#a8406778aad3e2dac47927d38a6689714">More...</a><br /></td></tr>
<tr class="separator:a8406778aad3e2dac47927d38a6689714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2af56dc678cba90344c8efc51e42fef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:af2af56dc678cba90344c8efc51e42fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#af2af56dc678cba90344c8efc51e42fef">More...</a><br /></td></tr>
<tr class="separator:af2af56dc678cba90344c8efc51e42fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ef334e167c132b6a9f13770b77f01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a8a9ef334e167c132b6a9f13770b77f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a8a9ef334e167c132b6a9f13770b77f01">More...</a><br /></td></tr>
<tr class="separator:a8a9ef334e167c132b6a9f13770b77f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e967b6fb85089168a6887111c1320"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:abb2e967b6fb85089168a6887111c1320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#abb2e967b6fb85089168a6887111c1320">More...</a><br /></td></tr>
<tr class="separator:abb2e967b6fb85089168a6887111c1320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b86b0ba922eb270ec2b545c8a537d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:acf5b86b0ba922eb270ec2b545c8a537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#acf5b86b0ba922eb270ec2b545c8a537d">More...</a><br /></td></tr>
<tr class="separator:acf5b86b0ba922eb270ec2b545c8a537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d9ce668f45c18f008ccb4ba4920880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a66d9ce668f45c18f008ccb4ba4920880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a66d9ce668f45c18f008ccb4ba4920880">More...</a><br /></td></tr>
<tr class="separator:a66d9ce668f45c18f008ccb4ba4920880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7767cbba8a5c61bf05fe06ee416a4542"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a7767cbba8a5c61bf05fe06ee416a4542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a7767cbba8a5c61bf05fe06ee416a4542">More...</a><br /></td></tr>
<tr class="separator:a7767cbba8a5c61bf05fe06ee416a4542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80831775aea07c24899ae747d8011bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ab80831775aea07c24899ae747d8011bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#ab80831775aea07c24899ae747d8011bc">More...</a><br /></td></tr>
<tr class="separator:ab80831775aea07c24899ae747d8011bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ab1da963f146144bd78937e561deaf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a13ab1da963f146144bd78937e561deaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a13ab1da963f146144bd78937e561deaf">More...</a><br /></td></tr>
<tr class="separator:a13ab1da963f146144bd78937e561deaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3078631872478b4855ee95713aa2cd48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a3078631872478b4855ee95713aa2cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a3078631872478b4855ee95713aa2cd48">More...</a><br /></td></tr>
<tr class="separator:a3078631872478b4855ee95713aa2cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3890959d248c67e0307f945f852a28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4a3890959d248c67e0307f945f852a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a4a3890959d248c67e0307f945f852a28">More...</a><br /></td></tr>
<tr class="separator:a4a3890959d248c67e0307f945f852a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59acb178be58ad2561eb49b14489800d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a59acb178be58ad2561eb49b14489800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a59acb178be58ad2561eb49b14489800d">More...</a><br /></td></tr>
<tr class="separator:a59acb178be58ad2561eb49b14489800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91162e72875b376189127affa7b2bf5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a91162e72875b376189127affa7b2bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a91162e72875b376189127affa7b2bf5c">More...</a><br /></td></tr>
<tr class="separator:a91162e72875b376189127affa7b2bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825d53d864b1d4d3bb7ab4b6ef457952"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a825d53d864b1d4d3bb7ab4b6ef457952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a825d53d864b1d4d3bb7ab4b6ef457952">More...</a><br /></td></tr>
<tr class="separator:a825d53d864b1d4d3bb7ab4b6ef457952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6618807ebcb4b758d18065b0512b456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad6618807ebcb4b758d18065b0512b456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#ad6618807ebcb4b758d18065b0512b456">More...</a><br /></td></tr>
<tr class="separator:ad6618807ebcb4b758d18065b0512b456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1efa9858c290fe95335119cd657a90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:aeb1efa9858c290fe95335119cd657a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#aeb1efa9858c290fe95335119cd657a90">More...</a><br /></td></tr>
<tr class="separator:aeb1efa9858c290fe95335119cd657a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b171b3af10ce3b58abef775d789f20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a>(a,  m,  i,  mask,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:af6b171b3af10ce3b58abef775d789f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#af6b171b3af10ce3b58abef775d789f20">More...</a><br /></td></tr>
<tr class="separator:af6b171b3af10ce3b58abef775d789f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afe7e70b1677fd4097166407ae827cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4afe7e70b1677fd4097166407ae827cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a4afe7e70b1677fd4097166407ae827cb">More...</a><br /></td></tr>
<tr class="separator:a4afe7e70b1677fd4097166407ae827cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80044451f05309770ce2bf171dbfa0be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a80044451f05309770ce2bf171dbfa0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a80044451f05309770ce2bf171dbfa0be">More...</a><br /></td></tr>
<tr class="separator:a80044451f05309770ce2bf171dbfa0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc1a3777f51496f53faf452ae31ebfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a6fc1a3777f51496f53faf452ae31ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a6fc1a3777f51496f53faf452ae31ebfc">More...</a><br /></td></tr>
<tr class="separator:a6fc1a3777f51496f53faf452ae31ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6cdf024224c2ed44d22717fd80434"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a10b6cdf024224c2ed44d22717fd80434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a10b6cdf024224c2ed44d22717fd80434">More...</a><br /></td></tr>
<tr class="separator:a10b6cdf024224c2ed44d22717fd80434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192468a06b0104ad516aaca8a4f0eee8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a192468a06b0104ad516aaca8a4f0eee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a192468a06b0104ad516aaca8a4f0eee8">More...</a><br /></td></tr>
<tr class="separator:a192468a06b0104ad516aaca8a4f0eee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74219a133afddd0577c5a391f041a936"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a74219a133afddd0577c5a391f041a936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a74219a133afddd0577c5a391f041a936">More...</a><br /></td></tr>
<tr class="separator:a74219a133afddd0577c5a391f041a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369276cfeba553776632edd1ee507cec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a369276cfeba553776632edd1ee507cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a369276cfeba553776632edd1ee507cec">More...</a><br /></td></tr>
<tr class="separator:a369276cfeba553776632edd1ee507cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897ba09d00f44657795d12e48beeca0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a897ba09d00f44657795d12e48beeca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a897ba09d00f44657795d12e48beeca0f">More...</a><br /></td></tr>
<tr class="separator:a897ba09d00f44657795d12e48beeca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc371417a059f4660f43bb9f70c0420"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a3fc371417a059f4660f43bb9f70c0420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a3fc371417a059f4660f43bb9f70c0420">More...</a><br /></td></tr>
<tr class="separator:a3fc371417a059f4660f43bb9f70c0420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1267ffda36b2c13484b36a209e37792"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad1267ffda36b2c13484b36a209e37792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#ad1267ffda36b2c13484b36a209e37792">More...</a><br /></td></tr>
<tr class="separator:ad1267ffda36b2c13484b36a209e37792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b68cf22a459a9867218792d42c0b5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad6b68cf22a459a9867218792d42c0b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 32-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#ad6b68cf22a459a9867218792d42c0b5d">More...</a><br /></td></tr>
<tr class="separator:ad6b68cf22a459a9867218792d42c0b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ead9a9686d802347c1311dbdb2166de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a4ead9a9686d802347c1311dbdb2166de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 32-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a4ead9a9686d802347c1311dbdb2166de">More...</a><br /></td></tr>
<tr class="separator:a4ead9a9686d802347c1311dbdb2166de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9f493fcb23d1f0266edb15035bc22f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a2f9f493fcb23d1f0266edb15035bc22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a2f9f493fcb23d1f0266edb15035bc22f">More...</a><br /></td></tr>
<tr class="separator:a2f9f493fcb23d1f0266edb15035bc22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16861b116c0624454372064f910c4f80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a16861b116c0624454372064f910c4f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>.  <a href="avx2intrin_8h.html#a16861b116c0624454372064f910c4f80">More...</a><br /></td></tr>
<tr class="separator:a16861b116c0624454372064f910c4f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a2425c4e406cc767d45cbd063ba7d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:a76a2425c4e406cc767d45cbd063ba7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#a76a2425c4e406cc767d45cbd063ba7d4">More...</a><br /></td></tr>
<tr class="separator:a76a2425c4e406cc767d45cbd063ba7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b484e1a1b32ff73f8857fc02dc8008"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a>(m,  i,  <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)</td></tr>
<tr class="memdesc:ad1b484e1a1b32ff73f8857fc02dc8008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>.  <a href="avx2intrin_8h.html#ad1b484e1a1b32ff73f8857fc02dc8008">More...</a><br /></td></tr>
<tr class="separator:ad1b484e1a1b32ff73f8857fc02dc8008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a012bc2eed4df0a81ee390af2ef919e9b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a012bc2eed4df0a81ee390af2ef919e9b">_mm256_abs_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:a012bc2eed4df0a81ee390af2ef919e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed byte in the 256-bit integer vector <em>__a</em> and returns each value in the corresponding byte of the result.  <a href="avx2intrin_8h.html#a012bc2eed4df0a81ee390af2ef919e9b">More...</a><br /></td></tr>
<tr class="separator:a012bc2eed4df0a81ee390af2ef919e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af356be486c9c44ff687a24eecb505123"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af356be486c9c44ff687a24eecb505123">_mm256_abs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:af356be486c9c44ff687a24eecb505123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed 16-bit element in the 256-bit vector of [16 x i16] in <em>__a</em> and returns each value in the corresponding element of the result.  <a href="avx2intrin_8h.html#af356be486c9c44ff687a24eecb505123">More...</a><br /></td></tr>
<tr class="separator:af356be486c9c44ff687a24eecb505123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fbd635339f3c30bf181326688a45d1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ae0fbd635339f3c30bf181326688a45d1">_mm256_abs_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:ae0fbd635339f3c30bf181326688a45d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value of each signed 32-bit element in the 256-bit vector of [8 x i32] in <em>__a</em> and returns each value in the corresponding element of the result.  <a href="avx2intrin_8h.html#ae0fbd635339f3c30bf181326688a45d1">More...</a><br /></td></tr>
<tr class="separator:ae0fbd635339f3c30bf181326688a45d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820ba07f5916a602806c2aecd6cd0f69"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a820ba07f5916a602806c2aecd6cd0f69">_mm256_packs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a820ba07f5916a602806c2aecd6cd0f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the elements of two 256-bit vectors of [16 x i16] to 8-bit integers using signed saturation, and returns the 256-bit result.  <a href="avx2intrin_8h.html#a820ba07f5916a602806c2aecd6cd0f69">More...</a><br /></td></tr>
<tr class="separator:a820ba07f5916a602806c2aecd6cd0f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f0a34407f0edaa6728ec94ced2431a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a18f0a34407f0edaa6728ec94ced2431a">_mm256_packs_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a18f0a34407f0edaa6728ec94ced2431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the elements of two 256-bit vectors of [8 x i32] to 16-bit integers using signed saturation, and returns the resulting 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#a18f0a34407f0edaa6728ec94ced2431a">More...</a><br /></td></tr>
<tr class="separator:a18f0a34407f0edaa6728ec94ced2431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54fdcd67534f2defc6f2564d7a031f5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ac54fdcd67534f2defc6f2564d7a031f5">_mm256_packus_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ac54fdcd67534f2defc6f2564d7a031f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elements from two 256-bit vectors of [16 x i16] to 8-bit integers using unsigned saturation, and returns the 256-bit result.  <a href="avx2intrin_8h.html#ac54fdcd67534f2defc6f2564d7a031f5">More...</a><br /></td></tr>
<tr class="separator:ac54fdcd67534f2defc6f2564d7a031f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ddfcbac48b6687c29540ba34187da"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aa67ddfcbac48b6687c29540ba34187da">_mm256_packus_epi32</a> (__m256i __V1, __m256i __V2)</td></tr>
<tr class="memdesc:aa67ddfcbac48b6687c29540ba34187da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts elements from two 256-bit vectors of [8 x i32] to 16-bit integers using unsigned saturation, and returns the resulting 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#aa67ddfcbac48b6687c29540ba34187da">More...</a><br /></td></tr>
<tr class="separator:aa67ddfcbac48b6687c29540ba34187da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b923dae009dd42ae05783e0955ee00"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a59b923dae009dd42ae05783e0955ee00">_mm256_add_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a59b923dae009dd42ae05783e0955ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors and returns the lower 8 bits of each sum in the corresponding byte of the 256-bit integer vector result (overflow is ignored).  <a href="avx2intrin_8h.html#a59b923dae009dd42ae05783e0955ee00">More...</a><br /></td></tr>
<tr class="separator:a59b923dae009dd42ae05783e0955ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5c1fe2000e40ddd6ccd91f29dfd4ae0d">_mm256_add_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in the corresponding element of the [16 x i16] result (overflow is ignored).  <a href="avx2intrin_8h.html#a5c1fe2000e40ddd6ccd91f29dfd4ae0d">More...</a><br /></td></tr>
<tr class="separator:a5c1fe2000e40ddd6ccd91f29dfd4ae0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c017a67c07b606eeaa106c1f7cdf73"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af8c017a67c07b606eeaa106c1f7cdf73">_mm256_add_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:af8c017a67c07b606eeaa106c1f7cdf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in the corresponding element of the [8 x i32] result (overflow is ignored).  <a href="avx2intrin_8h.html#af8c017a67c07b606eeaa106c1f7cdf73">More...</a><br /></td></tr>
<tr class="separator:af8c017a67c07b606eeaa106c1f7cdf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67010f3cee987f3dd117a785fc5a8890"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a67010f3cee987f3dd117a785fc5a8890">_mm256_add_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a67010f3cee987f3dd117a785fc5a8890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64] and returns the lower 64 bits of each sum in the corresponding element of the [4 x i64] result (overflow is ignored).  <a href="avx2intrin_8h.html#a67010f3cee987f3dd117a785fc5a8890">More...</a><br /></td></tr>
<tr class="separator:a67010f3cee987f3dd117a785fc5a8890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd983b6ed3ea7f23bea1deb062b8a72b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#acd983b6ed3ea7f23bea1deb062b8a72b">_mm256_adds_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:acd983b6ed3ea7f23bea1deb062b8a72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result.  <a href="avx2intrin_8h.html#acd983b6ed3ea7f23bea1deb062b8a72b">More...</a><br /></td></tr>
<tr class="separator:acd983b6ed3ea7f23bea1deb062b8a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af52f4d9d816fcdcc2fcd9852c20ccc87">_mm256_adds_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns the [16 x i16] result.  <a href="avx2intrin_8h.html#af52f4d9d816fcdcc2fcd9852c20ccc87">More...</a><br /></td></tr>
<tr class="separator:af52f4d9d816fcdcc2fcd9852c20ccc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d44817e7de48ab8c0774a1d8faae8"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#abf0d44817e7de48ab8c0774a1d8faae8">_mm256_adds_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:abf0d44817e7de48ab8c0774a1d8faae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result.  <a href="avx2intrin_8h.html#abf0d44817e7de48ab8c0774a1d8faae8">More...</a><br /></td></tr>
<tr class="separator:abf0d44817e7de48ab8c0774a1d8faae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d517ee9448be65c2af608809bab444e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4d517ee9448be65c2af608809bab444e">_mm256_adds_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a4d517ee9448be65c2af608809bab444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns the [16 x i16] result.  <a href="avx2intrin_8h.html#a4d517ee9448be65c2af608809bab444e">More...</a><br /></td></tr>
<tr class="separator:a4d517ee9448be65c2af608809bab444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b4ece913b92fa300c7fb60a2a70040"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a05b4ece913b92fa300c7fb60a2a70040">_mm256_and_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a05b4ece913b92fa300c7fb60a2a70040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <a href="avx2intrin_8h.html#a05b4ece913b92fa300c7fb60a2a70040">More...</a><br /></td></tr>
<tr class="separator:a05b4ece913b92fa300c7fb60a2a70040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad3c77b7bf2d8fd2dfb073b14a14b1ba2">_mm256_andnot_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise AND of the 256-bit integer vector in <em>__b</em> with the bitwise NOT of the 256-bit integer vector in <em>__a</em>.  <a href="avx2intrin_8h.html#ad3c77b7bf2d8fd2dfb073b14a14b1ba2">More...</a><br /></td></tr>
<tr class="separator:ad3c77b7bf2d8fd2dfb073b14a14b1ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bed13563c4899b28a80ee1650f5464"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af8bed13563c4899b28a80ee1650f5464">_mm256_avg_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:af8bed13563c4899b28a80ee1650f5464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the averages of the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns each average in the corresponding byte of the 256-bit result.  <a href="avx2intrin_8h.html#af8bed13563c4899b28a80ee1650f5464">More...</a><br /></td></tr>
<tr class="separator:af8bed13563c4899b28a80ee1650f5464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22ee1dca08e46d756de99cb7e96969a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aa22ee1dca08e46d756de99cb7e96969a">_mm256_avg_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:aa22ee1dca08e46d756de99cb7e96969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the averages of the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns each average in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#aa22ee1dca08e46d756de99cb7e96969a">More...</a><br /></td></tr>
<tr class="separator:aa22ee1dca08e46d756de99cb7e96969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62142b089038d77658d0b4b8a0d9cc60"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a62142b089038d77658d0b4b8a0d9cc60">_mm256_blendv_epi8</a> (__m256i __V1, __m256i __V2, __m256i __M)</td></tr>
<tr class="memdesc:a62142b089038d77658d0b4b8a0d9cc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges 8-bit integer values from either of the two 256-bit vectors <em>__V1</em> or <em>__V2</em>, as specified by the 256-bit mask <em>__M</em> and returns the resulting 256-bit integer vector.  <a href="avx2intrin_8h.html#a62142b089038d77658d0b4b8a0d9cc60">More...</a><br /></td></tr>
<tr class="separator:a62142b089038d77658d0b4b8a0d9cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1c56e14a2dde3eb2c34d1e9d6dcc253d">_mm256_cmpeq_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding bytes of the 256-bit result.  <a href="avx2intrin_8h.html#a1c56e14a2dde3eb2c34d1e9d6dcc253d">More...</a><br /></td></tr>
<tr class="separator:a1c56e14a2dde3eb2c34d1e9d6dcc253d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3995744cd296ba3afe8e63286cc001"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8d3995744cd296ba3afe8e63286cc001">_mm256_cmpeq_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a8d3995744cd296ba3afe8e63286cc001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#a8d3995744cd296ba3afe8e63286cc001">More...</a><br /></td></tr>
<tr class="separator:a8d3995744cd296ba3afe8e63286cc001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08dc58285046d2fcd2f22d810142926"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab08dc58285046d2fcd2f22d810142926">_mm256_cmpeq_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ab08dc58285046d2fcd2f22d810142926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#ab08dc58285046d2fcd2f22d810142926">More...</a><br /></td></tr>
<tr class="separator:ab08dc58285046d2fcd2f22d810142926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfc980648d672eb11da414edb750685"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a7dfc980648d672eb11da414edb750685">_mm256_cmpeq_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a7dfc980648d672eb11da414edb750685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#a7dfc980648d672eb11da414edb750685">More...</a><br /></td></tr>
<tr class="separator:a7dfc980648d672eb11da414edb750685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3576feade9f12b451ae0c9c4a0061029"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3576feade9f12b451ae0c9c4a0061029">_mm256_cmpgt_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a3576feade9f12b451ae0c9c4a0061029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding bytes of the 256-bit result.  <a href="avx2intrin_8h.html#a3576feade9f12b451ae0c9c4a0061029">More...</a><br /></td></tr>
<tr class="separator:a3576feade9f12b451ae0c9c4a0061029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786920fc3bb94533373fca034895faec"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a786920fc3bb94533373fca034895faec">_mm256_cmpgt_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a786920fc3bb94533373fca034895faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#a786920fc3bb94533373fca034895faec">More...</a><br /></td></tr>
<tr class="separator:a786920fc3bb94533373fca034895faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3c233b478906cc78e36cf04610b79a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3e3c233b478906cc78e36cf04610b79a">_mm256_cmpgt_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a3e3c233b478906cc78e36cf04610b79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#a3e3c233b478906cc78e36cf04610b79a">More...</a><br /></td></tr>
<tr class="separator:a3e3c233b478906cc78e36cf04610b79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c95c13f7072f5de6a1a81079605e87"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a55c95c13f7072f5de6a1a81079605e87">_mm256_cmpgt_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a55c95c13f7072f5de6a1a81079605e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares corresponding signed elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result.  <a href="avx2intrin_8h.html#a55c95c13f7072f5de6a1a81079605e87">More...</a><br /></td></tr>
<tr class="separator:a55c95c13f7072f5de6a1a81079605e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b15ed1ec6a9658484d049d654b4d3f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a04b15ed1ec6a9658484d049d654b4d3f">_mm256_hadd_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a04b15ed1ec6a9658484d049d654b4d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in an element of the [16 x i16] result (overflow is ignored).  <a href="avx2intrin_8h.html#a04b15ed1ec6a9658484d049d654b4d3f">More...</a><br /></td></tr>
<tr class="separator:a04b15ed1ec6a9658484d049d654b4d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ae2d57af7ba2fcd4ff1fc40bd69a89c1e">_mm256_hadd_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in an element of the [8 x i32] result (overflow is ignored).  <a href="avx2intrin_8h.html#ae2d57af7ba2fcd4ff1fc40bd69a89c1e">More...</a><br /></td></tr>
<tr class="separator:ae2d57af7ba2fcd4ff1fc40bd69a89c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6ac82b9f1eb9cec755e5bbff0e5a8c9a">_mm256_hadds_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result.  <a href="avx2intrin_8h.html#a6ac82b9f1eb9cec755e5bbff0e5a8c9a">More...</a><br /></td></tr>
<tr class="separator:a6ac82b9f1eb9cec755e5bbff0e5a8c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a47dba9aa45c3b9f52e2acb9016fa2dae">_mm256_hsub_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each difference in an element of the [16 x i16] result (overflow is ignored).  <a href="avx2intrin_8h.html#a47dba9aa45c3b9f52e2acb9016fa2dae">More...</a><br /></td></tr>
<tr class="separator:a47dba9aa45c3b9f52e2acb9016fa2dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c77e9df5766726e6bc06112dc97d44"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a72c77e9df5766726e6bc06112dc97d44">_mm256_hsub_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a72c77e9df5766726e6bc06112dc97d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each difference in an element of the [8 x i32] result (overflow is ignored).  <a href="avx2intrin_8h.html#a72c77e9df5766726e6bc06112dc97d44">More...</a><br /></td></tr>
<tr class="separator:a72c77e9df5766726e6bc06112dc97d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce513f7958d273eaebafb97d071f4b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a85ce513f7958d273eaebafb97d071f4b">_mm256_hsubs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a85ce513f7958d273eaebafb97d071f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result.  <a href="avx2intrin_8h.html#a85ce513f7958d273eaebafb97d071f4b">More...</a><br /></td></tr>
<tr class="separator:a85ce513f7958d273eaebafb97d071f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ca72807cf9d112a8db52f1c688400"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3f1ca72807cf9d112a8db52f1c688400">_mm256_maddubs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a3f1ca72807cf9d112a8db52f1c688400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each unsigned byte from the 256-bit integer vector in <em>__a</em> with the corresponding signed byte from the 256-bit integer vector in <em>__b</em>, forming signed 16-bit intermediate products.  <a href="avx2intrin_8h.html#a3f1ca72807cf9d112a8db52f1c688400">More...</a><br /></td></tr>
<tr class="separator:a3f1ca72807cf9d112a8db52f1c688400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a736efeb017832345499b28c44af161"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a9a736efeb017832345499b28c44af161">_mm256_madd_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a9a736efeb017832345499b28c44af161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies corresponding 16-bit elements of two 256-bit vectors of [16 x i16], forming 32-bit intermediate products, and adds pairs of those products to form 32-bit sums returned as elements of the [8 x i32] result.  <a href="avx2intrin_8h.html#a9a736efeb017832345499b28c44af161">More...</a><br /></td></tr>
<tr class="separator:a9a736efeb017832345499b28c44af161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a37b9e0bac773f0d39f3b41ef45d5d68c">_mm256_max_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result.  <a href="avx2intrin_8h.html#a37b9e0bac773f0d39f3b41ef45d5d68c">More...</a><br /></td></tr>
<tr class="separator:a37b9e0bac773f0d39f3b41ef45d5d68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5111412077ead099ddee344188839b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6c5111412077ead099ddee344188839b">_mm256_max_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6c5111412077ead099ddee344188839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a6c5111412077ead099ddee344188839b">More...</a><br /></td></tr>
<tr class="separator:a6c5111412077ead099ddee344188839b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbbe31483e96447c3e05be279bdc57f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6fbbe31483e96447c3e05be279bdc57f">_mm256_max_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6fbbe31483e96447c3e05be279bdc57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a6fbbe31483e96447c3e05be279bdc57f">More...</a><br /></td></tr>
<tr class="separator:a6fbbe31483e96447c3e05be279bdc57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210035d203bef654a1f1ade4da7c749"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6210035d203bef654a1f1ade4da7c749">_mm256_max_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6210035d203bef654a1f1ade4da7c749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result.  <a href="avx2intrin_8h.html#a6210035d203bef654a1f1ade4da7c749">More...</a><br /></td></tr>
<tr class="separator:a6210035d203bef654a1f1ade4da7c749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d5a2c501aac700288afa0c508c973"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a075d5a2c501aac700288afa0c508c973">_mm256_max_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a075d5a2c501aac700288afa0c508c973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a075d5a2c501aac700288afa0c508c973">More...</a><br /></td></tr>
<tr class="separator:a075d5a2c501aac700288afa0c508c973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1902c5c1b74ba78ba57686e3a5582"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a51d1902c5c1b74ba78ba57686e3a5582">_mm256_max_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a51d1902c5c1b74ba78ba57686e3a5582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a51d1902c5c1b74ba78ba57686e3a5582">More...</a><br /></td></tr>
<tr class="separator:a51d1902c5c1b74ba78ba57686e3a5582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da8c62a81a77a136d34c0f5b7ee04db"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2da8c62a81a77a136d34c0f5b7ee04db">_mm256_min_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a2da8c62a81a77a136d34c0f5b7ee04db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result.  <a href="avx2intrin_8h.html#a2da8c62a81a77a136d34c0f5b7ee04db">More...</a><br /></td></tr>
<tr class="separator:a2da8c62a81a77a136d34c0f5b7ee04db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3167f2bcae02dca2aadba469193eec"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6a3167f2bcae02dca2aadba469193eec">_mm256_min_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6a3167f2bcae02dca2aadba469193eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a6a3167f2bcae02dca2aadba469193eec">More...</a><br /></td></tr>
<tr class="separator:a6a3167f2bcae02dca2aadba469193eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96199c8df080cc2b44caf3de79afcd7a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a96199c8df080cc2b44caf3de79afcd7a">_mm256_min_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a96199c8df080cc2b44caf3de79afcd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a96199c8df080cc2b44caf3de79afcd7a">More...</a><br /></td></tr>
<tr class="separator:a96199c8df080cc2b44caf3de79afcd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa362f07383b28824491e2557d958fbbe"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aa362f07383b28824491e2557d958fbbe">_mm256_min_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:aa362f07383b28824491e2557d958fbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result.  <a href="avx2intrin_8h.html#aa362f07383b28824491e2557d958fbbe">More...</a><br /></td></tr>
<tr class="separator:aa362f07383b28824491e2557d958fbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189b0c70faa130570dc377be3841baa2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a189b0c70faa130570dc377be3841baa2">_mm256_min_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a189b0c70faa130570dc377be3841baa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#a189b0c70faa130570dc377be3841baa2">More...</a><br /></td></tr>
<tr class="separator:a189b0c70faa130570dc377be3841baa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d0653c9d79d3962498325f0a4c65a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab20d0653c9d79d3962498325f0a4c65a">_mm256_min_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ab20d0653c9d79d3962498325f0a4c65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result.  <a href="avx2intrin_8h.html#ab20d0653c9d79d3962498325f0a4c65a">More...</a><br /></td></tr>
<tr class="separator:ab20d0653c9d79d3962498325f0a4c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0a0e64386916c1945fd80f63800234"><td class="memItemLeft" align="right" valign="top">static __inline__ <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5e0a0e64386916c1945fd80f63800234">_mm256_movemask_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:a5e0a0e64386916c1945fd80f63800234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 32-bit integer mask from the most significant bit of each byte in the 256-bit integer vector in <em>__a</em> and returns the result.  <a href="avx2intrin_8h.html#a5e0a0e64386916c1945fd80f63800234">More...</a><br /></td></tr>
<tr class="separator:a5e0a0e64386916c1945fd80f63800234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1add4929d67f5823d4c81dedfa2d3903"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1add4929d67f5823d4c81dedfa2d3903">_mm256_cvtepi8_epi16</a> (__m128i __V)</td></tr>
<tr class="memdesc:a1add4929d67f5823d4c81dedfa2d3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#a1add4929d67f5823d4c81dedfa2d3903">More...</a><br /></td></tr>
<tr class="separator:a1add4929d67f5823d4c81dedfa2d3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a19f2f0881d66b9de014e6eb8ab3a9dab">_mm256_cvtepi8_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a19f2f0881d66b9de014e6eb8ab3a9dab">More...</a><br /></td></tr>
<tr class="separator:a19f2f0881d66b9de014e6eb8ab3a9dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ae14d1ebebc75eca235d1f3b8bf5d41c1">_mm256_cvtepi8_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#ae14d1ebebc75eca235d1f3b8bf5d41c1">More...</a><br /></td></tr>
<tr class="separator:ae14d1ebebc75eca235d1f3b8bf5d41c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061af1a474bed2da900b2cd81a56391c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a061af1a474bed2da900b2cd81a56391c">_mm256_cvtepi16_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a061af1a474bed2da900b2cd81a56391c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a061af1a474bed2da900b2cd81a56391c">More...</a><br /></td></tr>
<tr class="separator:a061af1a474bed2da900b2cd81a56391c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#adb8fb5be9f7b10d9d6370a9d21f27e10">_mm256_cvtepi16_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#adb8fb5be9f7b10d9d6370a9d21f27e10">More...</a><br /></td></tr>
<tr class="separator:adb8fb5be9f7b10d9d6370a9d21f27e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc0f7b9b824d94be3162eed4b231f48"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#abdc0f7b9b824d94be3162eed4b231f48">_mm256_cvtepi32_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:abdc0f7b9b824d94be3162eed4b231f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#abdc0f7b9b824d94be3162eed4b231f48">More...</a><br /></td></tr>
<tr class="separator:abdc0f7b9b824d94be3162eed4b231f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2ae0545e2a12c3e680a30c1ac531f1b9">_mm256_cvtepu8_epi16</a> (__m128i __V)</td></tr>
<tr class="memdesc:a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#a2ae0545e2a12c3e680a30c1ac531f1b9">More...</a><br /></td></tr>
<tr class="separator:a2ae0545e2a12c3e680a30c1ac531f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046fc39808a85623a1f45aed71d1e16a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a046fc39808a85623a1f45aed71d1e16a">_mm256_cvtepu8_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a046fc39808a85623a1f45aed71d1e16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a046fc39808a85623a1f45aed71d1e16a">More...</a><br /></td></tr>
<tr class="separator:a046fc39808a85623a1f45aed71d1e16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d05a1c6bfc00de679e008cf93f573f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a97d05a1c6bfc00de679e008cf93f573f">_mm256_cvtepu8_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:a97d05a1c6bfc00de679e008cf93f573f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#a97d05a1c6bfc00de679e008cf93f573f">More...</a><br /></td></tr>
<tr class="separator:a97d05a1c6bfc00de679e008cf93f573f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a7b021fb3012738fa4c6dbdfdec1e7ae0">_mm256_cvtepu16_epi32</a> (__m128i __V)</td></tr>
<tr class="memdesc:a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a7b021fb3012738fa4c6dbdfdec1e7ae0">More...</a><br /></td></tr>
<tr class="separator:a7b021fb3012738fa4c6dbdfdec1e7ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629f05b42ddb47b7b0928c0799f57e9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab629f05b42ddb47b7b0928c0799f57e9">_mm256_cvtepu16_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ab629f05b42ddb47b7b0928c0799f57e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#ab629f05b42ddb47b7b0928c0799f57e9">More...</a><br /></td></tr>
<tr class="separator:ab629f05b42ddb47b7b0928c0799f57e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad416d1dc4dc5b103142f8aae139bdf13"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad416d1dc4dc5b103142f8aae139bdf13">_mm256_cvtepu32_epi64</a> (__m128i __V)</td></tr>
<tr class="memdesc:ad416d1dc4dc5b103142f8aae139bdf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#ad416d1dc4dc5b103142f8aae139bdf13">More...</a><br /></td></tr>
<tr class="separator:ad416d1dc4dc5b103142f8aae139bdf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a21f2fd1fb0472301c6f6534fbb2c55b7">_mm256_mul_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 32-bit integers from even-numbered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result.  <a href="avx2intrin_8h.html#a21f2fd1fb0472301c6f6534fbb2c55b7">More...</a><br /></td></tr>
<tr class="separator:a21f2fd1fb0472301c6f6534fbb2c55b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b7b55f3eed342b5e4054b0625c4b13"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a53b7b55f3eed342b5e4054b0625c4b13">_mm256_mulhrs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a53b7b55f3eed342b5e4054b0625c4b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], truncates the 32-bit results to the most significant 18 bits, rounds by adding 1, and returns bits [16:1] of each rounded product in the [16 x i16] result.  <a href="avx2intrin_8h.html#a53b7b55f3eed342b5e4054b0625c4b13">More...</a><br /></td></tr>
<tr class="separator:a53b7b55f3eed342b5e4054b0625c4b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901d1db344d0637d0faedf57b68903e8"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a901d1db344d0637d0faedf57b68903e8">_mm256_mulhi_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a901d1db344d0637d0faedf57b68903e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result.  <a href="avx2intrin_8h.html#a901d1db344d0637d0faedf57b68903e8">More...</a><br /></td></tr>
<tr class="separator:a901d1db344d0637d0faedf57b68903e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bfbbc6944e651816ee6d43cad179f9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a77bfbbc6944e651816ee6d43cad179f9">_mm256_mulhi_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a77bfbbc6944e651816ee6d43cad179f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result.  <a href="avx2intrin_8h.html#a77bfbbc6944e651816ee6d43cad179f9">More...</a><br /></td></tr>
<tr class="separator:a77bfbbc6944e651816ee6d43cad179f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877a6985419ea9618d69a329cb88e9f"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab877a6985419ea9618d69a329cb88e9f">_mm256_mullo_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ab877a6985419ea9618d69a329cb88e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the lower 16 bits of each 32-bit product in the [16 x i16] result.  <a href="avx2intrin_8h.html#ab877a6985419ea9618d69a329cb88e9f">More...</a><br /></td></tr>
<tr class="separator:ab877a6985419ea9618d69a329cb88e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c6da5556cf54db6bfc7d51eaf4118b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a30c6da5556cf54db6bfc7d51eaf4118b">_mm256_mullo_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a30c6da5556cf54db6bfc7d51eaf4118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies signed 32-bit integer elements of two 256-bit vectors of [8 x i32], and returns the lower 32 bits of each 64-bit product in the [8 x i32] result.  <a href="avx2intrin_8h.html#a30c6da5556cf54db6bfc7d51eaf4118b">More...</a><br /></td></tr>
<tr class="separator:a30c6da5556cf54db6bfc7d51eaf4118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c156df6b966a0780fbf444cf05fac"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ae82c156df6b966a0780fbf444cf05fac">_mm256_mul_epu32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ae82c156df6b966a0780fbf444cf05fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies unsigned 32-bit integers from even-numered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result.  <a href="avx2intrin_8h.html#ae82c156df6b966a0780fbf444cf05fac">More...</a><br /></td></tr>
<tr class="separator:ae82c156df6b966a0780fbf444cf05fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af941fc48c1c8d082fdfac5df1953156b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af941fc48c1c8d082fdfac5df1953156b">_mm256_or_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:af941fc48c1c8d082fdfac5df1953156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise OR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <a href="avx2intrin_8h.html#af941fc48c1c8d082fdfac5df1953156b">More...</a><br /></td></tr>
<tr class="separator:af941fc48c1c8d082fdfac5df1953156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3080ecebc68a7fcfa068821af41d077"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af3080ecebc68a7fcfa068821af41d077">_mm256_sad_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:af3080ecebc68a7fcfa068821af41d077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes four sum of absolute difference (SAD) operations on sets of eight unsigned 8-bit integers from the 256-bit integer vectors <em>__a</em> and <em>__b</em>.  <a href="avx2intrin_8h.html#af3080ecebc68a7fcfa068821af41d077">More...</a><br /></td></tr>
<tr class="separator:af3080ecebc68a7fcfa068821af41d077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead06ffdd788a0be29d1e004cee07a9"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1ead06ffdd788a0be29d1e004cee07a9">_mm256_shuffle_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a1ead06ffdd788a0be29d1e004cee07a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles 8-bit integers in the 256-bit integer vector <em>__a</em> according to control information in the 256-bit integer vector <em>__b</em>, and returns the 256-bit result.  <a href="avx2intrin_8h.html#a1ead06ffdd788a0be29d1e004cee07a9">More...</a><br /></td></tr>
<tr class="separator:a1ead06ffdd788a0be29d1e004cee07a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77846fd35105eb6f2cbcef08f2b75140"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a77846fd35105eb6f2cbcef08f2b75140">_mm256_sign_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a77846fd35105eb6f2cbcef08f2b75140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each byte of the result to the corresponding byte of the 256-bit integer vector in <em>__a</em>, the negative of that byte, or zero, depending on whether the corresponding byte of the 256-bit integer vector in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <a href="avx2intrin_8h.html#a77846fd35105eb6f2cbcef08f2b75140">More...</a><br /></td></tr>
<tr class="separator:a77846fd35105eb6f2cbcef08f2b75140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cd3c3fea44760c82d99a31a8d830ba"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ae1cd3c3fea44760c82d99a31a8d830ba">_mm256_sign_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ae1cd3c3fea44760c82d99a31a8d830ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of the result to the corresponding element of the 256-bit vector of [16 x i16] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [16 x i16] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <a href="avx2intrin_8h.html#ae1cd3c3fea44760c82d99a31a8d830ba">More...</a><br /></td></tr>
<tr class="separator:ae1cd3c3fea44760c82d99a31a8d830ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67755b8ffa509f28de03a05df580fbc1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a67755b8ffa509f28de03a05df580fbc1">_mm256_sign_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a67755b8ffa509f28de03a05df580fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets each element of the result to the corresponding element of the 256-bit vector of [8 x i32] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [8 x i32] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively.  <a href="avx2intrin_8h.html#a67755b8ffa509f28de03a05df580fbc1">More...</a><br /></td></tr>
<tr class="separator:a67755b8ffa509f28de03a05df580fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9142525f9097a70a473365d4819be609"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a9142525f9097a70a473365d4819be609">_mm256_slli_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a9142525f9097a70a473365d4819be609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a9142525f9097a70a473365d4819be609">More...</a><br /></td></tr>
<tr class="separator:a9142525f9097a70a473365d4819be609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606790c952e969809a59ddf1e3510cf"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5606790c952e969809a59ddf1e3510cf">_mm256_sll_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a5606790c952e969809a59ddf1e3510cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by the number of bits specified by the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a5606790c952e969809a59ddf1e3510cf">More...</a><br /></td></tr>
<tr class="separator:a5606790c952e969809a59ddf1e3510cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8e153c8a1e0c5b909a192ccec34187"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1c8e153c8a1e0c5b909a192ccec34187">_mm256_slli_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a1c8e153c8a1e0c5b909a192ccec34187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a1c8e153c8a1e0c5b909a192ccec34187">More...</a><br /></td></tr>
<tr class="separator:a1c8e153c8a1e0c5b909a192ccec34187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff83b0c5ed8e28733927ba2ab93296"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a0bff83b0c5ed8e28733927ba2ab93296">_mm256_sll_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a0bff83b0c5ed8e28733927ba2ab93296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a0bff83b0c5ed8e28733927ba2ab93296">More...</a><br /></td></tr>
<tr class="separator:a0bff83b0c5ed8e28733927ba2ab93296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e1a7a9fd378072b072fbc369db480"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad40e1a7a9fd378072b072fbc369db480">_mm256_slli_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:ad40e1a7a9fd378072b072fbc369db480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#ad40e1a7a9fd378072b072fbc369db480">More...</a><br /></td></tr>
<tr class="separator:ad40e1a7a9fd378072b072fbc369db480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160466de250277c0621a1914f45cc2a2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a160466de250277c0621a1914f45cc2a2">_mm256_sll_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a160466de250277c0621a1914f45cc2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a160466de250277c0621a1914f45cc2a2">More...</a><br /></td></tr>
<tr class="separator:a160466de250277c0621a1914f45cc2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9640e28a301bd54f3c6eba51e91180"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#abb9640e28a301bd54f3c6eba51e91180">_mm256_srai_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:abb9640e28a301bd54f3c6eba51e91180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#abb9640e28a301bd54f3c6eba51e91180">More...</a><br /></td></tr>
<tr class="separator:abb9640e28a301bd54f3c6eba51e91180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6812ecb21f05132dbb5ce31ed82aabe"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad6812ecb21f05132dbb5ce31ed82aabe">_mm256_sra_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:ad6812ecb21f05132dbb5ce31ed82aabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#ad6812ecb21f05132dbb5ce31ed82aabe">More...</a><br /></td></tr>
<tr class="separator:ad6812ecb21f05132dbb5ce31ed82aabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b64b22d24b260ffb9a7018b1f8cca"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a241b64b22d24b260ffb9a7018b1f8cca">_mm256_srai_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a241b64b22d24b260ffb9a7018b1f8cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#a241b64b22d24b260ffb9a7018b1f8cca">More...</a><br /></td></tr>
<tr class="separator:a241b64b22d24b260ffb9a7018b1f8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b5cc7264b4572e61702aa385250c6"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a933b5cc7264b4572e61702aa385250c6">_mm256_sra_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a933b5cc7264b4572e61702aa385250c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#a933b5cc7264b4572e61702aa385250c6">More...</a><br /></td></tr>
<tr class="separator:a933b5cc7264b4572e61702aa385250c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#afdd37fdb3fd0ebf8b12261a4c5eb325e">_mm256_srli_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#afdd37fdb3fd0ebf8b12261a4c5eb325e">More...</a><br /></td></tr>
<tr class="separator:afdd37fdb3fd0ebf8b12261a4c5eb325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0204190987d295602363fac8e957bc88"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a0204190987d295602363fac8e957bc88">_mm256_srl_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a0204190987d295602363fac8e957bc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a0204190987d295602363fac8e957bc88">More...</a><br /></td></tr>
<tr class="separator:a0204190987d295602363fac8e957bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa577e01c74cd9071fb09c857fad1c2"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#acfa577e01c74cd9071fb09c857fad1c2">_mm256_srli_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:acfa577e01c74cd9071fb09c857fad1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#acfa577e01c74cd9071fb09c857fad1c2">More...</a><br /></td></tr>
<tr class="separator:acfa577e01c74cd9071fb09c857fad1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006440af4ed63245caff87056b25c3d1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a006440af4ed63245caff87056b25c3d1">_mm256_srl_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:a006440af4ed63245caff87056b25c3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a006440af4ed63245caff87056b25c3d1">More...</a><br /></td></tr>
<tr class="separator:a006440af4ed63245caff87056b25c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ca9a97310214d3f0e85302dd877dc5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a00ca9a97310214d3f0e85302dd877dc5">_mm256_srli_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> __count)</td></tr>
<tr class="memdesc:a00ca9a97310214d3f0e85302dd877dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a00ca9a97310214d3f0e85302dd877dc5">More...</a><br /></td></tr>
<tr class="separator:a00ca9a97310214d3f0e85302dd877dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf26700184b5a83da79aca8f9ade7fc3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#acf26700184b5a83da79aca8f9ade7fc3">_mm256_srl_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m128i __count)</td></tr>
<tr class="memdesc:acf26700184b5a83da79aca8f9ade7fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#acf26700184b5a83da79aca8f9ade7fc3">More...</a><br /></td></tr>
<tr class="separator:acf26700184b5a83da79aca8f9ade7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8fbe41f0f99a6839f3c4a5d4d992ca2a">_mm256_sub_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors.  <a href="avx2intrin_8h.html#a8fbe41f0f99a6839f3c4a5d4d992ca2a">More...</a><br /></td></tr>
<tr class="separator:a8fbe41f0f99a6839f3c4a5d4d992ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e2c682612c87d32af88011175c7893"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a31e2c682612c87d32af88011175c7893">_mm256_sub_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a31e2c682612c87d32af88011175c7893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16].  <a href="avx2intrin_8h.html#a31e2c682612c87d32af88011175c7893">More...</a><br /></td></tr>
<tr class="separator:a31e2c682612c87d32af88011175c7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab606b56493b9e67d5aa9413c66bd27cd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab606b56493b9e67d5aa9413c66bd27cd">_mm256_sub_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ab606b56493b9e67d5aa9413c66bd27cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32].  <a href="avx2intrin_8h.html#ab606b56493b9e67d5aa9413c66bd27cd">More...</a><br /></td></tr>
<tr class="separator:ab606b56493b9e67d5aa9413c66bd27cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3b4f41e586cb7b8643ffdee43f3a6ce6">_mm256_sub_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64].  <a href="avx2intrin_8h.html#a3b4f41e586cb7b8643ffdee43f3a6ce6">More...</a><br /></td></tr>
<tr class="separator:a3b4f41e586cb7b8643ffdee43f3a6ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a78b79f3e386367de719217e8b9b1"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5e9a78b79f3e386367de719217e8b9b1">_mm256_subs_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a5e9a78b79f3e386367de719217e8b9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each differences in the corresponding byte of the 256-bit integer vector result.  <a href="avx2intrin_8h.html#a5e9a78b79f3e386367de719217e8b9b1">More...</a><br /></td></tr>
<tr class="separator:a5e9a78b79f3e386367de719217e8b9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac62e43e232e2fe74019c3839e22d0ea"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aac62e43e232e2fe74019c3839e22d0ea">_mm256_subs_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:aac62e43e232e2fe74019c3839e22d0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns each difference in the corresponding element of the [16 x i16] result.  <a href="avx2intrin_8h.html#aac62e43e232e2fe74019c3839e22d0ea">More...</a><br /></td></tr>
<tr class="separator:aac62e43e232e2fe74019c3839e22d0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8efc1fee79411d45f2094d6a5bd6b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2af8efc1fee79411d45f2094d6a5bd6b">_mm256_subs_epu8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a2af8efc1fee79411d45f2094d6a5bd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each difference in the corresponding byte of the 256-bit integer vector result.  <a href="avx2intrin_8h.html#a2af8efc1fee79411d45f2094d6a5bd6b">More...</a><br /></td></tr>
<tr class="separator:a2af8efc1fee79411d45f2094d6a5bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2bf28cc66f89d73790bcaed2e6e502"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#afd2bf28cc66f89d73790bcaed2e6e502">_mm256_subs_epu16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:afd2bf28cc66f89d73790bcaed2e6e502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns each difference in the corresponding element of the [16 x i16] result.  <a href="avx2intrin_8h.html#afd2bf28cc66f89d73790bcaed2e6e502">More...</a><br /></td></tr>
<tr class="separator:afd2bf28cc66f89d73790bcaed2e6e502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4358789fa27173bf6e2d7b10c73418fd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4358789fa27173bf6e2d7b10c73418fd">_mm256_unpackhi_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a4358789fa27173bf6e2d7b10c73418fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result.  <a href="avx2intrin_8h.html#a4358789fa27173bf6e2d7b10c73418fd">More...</a><br /></td></tr>
<tr class="separator:a4358789fa27173bf6e2d7b10c73418fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb3e33051c22956a29e267c841ce2c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a76bb3e33051c22956a29e267c841ce2c">_mm256_unpackhi_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a76bb3e33051c22956a29e267c841ce2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#a76bb3e33051c22956a29e267c841ce2c">More...</a><br /></td></tr>
<tr class="separator:a76bb3e33051c22956a29e267c841ce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4d291187e5354e99a80fa31e0a2599"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a6d4d291187e5354e99a80fa31e0a2599">_mm256_unpackhi_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a6d4d291187e5354e99a80fa31e0a2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a6d4d291187e5354e99a80fa31e0a2599">More...</a><br /></td></tr>
<tr class="separator:a6d4d291187e5354e99a80fa31e0a2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53f37866e6d12b621cd8dd638dcfe49"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ac53f37866e6d12b621cd8dd638dcfe49">_mm256_unpackhi_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:ac53f37866e6d12b621cd8dd638dcfe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#ac53f37866e6d12b621cd8dd638dcfe49">More...</a><br /></td></tr>
<tr class="separator:ac53f37866e6d12b621cd8dd638dcfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1606df7412921d94f00a69091b79fd"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aac1606df7412921d94f00a69091b79fd">_mm256_unpacklo_epi8</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:aac1606df7412921d94f00a69091b79fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result.  <a href="avx2intrin_8h.html#aac1606df7412921d94f00a69091b79fd">More...</a><br /></td></tr>
<tr class="separator:aac1606df7412921d94f00a69091b79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29f2b775e0c3d34958e970252c37c0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#abc29f2b775e0c3d34958e970252c37c0">_mm256_unpacklo_epi16</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:abc29f2b775e0c3d34958e970252c37c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#abc29f2b775e0c3d34958e970252c37c0">More...</a><br /></td></tr>
<tr class="separator:abc29f2b775e0c3d34958e970252c37c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48355543080a7cbf1fcc3d38c8636b3d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a48355543080a7cbf1fcc3d38c8636b3d">_mm256_unpacklo_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a48355543080a7cbf1fcc3d38c8636b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#a48355543080a7cbf1fcc3d38c8636b3d">More...</a><br /></td></tr>
<tr class="separator:a48355543080a7cbf1fcc3d38c8636b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d22290d67e283811757c56bf20ab0f4"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a0d22290d67e283811757c56bf20ab0f4">_mm256_unpacklo_epi64</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a0d22290d67e283811757c56bf20ab0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#a0d22290d67e283811757c56bf20ab0f4">More...</a><br /></td></tr>
<tr class="separator:a0d22290d67e283811757c56bf20ab0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb76d9ee538f1556ce95a0a309224da"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5cb76d9ee538f1556ce95a0a309224da">_mm256_xor_si256</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a5cb76d9ee538f1556ce95a0a309224da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bitwise XOR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>.  <a href="avx2intrin_8h.html#a5cb76d9ee538f1556ce95a0a309224da">More...</a><br /></td></tr>
<tr class="separator:a5cb76d9ee538f1556ce95a0a309224da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062648ed7516d4b7f9304d8a66947877"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a062648ed7516d4b7f9304d8a66947877">_mm256_stream_load_si256</a> (const void *__V)</td></tr>
<tr class="memdesc:a062648ed7516d4b7f9304d8a66947877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the 256-bit integer vector from memory <em>__V</em> using a non-temporal memory hint and returns the vector.  <a href="avx2intrin_8h.html#a062648ed7516d4b7f9304d8a66947877">More...</a><br /></td></tr>
<tr class="separator:a062648ed7516d4b7f9304d8a66947877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7636713aae00b362d71015a3f444d079"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128 <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a7636713aae00b362d71015a3f444d079">_mm_broadcastss_ps</a> (__m128 __X)</td></tr>
<tr class="memdesc:a7636713aae00b362d71015a3f444d079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 128-bit vector of [4 x float].  <a href="avx2intrin_8h.html#a7636713aae00b362d71015a3f444d079">More...</a><br /></td></tr>
<tr class="separator:a7636713aae00b362d71015a3f444d079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128d <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a9aed0394b1e2f9ff4a0a8099637dd3d3">_mm_broadcastsd_pd</a> (__m128d <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>)</td></tr>
<tr class="memdesc:a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__a</em> to both elements of the result's 128-bit vector of [2 x double].  <a href="avx2intrin_8h.html#a9aed0394b1e2f9ff4a0a8099637dd3d3">More...</a><br /></td></tr>
<tr class="separator:a9aed0394b1e2f9ff4a0a8099637dd3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5947990d7f735029f6d858c99e76ee0"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256 <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#af5947990d7f735029f6d858c99e76ee0">_mm256_broadcastss_ps</a> (__m128 __X)</td></tr>
<tr class="memdesc:af5947990d7f735029f6d858c99e76ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x float].  <a href="avx2intrin_8h.html#af5947990d7f735029f6d858c99e76ee0">More...</a><br /></td></tr>
<tr class="separator:af5947990d7f735029f6d858c99e76ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bea69dd9bbf4de7be8b17aa32918268"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256d <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5bea69dd9bbf4de7be8b17aa32918268">_mm256_broadcastsd_pd</a> (__m128d __X)</td></tr>
<tr class="memdesc:a5bea69dd9bbf4de7be8b17aa32918268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x double].  <a href="avx2intrin_8h.html#a5bea69dd9bbf4de7be8b17aa32918268">More...</a><br /></td></tr>
<tr class="separator:a5bea69dd9bbf4de7be8b17aa32918268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7018cff60b93116947e57eea1f1c63"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a> (__m128i __X)</td></tr>
<tr class="memdesc:a4f7018cff60b93116947e57eea1f1c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the 128-bit integer data from <em>__X</em> to both the lower and upper halves of the 256-bit result.  <a href="avx2intrin_8h.html#a4f7018cff60b93116947e57eea1f1c63">More...</a><br /></td></tr>
<tr class="separator:a4f7018cff60b93116947e57eea1f1c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b65c7f74b80298dd753b067bb5ba42"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a75b65c7f74b80298dd753b067bb5ba42">_mm256_broadcastb_epi8</a> (__m128i __X)</td></tr>
<tr class="memdesc:a75b65c7f74b80298dd753b067bb5ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 256-bit result.  <a href="avx2intrin_8h.html#a75b65c7f74b80298dd753b067bb5ba42">More...</a><br /></td></tr>
<tr class="separator:a75b65c7f74b80298dd753b067bb5ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f81e03d536bf939f44b377b365f102"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ab7f81e03d536bf939f44b377b365f102">_mm256_broadcastw_epi16</a> (__m128i __X)</td></tr>
<tr class="memdesc:ab7f81e03d536bf939f44b377b365f102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 256-bit vector of [16 x i16].  <a href="avx2intrin_8h.html#ab7f81e03d536bf939f44b377b365f102">More...</a><br /></td></tr>
<tr class="separator:ab7f81e03d536bf939f44b377b365f102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ad902bf9f90ecbfc92a4ad3fd87b9ceb3">_mm256_broadcastd_epi32</a> (__m128i __X)</td></tr>
<tr class="memdesc:ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x i32].  <a href="avx2intrin_8h.html#ad902bf9f90ecbfc92a4ad3fd87b9ceb3">More...</a><br /></td></tr>
<tr class="separator:ad902bf9f90ecbfc92a4ad3fd87b9ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd93adcfd69f94269bd751d664199481"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#afd93adcfd69f94269bd751d664199481">_mm256_broadcastq_epi64</a> (__m128i __X)</td></tr>
<tr class="memdesc:afd93adcfd69f94269bd751d664199481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x i64].  <a href="avx2intrin_8h.html#afd93adcfd69f94269bd751d664199481">More...</a><br /></td></tr>
<tr class="separator:afd93adcfd69f94269bd751d664199481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719f57e8449edf0a868707685fcbfba"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a2719f57e8449edf0a868707685fcbfba">_mm_broadcastb_epi8</a> (__m128i __X)</td></tr>
<tr class="memdesc:a2719f57e8449edf0a868707685fcbfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 128-bit result.  <a href="avx2intrin_8h.html#a2719f57e8449edf0a868707685fcbfba">More...</a><br /></td></tr>
<tr class="separator:a2719f57e8449edf0a868707685fcbfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b5e9e77ac8e5f7f639806936c7113"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a865b5e9e77ac8e5f7f639806936c7113">_mm_broadcastw_epi16</a> (__m128i __X)</td></tr>
<tr class="memdesc:a865b5e9e77ac8e5f7f639806936c7113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 128-bit vector of [8 x i16].  <a href="avx2intrin_8h.html#a865b5e9e77ac8e5f7f639806936c7113">More...</a><br /></td></tr>
<tr class="separator:a865b5e9e77ac8e5f7f639806936c7113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f391075669a7b417e83af174398a9b"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a10f391075669a7b417e83af174398a9b">_mm_broadcastd_epi32</a> (__m128i __X)</td></tr>
<tr class="memdesc:a10f391075669a7b417e83af174398a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's vector of [4 x i32].  <a href="avx2intrin_8h.html#a10f391075669a7b417e83af174398a9b">More...</a><br /></td></tr>
<tr class="separator:a10f391075669a7b417e83af174398a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace283494a6faf8c26cb5553c007a78ef"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#ace283494a6faf8c26cb5553c007a78ef">_mm_broadcastq_epi64</a> (__m128i __X)</td></tr>
<tr class="memdesc:ace283494a6faf8c26cb5553c007a78ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to both elements of the result's 128-bit vector of [2 x i64].  <a href="avx2intrin_8h.html#ace283494a6faf8c26cb5553c007a78ef">More...</a><br /></td></tr>
<tr class="separator:ace283494a6faf8c26cb5553c007a78ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9bff425325a7c8e2a4f857e3d0b22"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a33d9bff425325a7c8e2a4f857e3d0b22">_mm256_permutevar8x32_epi32</a> (__m256i <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a33d9bff425325a7c8e2a4f857e3d0b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [8 x i32] to copies of elements of the 256-bit vector of [8 x i32] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>.  <a href="avx2intrin_8h.html#a33d9bff425325a7c8e2a4f857e3d0b22">More...</a><br /></td></tr>
<tr class="separator:a33d9bff425325a7c8e2a4f857e3d0b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4284aa3d71d30c3241c1ea550f4429"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256 <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5c4284aa3d71d30c3241c1ea550f4429">_mm256_permutevar8x32_ps</a> (__m256 <a class="el" href="emmintrin_8h.html#a621c56fb063f5d6c7f0d06aa3326e239">__a</a>, __m256i <a class="el" href="wasm__simd128_8h.html#a4b6053e8dd8c03982ecf6be4e84c1561">__b</a>)</td></tr>
<tr class="memdesc:a5c4284aa3d71d30c3241c1ea550f4429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the result's 256-bit vector of [8 x float] to copies of elements of the 256-bit vector of [8 x float] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>.  <a href="avx2intrin_8h.html#a5c4284aa3d71d30c3241c1ea550f4429">More...</a><br /></td></tr>
<tr class="separator:a5c4284aa3d71d30c3241c1ea550f4429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fd743b1c2f9aed720704b10114e42c"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a22fd743b1c2f9aed720704b10114e42c">_mm256_maskload_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *__X, __m256i __M)</td></tr>
<tr class="memdesc:a22fd743b1c2f9aed720704b10114e42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads eight 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <a href="avx2intrin_8h.html#a22fd743b1c2f9aed720704b10114e42c">More...</a><br /></td></tr>
<tr class="separator:a22fd743b1c2f9aed720704b10114e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1997e59ad47611e448defb72da464056"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1997e59ad47611e448defb72da464056">_mm256_maskload_epi64</a> (long long const *__X, __m256i __M)</td></tr>
<tr class="memdesc:a1997e59ad47611e448defb72da464056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads four 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <a href="avx2intrin_8h.html#a1997e59ad47611e448defb72da464056">More...</a><br /></td></tr>
<tr class="separator:a1997e59ad47611e448defb72da464056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694947e72cdcd91cace9252259d8cc9e"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a694947e72cdcd91cace9252259d8cc9e">_mm_maskload_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *__X, __m128i __M)</td></tr>
<tr class="memdesc:a694947e72cdcd91cace9252259d8cc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads four 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <a href="avx2intrin_8h.html#a694947e72cdcd91cace9252259d8cc9e">More...</a><br /></td></tr>
<tr class="separator:a694947e72cdcd91cace9252259d8cc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51c2e90947a2569e048166b39e4495"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#adf51c2e90947a2569e048166b39e4495">_mm_maskload_epi64</a> (long long const *__X, __m128i __M)</td></tr>
<tr class="memdesc:adf51c2e90947a2569e048166b39e4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally loads two 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero.  <a href="avx2intrin_8h.html#adf51c2e90947a2569e048166b39e4495">More...</a><br /></td></tr>
<tr class="separator:adf51c2e90947a2569e048166b39e4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf351469e97da264116eea7952c2aba"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a1bf351469e97da264116eea7952c2aba">_mm256_maskstore_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *__X, __m256i __M, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a1bf351469e97da264116eea7952c2aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores eight 32-bit integer elements from the 256-bit vector of [8 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <a href="avx2intrin_8h.html#a1bf351469e97da264116eea7952c2aba">More...</a><br /></td></tr>
<tr class="separator:a1bf351469e97da264116eea7952c2aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0559634edb55b319e7ee19baac957c95"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a0559634edb55b319e7ee19baac957c95">_mm256_maskstore_epi64</a> (long long *__X, __m256i __M, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a0559634edb55b319e7ee19baac957c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores four 64-bit integer elements from the 256-bit vector of [4 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <a href="avx2intrin_8h.html#a0559634edb55b319e7ee19baac957c95">More...</a><br /></td></tr>
<tr class="separator:a0559634edb55b319e7ee19baac957c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d960541afa801cef10bec77aac5e258"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a8d960541afa801cef10bec77aac5e258">_mm_maskstore_epi32</a> (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *__X, __m128i __M, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a8d960541afa801cef10bec77aac5e258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores four 32-bit integer elements from the 128-bit vector of [4 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <a href="avx2intrin_8h.html#a8d960541afa801cef10bec77aac5e258">More...</a><br /></td></tr>
<tr class="separator:a8d960541afa801cef10bec77aac5e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582da479a1ada35c7316c4deab34adfd"><td class="memItemLeft" align="right" valign="top">static __inline__ void <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a582da479a1ada35c7316c4deab34adfd">_mm_maskstore_epi64</a> (long long *__X, __m128i __M, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a582da479a1ada35c7316c4deab34adfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally stores two 64-bit integer elements from the 128-bit vector of [2 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged.  <a href="avx2intrin_8h.html#a582da479a1ada35c7316c4deab34adfd">More...</a><br /></td></tr>
<tr class="separator:a582da479a1ada35c7316c4deab34adfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8eebf24183f66e3cd905501948068"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a71d8eebf24183f66e3cd905501948068">_mm256_sllv_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a71d8eebf24183f66e3cd905501948068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a71d8eebf24183f66e3cd905501948068">More...</a><br /></td></tr>
<tr class="separator:a71d8eebf24183f66e3cd905501948068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699470176eaef166e2a71c026aa85cfc"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a699470176eaef166e2a71c026aa85cfc">_mm_sllv_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a699470176eaef166e2a71c026aa85cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a699470176eaef166e2a71c026aa85cfc">More...</a><br /></td></tr>
<tr class="separator:a699470176eaef166e2a71c026aa85cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d328c38377911cc60da2a7c6d5363f5"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a3d328c38377911cc60da2a7c6d5363f5">_mm256_sllv_epi64</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a3d328c38377911cc60da2a7c6d5363f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a3d328c38377911cc60da2a7c6d5363f5">More...</a><br /></td></tr>
<tr class="separator:a3d328c38377911cc60da2a7c6d5363f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec60ec05d6c5e57a8cce91a77f75603d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#aec60ec05d6c5e57a8cce91a77f75603d">_mm_sllv_epi64</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:aec60ec05d6c5e57a8cce91a77f75603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#aec60ec05d6c5e57a8cce91a77f75603d">More...</a><br /></td></tr>
<tr class="separator:aec60ec05d6c5e57a8cce91a77f75603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58df154a23884308de2be8f1673431bb"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a58df154a23884308de2be8f1673431bb">_mm256_srav_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a58df154a23884308de2be8f1673431bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#a58df154a23884308de2be8f1673431bb">More...</a><br /></td></tr>
<tr class="separator:a58df154a23884308de2be8f1673431bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac7327486a0d44f7f4154ac337bb85"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a95ac7327486a0d44f7f4154ac337bb85">_mm_srav_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a95ac7327486a0d44f7f4154ac337bb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result.  <a href="avx2intrin_8h.html#a95ac7327486a0d44f7f4154ac337bb85">More...</a><br /></td></tr>
<tr class="separator:a95ac7327486a0d44f7f4154ac337bb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a9cc3e0a1a4e2bbbc72630cf26ed54225">_mm256_srlv_epi32</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a9cc3e0a1a4e2bbbc72630cf26ed54225">More...</a><br /></td></tr>
<tr class="separator:a9cc3e0a1a4e2bbbc72630cf26ed54225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb295f9dbef670b0a134d834e5f279a"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a5eb295f9dbef670b0a134d834e5f279a">_mm_srlv_epi32</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a5eb295f9dbef670b0a134d834e5f279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a5eb295f9dbef670b0a134d834e5f279a">More...</a><br /></td></tr>
<tr class="separator:a5eb295f9dbef670b0a134d834e5f279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77501391ed2c52d990a2c4004e86c36d"><td class="memItemLeft" align="right" valign="top">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a77501391ed2c52d990a2c4004e86c36d">_mm256_srlv_epi64</a> (__m256i __X, __m256i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a77501391ed2c52d990a2c4004e86c36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a77501391ed2c52d990a2c4004e86c36d">More...</a><br /></td></tr>
<tr class="separator:a77501391ed2c52d990a2c4004e86c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619b2e23f9247af334811e4b6ec75f40"><td class="memItemLeft" align="right" valign="top">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avx2intrin_8h.html#a619b2e23f9247af334811e4b6ec75f40">_mm_srlv_epi64</a> (__m128i __X, __m128i <a class="el" href="ppc__wrappers_2bmiintrin_8h.html#ae62cdb2dece5581a4b02ba1b04bcb9dc">__Y</a>)</td></tr>
<tr class="memdesc:a619b2e23f9247af334811e4b6ec75f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result.  <a href="avx2intrin_8h.html#a619b2e23f9247af334811e4b6ec75f40">More...</a><br /></td></tr>
<tr class="separator:a619b2e23f9247af334811e4b6ec75f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa5269551cf777adb9ce7ae4726145df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5269551cf777adb9ce7ae4726145df2">&#9670;&nbsp;</a></span>__DEFAULT_FN_ATTRS128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __DEFAULT_FN_ATTRS128</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__,                               \</div>
<div class="line">                 __target__(<span class="stringliteral">&quot;avx2,no-evex512&quot;</span>), __min_vector_width__(128)))</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a3da0931a820e46f95754b07f9b413d58"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a></div><div class="ttdeci">_Float16 __2f16 __attribute__((ext_vector_type(2)))</div><div class="ttdoc">Zeroes the upper 128 bits (bits 255:128) of all YMM registers.</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00293">__clang_hip_libdevice_declares.h:293</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00021">21</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a9c3364b71a7fe0439ba73567fc303fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3364b71a7fe0439ba73567fc303fcc">&#9670;&nbsp;</a></span>__DEFAULT_FN_ATTRS256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __DEFAULT_FN_ATTRS256</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__always_inline__, __nodebug__,                               \</div>
<div class="line">                 __target__(<span class="stringliteral">&quot;avx2,no-evex512&quot;</span>), __min_vector_width__(256)))</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00018">18</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8fe3521900e672c4655149ced8682d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe3521900e672c4655149ced8682d05">&#9670;&nbsp;</a></span>_mm256_alignr_epi8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_alignr_epi8</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_palignr256((__v32qi)(__m256i)(a), \</div>
<div class="line">                                      (__v32qi)(__m256i)(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>), (n)))</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a373e9fc646873cd20f2c9fdb7125a207"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div><div class="ttdeci">__device__ __2f16 b</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00303">__clang_hip_libdevice_declares.h:303</a></div></div>
</div><!-- fragment -->
<p>Uses the lower half of the 256-bit vector <em>a</em> as the upper half of a temporary 256-bit value, and the lower half of the 256-bit vector <em>b</em> as the lower half of the temporary value. </p>
<p>Right-shifts the temporary value by <em>n</em> bytes, and uses the lower 16 bytes of the shifted value as the lower 16 bytes of the result. Uses the upper halves of <em>a</em> and <em>b</em> to make another temporary value, right shifts by <em>n</em>, and uses the lower 16 bytes of the shifted value as the upper 16 bytes of the result.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a>(__m256i a, __m256i <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> n);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8fe3521900e672c4655149ced8682d05"><div class="ttname"><a href="avx2intrin_8h.html#a8fe3521900e672c4655149ced8682d05">_mm256_alignr_epi8</a></div><div class="ttdeci">#define _mm256_alignr_epi8(a, b, n)</div><div class="ttdoc">Uses the lower half of the 256-bit vector a as the upper half of a temporary 256-bit value,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l00438">avx2intrin.h:438</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPALIGNR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">b</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">n</td><td>An immediate value specifying the number of bytes to shift. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00438">438</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad018a82854ddb7a5c81d00ea72140972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad018a82854ddb7a5c81d00ea72140972">&#9670;&nbsp;</a></span>_mm256_blend_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_blend_epi16</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pblendw256((__v16hi)(__m256i)(V1), \</div>
<div class="line">                                      (__v16hi)(__m256i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 16-bit integer values from either of the two 256-bit vectors <em>V1</em> or <em>V2</em>, as specified by the immediate integer operand <em>M</em>, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[7+j:j] := V1[7+j:j]</div>
<div class="line">    result[135+j:128+j] := V1[135+j:128+j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[7+j:j] := V2[7+j:j]</div>
<div class="line">    result[135+j:128+j] := V2[135+j:128+j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad018a82854ddb7a5c81d00ea72140972"><div class="ttname"><a href="avx2intrin_8h.html#ad018a82854ddb7a5c81d00ea72140972">_mm256_blend_epi16</a></div><div class="ttdeci">#define _mm256_blend_epi16(V1, V2, M)</div><div class="ttdoc">Merges 16-bit integer values from either of the two 256-bit vectors V1 or V2, as specified by the imm...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l00603">avx2intrin.h:603</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [7:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is copied from <em>V2</em>. <em>M</em>[0] determines the source for elements 0 and 8, <em>M</em>[1] for elements 1 and 9, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00603">603</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a5f8fd952a7c88dfb5b9437f0cd94b9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fd952a7c88dfb5b9437f0cd94b9db">&#9670;&nbsp;</a></span>_mm256_blend_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_blend_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_pblendd256((__v8si)(__m256i)(V1), \</div>
<div class="line">                                      (__v8si)(__m256i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in <em>V1</em> or <em>V2</em> to return a 256-bit vector of [8 x i32], as specified by the immediate integer operand <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[31+j:j] := V1[31+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[31+j:j] := V2[32+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a5f8fd952a7c88dfb5b9437f0cd94b9db"><div class="ttname"><a href="avx2intrin_8h.html#a5f8fd952a7c88dfb5b9437f0cd94b9db">_mm256_blend_epi32</a></div><div class="ttdeci">#define _mm256_blend_epi32(V1, V2, M)</div><div class="ttdoc">Merges 32-bit integer elements from either of the two 256-bit vectors of [8 x i32] in V1 or V2 to ret...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03148">avx2intrin.h:3148</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [7:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is is copied from <em>V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03148">3148</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a0adabedfb750d899e60f3685b434c6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adabedfb750d899e60f3685b434c6ad">&#9670;&nbsp;</a></span>_mm256_bslli_epi128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_bslli_epi128</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a0adabedfb750d899e60f3685b434c6ad"><div class="ttname"><a href="avx2intrin_8h.html#a0adabedfb750d899e60f3685b434c6ad">_mm256_bslli_epi128</a></div><div class="ttdeci">#define _mm256_bslli_epi128(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector a left by imm bytes, shifting in zero bytes,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l02112">avx2intrin.h:2112</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSLLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02112">2112</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="acf654837b8bfee81dbdcae53b79e7961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf654837b8bfee81dbdcae53b79e7961">&#9670;&nbsp;</a></span>_mm256_bsrli_epi128</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_bsrli_epi128</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_acf654837b8bfee81dbdcae53b79e7961"><div class="ttname"><a href="avx2intrin_8h.html#acf654837b8bfee81dbdcae53b79e7961">_mm256_bsrli_epi128</a></div><div class="ttdeci">#define _mm256_bsrli_epi128(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector in a right by imm bytes, shifting in zero byte...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l02356">avx2intrin.h:2356</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSRLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02356">2356</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aad58b51492bbbb175bcafd021585d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad58b51492bbbb175bcafd021585d930">&#9670;&nbsp;</a></span>_mm256_extracti128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_extracti128_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m128i)__builtin_ia32_extract128i256((__v4di)(__m256i)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts half of the 256-bit vector <em>V</em> to the 128-bit result. </p>
<p>If bit 0 of the immediate <em>M</em> is zero, extracts the lower half of the result; otherwise, extracts the upper half.</p>
<div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a>(__m256i <a class="code" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aASTContext_8h_html_ab1457e11becd51c5d0c750caab5446c2"><div class="ttname"><a href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></div><div class="ttdeci">#define V(N, I)</div><div class="ttdef"><b>Definition:</b> <a href="ASTContext_8h_source.html#l03278">ASTContext.h:3278</a></div></div>
<div class="ttc" id="aavx2intrin_8h_html_aad58b51492bbbb175bcafd021585d930"><div class="ttname"><a href="avx2intrin_8h.html#aad58b51492bbbb175bcafd021585d930">_mm256_extracti128_si256</a></div><div class="ttdeci">#define _mm256_extracti128_si256(V, M)</div><div class="ttdoc">Extracts half of the 256-bit vector V to the 128-bit result.</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03459">avx2intrin.h:3459</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VEXTRACTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit integer vector containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying which half of <em>V</em> to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03459">3459</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad1267ffda36b2c13484b36a209e37792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1267ffda36b2c13484b36a209e37792">&#9670;&nbsp;</a></span>_mm256_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_d256((__v8si)<a class="code" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8si)<a class="code" href="avxintrin_8h.html#af4aae99a61d0c026b106cf4550691dca">_mm256_set1_epi32</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa9513b8e157e945e0f9eb68bf6e7e7d7"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></div><div class="ttdeci">__device__ __2f16 float __ockl_bool s</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00304">__clang_hip_libdevice_declares.h:304</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a5d03860407459337bbfbc277face762b"><div class="ttname"><a href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a></div><div class="ttdeci">static __inline__ __m256i __DEFAULT_FN_ATTRS _mm256_undefined_si256(void)</div><div class="ttdoc">Create a 256-bit integer vector with undefined values.</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l03666">avxintrin.h:3666</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_af4aae99a61d0c026b106cf4550691dca"><div class="ttname"><a href="avxintrin_8h.html#af4aae99a61d0c026b106cf4550691dca">_mm256_set1_epi32</a></div><div class="ttdeci">static __inline __m256i __DEFAULT_FN_ATTRS _mm256_set1_epi32(int __i)</div><div class="ttdoc">Constructs a 256-bit integer vector of [8 x i32], with each of the 32-bit integral vector elements se...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l04254">avxintrin.h:4254</a></div></div>
</div><!-- fragment -->
<p>Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad1267ffda36b2c13484b36a209e37792"><div class="ttname"><a href="avx2intrin_8h.html#ad1267ffda36b2c13484b36a209e37792">_mm256_i32gather_epi32</a></div><div class="ttdeci">#define _mm256_i32gather_epi32(m, i, s)</div><div class="ttdoc">Gathers eight 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05077">avx2intrin.h:5077</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05077">5077</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a16861b116c0624454372064f910c4f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16861b116c0624454372064f910c4f80">&#9670;&nbsp;</a></span>_mm256_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_q256((__v4di)<a class="code" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4si)(__m128i)(i), \</div>
<div class="line">                                        (__v4di)<a class="code" href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a62a0e00da40e99bd0112ab77186984cf"><div class="ttname"><a href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a></div><div class="ttdeci">static __inline __m256i __DEFAULT_FN_ATTRS _mm256_set1_epi64x(long long __q)</div><div class="ttdoc">Constructs a 256-bit integer vector of [4 x i64], with each of the 64-bit integral vector elements se...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l04311">avxintrin.h:4311</a></div></div>
</div><!-- fragment -->
<p>Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a16861b116c0624454372064f910c4f80"><div class="ttname"><a href="avx2intrin_8h.html#a16861b116c0624454372064f910c4f80">_mm256_i32gather_epi64</a></div><div class="ttdeci">#define _mm256_i32gather_epi64(m, i, s)</div><div class="ttdoc">Gathers four 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [4 x...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05209">avx2intrin.h:5209</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05209">5209</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a80044451f05309770ce2bf171dbfa0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80044451f05309770ce2bf171dbfa0be">&#9670;&nbsp;</a></span>_mm256_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherd_pd256((__v4df)<a class="code" href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a>(), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4si)(__m128i)(i), \</div>
<div class="line">                                         (__v4df)<a class="code" href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a>(<a class="code" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code" href="xmmintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                         (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a483d5f7ab8caca878e4be157e3d07f62"><div class="ttname"><a href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a></div><div class="ttdeci">static __inline__ __m256d __DEFAULT_FN_ATTRS _mm256_undefined_pd(void)</div><div class="ttdoc">Create a 256-bit vector of [4 x double] with undefined values.</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l03640">avxintrin.h:3640</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a65f0cd8e0a33a987b052a60b03249077"><div class="ttname"><a href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a></div><div class="ttdeci">#define _mm256_cmp_pd(a, b, c)</div><div class="ttdoc">Compares each of the corresponding double-precision values of two 256-bit vectors of [4 x double],...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l01785">avxintrin.h:1785</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_aac4a2ce03fb26132483fae2f6bf3e734"><div class="ttname"><a href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a></div><div class="ttdeci">static __inline __m256d __DEFAULT_FN_ATTRS _mm256_setzero_pd(void)</div><div class="ttdoc">Constructs a 256-bit floating-point vector of [4 x double] with all vector elements initialized to ze...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l04326">avxintrin.h:4326</a></div></div>
<div class="ttc" id="axmmintrin_8h_html_a9dac2ea83695373391286f7f38cf3741"><div class="ttname"><a href="xmmintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a></div><div class="ttdeci">#define _CMP_EQ_OQ</div><div class="ttdef"><b>Definition:</b> <a href="xmmintrin_8h_source.html#l03051">xmmintrin.h:3051</a></div></div>
</div><!-- fragment -->
<p>Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code" href="avx2intrin_8h.html#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a80044451f05309770ce2bf171dbfa0be"><div class="ttname"><a href="avx2intrin_8h.html#a80044451f05309770ce2bf171dbfa0be">_mm256_i32gather_pd</a></div><div class="ttdeci">#define _mm256_i32gather_pd(m, i, s)</div><div class="ttdoc">Gathers four 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04795">avx2intrin.h:4795</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04795">4795</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a74219a133afddd0577c5a391f041a936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74219a133afddd0577c5a391f041a936">&#9670;&nbsp;</a></span>_mm256_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256)__builtin_ia32_gatherd_ps256((__v8sf)<a class="code" href="avxintrin_8h.html#a21b240c99046705ad915ee3d5abcd03c">_mm256_undefined_ps</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8sf)<a class="code" href="avxintrin_8h.html#a017a59237c66c74e4bccb10fed2d66c4">_mm256_cmp_ps</a>(<a class="code" href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a>(), \</div>
<div class="line">                                                              <a class="code" href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a>(), \</div>
<div class="line">                                                              <a class="code" href="xmmintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                        (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aavxintrin_8h_html_a017a59237c66c74e4bccb10fed2d66c4"><div class="ttname"><a href="avxintrin_8h.html#a017a59237c66c74e4bccb10fed2d66c4">_mm256_cmp_ps</a></div><div class="ttdeci">#define _mm256_cmp_ps(a, b, c)</div><div class="ttdoc">Compares each of the corresponding values of two 256-bit vectors of [8 x float], using the operation ...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l01845">avxintrin.h:1845</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a210663317b1495683ea4e42ddc297da5"><div class="ttname"><a href="avxintrin_8h.html#a210663317b1495683ea4e42ddc297da5">_mm256_setzero_ps</a></div><div class="ttdeci">static __inline __m256 __DEFAULT_FN_ATTRS _mm256_setzero_ps(void)</div><div class="ttdoc">Constructs a 256-bit floating-point vector of [8 x float] with all vector elements initialized to zer...</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l04340">avxintrin.h:4340</a></div></div>
<div class="ttc" id="aavxintrin_8h_html_a21b240c99046705ad915ee3d5abcd03c"><div class="ttname"><a href="avxintrin_8h.html#a21b240c99046705ad915ee3d5abcd03c">_mm256_undefined_ps</a></div><div class="ttdeci">static __inline__ __m256 __DEFAULT_FN_ATTRS _mm256_undefined_ps(void)</div><div class="ttdoc">Create a 256-bit vector of [8 x float] with undefined values.</div><div class="ttdef"><b>Definition:</b> <a href="avxintrin_8h_source.html#l03653">avxintrin.h:3653</a></div></div>
</div><!-- fragment -->
<p>Gathers eight 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256 <a class="code" href="avx2intrin_8h.html#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a74219a133afddd0577c5a391f041a936"><div class="ttname"><a href="avx2intrin_8h.html#a74219a133afddd0577c5a391f041a936">_mm256_i32gather_ps</a></div><div class="ttdeci">#define _mm256_i32gather_ps(m, i, s)</div><div class="ttdoc">Gathers eight 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04937">avx2intrin.h:4937</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04937">4937</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4ead9a9686d802347c1311dbdb2166de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ead9a9686d802347c1311dbdb2166de">&#9670;&nbsp;</a></span>_mm256_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d256((__v4si)<a class="code" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4si)<a class="code" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_a745e2e4ca5292bf5f9ba85e0e1e34de1"><div class="ttname"><a href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_undefined_si128(void)</div><div class="ttdoc">Generates a 128-bit vector of [4 x i32] with unspecified content.</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l03477">emmintrin.h:3477</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_a9e143edcb574e990a3762ef8044cf20a"><div class="ttname"><a href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_set1_epi32(int __i)</div><div class="ttdoc">Initializes all values in a 128-bit vector of [4 x i32] with the specified 32-bit value.</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l03689">emmintrin.h:3689</a></div></div>
</div><!-- fragment -->
<p>Gathers four 32-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4ead9a9686d802347c1311dbdb2166de"><div class="ttname"><a href="avx2intrin_8h.html#a4ead9a9686d802347c1311dbdb2166de">_mm256_i64gather_epi32</a></div><div class="ttdeci">#define _mm256_i64gather_epi32(m, i, s)</div><div class="ttdoc">Gathers four 32-bit integer values from memory m using scaled indexes from the 256-bit vector of [4 x...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05143">avx2intrin.h:5143</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05143">5143</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad1b484e1a1b32ff73f8857fc02dc8008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b484e1a1b32ff73f8857fc02dc8008">&#9670;&nbsp;</a></span>_mm256_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherq_q256((__v4di)<a class="code" href="avxintrin_8h.html#a5d03860407459337bbfbc277face762b">_mm256_undefined_si256</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4di)<a class="code" href="avxintrin_8h.html#a62a0e00da40e99bd0112ab77186984cf">_mm256_set1_epi64x</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 64-bit integer values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad1b484e1a1b32ff73f8857fc02dc8008"><div class="ttname"><a href="avx2intrin_8h.html#ad1b484e1a1b32ff73f8857fc02dc8008">_mm256_i64gather_epi64</a></div><div class="ttdeci">#define _mm256_i64gather_epi64(m, i, s)</div><div class="ttdoc">Gathers four 64-bit integer values from memory m using scaled indexes from the 256-bit vector of [4 x...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05275">avx2intrin.h:5275</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05275">5275</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a10b6cdf024224c2ed44d22717fd80434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6cdf024224c2ed44d22717fd80434">&#9670;&nbsp;</a></span>_mm256_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherq_pd256((__v4df)<a class="code" href="avxintrin_8h.html#a483d5f7ab8caca878e4be157e3d07f62">_mm256_undefined_pd</a>(), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4di)(__m256i)(i), \</div>
<div class="line">                                         (__v4df)<a class="code" href="avxintrin_8h.html#a65f0cd8e0a33a987b052a60b03249077">_mm256_cmp_pd</a>(<a class="code" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code" href="avxintrin_8h.html#aac4a2ce03fb26132483fae2f6bf3e734">_mm256_setzero_pd</a>(), \</div>
<div class="line">                                                               <a class="code" href="xmmintrin_8h.html#a9dac2ea83695373391286f7f38cf3741">_CMP_EQ_OQ</a>), \</div>
<div class="line">                                         (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code" href="avx2intrin_8h.html#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a10b6cdf024224c2ed44d22717fd80434"><div class="ttname"><a href="avx2intrin_8h.html#a10b6cdf024224c2ed44d22717fd80434">_mm256_i64gather_pd</a></div><div class="ttdeci">#define _mm256_i64gather_pd(m, i, s)</div><div class="ttdoc">Gathers four 64-bit floating-point values from memory m using scaled indexes from the 256-bit vector ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04866">avx2intrin.h:4866</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04866">4866</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a897ba09d00f44657795d12e48beeca0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897ba09d00f44657795d12e48beeca0f">&#9670;&nbsp;</a></span>_mm256_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps256((__v4sf)<a class="code" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4sf)<a class="code" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                             <a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                        (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="axmmintrin_8h_html_a100921ec3d30feb9bdf0d661186b4df6"><div class="ttname"><a href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_cmpeq_ps(__m128 __a, __m128 __b)</div><div class="ttdoc">Compares each of the corresponding 32-bit float values of the 128-bit vectors of [4 x float] for equa...</div><div class="ttdef"><b>Definition:</b> <a href="xmmintrin_8h_source.html#l00525">xmmintrin.h:525</a></div></div>
<div class="ttc" id="axmmintrin_8h_html_a10ea459352416f5ae50823116d1d2a58"><div class="ttname"><a href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_setzero_ps(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [4 x float] initialized to zero.</div><div class="ttdef"><b>Definition:</b> <a href="xmmintrin_8h_source.html#l02018">xmmintrin.h:2018</a></div></div>
<div class="ttc" id="axmmintrin_8h_html_a2bb31df1ff50f696cce94e88075184c1"><div class="ttname"><a href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a></div><div class="ttdeci">static __inline__ __m128 __DEFAULT_FN_ATTRS _mm_undefined_ps(void)</div><div class="ttdoc">Create a 128-bit vector of [4 x float] with undefined values.</div><div class="ttdef"><b>Definition:</b> <a href="xmmintrin_8h_source.html#l01891">xmmintrin.h:1891</a></div></div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+64:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a897ba09d00f44657795d12e48beeca0f"><div class="ttname"><a href="avx2intrin_8h.html#a897ba09d00f44657795d12e48beeca0f">_mm256_i64gather_ps</a></div><div class="ttdeci">#define _mm256_i64gather_ps(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 256-bit vector ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05010">avx2intrin.h:5010</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05010">5010</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8406778aad3e2dac47927d38a6689714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8406778aad3e2dac47927d38a6689714">&#9670;&nbsp;</a></span>_mm256_inserti128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_inserti128_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_insert128i256((__v4di)(__m256i)(V1), \</div>
<div class="line">                                         (__v2di)(__m128i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Copies the 256-bit vector <em>V1</em> to the result, then overwrites half of the result with the 128-bit vector <em>V2</em>. </p>
<p>If bit 0 of the immediate <em>M</em> is zero, overwrites the lower half of the result; otherwise, overwrites the upper half.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a>(__m256i V1, __m128i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8406778aad3e2dac47927d38a6689714"><div class="ttname"><a href="avx2intrin_8h.html#a8406778aad3e2dac47927d38a6689714">_mm256_inserti128_si256</a></div><div class="ttdeci">#define _mm256_inserti128_si256(V1, V2, M)</div><div class="ttdoc">Copies the 256-bit vector V1 to the result, then overwrites half of the result with the 128-bit vecto...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03482">avx2intrin.h:3482</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VINSERTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit integer vector containing a source value. </td></tr>
    <tr><td class="paramname">V2</td><td>A 128-bit integer vector containing a source value. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying where to put <em>V2</em> in the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03482">3482</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4a3890959d248c67e0307f945f852a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3890959d248c67e0307f945f852a28">&#9670;&nbsp;</a></span>_mm256_mask_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_d256((__v8si)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8si)(__m256i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [8 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i,</div>
<div class="line">                                    __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4a3890959d248c67e0307f945f852a28"><div class="ttname"><a href="avx2intrin_8h.html#a4a3890959d248c67e0307f945f852a28">_mm256_mask_i32gather_epi32</a></div><div class="ttdeci">#define _mm256_mask_i32gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers eight 32-bit integer values, either from the 256-bit vector of [8 x i32] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04434">avx2intrin.h:4434</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [8 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04434">4434</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad6618807ebcb4b758d18065b0512b456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6618807ebcb4b758d18065b0512b456">&#9670;&nbsp;</a></span>_mm256_mask_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherd_q256((__v4di)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4si)(__m128i)(i), \</div>
<div class="line">                                        (__v4di)(__m256i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m,</div>
<div class="line">                                    __m128i i, __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad6618807ebcb4b758d18065b0512b456"><div class="ttname"><a href="avx2intrin_8h.html#ad6618807ebcb4b758d18065b0512b456">_mm256_mask_i32gather_epi64</a></div><div class="ttdeci">#define _mm256_mask_i32gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04630">avx2intrin.h:4630</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04630">4630</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8a9ef334e167c132b6a9f13770b77f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ef334e167c132b6a9f13770b77f01">&#9670;&nbsp;</a></span>_mm256_mask_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherd_pd256((__v4df)(__m256d)(a), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4si)(__m128i)(i), \</div>
<div class="line">                                         (__v4df)(__m256d)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code" href="avx2intrin_8h.html#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a>(__m256d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                                 __m256d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a8a9ef334e167c132b6a9f13770b77f01"><div class="ttname"><a href="avx2intrin_8h.html#a8a9ef334e167c132b6a9f13770b77f01">_mm256_mask_i32gather_pd</a></div><div class="ttdeci">#define _mm256_mask_i32gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x doubl...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04047">avx2intrin.h:4047</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04047">4047</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a7767cbba8a5c61bf05fe06ee416a4542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7767cbba8a5c61bf05fe06ee416a4542">&#9670;&nbsp;</a></span>_mm256_mask_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256)__builtin_ia32_gatherd_ps256((__v8sf)(__m256)(a), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v8si)(__m256i)(i), \</div>
<div class="line">                                        (__v8sf)(__m256)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [8 x i32] in <em>i</em>. </p>
<p>The 256-bit vector of [8 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 7</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256 <a class="code" href="avx2intrin_8h.html#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a>(__m256 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i,</div>
<div class="line">                                __m256 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a7767cbba8a5c61bf05fe06ee416a4542"><div class="ttname"><a href="avx2intrin_8h.html#a7767cbba8a5c61bf05fe06ee416a4542">_mm256_mask_i32gather_ps</a></div><div class="ttdeci">#define _mm256_mask_i32gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers eight 32-bit floating-point values, either from the 256-bit vector of [8 x floa...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04239">avx2intrin.h:4239</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [8 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [8 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04239">4239</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a91162e72875b376189127affa7b2bf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91162e72875b376189127affa7b2bf5c">&#9670;&nbsp;</a></span>_mm256_mask_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d256((__v4si)(__m128i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4si)(__m128i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m256i i,</div>
<div class="line">                                    __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a91162e72875b376189127affa7b2bf5c"><div class="ttname"><a href="avx2intrin_8h.html#a91162e72875b376189127affa7b2bf5c">_mm256_mask_i64gather_epi32</a></div><div class="ttdeci">#define _mm256_mask_i64gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04533">avx2intrin.h:4533</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04533">4533</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af6b171b3af10ce3b58abef775d789f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b171b3af10ce3b58abef775d789f20">&#9670;&nbsp;</a></span>_mm256_mask_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_gatherq_q256((__v4di)(__m256i)(a), \</div>
<div class="line">                                        (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4di)(__m256i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m,</div>
<div class="line">                                    __m256i i, __m256i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_af6b171b3af10ce3b58abef775d789f20"><div class="ttname"><a href="avx2intrin_8h.html#af6b171b3af10ce3b58abef775d789f20">_mm256_mask_i64gather_epi64</a></div><div class="ttdeci">#define _mm256_mask_i64gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit integer values, either from the 256-bit vector of [4 x i64] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04726">avx2intrin.h:4726</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04726">4726</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="acf5b86b0ba922eb270ec2b545c8a537d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5b86b0ba922eb270ec2b545c8a537d">&#9670;&nbsp;</a></span>_mm256_mask_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256d)__builtin_ia32_gatherq_pd256((__v4df)(__m256d)(a), \</div>
<div class="line">                                         (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                         (__v4di)(__m256i)(i), \</div>
<div class="line">                                         (__v4df)(__m256d)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 256-bit vector of [4 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code" href="avx2intrin_8h.html#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a>(__m256d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m256i i,</div>
<div class="line">                                 __m256d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_acf5b86b0ba922eb270ec2b545c8a537d"><div class="ttname"><a href="avx2intrin_8h.html#acf5b86b0ba922eb270ec2b545c8a537d">_mm256_mask_i64gather_pd</a></div><div class="ttdeci">#define _mm256_mask_i64gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 64-bit floating-point values, either from the 256-bit vector of [4 x doubl...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04143">avx2intrin.h:4143</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [4 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 256-bit vector of [4 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04143">4143</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a13ab1da963f146144bd78937e561deaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ab1da963f146144bd78937e561deaf">&#9670;&nbsp;</a></span>_mm256_mask_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mask_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps256((__v4sf)(__m128)(a), \</div>
<div class="line">                                        (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                        (__v4di)(__m256i)(i), \</div>
<div class="line">                                        (__v4sf)(__m128)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 256-bit vector of [4 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m256i i,</div>
<div class="line">                                __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a13ab1da963f146144bd78937e561deaf"><div class="ttname"><a href="avx2intrin_8h.html#a13ab1da963f146144bd78937e561deaf">_mm256_mask_i64gather_ps</a></div><div class="ttdeci">#define _mm256_mask_i64gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04338">avx2intrin.h:4338</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 256-bit vector of [4 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04338">4338</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac139092f30e8322e5d76257b5bac2886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac139092f30e8322e5d76257b5bac2886">&#9670;&nbsp;</a></span>_mm256_mpsadbw_epu8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_mpsadbw_epu8</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m256i)__builtin_ia32_mpsadbw256((__v32qi)(__m256i)(<a class="code" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>), \</div>
<div class="line">                                      (__v32qi)(__m256i)(Y), (<span class="keywordtype">int</span>)(M)))</div>
<div class="ttc" id="aInterpreter_2Value_8h_html_a094c3d875c5b3d55fb5307c29cfc2c18"><div class="ttname"><a href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></div><div class="ttdeci">#define X(type, name)</div><div class="ttdef"><b>Definition:</b> <a href="Interpreter_2Value_8h_source.html#l00143">Value.h:143</a></div></div>
</div><!-- fragment -->
<p>Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers from the 256-bit integer vectors <em>X</em> and <em>Y</em>. </p>
<p>Eight SAD results are computed using the lower half of the input vectors, and another eight using the upper half. These 16-bit values are returned in the lower and upper halves of the 256-bit result, respectively.</p>
<p>A single SAD operation selects four bytes from <em>X</em> and four bytes from <em>Y</em> as input. It computes the differences between each <em>X</em> byte and the corresponding <em>Y</em> byte, takes the absolute value of each difference, and sums these four values to form one 16-bit result. The intrinsic computes 16 of these results with different sets of input bytes.</p>
<p>For each set of eight results, the SAD operations use the same four bytes from <em>Y</em>; the starting bit position for these four bytes is specified by <em>M</em>[1:0] times 32. The eight operations use successive sets of four bytes from <em>X</em>; the starting bit position for the first set of four bytes is specified by <em>M</em>[2] times 32. These bit positions are all relative to the 128-bit lane for each set of eight operations.</p>
<div class="fragment"><div class="line">r := 0</div>
<div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*3</div>
<div class="line">  Ybase := M[j+1:j]*32 + i*128</div>
<div class="line">  Xbase := M[j+2]*32 + i*128</div>
<div class="line">  FOR k := 0 TO 3</div>
<div class="line">    temp0 := ABS(X[Xbase+7:Xbase] - Y[Ybase+7:Ybase])</div>
<div class="line">    temp1 := ABS(X[Xbase+15:Xbase+8] - Y[Ybase+15:Ybase+8])</div>
<div class="line">    temp2 := ABS(X[Xbase+23:Xbase+16] - Y[Ybase+23:Ybase+16])</div>
<div class="line">    temp3 := ABS(X[Xbase+31:Xbase+24] - Y[Ybase+31:Ybase+24])</div>
<div class="line">    result[r+15:r] := temp0 + temp1 + temp2 + temp3</div>
<div class="line">    Xbase := Xbase + 8</div>
<div class="line">    r := r + 16</div>
<div class="line">  ENDFOR</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a>(__m256i <a class="code" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a>, __m256i Y, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac139092f30e8322e5d76257b5bac2886"><div class="ttname"><a href="avx2intrin_8h.html#ac139092f30e8322e5d76257b5bac2886">_mm256_mpsadbw_epu8</a></div><div class="ttdeci">#define _mm256_mpsadbw_epu8(X, Y, M)</div><div class="ttdoc">Computes sixteen sum of absolute difference (SAD) operations on sets of four unsigned 8-bit integers ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l00083">avx2intrin.h:83</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VMPSADBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">Y</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">M</td><td>An unsigned immediate value specifying the starting positions of the bytes to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00083">83</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aa42c8a9ffd50a4d2e392dc16043f3be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42c8a9ffd50a4d2e392dc16043f3be2">&#9670;&nbsp;</a></span>_mm256_permute2x128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute2x128_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_permti256((__m256i)(V1), (__m256i)(V2), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of the 256-bit vectors <em>V1</em> and <em>V2</em>, as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  k := M &gt;&gt; (i*4)</div>
<div class="line">  IF k[3] == 0</div>
<div class="line">    CASE (k[1:0]) OF</div>
<div class="line">    0: result[127+j:j] := V1[127:0]</div>
<div class="line">    1: result[127+j:j] := V1[255:128]</div>
<div class="line">    2: result[127+j:j] := V2[127:0]</div>
<div class="line">    3: result[127+j:j] := V2[255:128]</div>
<div class="line">    ESAC</div>
<div class="line">  ELSE</div>
<div class="line">    result[127+j:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a>(__m256i V1, __m256i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_aa42c8a9ffd50a4d2e392dc16043f3be2"><div class="ttname"><a href="avx2intrin_8h.html#aa42c8a9ffd50a4d2e392dc16043f3be2">_mm256_permute2x128_si256</a></div><div class="ttdeci">#define _mm256_permute2x128_si256(V1, V2, M)</div><div class="ttdoc">Sets each half of the 256-bit result either to zero or to one of the four possible 128-bit halves of ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03439">avx2intrin.h:3439</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERM2I128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate value specifying how to form the result. Bits [3:0] control the lower half of the result, bits [7:4] control the upper half. Within each 4-bit control value, if bit 3 is 1, the result is zero, otherwise bits [1:0] determine the source as follows. <br  />
 0: the lower half of <em>V1</em> <br  />
 1: the upper half of <em>V1</em> <br  />
 2: the lower half of <em>V2</em> <br  />
 3: the upper half of <em>V2</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03439">3439</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a68537aee7b7c35974ea46b32d6be8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68537aee7b7c35974ea46b32d6be8539">&#9670;&nbsp;</a></span>_mm256_permute4x64_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute4x64_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_permdi256((__v4di)(__m256i)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [4 x i64] in <em>V</em> as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  k := (M &gt;&gt; i*2)[1:0] * 64</div>
<div class="line">  result[j+63:j] := V[k+63:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a>(__m256i <a class="code" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a68537aee7b7c35974ea46b32d6be8539"><div class="ttname"><a href="avx2intrin_8h.html#a68537aee7b7c35974ea46b32d6be8539">_mm256_permute4x64_epi64</a></div><div class="ttdeci">#define _mm256_permute4x64_epi64(V, M)</div><div class="ttdoc">Sets the result's 256-bit vector of [4 x i64] result to copies of elements of the 256-bit vector of [...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03393">avx2intrin.h:3393</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit vector of [4 x i64] containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit value specifying which elements to copy from <em>V</em>. <em>M</em>[1:0] specifies the index in <em>a</em> for element 0 of the result, <em>M</em>[3:2] specifies the index for element 1, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03393">3393</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a6e712383837346afed6b8bb7980d1ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e712383837346afed6b8bb7980d1ed1">&#9670;&nbsp;</a></span>_mm256_permute4x64_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_permute4x64_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256d)__builtin_ia32_permdf256((__v4df)(__m256d)(<a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(M)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x double] in <em>V</em> as specified by the immediate value <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  k := (M &gt;&gt; i*2)[1:0] * 64</div>
<div class="line">  result[j+63:j] := V[k+63:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256d <a class="code" href="avx2intrin_8h.html#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a>(__m256d <a class="code" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a6e712383837346afed6b8bb7980d1ed1"><div class="ttname"><a href="avx2intrin_8h.html#a6e712383837346afed6b8bb7980d1ed1">_mm256_permute4x64_pd</a></div><div class="ttdeci">#define _mm256_permute4x64_pd(V, M)</div><div class="ttdoc">Sets the result's 256-bit vector of [4 x double] to copies of elements of the 256-bit vector of [4 x ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03335">avx2intrin.h:3335</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>A 256-bit vector of [4 x double] containing the source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit value specifying which elements to copy from <em>V</em>. <em>M</em>[1:0] specifies the index in <em>a</em> for element 0 of the result, <em>M</em>[3:2] specifies the index for element 1, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03335">3335</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac0e537a750e453f44a0ed29eeeba6c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e537a750e453f44a0ed29eeeba6c88">&#9670;&nbsp;</a></span>_mm256_shuffle_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shuffle_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshufd256((__v8si)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result. </p>
<p>In effect there are two parallel 128-bit shuffles in the lower and upper halves.</p>
<div class="fragment"><div class="line">FOR i := 0 to 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 32</div>
<div class="line">  result[j+31:j] := a[k+31:k]</div>
<div class="line">  result[128+j+31:128+j] := a[128+k+31:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac0e537a750e453f44a0ed29eeeba6c88"><div class="ttname"><a href="avx2intrin_8h.html#ac0e537a750e453f44a0ed29eeeba6c88">_mm256_shuffle_epi32</a></div><div class="ttdeci">#define _mm256_shuffle_epi32(a, imm)</div><div class="ttdoc">Shuffles 32-bit integers from the 256-bit vector of [8 x i32] in a according to control information i...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l01936">avx2intrin.h:1936</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [8 x i32] containing source values. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 0 and 4 of the result, <em>imm</em>[3:2] specifies the index for elements 1 and 5, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01936">1936</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a067971162dbcfead4d820ccda94fc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067971162dbcfead4d820ccda94fc850">&#9670;&nbsp;</a></span>_mm256_shufflehi_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shufflehi_epi16</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshufhw256((__v16hi)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit result. </p>
<p>The upper 64 bits of each 128-bit half are shuffled in parallel; the lower 64 bits of each 128-bit half are copied from <em>a</em> unchanged.</p>
<div class="fragment"><div class="line">result[63:0] := a[63:0]</div>
<div class="line">result[191:128] := a[191:128]</div>
<div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i * 16 + 64</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 16 + 64</div>
<div class="line">  result[j+15:j] := a[k+15:k]</div>
<div class="line">  result[128+j+15:128+j] := a[128+k+15:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a067971162dbcfead4d820ccda94fc850"><div class="ttname"><a href="avx2intrin_8h.html#a067971162dbcfead4d820ccda94fc850">_mm256_shufflehi_epi16</a></div><div class="ttdeci">#define _mm256_shufflehi_epi16(a, imm)</div><div class="ttdoc">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] in a according to control information ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l01972">avx2intrin.h:1972</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFHW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [16 x i16] containing source values. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 4 and 8 of the result, <em>imm</em>[3:2] specifies the index for elements 5 and 9, and so forth. Indexes are offset by 4 (so 0 means index 4, and so forth). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01972">1972</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad3ebb6cfdddfb1692373d6cf70ac8ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ebb6cfdddfb1692373d6cf70ac8ccf">&#9670;&nbsp;</a></span>_mm256_shufflelo_epi16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_shufflelo_epi16</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pshuflw256((__v16hi)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles 16-bit integers from the 256-bit vector of [16 x i16] <em>a</em> according to control information in the integer literal <em>imm</em>, and returns the 256-bit [16 x i16] result. </p>
<p>The lower 64 bits of each 128-bit half are shuffled; the upper 64 bits of each 128-bit half are copied from <em>a</em> unchanged.</p>
<div class="fragment"><div class="line">result[127:64] := a[127:64]</div>
<div class="line">result[255:192] := a[255:192]</div>
<div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i * 16</div>
<div class="line">  k := (imm &gt;&gt; i*2)[1:0] * 16</div>
<div class="line">  result[j+15:j] := a[k+15:k]</div>
<div class="line">  result[128+j+15:128+j] := a[128+k+15:128+k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad3ebb6cfdddfb1692373d6cf70ac8ccf"><div class="ttname"><a href="avx2intrin_8h.html#ad3ebb6cfdddfb1692373d6cf70ac8ccf">_mm256_shufflelo_epi16</a></div><div class="ttdeci">#define _mm256_shufflelo_epi16(a, imm)</div><div class="ttdoc">Shuffles 16-bit integers from the 256-bit vector of [16 x i16] a according to control information in ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l02009">avx2intrin.h:2009</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit vector of [16 x i16] to use as a source of data for the result. </td></tr>
    <tr><td class="paramname">imm</td><td>An immediate 8-bit value specifying which elements to copy from <em>a</em>. <em>imm</em>[1:0] specifies the index in <em>a</em> for elements 0 and 8 of the result, <em>imm</em>[3:2] specifies the index for elements 1 and 9, and so forth. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02009">2009</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ac2f1212570d0e3dee4a64ef6e8a19693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f1212570d0e3dee4a64ef6e8a19693">&#9670;&nbsp;</a></span>_mm256_slli_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_slli_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_pslldqi256_byteshift((__v4di)(__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts each 128-bit half of the 256-bit integer vector <em>a</em> left by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_ac2f1212570d0e3dee4a64ef6e8a19693"><div class="ttname"><a href="avx2intrin_8h.html#ac2f1212570d0e3dee4a64ef6e8a19693">_mm256_slli_si256</a></div><div class="ttdeci">#define _mm256_slli_si256(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector a left by imm bytes, shifting in zero bytes,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l02092">avx2intrin.h:2092</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSLLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02092">2092</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a59a707f6f1a0cc3039cacb54fb420d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a707f6f1a0cc3039cacb54fb420d4b">&#9670;&nbsp;</a></span>_mm256_srli_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm256_srli_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">imm&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((__m256i)__builtin_ia32_psrldqi256_byteshift((__m256i)(a), (<a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(imm)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts each 128-bit half of the 256-bit integer vector in <em>a</em> right by <em>imm</em> bytes, shifting in zero bytes, and returns the result. </p>
<p>If <em>imm</em> is greater than 15, the returned result is all zeroes.</p>
<div class="fragment"><div class="line">__m256i <a class="code" href="avx2intrin_8h.html#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a>(__m256i a, <span class="keyword">const</span> <span class="keywordtype">int</span> imm);</div>
<div class="ttc" id="aavx2intrin_8h_html_a59a707f6f1a0cc3039cacb54fb420d4b"><div class="ttname"><a href="avx2intrin_8h.html#a59a707f6f1a0cc3039cacb54fb420d4b">_mm256_srli_si256</a></div><div class="ttdeci">#define _mm256_srli_si256(a, imm)</div><div class="ttdoc">Shifts each 128-bit half of the 256-bit integer vector in a right by imm bytes, shifting in zero byte...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l02336">avx2intrin.h:2336</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSRLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 256-bit integer vector to be shifted. </td></tr>
    <tr><td class="paramname">imm</td><td>An unsigned immediate value specifying the shift count (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02336">2336</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a51a2ff86a16a4fc5a9e3c94a817064ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2ff86a16a4fc5a9e3c94a817064ea">&#9670;&nbsp;</a></span>_mm_blend_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_blend_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">V2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_pblendd128((__v4si)(__m128i)(V1), \</div>
<div class="line">                                      (__v4si)(__m128i)(V2), (<span class="keywordtype">int</span>)(M)))</div>
</div><!-- fragment -->
<p>Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in <em>V1</em> or <em>V2</em> to the result's 128-bit vector of [4 x i32], as specified by the immediate integer operand <em>M</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF M[i] == 0</div>
<div class="line">    result[31+j:j] := V1[31+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[31+j:j] := V2[32+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a>(__m128i V1, __m128i V2, <span class="keyword">const</span> <span class="keywordtype">int</span> M);</div>
<div class="ttc" id="aavx2intrin_8h_html_a51a2ff86a16a4fc5a9e3c94a817064ea"><div class="ttname"><a href="avx2intrin_8h.html#a51a2ff86a16a4fc5a9e3c94a817064ea">_mm_blend_epi32</a></div><div class="ttdeci">#define _mm_blend_epi32(V1, V2, M)</div><div class="ttdoc">Merges 32-bit integer elements from either of the two 128-bit vectors of [4 x i32] in V1 or V2 to the...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03111">avx2intrin.h:3111</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V1</td><td>A 128-bit vector of [4 x i32] containing source values. </td></tr>
    <tr><td class="paramname">V2</td><td>A 128-bit vector of [4 x i32] containing source values. </td></tr>
    <tr><td class="paramname">M</td><td>An immediate 8-bit integer operand, with bits [3:0] specifying the source for each element of the result. The position of the mask bit corresponds to the index of a copied value. When a mask bit is 0, the element is copied from <em>V1</em>; otherwise, it is copied from <em>V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03111">3111</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a2c7c90e2a3c140bd5828be66dd00450c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7c90e2a3c140bd5828be66dd00450c">&#9670;&nbsp;</a></span>_mm_broadcastsi128_si256</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_broadcastsi128_si256</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="avx2intrin_8h.html#a4f7018cff60b93116947e57eea1f1c63">_mm256_broadcastsi128_si256</a>(<a class="el" href="JSONCompilationDatabase_8cpp.html#ae2bfabb8d55939ef9b159c988453ee04">X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03076">3076</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a3fc371417a059f4660f43bb9f70c0420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc371417a059f4660f43bb9f70c0420">&#9670;&nbsp;</a></span>_mm_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_d((__v4si)<a class="code" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)<a class="code" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a3fc371417a059f4660f43bb9f70c0420"><div class="ttname"><a href="avx2intrin_8h.html#a3fc371417a059f4660f43bb9f70c0420">_mm_i32gather_epi32</a></div><div class="ttdeci">#define _mm_i32gather_epi32(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05045">avx2intrin.h:5045</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05045">5045</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a2f9f493fcb23d1f0266edb15035bc22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9f493fcb23d1f0266edb15035bc22f">&#9670;&nbsp;</a></span>_mm_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_q((__v2di)<a class="code" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)<a class="code" href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_ae179f6bcfa4da66b9833da96fec21c2c"><div class="ttname"><a href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a></div><div class="ttdeci">static __inline__ __m128i __DEFAULT_FN_ATTRS _mm_set1_epi64x(long long __q)</div><div class="ttdoc">Initializes both values in a 128-bit integer vector with the specified 64-bit integer value.</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l03655">emmintrin.h:3655</a></div></div>
</div><!-- fragment -->
<p>Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a2f9f493fcb23d1f0266edb15035bc22f"><div class="ttname"><a href="avx2intrin_8h.html#a2f9f493fcb23d1f0266edb15035bc22f">_mm_i32gather_epi64</a></div><div class="ttdeci">#define _mm_i32gather_epi64(m, i, s)</div><div class="ttdoc">Gathers two 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [4 x ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05176">avx2intrin.h:5176</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05176">5176</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a4afe7e70b1677fd4097166407ae827cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afe7e70b1677fd4097166407ae827cb">&#9670;&nbsp;</a></span>_mm_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherd_pd((__v2df)<a class="code" href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a>(), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v4si)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)<a class="code" href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a>(<a class="code" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>(), \</div>
<div class="line">                                                           <a class="code" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>()), \</div>
<div class="line">                                      (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
<div class="ttc" id="aemmintrin_8h_html_a8873e2c5dba429d4f4386c2fe6e479f7"><div class="ttname"><a href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_undefined_pd(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [2 x double] with unspecified content.</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l01755">emmintrin.h:1755</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_abb21a22f10c4f15dab5aa34e9886c598"><div class="ttname"><a href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_setzero_pd(void)</div><div class="ttdoc">Constructs a 128-bit floating-point vector of [2 x double] initialized to zero.</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l01857">emmintrin.h:1857</a></div></div>
<div class="ttc" id="aemmintrin_8h_html_ad7c5c50dc07e64e82ef8852bcb093fa6"><div class="ttname"><a href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a></div><div class="ttdeci">static __inline__ __m128d __DEFAULT_FN_ATTRS _mm_cmpeq_pd(__m128d __a, __m128d __b)</div><div class="ttdoc">Compares each of the corresponding double-precision values of the 128-bit vectors of [2 x double] for...</div><div class="ttdef"><b>Definition:</b> <a href="emmintrin_8h_source.html#l00435">emmintrin.h:435</a></div></div>
</div><!-- fragment -->
<p>Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code" href="avx2intrin_8h.html#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a4afe7e70b1677fd4097166407ae827cb"><div class="ttname"><a href="avx2intrin_8h.html#a4afe7e70b1677fd4097166407ae827cb">_mm_i32gather_pd</a></div><div class="ttdeci">#define _mm_i32gather_pd(m, i, s)</div><div class="ttdoc">Gathers two 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04760">avx2intrin.h:4760</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04760">4760</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a192468a06b0104ad516aaca8a4f0eee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192468a06b0104ad516aaca8a4f0eee8">&#9670;&nbsp;</a></span>_mm_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherd_ps((__v4sf)<a class="code" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)<a class="code" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                          <a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                     (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers four 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a192468a06b0104ad516aaca8a4f0eee8"><div class="ttname"><a href="avx2intrin_8h.html#a192468a06b0104ad516aaca8a4f0eee8">_mm_i32gather_ps</a></div><div class="ttdeci">#define _mm_i32gather_ps(m, i, s)</div><div class="ttdoc">Gathers four 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04902">avx2intrin.h:4902</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04902">4902</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ad6b68cf22a459a9867218792d42c0b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b68cf22a459a9867218792d42c0b5d">&#9670;&nbsp;</a></span>_mm_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d((__v4si)<a class="code" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)<a class="code" href="emmintrin_8h.html#a9e143edcb574e990a3762ef8044cf20a">_mm_set1_epi32</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 32-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ad6b68cf22a459a9867218792d42c0b5d"><div class="ttname"><a href="avx2intrin_8h.html#ad6b68cf22a459a9867218792d42c0b5d">_mm_i64gather_epi32</a></div><div class="ttdeci">#define _mm_i64gather_epi32(m, i, s)</div><div class="ttdoc">Gathers two 32-bit integer values from memory m using scaled indexes from the 128-bit vector of [2 x ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05111">avx2intrin.h:5111</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05111">5111</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a76a2425c4e406cc767d45cbd063ba7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a2425c4e406cc767d45cbd063ba7d4">&#9670;&nbsp;</a></span>_mm_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_q((__v2di)<a class="code" href="emmintrin_8h.html#a745e2e4ca5292bf5f9ba85e0e1e34de1">_mm_undefined_si128</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)<a class="code" href="emmintrin_8h.html#ae179f6bcfa4da66b9833da96fec21c2c">_mm_set1_epi64x</a>(-1), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 64-bit integer values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a>(<span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a76a2425c4e406cc767d45cbd063ba7d4"><div class="ttname"><a href="avx2intrin_8h.html#a76a2425c4e406cc767d45cbd063ba7d4">_mm_i64gather_epi64</a></div><div class="ttdeci">#define _mm_i64gather_epi64(m, i, s)</div><div class="ttdoc">Gathers two 64-bit integer values from memory m using scaled indexes from the 128-bit vector of [2 x ...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l05242">avx2intrin.h:5242</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l05242">5242</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a6fc1a3777f51496f53faf452ae31ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc1a3777f51496f53faf452ae31ebfc">&#9670;&nbsp;</a></span>_mm_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherq_pd((__v2df)<a class="code" href="emmintrin_8h.html#a8873e2c5dba429d4f4386c2fe6e479f7">_mm_undefined_pd</a>(), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v2di)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)<a class="code" href="emmintrin_8h.html#ad7c5c50dc07e64e82ef8852bcb093fa6">_mm_cmpeq_pd</a>(<a class="code" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>(), \</div>
<div class="line">                                                           <a class="code" href="emmintrin_8h.html#abb21a22f10c4f15dab5aa34e9886c598">_mm_setzero_pd</a>()), \</div>
<div class="line">                                      (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 64-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code" href="avx2intrin_8h.html#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a6fc1a3777f51496f53faf452ae31ebfc"><div class="ttname"><a href="avx2intrin_8h.html#a6fc1a3777f51496f53faf452ae31ebfc">_mm_i64gather_pd</a></div><div class="ttdeci">#define _mm_i64gather_pd(m, i, s)</div><div class="ttdoc">Gathers two 64-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04831">avx2intrin.h:4831</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04831">4831</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a369276cfeba553776632edd1ee507cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369276cfeba553776632edd1ee507cec">&#9670;&nbsp;</a></span>_mm_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps((__v4sf)<a class="code" href="xmmintrin_8h.html#a2bb31df1ff50f696cce94e88075184c1">_mm_undefined_ps</a>(), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)<a class="code" href="xmmintrin_8h.html#a100921ec3d30feb9bdf0d661186b4df6">_mm_cmpeq_ps</a>(<a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>(), \</div>
<div class="line">                                                          <a class="code" href="xmmintrin_8h.html#a10ea459352416f5ae50823116d1d2a58">_mm_setzero_ps</a>()), \</div>
<div class="line">                                     (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Gathers two 32-bit floating-point values from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a369276cfeba553776632edd1ee507cec"><div class="ttname"><a href="avx2intrin_8h.html#a369276cfeba553776632edd1ee507cec">_mm_i64gather_ps</a></div><div class="ttdeci">#define _mm_i64gather_ps(m, i, s)</div><div class="ttdoc">Gathers two 32-bit floating-point values from memory m using scaled indexes from the 128-bit vector o...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04975">avx2intrin.h:4975</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04975">4975</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a3078631872478b4855ee95713aa2cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3078631872478b4855ee95713aa2cd48">&#9670;&nbsp;</a></span>_mm_mask_i32gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_d((__v4si)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)(__m128i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a3078631872478b4855ee95713aa2cd48"><div class="ttname"><a href="avx2intrin_8h.html#a3078631872478b4855ee95713aa2cd48">_mm_mask_i32gather_epi32</a></div><div class="ttdeci">#define _mm_mask_i32gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04386">avx2intrin.h:4386</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04386">4386</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a825d53d864b1d4d3bb7ab4b6ef457952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825d53d864b1d4d3bb7ab4b6ef457952">&#9670;&nbsp;</a></span>_mm_mask_i32gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherd_q((__v2di)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)(__m128i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a825d53d864b1d4d3bb7ab4b6ef457952"><div class="ttname"><a href="avx2intrin_8h.html#a825d53d864b1d4d3bb7ab4b6ef457952">_mm_mask_i32gather_epi64</a></div><div class="ttdeci">#define _mm_mask_i32gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04582">avx2intrin.h:4582</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04582">4582</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af2af56dc678cba90344c8efc51e42fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2af56dc678cba90344c8efc51e42fef">&#9670;&nbsp;</a></span>_mm_mask_i32gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherd_pd((__v2df)(__m128i)(a), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v4si)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)(__m128d)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code" href="avx2intrin_8h.html#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a>(__m128d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                              __m128d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_af2af56dc678cba90344c8efc51e42fef"><div class="ttname"><a href="avx2intrin_8h.html#af2af56dc678cba90344c8efc51e42fef">_mm_mask_i32gather_pd</a></div><div class="ttdeci">#define _mm_mask_i32gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l03999">avx2intrin.h:3999</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03999">3999</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a66d9ce668f45c18f008ccb4ba4920880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d9ce668f45c18f008ccb4ba4920880">&#9670;&nbsp;</a></span>_mm_mask_i32gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i32gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherd_ps((__v4sf)(__m128)(a), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v4si)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)(__m128)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [4 x i32] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 3</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*32</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i,</div>
<div class="line">                             __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a66d9ce668f45c18f008ccb4ba4920880"><div class="ttname"><a href="avx2intrin_8h.html#a66d9ce668f45c18f008ccb4ba4920880">_mm_mask_i32gather_ps</a></div><div class="ttdeci">#define _mm_mask_i32gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers four 32-bit floating-point values, either from the 128-bit vector of [4 x float...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04191">avx2intrin.h:4191</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERDPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [4 x i32] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04191">4191</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a59acb178be58ad2561eb49b14489800d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59acb178be58ad2561eb49b14489800d">&#9670;&nbsp;</a></span>_mm_mask_i64gather_epi32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_epi32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_d((__v4si)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">int</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4si)(__m128i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x i32] in <em>mask</em> determines the source for the lower two elements. The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">int</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_a59acb178be58ad2561eb49b14489800d"><div class="ttname"><a href="avx2intrin_8h.html#a59acb178be58ad2561eb49b14489800d">_mm_mask_i64gather_epi32</a></div><div class="ttdeci">#define _mm_mask_i64gather_epi32(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 32-bit integer values, either from the 128-bit vector of [4 x i32] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04485">avx2intrin.h:4485</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x i32] used as the source when a mask bit is zero. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x i32] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04485">4485</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="aeb1efa9858c290fe95335119cd657a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1efa9858c290fe95335119cd657a90">&#9670;&nbsp;</a></span>_mm_mask_i64gather_epi64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_epi64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128i)__builtin_ia32_gatherq_q((__v2di)(__m128i)(a), \</div>
<div class="line">                                     (<span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v2di)(__m128i)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x i64] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128i <a class="code" href="avx2intrin_8h.html#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a>(__m128i a, <span class="keyword">const</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> *m, __m128i i,</div>
<div class="line">                                 __m128i mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_aeb1efa9858c290fe95335119cd657a90"><div class="ttname"><a href="avx2intrin_8h.html#aeb1efa9858c290fe95335119cd657a90">_mm_mask_i64gather_epi64</a></div><div class="ttdeci">#define _mm_mask_i64gather_epi64(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit integer values, either from the 128-bit vector of [2 x i64] in a,...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04678">avx2intrin.h:4678</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPGATHERQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x i64] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x i64] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04678">4678</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="abb2e967b6fb85089168a6887111c1320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2e967b6fb85089168a6887111c1320">&#9670;&nbsp;</a></span>_mm_mask_i64gather_pd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_pd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128d)__builtin_ia32_gatherq_pd((__v2df)(__m128d)(a), \</div>
<div class="line">                                      (<span class="keywordtype">double</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                      (__v2di)(__m128i)(i), \</div>
<div class="line">                                      (__v2df)(__m128d)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [2 x double] in <em>mask</em> determines the source for each element.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*64</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+63] == 0</div>
<div class="line">    result[j+63:j] := a[j+63:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128d <a class="code" href="avx2intrin_8h.html#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a>(__m128d a, <span class="keyword">const</span> <span class="keywordtype">double</span> *m, __m128i i,</div>
<div class="line">                              __m128d mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_abb2e967b6fb85089168a6887111c1320"><div class="ttname"><a href="avx2intrin_8h.html#abb2e967b6fb85089168a6887111c1320">_mm_mask_i64gather_pd</a></div><div class="ttdeci">#define _mm_mask_i64gather_pd(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 64-bit floating-point values, either from the 128-bit vector of [2 x double...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04095">avx2intrin.h:4095</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [2 x double] used as the source when a mask bit is zero. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [2 x double] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04095">4095</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="ab80831775aea07c24899ae747d8011bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80831775aea07c24899ae747d8011bc">&#9670;&nbsp;</a></span>_mm_mask_i64gather_ps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _mm_mask_i64gather_ps</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mask, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((__m128)__builtin_ia32_gatherq_ps((__v4sf)(__m128)(a), \</div>
<div class="line">                                     (<span class="keywordtype">float</span> <span class="keyword">const</span> *)(m), \</div>
<div class="line">                                     (__v2di)(__m128i)(i), \</div>
<div class="line">                                     (__v4sf)(__m128)(mask), (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>)))</div>
</div><!-- fragment -->
<p>Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float] in <em>a</em>, or from memory <em>m</em> using scaled indexes from the 128-bit vector of [2 x i64] in <em>i</em>. </p>
<p>The 128-bit vector of [4 x float] in <em>mask</em> determines the source for the lower two elements. The upper two elements of the result are zeroed.</p>
<div class="fragment"><div class="line">FOR element := 0 to 1</div>
<div class="line">  j := element*32</div>
<div class="line">  k := element*64</div>
<div class="line">  IF mask[j+31] == 0</div>
<div class="line">    result[j+31:j] := a[j+31:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s)</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
<div class="line">result[127:64] := 0</div>
</div><!-- fragment --><div class="fragment"><div class="line">__m128 <a class="code" href="avx2intrin_8h.html#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a>(__m128 a, <span class="keyword">const</span> <span class="keywordtype">float</span> *m, __m128i i,</div>
<div class="line">                             __m128 mask, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a>);</div>
<div class="ttc" id="aavx2intrin_8h_html_ab80831775aea07c24899ae747d8011bc"><div class="ttname"><a href="avx2intrin_8h.html#ab80831775aea07c24899ae747d8011bc">_mm_mask_i64gather_ps</a></div><div class="ttdeci">#define _mm_mask_i64gather_ps(a, m, i, mask, s)</div><div class="ttdoc">Conditionally gathers two 32-bit floating-point values, either from the 128-bit vector of [4 x float]...</div><div class="ttdef"><b>Definition:</b> <a href="avx2intrin_8h_source.html#l04290">avx2intrin.h:4290</a></div></div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VGATHERQPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A 128-bit vector of [4 x float] used as the source when a mask bit is zero. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">i</td><td>A 128-bit vector of [2 x i64] containing signed indexes into <em>m</em>. </td></tr>
    <tr><td class="paramname">mask</td><td>A 128-bit vector of [4 x float] containing the mask. The most significant bit of each element in the mask vector represents the mask bits. If a mask bit is zero, the corresponding value from vector <em>a</em> is gathered; otherwise the value is loaded from memory. Only the first two elements are used. </td></tr>
    <tr><td class="paramname">s</td><td>A literal constant scale factor for the indexes in <em>i</em>. Must be 1, 2, 4, or 8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the gathered values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l04290">4290</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af356be486c9c44ff687a24eecb505123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af356be486c9c44ff687a24eecb505123">&#9670;&nbsp;</a></span>_mm256_abs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed 16-bit element in the 256-bit vector of [16 x i16] in <em>__a</em> and returns each value in the corresponding element of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00116">116</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00530">_mm256_mask_abs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00538">_mm256_maskz_abs_epi16()</a>.</p>

</div>
</div>
<a id="ae0fbd635339f3c30bf181326688a45d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fbd635339f3c30bf181326688a45d1">&#9670;&nbsp;</a></span>_mm256_abs_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed 32-bit element in the 256-bit vector of [8 x i32] in <em>__a</em> and returns each value in the corresponding element of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00133">133</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l02982">_mm256_mask_abs_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l02989">_mm256_maskz_abs_epi32()</a>.</p>

</div>
</div>
<a id="a012bc2eed4df0a81ee390af2ef919e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012bc2eed4df0a81ee390af2ef919e9b">&#9670;&nbsp;</a></span>_mm256_abs_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_abs_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the absolute value of each signed byte in the 256-bit integer vector <em>__a</em> and returns each value in the corresponding byte of the result. </p>
<p>This intrinsic corresponds to the <code>VPABSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00099">99</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00498">_mm256_mask_abs_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00506">_mm256_maskz_abs_epi8()</a>.</p>

</div>
</div>
<a id="a5c1fe2000e40ddd6ccd91f29dfd4ae0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1fe2000e40ddd6ccd91f29dfd4ae0d">&#9670;&nbsp;</a></span>_mm256_add_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in the corresponding element of the [16 x i16] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00297">297</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00324">_mm256_mask_add_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00331">_mm256_maskz_add_epi16()</a>.</p>

</div>
</div>
<a id="af8c017a67c07b606eeaa106c1f7cdf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c017a67c07b606eeaa106c1f7cdf73">&#9670;&nbsp;</a></span>_mm256_add_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in the corresponding element of the [8 x i32] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00316">316</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00233">_mm256_mask_add_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00241">_mm256_maskz_add_epi32()</a>.</p>

</div>
</div>
<a id="a67010f3cee987f3dd117a785fc5a8890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67010f3cee987f3dd117a785fc5a8890">&#9670;&nbsp;</a></span>_mm256_add_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64] and returns the lower 64 bits of each sum in the corresponding element of the [4 x i64] result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00335">335</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00249">_mm256_mask_add_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00257">_mm256_maskz_add_epi64()</a>.</p>

</div>
</div>
<a id="a59b923dae009dd42ae05783e0955ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b923dae009dd42ae05783e0955ee00">&#9670;&nbsp;</a></span>_mm256_add_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_add_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors and returns the lower 8 bits of each sum in the corresponding byte of the 256-bit integer vector result (overflow is ignored). </p>
<p>This intrinsic corresponds to the <code>VPADDB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00278">278</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00310">_mm256_mask_add_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00317">_mm256_maskz_add_epi8()</a>.</p>

</div>
</div>
<a id="af52f4d9d816fcdcc2fcd9852c20ccc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52f4d9d816fcdcc2fcd9852c20ccc87">&#9670;&nbsp;</a></span>_mm256_adds_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPADDSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00372">372</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00721">_mm256_mask_adds_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00729">_mm256_maskz_adds_epi16()</a>.</p>

</div>
</div>
<a id="acd983b6ed3ea7f23bea1deb062b8a72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd983b6ed3ea7f23bea1deb062b8a72b">&#9670;&nbsp;</a></span>_mm256_adds_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result. </p>
<p>This intrinsic corresponds to the <code>VPADDSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00354">354</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00689">_mm256_mask_adds_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00697">_mm256_maskz_adds_epi8()</a>.</p>

</div>
</div>
<a id="a4d517ee9448be65c2af608809bab444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d517ee9448be65c2af608809bab444e">&#9670;&nbsp;</a></span>_mm256_adds_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPADDUSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00409">409</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00785">_mm256_mask_adds_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00793">_mm256_maskz_adds_epu16()</a>.</p>

</div>
</div>
<a id="abf0d44817e7de48ab8c0774a1d8faae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0d44817e7de48ab8c0774a1d8faae8">&#9670;&nbsp;</a></span>_mm256_adds_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_adds_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each sum in the corresponding byte of the 256-bit integer vector result. </p>
<p>This intrinsic corresponds to the <code>VPADDUSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00391">391</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00753">_mm256_mask_adds_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00761">_mm256_maskz_adds_epu8()</a>.</p>

</div>
</div>
<a id="a05b4ece913b92fa300c7fb60a2a70040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b4ece913b92fa300c7fb60a2a70040">&#9670;&nbsp;</a></span>_mm256_and_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_and_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPAND</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00455">455</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02514">_mm256_mask_test_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06166">_mm256_mask_test_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06193">_mm256_mask_test_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02487">_mm256_mask_test_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02567">_mm256_mask_testn_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06220">_mm256_mask_testn_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06247">_mm256_mask_testn_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02541">_mm256_mask_testn_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02507">_mm256_test_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06159">_mm256_test_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06186">_mm256_test_epi64_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02480">_mm256_test_epi8_mask()</a>, <a class="el" href="avx512vlbwintrin_8h_source.html#l02560">_mm256_testn_epi16_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06213">_mm256_testn_epi32_mask()</a>, <a class="el" href="avx512vlintrin_8h_source.html#l06240">_mm256_testn_epi64_mask()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02534">_mm256_testn_epi8_mask()</a>.</p>

</div>
</div>
<a id="ad3c77b7bf2d8fd2dfb073b14a14b1ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c77b7bf2d8fd2dfb073b14a14b1ba2">&#9670;&nbsp;</a></span>_mm256_andnot_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_andnot_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise AND of the 256-bit integer vector in <em>__b</em> with the bitwise NOT of the 256-bit integer vector in <em>__a</em>. </p>
<p>This intrinsic corresponds to the <code>VPANDN</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00473">473</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="aa22ee1dca08e46d756de99cb7e96969a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22ee1dca08e46d756de99cb7e96969a">&#9670;&nbsp;</a></span>_mm256_avg_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_avg_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the averages of the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns each average in the corresponding element of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] + __b[j+15:j] + 1) &gt;&gt; 1</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPAVGW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00525">525</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00849">_mm256_mask_avg_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00857">_mm256_maskz_avg_epu16()</a>.</p>

</div>
</div>
<a id="af8bed13563c4899b28a80ee1650f5464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bed13563c4899b28a80ee1650f5464">&#9670;&nbsp;</a></span>_mm256_avg_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_avg_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the averages of the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns each average in the corresponding byte of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] + __b[j+7:j] + 1) &gt;&gt; 1</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPAVGB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00499">499</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00817">_mm256_mask_avg_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00825">_mm256_maskz_avg_epu8()</a>.</p>

</div>
</div>
<a id="a62142b089038d77658d0b4b8a0d9cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62142b089038d77658d0b4b8a0d9cc60">&#9670;&nbsp;</a></span>_mm256_blendv_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_blendv_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges 8-bit integer values from either of the two 256-bit vectors <em>__V1</em> or <em>__V2</em>, as specified by the 256-bit mask <em>__M</em> and returns the resulting 256-bit integer vector. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  IF __M[7+i] == 0</div>
<div class="line">    result[7+j:j] := __V1[7+j:j]</div>
<div class="line">  ELSE</div>
<div class="line">    result[7+j:j] := __V2[7+j:j]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPBLENDVB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V1</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__V2</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit integer vector, with bit [7] of each byte specifying the source for each corresponding byte of the result. When the mask bit is 0, the byte is copied from <em>__V1</em>; otherwise, it is copied from <em>__V2</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00560">560</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a75b65c7f74b80298dd753b067bb5ba42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b65c7f74b80298dd753b067bb5ba42">&#9670;&nbsp;</a></span>_mm256_broadcastb_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastb_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector whose low byte will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03163">3163</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02638">_mm256_mask_broadcastb_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02646">_mm256_maskz_broadcastb_epi8()</a>.</p>

</div>
</div>
<a id="ad902bf9f90ecbfc92a4ad3fd87b9ceb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902bf9f90ecbfc92a4ad3fd87b9ceb3">&#9670;&nbsp;</a></span>_mm256_broadcastd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x i32]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03195">3195</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06906">_mm256_mask_broadcastd_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06914">_mm256_maskz_broadcastd_epi32()</a>.</p>

</div>
</div>
<a id="afd93adcfd69f94269bd751d664199481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd93adcfd69f94269bd751d664199481">&#9670;&nbsp;</a></span>_mm256_broadcastq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x i64]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03211">3211</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06938">_mm256_mask_broadcastq_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06946">_mm256_maskz_broadcastq_epi64()</a>.</p>

</div>
</div>
<a id="a5bea69dd9bbf4de7be8b17aa32918268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bea69dd9bbf4de7be8b17aa32918268">&#9670;&nbsp;</a></span>_mm256_broadcastsd_pd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256d <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastsd_pd </td>
          <td>(</td>
          <td class="paramtype">__m128d&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__X</em> to all elements of the result's 256-bit vector of [4 x double]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x double] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03055">3055</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06842">_mm256_mask_broadcastsd_pd()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06850">_mm256_maskz_broadcastsd_pd()</a>.</p>

</div>
</div>
<a id="a4f7018cff60b93116947e57eea1f1c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7018cff60b93116947e57eea1f1c63">&#9670;&nbsp;</a></span>_mm256_broadcastsi128_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastsi128_si256 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 128-bit integer data from <em>__X</em> to both the lower and upper halves of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTI128</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector to be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03071">3071</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="af5947990d7f735029f6d858c99e76ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5947990d7f735029f6d858c99e76ee0">&#9670;&nbsp;</a></span>_mm256_broadcastss_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256 <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastss_ps </td>
          <td>(</td>
          <td class="paramtype">__m128&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 256-bit vector of [8 x float]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x float] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03038">3038</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06874">_mm256_mask_broadcastss_ps()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06882">_mm256_maskz_broadcastss_ps()</a>.</p>

</div>
</div>
<a id="ab7f81e03d536bf939f44b377b365f102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f81e03d536bf939f44b377b365f102">&#9670;&nbsp;</a></span>_mm256_broadcastw_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_broadcastw_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 256-bit vector of [16 x i16]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [8 x i16] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03179">3179</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02670">_mm256_mask_broadcastw_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02678">_mm256_maskz_broadcastw_epi16()</a>.</p>

</div>
</div>
<a id="a8d3995744cd296ba3afe8e63286cc001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3995744cd296ba3afe8e63286cc001">&#9670;&nbsp;</a></span>_mm256_cmpeq_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] == __b[j+15:j]) ? 0xFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00654">654</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="ab08dc58285046d2fcd2f22d810142926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08dc58285046d2fcd2f22d810142926">&#9670;&nbsp;</a></span>_mm256_cmpeq_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := (__a[j+31:j] == __b[j+31:j]) ? 0xFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00680">680</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a7dfc980648d672eb11da414edb750685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfc980648d672eb11da414edb750685">&#9670;&nbsp;</a></span>_mm256_cmpeq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := (__a[j+63:j] == __b[j+63:j]) ? 0xFFFFFFFFFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00706">706</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a1c56e14a2dde3eb2c34d1e9d6dcc253d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c56e14a2dde3eb2c34d1e9d6dcc253d">&#9670;&nbsp;</a></span>_mm256_cmpeq_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpeq_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for equality and returns the outcomes in the corresponding bytes of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] == __b[j+7:j]) ? 0xFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPEQB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00628">628</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a786920fc3bb94533373fca034895faec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786920fc3bb94533373fca034895faec">&#9670;&nbsp;</a></span>_mm256_cmpgt_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := (__a[j+15:j] &gt; __b[j+15:j]) ? 0xFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00760">760</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a3e3c233b478906cc78e36cf04610b79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3c233b478906cc78e36cf04610b79a">&#9670;&nbsp;</a></span>_mm256_cmpgt_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := (__a[j+31:j] &gt; __b[j+31:j]) ? 0xFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00786">786</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a55c95c13f7072f5de6a1a81079605e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c95c13f7072f5de6a1a81079605e87">&#9670;&nbsp;</a></span>_mm256_cmpgt_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed elements in the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding elements of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := (__a[j+63:j] &gt; __b[j+63:j]) ? 0xFFFFFFFFFFFFFFFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00812">812</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a3576feade9f12b451ae0c9c4a0061029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3576feade9f12b451ae0c9c4a0061029">&#9670;&nbsp;</a></span>_mm256_cmpgt_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cmpgt_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares corresponding signed bytes in the 256-bit integer vectors in <em>__a</em> and <em>__b</em> for greater-than and returns the outcomes in the corresponding bytes of the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := (__a[j+7:j] &gt; __b[j+7:j]) ? 0xFF : 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPCMPGTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing one of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00732">732</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a061af1a474bed2da900b2cd81a56391c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061af1a474bed2da900b2cd81a56391c">&#9670;&nbsp;</a></span>_mm256_cvtepi16_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi16_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := SignExtend(__V[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01441">1441</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04097">_mm256_mask_cvtepi16_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04105">_mm256_maskz_cvtepi16_epi32()</a>.</p>

</div>
</div>
<a id="adb8fb5be9f7b10d9d6370a9d21f27e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8fb5be9f7b10d9d6370a9d21f27e10">&#9670;&nbsp;</a></span>_mm256_cvtepi16_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi16_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[15:0])</div>
<div class="line">result[127:64] := SignExtend(__V[31:16])</div>
<div class="line">result[191:128] := SignExtend(__V[47:32])</div>
<div class="line">result[255:192] := SignExtend(__V[64:48])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01466">1466</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04129">_mm256_mask_cvtepi16_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04137">_mm256_maskz_cvtepi16_epi64()</a>.</p>

</div>
</div>
<a id="abdc0f7b9b824d94be3162eed4b231f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc0f7b9b824d94be3162eed4b231f48">&#9670;&nbsp;</a></span>_mm256_cvtepi32_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi32_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[31:0])</div>
<div class="line">result[127:64] := SignExtend(__V[63:32])</div>
<div class="line">result[191:128] := SignExtend(__V[95:64])</div>
<div class="line">result[255:192] := SignExtend(__V[127:96])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [4 x i32] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01491">1491</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04065">_mm256_mask_cvtepi32_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04073">_mm256_maskz_cvtepi32_epi64()</a>.</p>

</div>
</div>
<a id="a1add4929d67f5823d4c81dedfa2d3903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1add4929d67f5823d4c81dedfa2d3903">&#9670;&nbsp;</a></span>_mm256_cvtepi8_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*16</div>
<div class="line">  result[k+15:k] := SignExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01358">1358</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01780">_mm256_mask_cvtepi8_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01788">_mm256_maskz_cvtepi8_epi16()</a>.</p>

</div>
</div>
<a id="a19f2f0881d66b9de014e6eb8ab3a9dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2f0881d66b9de014e6eb8ab3a9dab">&#9670;&nbsp;</a></span>_mm256_cvtepi8_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := SignExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01386">1386</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04001">_mm256_mask_cvtepi8_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04009">_mm256_maskz_cvtepi8_epi32()</a>.</p>

</div>
</div>
<a id="ae14d1ebebc75eca235d1f3b8bf5d41c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14d1ebebc75eca235d1f3b8bf5d41c1">&#9670;&nbsp;</a></span>_mm256_cvtepi8_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepi8_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sign-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := SignExtend(__V[7:0])</div>
<div class="line">result[127:64] := SignExtend(__V[15:8])</div>
<div class="line">result[191:128] := SignExtend(__V[23:16])</div>
<div class="line">result[255:192] := SignExtend(__V[31:24])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the sign-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01413">1413</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04033">_mm256_mask_cvtepi8_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04041">_mm256_maskz_cvtepi8_epi64()</a>.</p>

</div>
</div>
<a id="a7b021fb3012738fa4c6dbdfdec1e7ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b021fb3012738fa4c6dbdfdec1e7ae0">&#9670;&nbsp;</a></span>_mm256_cvtepu16_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu16_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 16-bit elements from the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := ZeroExtend(__V[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01594">1594</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04258">_mm256_mask_cvtepu16_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04266">_mm256_maskz_cvtepu16_epi32()</a>.</p>

</div>
</div>
<a id="ab629f05b42ddb47b7b0928c0799f57e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629f05b42ddb47b7b0928c0799f57e9">&#9670;&nbsp;</a></span>_mm256_cvtepu16_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu16_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 16-bit elements from the lower half of the 128-bit vector of [8 x i16] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[15:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[31:16])</div>
<div class="line">result[191:128] := ZeroExtend(__V[47:32])</div>
<div class="line">result[255:192] := ZeroExtend(__V[64:48])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVSXWQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [8 x i16] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01619">1619</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04290">_mm256_mask_cvtepu16_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04298">_mm256_maskz_cvtepu16_epi64()</a>.</p>

</div>
</div>
<a id="ad416d1dc4dc5b103142f8aae139bdf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad416d1dc4dc5b103142f8aae139bdf13">&#9670;&nbsp;</a></span>_mm256_cvtepu32_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu32_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends 32-bit elements from the 128-bit vector of [4 x i32] in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[31:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[63:32])</div>
<div class="line">result[191:128] := ZeroExtend(__V[95:64])</div>
<div class="line">result[255:192] := ZeroExtend(__V[127:96])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit vector of [4 x i32] containing the source values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01644">1644</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04226">_mm256_mask_cvtepu32_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04234">_mm256_maskz_cvtepu32_epi64()</a>.</p>

</div>
</div>
<a id="a2ae0545e2a12c3e680a30c1ac531f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae0545e2a12c3e680a30c1ac531f1b9">&#9670;&nbsp;</a></span>_mm256_cvtepu8_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends bytes from the 128-bit integer vector in <em>__V</em> and returns the 16-bit values in the corresponding elements of a 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*16</div>
<div class="line">  result[k+15:k] := ZeroExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01517">1517</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01813">_mm256_mask_cvtepu8_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01821">_mm256_maskz_cvtepu8_epi16()</a>.</p>

</div>
</div>
<a id="a046fc39808a85623a1f45aed71d1e16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046fc39808a85623a1f45aed71d1e16a">&#9670;&nbsp;</a></span>_mm256_cvtepu8_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends bytes from the lower half of the 128-bit integer vector in <em>__V</em> and returns the 32-bit values in the corresponding elements of a 256-bit vector of [8 x i32]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*8</div>
<div class="line">  k := i*32</div>
<div class="line">  result[k+31:k] := ZeroExtend(__V[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01543">1543</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04162">_mm256_mask_cvtepu8_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04170">_mm256_maskz_cvtepu8_epi32()</a>.</p>

</div>
</div>
<a id="a97d05a1c6bfc00de679e008cf93f573f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d05a1c6bfc00de679e008cf93f573f">&#9670;&nbsp;</a></span>_mm256_cvtepu8_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_cvtepu8_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero-extends the first four bytes from the 128-bit integer vector in <em>__V</em> and returns the 64-bit values in the corresponding elements of a 256-bit vector of [4 x i64]. </p>
<div class="fragment"><div class="line">result[63:0] := ZeroExtend(__V[7:0])</div>
<div class="line">result[127:64] := ZeroExtend(__V[15:8])</div>
<div class="line">result[191:128] := ZeroExtend(__V[23:16])</div>
<div class="line">result[255:192] := ZeroExtend(__V[31:24])</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVZXBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A 128-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the zero-extended values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01568">1568</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04194">_mm256_mask_cvtepu8_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04202">_mm256_maskz_cvtepu8_epi64()</a>.</p>

</div>
</div>
<a id="a04b15ed1ec6a9658484d049d654b4d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b15ed1ec6a9658484d049d654b4d3f">&#9670;&nbsp;</a></span>_mm256_hadd_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadd_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each sum in an element of the [16 x i16] result (overflow is ignored). </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := __a[j+15:j] + __a[j+31:j+16]</div>
<div class="line">  result[j+31:j+16] := __a[j+47:j+32] + __a[j+63:j+48]</div>
<div class="line">  result[j+47:j+32] := __a[j+79:j+64] + __a[j+95:j+80]</div>
<div class="line">  result[j+63:j+48] := __a[j+111:j+96] + __a[j+127:j+112]</div>
<div class="line">  result[j+79:j+64] := __b[j+15:j] + __b[j+31:j+16]</div>
<div class="line">  result[j+95:j+80] := __b[j+47:j+32] + __b[j+63:j+48]</div>
<div class="line">  result[j+111:j+96] := __b[j+79:j+64] + __b[j+95:j+80]</div>
<div class="line">  result[j+127:j+112] := __b[j+111:j+96] + __b[j+127:j+112]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00848">848</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="ae2d57af7ba2fcd4ff1fc40bd69a89c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d57af7ba2fcd4ff1fc40bd69a89c1e">&#9670;&nbsp;</a></span>_mm256_hadd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each sum in an element of the [8 x i32] result (overflow is ignored). </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+31:j] := __a[j+31:j] + __a[j+63:j+32]</div>
<div class="line">  result[j+63:j+32] := __a[j+95:j+64] + __a[j+127:j+96]</div>
<div class="line">  result[j+95:j+64] := __b[j+31:j] + __b[j+63:j+32]</div>
<div class="line">  result[j+127:j+96] := __b[j+95:j+64] + __b[j+127:j+96]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00880">880</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a6ac82b9f1eb9cec755e5bbff0e5a8c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac82b9f1eb9cec755e5bbff0e5a8c9a">&#9670;&nbsp;</a></span>_mm256_hadds_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hadds_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally adds the adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result. </p>
<p>Sums from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; sums from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := SATURATE16(__a[j+15:j] + __a[j+31:j+16])</div>
<div class="line">  result[j+31:j+16] := SATURATE16(__a[j+47:j+32] + __a[j+63:j+48])</div>
<div class="line">  result[j+47:j+32] := SATURATE16(__a[j+79:j+64] + __a[j+95:j+80])</div>
<div class="line">  result[j+63:j+48] := SATURATE16(__a[j+111:j+96] + __a[j+127:j+112])</div>
<div class="line">  result[j+79:j+64] := SATURATE16(__b[j+15:j] + __b[j+31:j+16])</div>
<div class="line">  result[j+95:j+80] := SATURATE16(__b[j+47:j+32] + __b[j+63:j+48])</div>
<div class="line">  result[j+111:j+96] := SATURATE16(__b[j+79:j+64] + __b[j+95:j+80])</div>
<div class="line">  result[j+127:j+112] := SATURATE16(__b[j+111:j+96] + __b[j+127:j+112])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHADDSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the sums. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00915">915</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a47dba9aa45c3b9f52e2acb9016fa2dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dba9aa45c3b9f52e2acb9016fa2dae">&#9670;&nbsp;</a></span>_mm256_hsub_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsub_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] and returns the lower 16 bits of each difference in an element of the [16 x i16] result (overflow is ignored). </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := __a[j+15:j] - __a[j+31:j+16]</div>
<div class="line">  result[j+31:j+16] := __a[j+47:j+32] - __a[j+63:j+48]</div>
<div class="line">  result[j+47:j+32] := __a[j+79:j+64] - __a[j+95:j+80]</div>
<div class="line">  result[j+63:j+48] := __a[j+111:j+96] - __a[j+127:j+112]</div>
<div class="line">  result[j+79:j+64] := __b[j+15:j] - __b[j+31:j+16]</div>
<div class="line">  result[j+95:j+80] := __b[j+47:j+32] - __b[j+63:j+48]</div>
<div class="line">  result[j+111:j+96] := __b[j+79:j+64] - __b[j+95:j+80]</div>
<div class="line">  result[j+127:j+112] := __b[j+111:j+96] - __b[j+127:j+112]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00951">951</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a72c77e9df5766726e6bc06112dc97d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c77e9df5766726e6bc06112dc97d44">&#9670;&nbsp;</a></span>_mm256_hsub_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsub_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 32-bit integers from two 256-bit vectors of [8 x i32] and returns the lower 32 bits of each difference in an element of the [8 x i32] result (overflow is ignored). </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+31:j] := __a[j+31:j] - __a[j+63:j+32]</div>
<div class="line">  result[j+63:j+32] := __a[j+95:j+64] - __a[j+127:j+96]</div>
<div class="line">  result[j+95:j+64] := __b[j+31:j] - __b[j+63:j+32]</div>
<div class="line">  result[j+127:j+96] := __b[j+95:j+64] - __b[j+127:j+96]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00983">983</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a85ce513f7958d273eaebafb97d071f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce513f7958d273eaebafb97d071f4b">&#9670;&nbsp;</a></span>_mm256_hsubs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_hsubs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Horizontally subtracts adjacent pairs of 16-bit integers from two 256-bit vectors of [16 x i16] using signed saturation and returns each sum in an element of the [16 x i16] result. </p>
<p>Differences from <em>__a</em> are returned in the lower 64 bits of each 128-bit half of the result; differences from <em>__b</em> are returned in the upper 64 bits of each 128-bit half of the result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*128</div>
<div class="line">  result[j+15:j] := SATURATE16(__a[j+15:j] - __a[j+31:j+16])</div>
<div class="line">  result[j+31:j+16] := SATURATE16(__a[j+47:j+32] - __a[j+63:j+48])</div>
<div class="line">  result[j+47:j+32] := SATURATE16(__a[j+79:j+64] - __a[j+95:j+80])</div>
<div class="line">  result[j+63:j+48] := SATURATE16(__a[j+111:j+96] - __a[j+127:j+112])</div>
<div class="line">  result[j+79:j+64] := SATURATE16(__b[j+15:j] - __b[j+31:j+16])</div>
<div class="line">  result[j+95:j+80] := SATURATE16(__b[j+47:j+32] - __b[j+63:j+48])</div>
<div class="line">  result[j+111:j+96] := SATURATE16(__b[j+79:j+64] - __b[j+95:j+80])</div>
<div class="line">  result[j+127:j+112] := SATURATE16(__b[j+111:j+96] - __b[j+127:j+112])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPHSUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01019">1019</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a9a736efeb017832345499b28c44af161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a736efeb017832345499b28c44af161">&#9670;&nbsp;</a></span>_mm256_madd_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_madd_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies corresponding 16-bit elements of two 256-bit vectors of [16 x i16], forming 32-bit intermediate products, and adds pairs of those products to form 32-bit sums returned as elements of the [8 x i32] result. </p>
<p>There is only one wraparound case: when all four of the 16-bit sources are <code>0x8000</code>, the result will be <code>0x80000000</code>.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  temp1 := __a[j+15:j] * __b[j+15:j]</div>
<div class="line">  temp2 := __a[j+31:j+16] * __b[j+31:j+16]</div>
<div class="line">  result[j+31:j] := temp1 + temp2</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMADDWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01081">1081</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01392">_mm256_mask_madd_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01399">_mm256_maskz_madd_epi16()</a>.</p>

</div>
</div>
<a id="a3f1ca72807cf9d112a8db52f1c688400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ca72807cf9d112a8db52f1c688400">&#9670;&nbsp;</a></span>_mm256_maddubs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maddubs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each unsigned byte from the 256-bit integer vector in <em>__a</em> with the corresponding signed byte from the 256-bit integer vector in <em>__b</em>, forming signed 16-bit intermediate products. </p>
<p>Adds adjacent pairs of those products using signed saturation to form 16-bit sums returned as elements of the [16 x i16] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  temp1 := __a[j+7:j] * __b[j+7:j]</div>
<div class="line">  temp2 := __a[j+15:j+8] * __b[j+15:j+8]</div>
<div class="line">  result[j+15:j] := SATURATE16(temp1 + temp2)</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMADDUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01049">1049</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01363">_mm256_mask_maddubs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01371">_mm256_maskz_maddubs_epi16()</a>.</p>

</div>
</div>
<a id="a22fd743b1c2f9aed720704b10114e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fd743b1c2f9aed720704b10114e42c">&#9670;&nbsp;</a></span>_mm256_maskload_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskload_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads eight 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 256-bit [8 x i32] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    result[j+31:j] := Load32(__X+(i*4))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [8 x i32] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03513">3513</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a1997e59ad47611e448defb72da464056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1997e59ad47611e448defb72da464056">&#9670;&nbsp;</a></span>_mm256_maskload_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskload_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads four 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 256-bit [4 x i64] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    result[j+63:j] := Load64(__X+(i*8))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [4 x i64] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03545">3545</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a1bf351469e97da264116eea7952c2aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf351469e97da264116eea7952c2aba">&#9670;&nbsp;</a></span>_mm256_maskstore_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskstore_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores eight 32-bit integer elements from the 256-bit vector of [8 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    Store32(__X+(i*4), __Y[j+31:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [8 x i32] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03639">3639</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a0559634edb55b319e7ee19baac957c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0559634edb55b319e7ee19baac957c95">&#9670;&nbsp;</a></span>_mm256_maskstore_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_maskstore_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores four 64-bit integer elements from the 256-bit vector of [4 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    Store64(__X+(i*8), __Y[j+63:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 256-bit vector of [4 x i64] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03669">3669</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a6c5111412077ead099ddee344188839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5111412077ead099ddee344188839b">&#9670;&nbsp;</a></span>_mm256_max_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01119">1119</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00921">_mm256_mask_max_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00913">_mm256_maskz_max_epi16()</a>.</p>

</div>
</div>
<a id="a6fbbe31483e96447c3e05be279bdc57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbbe31483e96447c3e05be279bdc57f">&#9670;&nbsp;</a></span>_mm256_max_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01138">1138</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03055">_mm256_mask_max_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03048">_mm256_maskz_max_epi32()</a>.</p>

</div>
</div>
<a id="a37b9e0bac773f0d39f3b41ef45d5d68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b9e0bac773f0d39f3b41ef45d5d68c">&#9670;&nbsp;</a></span>_mm256_max_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01100">1100</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00889">_mm256_mask_max_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00881">_mm256_maskz_max_epi8()</a>.</p>

</div>
</div>
<a id="a075d5a2c501aac700288afa0c508c973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d5a2c501aac700288afa0c508c973">&#9670;&nbsp;</a></span>_mm256_max_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01176">1176</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00985">_mm256_mask_max_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00977">_mm256_maskz_max_epu16()</a>.</p>

</div>
</div>
<a id="a51d1902c5c1b74ba78ba57686e3a5582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d1902c5c1b74ba78ba57686e3a5582">&#9670;&nbsp;</a></span>_mm256_max_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01195">1195</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03121">_mm256_mask_max_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03114">_mm256_maskz_max_epu32()</a>.</p>

</div>
</div>
<a id="a6210035d203bef654a1f1ade4da7c749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6210035d203bef654a1f1ade4da7c749">&#9670;&nbsp;</a></span>_mm256_max_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_max_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the larger of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMAXUB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01157">1157</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00953">_mm256_mask_max_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00945">_mm256_maskz_max_epu8()</a>.</p>

</div>
</div>
<a id="a6a3167f2bcae02dca2aadba469193eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3167f2bcae02dca2aadba469193eec">&#9670;&nbsp;</a></span>_mm256_min_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01233">1233</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01049">_mm256_mask_min_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01041">_mm256_maskz_min_epi16()</a>.</p>

</div>
</div>
<a id="a96199c8df080cc2b44caf3de79afcd7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96199c8df080cc2b44caf3de79afcd7a">&#9670;&nbsp;</a></span>_mm256_min_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01252">1252</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03187">_mm256_mask_min_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03180">_mm256_maskz_min_epi32()</a>.</p>

</div>
</div>
<a id="a2da8c62a81a77a136d34c0f5b7ee04db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da8c62a81a77a136d34c0f5b7ee04db">&#9670;&nbsp;</a></span>_mm256_min_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding signed bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01214">1214</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01017">_mm256_mask_min_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01009">_mm256_maskz_min_epi8()</a>.</p>

</div>
</div>
<a id="a189b0c70faa130570dc377be3841baa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189b0c70faa130570dc377be3841baa2">&#9670;&nbsp;</a></span>_mm256_min_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 16-bit integers in the two 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01290">1290</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01113">_mm256_mask_min_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01105">_mm256_maskz_min_epu16()</a>.</p>

</div>
</div>
<a id="ab20d0653c9d79d3962498325f0a4c65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20d0653c9d79d3962498325f0a4c65a">&#9670;&nbsp;</a></span>_mm256_min_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned 32-bit integers in the two 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding element of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01309">1309</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l03253">_mm256_mask_min_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l03246">_mm256_maskz_min_epu32()</a>.</p>

</div>
</div>
<a id="aa362f07383b28824491e2557d958fbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa362f07383b28824491e2557d958fbbe">&#9670;&nbsp;</a></span>_mm256_min_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_min_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the corresponding unsigned bytes in the two 256-bit integer vectors in <em>__a</em> and <em>__b</em> and returns the smaller of each pair in the corresponding byte of the 256-bit result. </p>
<p>This intrinsic corresponds to the <code>VPMINUB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01271">1271</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01081">_mm256_mask_min_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01073">_mm256_maskz_min_epu8()</a>.</p>

</div>
</div>
<a id="a5e0a0e64386916c1945fd80f63800234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0a0e64386916c1945fd80f63800234">&#9670;&nbsp;</a></span>_mm256_movemask_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_movemask_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a 32-bit integer mask from the most significant bit of each byte in the 256-bit integer vector in <em>__a</em> and returns the result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[i] := __a[j+7]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMOVMSKB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the source bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit integer mask. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01332">1332</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

</div>
</div>
<a id="a21f2fd1fb0472301c6f6534fbb2c55b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f2fd1fb0472301c6f6534fbb2c55b7">&#9670;&nbsp;</a></span>_mm256_mul_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mul_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 32-bit integers from even-numbered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result. </p>
<div class="fragment"><div class="line">result[63:0] := __a[31:0] * __b[31:0]</div>
<div class="line">result[127:64] := __a[95:64] * __b[95:64]</div>
<div class="line">result[191:128] := __a[159:128] * __b[159:128]</div>
<div class="line">result[255:192] := __a[223:192] * __b[223:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01670">1670</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00361">_mm256_mask_mul_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00369">_mm256_maskz_mul_epi32()</a>.</p>

</div>
</div>
<a id="ae82c156df6b966a0780fbf444cf05fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82c156df6b966a0780fbf444cf05fac">&#9670;&nbsp;</a></span>_mm256_mul_epu32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mul_epu32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies unsigned 32-bit integers from even-numered elements of two 256-bit vectors of [8 x i32] and returns the 64-bit products in the [4 x i64] result. </p>
<div class="fragment"><div class="line">result[63:0] := __a[31:0] * __b[31:0]</div>
<div class="line">result[127:64] := __a[95:64] * __b[95:64]</div>
<div class="line">result[191:128] := __a[159:128] * __b[159:128]</div>
<div class="line">result[255:192] := __a[223:192] * __b[223:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULUDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01799">1799</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00393">_mm256_mask_mul_epu32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00401">_mm256_maskz_mul_epu32()</a>.</p>

</div>
</div>
<a id="a77bfbbc6944e651816ee6d43cad179f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bfbbc6944e651816ee6d43cad179f9">&#9670;&nbsp;</a></span>_mm256_mulhi_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhi_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULHW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01735">1735</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01638">_mm256_mask_mulhi_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01645">_mm256_maskz_mulhi_epi16()</a>.</p>

</div>
</div>
<a id="a901d1db344d0637d0faedf57b68903e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901d1db344d0637d0faedf57b68903e8">&#9670;&nbsp;</a></span>_mm256_mulhi_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhi_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies unsigned 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the upper 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULHUW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01716">1716</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01610">_mm256_mask_mulhi_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01617">_mm256_maskz_mulhi_epu16()</a>.</p>

</div>
</div>
<a id="a53b7b55f3eed342b5e4054b0625c4b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b7b55f3eed342b5e4054b0625c4b13">&#9670;&nbsp;</a></span>_mm256_mulhrs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mulhrs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], truncates the 32-bit results to the most significant 18 bits, rounds by adding 1, and returns bits [16:1] of each rounded product in the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  temp := ((__a[j+15:j] * __b[j+15:j]) &gt;&gt; 14) + 1</div>
<div class="line">  result[j+15:j] := temp[16:1]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMULHRSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the rounded products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01697">1697</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01582">_mm256_mask_mulhrs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01589">_mm256_maskz_mulhrs_epi16()</a>.</p>

</div>
</div>
<a id="ab877a6985419ea9618d69a329cb88e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877a6985419ea9618d69a329cb88e9f">&#9670;&nbsp;</a></span>_mm256_mullo_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mullo_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 16-bit integer elements of two 256-bit vectors of [16 x i16], and returns the lower 16 bits of each 32-bit product in the [16 x i16] result. </p>
<p>This intrinsic corresponds to the <code>VPMULLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01754">1754</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00422">_mm256_mask_mullo_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00429">_mm256_maskz_mullo_epi16()</a>.</p>

</div>
</div>
<a id="a30c6da5556cf54db6bfc7d51eaf4118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c6da5556cf54db6bfc7d51eaf4118b">&#9670;&nbsp;</a></span>_mm256_mullo_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_mullo_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies signed 32-bit integer elements of two 256-bit vectors of [8 x i32], and returns the lower 32 bits of each 64-bit product in the [8 x i32] result. </p>
<p>This intrinsic corresponds to the <code>VPMULLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing one of the source operands. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the products. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01773">1773</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00433">_mm256_mask_mullo_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00425">_mm256_maskz_mullo_epi32()</a>.</p>

</div>
</div>
<a id="af941fc48c1c8d082fdfac5df1953156b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af941fc48c1c8d082fdfac5df1953156b">&#9670;&nbsp;</a></span>_mm256_or_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_or_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise OR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPOR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01817">1817</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a820ba07f5916a602806c2aecd6cd0f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820ba07f5916a602806c2aecd6cd0f69">&#9670;&nbsp;</a></span>_mm256_packs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the elements of two 256-bit vectors of [16 x i16] to 8-bit integers using signed saturation, and returns the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*8</div>
<div class="line">  result[7+k:k] := SATURATE8(__a[15+j:j])</div>
<div class="line">  result[71+k:64+k] := SATURATE8(__b[15+j:j])</div>
<div class="line">  result[135+k:128+k] := SATURATE8(__a[143+j:128+j])</div>
<div class="line">  result[199+k:192+k] := SATURATE8(__b[143+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKSSWB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00164">164</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00601">_mm256_mask_packs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00593">_mm256_maskz_packs_epi16()</a>.</p>

</div>
</div>
<a id="a18f0a34407f0edaa6728ec94ced2431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f0a34407f0edaa6728ec94ced2431a">&#9670;&nbsp;</a></span>_mm256_packs_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packs_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the elements of two 256-bit vectors of [8 x i32] to 16-bit integers using signed saturation, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := i*16</div>
<div class="line">  result[15+k:k] := SATURATE16(__a[31+j:j])</div>
<div class="line">  result[79+k:64+k] := SATURATE16(__b[31+j:j])</div>
<div class="line">  result[143+k:128+k] := SATURATE16(__a[159+j:128+j])</div>
<div class="line">  result[207+k:192+k] := SATURATE16(__b[159+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKSSDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00196">196</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00569">_mm256_mask_packs_epi32()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00561">_mm256_maskz_packs_epi32()</a>.</p>

</div>
</div>
<a id="ac54fdcd67534f2defc6f2564d7a031f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54fdcd67534f2defc6f2564d7a031f5">&#9670;&nbsp;</a></span>_mm256_packus_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packus_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts elements from two 256-bit vectors of [16 x i16] to 8-bit integers using unsigned saturation, and returns the 256-bit result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*16</div>
<div class="line">  k := i*8</div>
<div class="line">  result[7+k:k] := SATURATE8U(__a[15+j:j])</div>
<div class="line">  result[71+k:64+k] := SATURATE8U(__b[15+j:j])</div>
<div class="line">  result[135+k:128+k] := SATURATE8U(__a[143+j:128+j])</div>
<div class="line">  result[199+k:192+k] := SATURATE8U(__b[143+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKUSWB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00227">227</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00665">_mm256_mask_packus_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00657">_mm256_maskz_packus_epi16()</a>.</p>

</div>
</div>
<a id="aa67ddfcbac48b6687c29540ba34187da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67ddfcbac48b6687c29540ba34187da">&#9670;&nbsp;</a></span>_mm256_packus_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_packus_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts elements from two 256-bit vectors of [8 x i32] to 16-bit integers using unsigned saturation, and returns the resulting 256-bit vector of [16 x i16]. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  k := i*16</div>
<div class="line">  result[15+k:k] := SATURATE16U(__V1[31+j:j])</div>
<div class="line">  result[79+k:64+k] := SATURATE16U(__V2[31+j:j])</div>
<div class="line">  result[143+k:128+k] := SATURATE16U(__V1[159+j:128+j])</div>
<div class="line">  result[207+k:192+k] := SATURATE16U(__V2[159+j:128+j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPACKUSDW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V1</td><td>A 256-bit vector of [8 x i32] used to generate result[63:0] and result[191:128]. </td></tr>
    <tr><td class="paramname">__V2</td><td>A 256-bit vector of [8 x i32] used to generate result[127:64] and result[255:192]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l00259">259</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00633">_mm256_mask_packus_epi32()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00625">_mm256_maskz_packus_epi32()</a>.</p>

</div>
</div>
<a id="a33d9bff425325a7c8e2a4f857e3d0b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9bff425325a7c8e2a4f857e3d0b22">&#9670;&nbsp;</a></span>_mm256_permutevar8x32_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_permutevar8x32_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [8 x i32] to copies of elements of the 256-bit vector of [8 x i32] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  k := __b[j+2:j] * 32</div>
<div class="line">  result[j+31:j] := __a[k+31:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing the source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing indexes of values to use from <em>__a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03303">3303</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a5c4284aa3d71d30c3241c1ea550f4429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4284aa3d71d30c3241c1ea550f4429">&#9670;&nbsp;</a></span>_mm256_permutevar8x32_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256 <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_permutevar8x32_ps </td>
          <td>(</td>
          <td class="paramtype">__m256&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the result's 256-bit vector of [8 x float] to copies of elements of the 256-bit vector of [8 x float] in <em>__a</em> as specified by indexes in the elements of the 256-bit vector of [8 x i32] in <em>__b</em>. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  k := __b[j+2:j] * 32</div>
<div class="line">  result[j+31:j] := __a[k+31:k]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPERMPS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x float] containing the source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing indexes of values to use from <em>__a</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03361">3361</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="af3080ecebc68a7fcfa068821af41d077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3080ecebc68a7fcfa068821af41d077">&#9670;&nbsp;</a></span>_mm256_sad_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sad_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes four sum of absolute difference (SAD) operations on sets of eight unsigned 8-bit integers from the 256-bit integer vectors <em>__a</em> and <em>__b</em>. </p>
<p>One SAD result is computed for each set of eight bytes from <em>__a</em> and eight bytes from <em>__b</em>. The zero-extended SAD value is returned in the corresponding 64-bit element of the result.</p>
<p>A single SAD operation takes the differences between the corresponding bytes of <em>__a</em> and <em>__b</em>, takes the absolute value of each difference, and sums these eight values to form one 16-bit result. This operation is repeated four times with successive sets of eight bytes.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  temp0 := ABS(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">  temp1 := ABS(__a[j+15:j+8] - __b[j+15:j+8])</div>
<div class="line">  temp2 := ABS(__a[j+23:j+16] - __b[j+23:j+16])</div>
<div class="line">  temp3 := ABS(__a[j+31:j+24] - __b[j+31:j+24])</div>
<div class="line">  temp4 := ABS(__a[j+39:j+32] - __b[j+39:j+32])</div>
<div class="line">  temp5 := ABS(__a[j+47:j+40] - __b[j+47:j+40])</div>
<div class="line">  temp6 := ABS(__a[j+55:j+48] - __b[j+55:j+48])</div>
<div class="line">  temp7 := ABS(__a[j+63:j+56] - __b[j+63:j+56])</div>
<div class="line">  result[j+15:j] := temp0 + temp1 + temp2 + temp3 +</div>
<div class="line">                    temp4 + temp5 + temp6 + temp7</div>
<div class="line">  result[j+63:j+16] := 0</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSADBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01862">1862</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a1ead06ffdd788a0be29d1e004cee07a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ead06ffdd788a0be29d1e004cee07a9">&#9670;&nbsp;</a></span>_mm256_shuffle_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_shuffle_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffles 8-bit integers in the 256-bit integer vector <em>__a</em> according to control information in the 256-bit integer vector <em>__b</em>, and returns the 256-bit result. </p>
<p>In effect there are two separate 128-bit shuffles in the lower and upper halves.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  IF __b[j+7] == 1</div>
<div class="line">    result[j+7:j] := 0</div>
<div class="line">  ELSE</div>
<div class="line">    k := __b[j+3:j] * 8</div>
<div class="line">    IF i &gt; 15</div>
<div class="line">      k := k + 128</div>
<div class="line">    FI</div>
<div class="line">    result[j+7:j] := __a[k+7:k]</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSHUFB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing source values. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing control information to determine what goes into the corresponding byte of the result. If bit 7 of the control byte is 1, the result byte is 0; otherwise, bits 3:0 of the control byte specify the index (within the same 128-bit half) of <em>__a</em> to copy to the result byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l01901">1901</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01137">_mm256_mask_shuffle_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01145">_mm256_maskz_shuffle_epi8()</a>.</p>

</div>
</div>
<a id="ae1cd3c3fea44760c82d99a31a8d830ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cd3c3fea44760c82d99a31a8d830ba">&#9670;&nbsp;</a></span>_mm256_sign_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of the result to the corresponding element of the 256-bit vector of [16 x i16] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [16 x i16] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGNW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02049">2049</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a67755b8ffa509f28de03a05df580fbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67755b8ffa509f28de03a05df580fbc1">&#9670;&nbsp;</a></span>_mm256_sign_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each element of the result to the corresponding element of the 256-bit vector of [8 x i32] in <em>__a</em>, the negative of that element, or zero, depending on whether the corresponding element of the 256-bit vector of [8 x i32] in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGND</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32]. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02070">2070</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a77846fd35105eb6f2cbcef08f2b75140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77846fd35105eb6f2cbcef08f2b75140">&#9670;&nbsp;</a></span>_mm256_sign_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sign_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets each byte of the result to the corresponding byte of the 256-bit integer vector in <em>__a</em>, the negative of that byte, or zero, depending on whether the corresponding byte of the 256-bit integer vector in <em>__b</em> is greater than zero, less than zero, or equal to zero, respectively. </p>
<p>This intrinsic corresponds to the <code>VPSIGNB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02028">2028</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a5606790c952e969809a59ddf1e3510cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5606790c952e969809a59ddf1e3510cf">&#9670;&nbsp;</a></span>_mm256_sll_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by the number of bits specified by the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02150">2150</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01932">_mm256_mask_sll_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01940">_mm256_maskz_sll_epi16()</a>.</p>

</div>
</div>
<a id="a0bff83b0c5ed8e28733927ba2ab93296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff83b0c5ed8e28733927ba2ab93296">&#9670;&nbsp;</a></span>_mm256_sll_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02190">2190</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04515">_mm256_mask_sll_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04523">_mm256_maskz_sll_epi32()</a>.</p>

</div>
</div>
<a id="a160466de250277c0621a1914f45cc2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160466de250277c0621a1914f45cc2a2">&#9670;&nbsp;</a></span>_mm256_sll_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sll_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02230">2230</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04579">_mm256_mask_sll_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04587">_mm256_maskz_sll_epi64()</a>.</p>

</div>
</div>
<a id="a9142525f9097a70a473365d4819be609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9142525f9097a70a473365d4819be609">&#9670;&nbsp;</a></span>_mm256_slli_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02129">2129</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01964">_mm256_mask_slli_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01973">_mm256_maskz_slli_epi16()</a>.</p>

</div>
</div>
<a id="a1c8e153c8a1e0c5b909a192ccec34187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8e153c8a1e0c5b909a192ccec34187">&#9670;&nbsp;</a></span>_mm256_slli_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02169">2169</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04547">_mm256_mask_slli_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04555">_mm256_maskz_slli_epi32()</a>.</p>

</div>
</div>
<a id="ad40e1a7a9fd378072b072fbc369db480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e1a7a9fd378072b072fbc369db480">&#9670;&nbsp;</a></span>_mm256_slli_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_slli_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> left by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSLLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02209">2209</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04611">_mm256_mask_slli_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04619">_mm256_maskz_slli_epi64()</a>.</p>

</div>
</div>
<a id="a71d8eebf24183f66e3cd905501948068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d8eebf24183f66e3cd905501948068">&#9670;&nbsp;</a></span>_mm256_sllv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sllv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03751">3751</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04763">_mm256_mask_sllv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04771">_mm256_maskz_sllv_epi32()</a>.</p>

</div>
</div>
<a id="a3d328c38377911cc60da2a7c6d5363f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d328c38377911cc60da2a7c6d5363f5">&#9670;&nbsp;</a></span>_mm256_sllv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sllv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03795">3795</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04731">_mm256_mask_sllv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04739">_mm256_maskz_sllv_epi64()</a>.</p>

</div>
</div>
<a id="ad6812ecb21f05132dbb5ce31ed82aabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6812ecb21f05132dbb5ce31ed82aabe">&#9670;&nbsp;</a></span>_mm256_sra_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sra_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02272">2272</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02085">_mm256_mask_sra_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02093">_mm256_maskz_sra_epi16()</a>.</p>

</div>
</div>
<a id="a933b5cc7264b4572e61702aa385250c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933b5cc7264b4572e61702aa385250c6">&#9670;&nbsp;</a></span>_mm256_sra_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sra_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02314">2314</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06398">_mm256_mask_sra_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06406">_mm256_maskz_sra_epi32()</a>.</p>

</div>
</div>
<a id="abb9640e28a301bd54f3c6eba51e91180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9640e28a301bd54f3c6eba51e91180">&#9670;&nbsp;</a></span>_mm256_srai_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srai_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02250">2250</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02117">_mm256_mask_srai_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02126">_mm256_maskz_srai_epi16()</a>.</p>

</div>
</div>
<a id="a241b64b22d24b260ffb9a7018b1f8cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241b64b22d24b260ffb9a7018b1f8cca">&#9670;&nbsp;</a></span>_mm256_srai_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srai_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in sign bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, each element of the result is either 0 or -1 according to the corresponding input sign bit.</p>
<p>This intrinsic corresponds to the <code>VPSRAD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02292">2292</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06430">_mm256_mask_srai_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06438">_mm256_maskz_srai_epi32()</a>.</p>

</div>
</div>
<a id="a58df154a23884308de2be8f1673431bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58df154a23884308de2be8f1673431bb">&#9670;&nbsp;</a></span>_mm256_srav_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srav_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is 0 or -1 according to the sign bit for that element.</p>
<p>This intrinsic corresponds to the <code>VPSRAVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03840">3840</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04987">_mm256_mask_srav_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04995">_mm256_maskz_srav_epi32()</a>.</p>

</div>
</div>
<a id="a0204190987d295602363fac8e957bc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0204190987d295602363fac8e957bc88">&#9670;&nbsp;</a></span>_mm256_srl_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02394">2394</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02150">_mm256_mask_srl_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02158">_mm256_maskz_srl_epi16()</a>.</p>

</div>
</div>
<a id="a006440af4ed63245caff87056b25c3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006440af4ed63245caff87056b25c3d1">&#9670;&nbsp;</a></span>_mm256_srl_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02434">2434</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04859">_mm256_mask_srl_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04867">_mm256_maskz_srl_epi32()</a>.</p>

</div>
</div>
<a id="acf26700184b5a83da79aca8f9ade7fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf26700184b5a83da79aca8f9ade7fc3">&#9670;&nbsp;</a></span>_mm256_srl_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srl_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by the number of bits given in the lower 64 bits of <em>__count</em>, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>A 128-bit vector of [2 x i64] whose lower element gives the unsigned shift count (in bits). The upper element is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02474">2474</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04923">_mm256_mask_srl_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04931">_mm256_maskz_srl_epi64()</a>.</p>

</div>
</div>
<a id="afdd37fdb3fd0ebf8b12261a4c5eb325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd37fdb3fd0ebf8b12261a4c5eb325e">&#9670;&nbsp;</a></span>_mm256_srli_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 16-bit element of the 256-bit vector of [16 x i16] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 15, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02373">2373</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02182">_mm256_mask_srli_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02190">_mm256_maskz_srli_epi16()</a>.</p>

</div>
</div>
<a id="acfa577e01c74cd9071fb09c857fad1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa577e01c74cd9071fb09c857fad1c2">&#9670;&nbsp;</a></span>_mm256_srli_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 31, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02413">2413</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04891">_mm256_mask_srli_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04899">_mm256_maskz_srli_epi32()</a>.</p>

</div>
</div>
<a id="a00ca9a97310214d3f0e85302dd877dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ca9a97310214d3f0e85302dd877dc5">&#9670;&nbsp;</a></span>_mm256_srli_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srli_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td>
          <td class="paramname"><em>__count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__a</em> right by <em>__count</em> bits, shifting in zero bits, and returns the result. </p>
<p>If <em>__count</em> is greater than 63, the returned result is all zeroes.</p>
<p>This intrinsic corresponds to the <code>VPSRLQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__count</td><td>An unsigned integer value specifying the shift count (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02453">2453</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04955">_mm256_mask_srli_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04963">_mm256_maskz_srli_epi64()</a>.</p>

</div>
</div>
<a id="a9cc3e0a1a4e2bbbc72630cf26ed54225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc3e0a1a4e2bbbc72630cf26ed54225">&#9670;&nbsp;</a></span>_mm256_srlv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srlv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 256-bit vector of [8 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 256-bit vector of [8 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [8 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [8 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03885">3885</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04827">_mm256_mask_srlv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04835">_mm256_maskz_srlv_epi32()</a>.</p>

</div>
</div>
<a id="a77501391ed2c52d990a2c4004e86c36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77501391ed2c52d990a2c4004e86c36d">&#9670;&nbsp;</a></span>_mm256_srlv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_srlv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 256-bit vector of [4 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 256-bit vector of [4 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 256-bit vector of [4 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03929">3929</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04795">_mm256_mask_srlv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04803">_mm256_maskz_srlv_epi64()</a>.</p>

</div>
</div>
<a id="a062648ed7516d4b7f9304d8a66947877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062648ed7516d4b7f9304d8a66947877">&#9670;&nbsp;</a></span>_mm256_stream_load_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_stream_load_si256 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>__V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the 256-bit integer vector from memory <em>__V</em> using a non-temporal memory hint and returns the vector. </p>
<p><em>__V</em> must be aligned on a 32-byte boundary.</p>
<p>This intrinsic corresponds to the <code>VMOVNTDQA</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__V</td><td>A pointer to the 32-byte aligned memory containing the vector to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector loaded from memory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02986">2986</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="PrimType_8h_source.html#l00103">clang::interp::aligned()</a>.</p>

</div>
</div>
<a id="a31e2c682612c87d32af88011175c7893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e2c682612c87d32af88011175c7893">&#9670;&nbsp;</a></span>_mm256_sub_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16]. </p>
<p>Returns the lower 16 bits of each difference in the corresponding element of the [16 x i16] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := __a[j+15:j] - __b[j+15:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02528">2528</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00352">_mm256_mask_sub_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00359">_mm256_maskz_sub_epi16()</a>.</p>

</div>
</div>
<a id="ab606b56493b9e67d5aa9413c66bd27cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab606b56493b9e67d5aa9413c66bd27cd">&#9670;&nbsp;</a></span>_mm256_sub_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 32-bit integers from corresponding elements of two 256-bit vectors of [8 x i32]. </p>
<p>Returns the lower 32 bits of each difference in the corresponding element of the [8 x i32] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 7</div>
<div class="line">  j := i*32</div>
<div class="line">  result[j+31:j] := __a[j+31:j] - __b[j+31:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02554">2554</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00265">_mm256_mask_sub_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00273">_mm256_maskz_sub_epi32()</a>.</p>

</div>
</div>
<a id="a3b4f41e586cb7b8643ffdee43f3a6ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4f41e586cb7b8643ffdee43f3a6ce6">&#9670;&nbsp;</a></span>_mm256_sub_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 64-bit integers from corresponding elements of two 256-bit vectors of [4 x i64]. </p>
<p>Returns the lower 64 bits of each difference in the corresponding element of the [4 x i64] result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*64</div>
<div class="line">  result[j+63:j] := __a[j+63:j] - __b[j+63:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02580">2580</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l00281">_mm256_mask_sub_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l00289">_mm256_maskz_sub_epi64()</a>.</p>

</div>
</div>
<a id="a8fbe41f0f99a6839f3c4a5d4d992ca2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbe41f0f99a6839f3c4a5d4d992ca2a">&#9670;&nbsp;</a></span>_mm256_sub_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_sub_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors. </p>
<p>Returns the lower 8 bits of each difference in the corresponding byte of the 256-bit integer vector result (overflow is ignored).</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := __a[j+7:j] - __b[j+7:j]</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02501">2501</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l00338">_mm256_mask_sub_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l00345">_mm256_maskz_sub_epi8()</a>.</p>

</div>
</div>
<a id="aac62e43e232e2fe74019c3839e22d0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac62e43e232e2fe74019c3839e22d0ea">&#9670;&nbsp;</a></span>_mm256_subs_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using signed saturation, and returns each difference in the corresponding element of the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+7:j] := SATURATE16(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02632">2632</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01201">_mm256_mask_subs_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01209">_mm256_maskz_subs_epi16()</a>.</p>

</div>
</div>
<a id="a5e9a78b79f3e386367de719217e8b9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9a78b79f3e386367de719217e8b9b1">&#9670;&nbsp;</a></span>_mm256_subs_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using signed saturation, and returns each differences in the corresponding byte of the 256-bit integer vector result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := SATURATE8(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02606">2606</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01169">_mm256_mask_subs_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01177">_mm256_maskz_subs_epi8()</a>.</p>

</div>
</div>
<a id="afd2bf28cc66f89d73790bcaed2e6e502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2bf28cc66f89d73790bcaed2e6e502">&#9670;&nbsp;</a></span>_mm256_subs_epu16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epu16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 16-bit integers from corresponding elements of two 256-bit vectors of [16 x i16] using unsigned saturation, and returns each difference in the corresponding element of the [16 x i16] result. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 15</div>
<div class="line">  j := i*16</div>
<div class="line">  result[j+15:j] := SATURATE16U(__a[j+15:j] - __b[j+15:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBUSW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02685">2685</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01265">_mm256_mask_subs_epu16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01273">_mm256_maskz_subs_epu16()</a>.</p>

</div>
</div>
<a id="a2af8efc1fee79411d45f2094d6a5bd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af8efc1fee79411d45f2094d6a5bd6b">&#9670;&nbsp;</a></span>_mm256_subs_epu8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_subs_epu8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts 8-bit integers from corresponding bytes of two 256-bit integer vectors using unsigned saturation, and returns each difference in the corresponding byte of the 256-bit integer vector result. </p>
<p>For each byte, computes <code> result = __a - __b </code>.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 31</div>
<div class="line">  j := i*8</div>
<div class="line">  result[j+7:j] := SATURATE8U(__a[j+7:j] - __b[j+7:j])</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPSUBUSB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector containing the minuends. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector containing the subtrahends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the differences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02659">2659</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01233">_mm256_mask_subs_epu8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01241">_mm256_maskz_subs_epu8()</a>.</p>

</div>
</div>
<a id="a76bb3e33051c22956a29e267c841ce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bb3e33051c22956a29e267c841ce2c">&#9670;&nbsp;</a></span>_mm256_unpackhi_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[15:0] := __a[79:64]</div>
<div class="line">result[31:16] := __b[79:64]</div>
<div class="line">result[47:32] := __a[95:80]</div>
<div class="line">result[63:48] := __b[95:80]</div>
<div class="line">. . .</div>
<div class="line">result[127:112] := __b[127:112]</div>
<div class="line">result[143:128] := __a[211:196]</div>
<div class="line">. . .</div>
<div class="line">result[255:240] := __b[255:240]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02754">2754</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01694">_mm256_mask_unpackhi_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01701">_mm256_maskz_unpackhi_epi16()</a>.</p>

</div>
</div>
<a id="a6d4d291187e5354e99a80fa31e0a2599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4d291187e5354e99a80fa31e0a2599">&#9670;&nbsp;</a></span>_mm256_unpackhi_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[31:0] := __a[95:64]</div>
<div class="line">result[63:32] := __b[95:64]</div>
<div class="line">result[95:64] := __a[127:96]</div>
<div class="line">result[127:96] := __b[127:96]</div>
<div class="line">result[159:128] := __a[223:192]</div>
<div class="line">result[191:160] := __b[223:192]</div>
<div class="line">result[223:192] := __a[255:224]</div>
<div class="line">result[255:224] := __b[255:224]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02788">2788</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06270">_mm256_mask_unpackhi_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06278">_mm256_maskz_unpackhi_epi32()</a>.</p>

</div>
</div>
<a id="ac53f37866e6d12b621cd8dd638dcfe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53f37866e6d12b621cd8dd638dcfe49">&#9670;&nbsp;</a></span>_mm256_unpackhi_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64]. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[63:0] := __a[127:64]</div>
<div class="line">result[127:64] := __b[127:64]</div>
<div class="line">result[191:128] := __a[255:192]</div>
<div class="line">result[255:192] := __b[255:192]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHQDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02818">2818</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06302">_mm256_mask_unpackhi_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06310">_mm256_maskz_unpackhi_epi64()</a>.</p>

</div>
</div>
<a id="a4358789fa27173bf6e2d7b10c73418fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4358789fa27173bf6e2d7b10c73418fd">&#9670;&nbsp;</a></span>_mm256_unpackhi_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpackhi_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result. </p>
<p>Specifically, uses the upper 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[7:0] := __a[71:64]</div>
<div class="line">result[15:8] := __b[71:64]</div>
<div class="line">result[23:16] := __a[79:72]</div>
<div class="line">result[31:24] := __b[79:72]</div>
<div class="line">. . .</div>
<div class="line">result[127:120] := __b[127:120]</div>
<div class="line">result[135:128] := __a[199:192]</div>
<div class="line">. . .</div>
<div class="line">result[255:248] := __b[255:248]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKHBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector used as the source for the even-numbered bytes of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector used as the source for the odd-numbered bytes of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02719">2719</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01666">_mm256_mask_unpackhi_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01673">_mm256_maskz_unpackhi_epi8()</a>.</p>

</div>
</div>
<a id="abc29f2b775e0c3d34958e970252c37c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc29f2b775e0c3d34958e970252c37c0">&#9670;&nbsp;</a></span>_mm256_unpacklo_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 16-bit integers from parts of the 256-bit vectors of [16 x i16] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [16 x i16]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[15:0] := __a[15:0]</div>
<div class="line">result[31:16] := __b[15:0]</div>
<div class="line">result[47:32] := __a[31:16]</div>
<div class="line">result[63:48] := __b[31:16]</div>
<div class="line">. . .</div>
<div class="line">result[127:112] := __b[63:48]</div>
<div class="line">result[143:128] := __a[143:128]</div>
<div class="line">. . .</div>
<div class="line">result[255:239] := __b[191:176]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLWD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [16 x i16] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [16 x i16] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [16 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02887">2887</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01750">_mm256_mask_unpacklo_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01757">_mm256_maskz_unpacklo_epi16()</a>.</p>

</div>
</div>
<a id="a48355543080a7cbf1fcc3d38c8636b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48355543080a7cbf1fcc3d38c8636b3d">&#9670;&nbsp;</a></span>_mm256_unpacklo_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 32-bit integers from parts of the 256-bit vectors of [8 x i32] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [8 x i32]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[31:0] := __a[31:0]</div>
<div class="line">result[63:32] := __b[31:0]</div>
<div class="line">result[95:64] := __a[63:32]</div>
<div class="line">result[127:96] := __b[63:32]</div>
<div class="line">result[159:128] := __a[159:128]</div>
<div class="line">result[191:160] := __b[159:128]</div>
<div class="line">result[223:192] := __a[191:160]</div>
<div class="line">result[255:224] := __b[191:190]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [8 x i32] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [8 x i32] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [8 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02921">2921</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06334">_mm256_mask_unpacklo_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06342">_mm256_maskz_unpacklo_epi32()</a>.</p>

</div>
</div>
<a id="a0d22290d67e283811757c56bf20ab0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d22290d67e283811757c56bf20ab0f4">&#9670;&nbsp;</a></span>_mm256_unpacklo_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 64-bit integers from parts of the 256-bit vectors of [4 x i64] in <em>__a</em> and <em>__b</em> to return the resulting 256-bit vector of [4 x i64]. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[63:0] := __a[63:0]</div>
<div class="line">result[127:64] := __b[63:0]</div>
<div class="line">result[191:128] := __a[191:128]</div>
<div class="line">result[255:192] := __b[191:128]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLQDQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit vector of [4 x i64] used as the source for the even-numbered elements of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit vector of [4 x i64] used as the source for the odd-numbered elements of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit vector of [4 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02951">2951</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06366">_mm256_mask_unpacklo_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06374">_mm256_maskz_unpacklo_epi64()</a>.</p>

</div>
</div>
<a id="aac1606df7412921d94f00a69091b79fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1606df7412921d94f00a69091b79fd">&#9670;&nbsp;</a></span>_mm256_unpacklo_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_unpacklo_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks and interleaves 8-bit integers from parts of the 256-bit integer vectors in <em>__a</em> and <em>__b</em> to form the 256-bit result. </p>
<p>Specifically, uses the lower 64 bits of each 128-bit half of <em>__a</em> and <em>__b</em> as input; other bits in these parameters are ignored.</p>
<div class="fragment"><div class="line">result[7:0] := __a[7:0]</div>
<div class="line">result[15:8] := __b[7:0]</div>
<div class="line">result[23:16] := __a[15:8]</div>
<div class="line">result[31:24] := __b[15:8]</div>
<div class="line">. . .</div>
<div class="line">result[127:120] := __b[63:56]</div>
<div class="line">result[135:128] := __a[135:128]</div>
<div class="line">. . .</div>
<div class="line">result[255:248] := __b[191:184]</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPUNPCKLBW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector used as the source for the even-numbered bytes of the result. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector used as the source for the odd-numbered bytes of the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02852">2852</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l01722">_mm256_mask_unpacklo_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l01729">_mm256_maskz_unpacklo_epi8()</a>.</p>

</div>
</div>
<a id="a5cb76d9ee538f1556ce95a0a309224da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb76d9ee538f1556ce95a0a309224da">&#9670;&nbsp;</a></span>_mm256_xor_si256()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m256i <a class="el" href="xopintrin_8h.html#a9c3364b71a7fe0439ba73567fc303fcc">__DEFAULT_FN_ATTRS256</a> _mm256_xor_si256 </td>
          <td>(</td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m256i&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the bitwise XOR of the 256-bit integer vectors in <em>__a</em> and <em>__b</em>. </p>
<p>This intrinsic corresponds to the <code>VPXOR</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 256-bit integer vector. </td></tr>
    <tr><td class="paramname">__b</td><td>A 256-bit integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 256-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l02969">2969</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>, and <a class="el" href="altivec_8h_source.html#l00578">__b</a>.</p>

</div>
</div>
<a id="a2719f57e8449edf0a868707685fcbfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2719f57e8449edf0a868707685fcbfba">&#9670;&nbsp;</a></span>_mm_broadcastb_epi8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastb_epi8 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low byte from the 128-bit integer vector in <em>__X</em> to all bytes of the 128-bit result. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTB</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit integer vector whose low byte will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit integer vector containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03227">3227</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02622">_mm_mask_broadcastb_epi8()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02630">_mm_maskz_broadcastb_epi8()</a>.</p>

</div>
</div>
<a id="a10f391075669a7b417e83af174398a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f391075669a7b417e83af174398a9b">&#9670;&nbsp;</a></span>_mm_broadcastd_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastd_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [4 x i32] in <em>__X</em> to all elements of the result's vector of [4 x i32]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03259">3259</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06890">_mm_mask_broadcastd_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06898">_mm_maskz_broadcastd_epi32()</a>.</p>

</div>
</div>
<a id="ace283494a6faf8c26cb5553c007a78ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace283494a6faf8c26cb5553c007a78ef">&#9670;&nbsp;</a></span>_mm_broadcastq_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastq_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [2 x i64] in <em>__X</em> to both elements of the result's 128-bit vector of [2 x i64]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03275">3275</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06922">_mm_mask_broadcastq_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06930">_mm_maskz_broadcastq_epi64()</a>.</p>

</div>
</div>
<a id="a9aed0394b1e2f9ff4a0a8099637dd3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed0394b1e2f9ff4a0a8099637dd3d3">&#9670;&nbsp;</a></span>_mm_broadcastsd_pd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128d <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastsd_pd </td>
          <td>(</td>
          <td class="paramtype">__m128d&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 64-bit floating-point value from the low element of the 128-bit vector of [2 x double] in <em>__a</em> to both elements of the result's 128-bit vector of [2 x double]. </p>
<p>This intrinsic corresponds to the <code>MOVDDUP</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A 128-bit vector of [2 x double] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x double] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03021">3021</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="emmintrin_8h_source.html#l04057">__a</a>.</p>

</div>
</div>
<a id="a7636713aae00b362d71015a3f444d079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7636713aae00b362d71015a3f444d079">&#9670;&nbsp;</a></span>_mm_broadcastss_ps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128 <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastss_ps </td>
          <td>(</td>
          <td class="paramtype">__m128&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the 32-bit floating-point value from the low element of the 128-bit vector of [4 x float] in <em>__X</em> to all elements of the result's 128-bit vector of [4 x float]. </p>
<p>This intrinsic corresponds to the <code>VBROADCASTSS</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x float] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x float] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03004">3004</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l06858">_mm_mask_broadcastss_ps()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l06866">_mm_maskz_broadcastss_ps()</a>.</p>

</div>
</div>
<a id="a865b5e9e77ac8e5f7f639806936c7113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b5e9e77ac8e5f7f639806936c7113">&#9670;&nbsp;</a></span>_mm_broadcastw_epi16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_broadcastw_epi16 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcasts the low element from the 128-bit vector of [8 x i16] in <em>__X</em> to all elements of the result's 128-bit vector of [8 x i16]. </p>
<p>This intrinsic corresponds to the <code>VPBROADCASTW</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [8 x i16] whose low element will be broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [8 x i16] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03243">3243</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlbwintrin_8h_source.html#l02654">_mm_mask_broadcastw_epi16()</a>, and <a class="el" href="avx512vlbwintrin_8h_source.html#l02662">_mm_maskz_broadcastw_epi16()</a>.</p>

</div>
</div>
<a id="a694947e72cdcd91cace9252259d8cc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694947e72cdcd91cace9252259d8cc9e">&#9670;&nbsp;</a></span>_mm_maskload_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskload_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> const *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads four 32-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 128-bit [4 x i32] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    result[j+31:j] := Load32(__X+(i*4))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+31:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [4 x i32] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03577">3577</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="adf51c2e90947a2569e048166b39e4495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf51c2e90947a2569e048166b39e4495">&#9670;&nbsp;</a></span>_mm_maskload_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskload_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long const *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally loads two 64-bit integer elements from memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, sets that element of the result to zero. </p>
<p>Returns the 128-bit [2 x i64] result.</p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    result[j+63:j] := Load64(__X+(i*8))</div>
<div class="line">  ELSE</div>
<div class="line">    result[j+63:j] := 0</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for loading values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [2 x i64] containing the mask bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the loaded or zeroed elements. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03609">3609</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

</div>
</div>
<a id="a8d960541afa801cef10bec77aac5e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d960541afa801cef10bec77aac5e258">&#9670;&nbsp;</a></span>_mm_maskstore_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskstore_epi32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores four 32-bit integer elements from the 128-bit vector of [4 x i32] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 3</div>
<div class="line">  j := i*32</div>
<div class="line">  IF __M[j+31] == 1</div>
<div class="line">    Store32(__X+(i*4), __Y[j+31:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [4 x i32] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03699">3699</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a582da479a1ada35c7316c4deab34adfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582da479a1ada35c7316c4deab34adfd">&#9670;&nbsp;</a></span>_mm_maskstore_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ void <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_maskstore_epi64 </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally stores two 64-bit integer elements from the 128-bit vector of [2 x i64] in <em>__Y</em> to memory <em>__X</em>, if the most significant bit of the corresponding element in the mask <em>__M</em> is set; otherwise, the memory element is unchanged. </p>
<div class="fragment"><div class="line">FOR i := 0 TO 1</div>
<div class="line">  j := i*64</div>
<div class="line">  IF __M[j+63] == 1</div>
<div class="line">    Store64(__X+(i*8), __Y[j+63:j])</div>
<div class="line">  FI</div>
<div class="line">ENDFOR</div>
</div><!-- fragment --><p>This intrinsic corresponds to the <code>VPMASKMOVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A pointer to the memory used for storing values. </td></tr>
    <tr><td class="paramname">__M</td><td>A 128-bit vector of [2 x i64] containing the mask bits. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the values to store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03729">3729</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

</div>
</div>
<a id="a699470176eaef166e2a71c026aa85cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699470176eaef166e2a71c026aa85cfc">&#9670;&nbsp;</a></span>_mm_sllv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_sllv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03773">3773</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04747">_mm_mask_sllv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04755">_mm_maskz_sllv_epi32()</a>.</p>

</div>
</div>
<a id="aec60ec05d6c5e57a8cce91a77f75603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec60ec05d6c5e57a8cce91a77f75603d">&#9670;&nbsp;</a></span>_mm_sllv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_sllv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> left by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSLLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03817">3817</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04715">_mm_mask_sllv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04723">_mm_maskz_sllv_epi64()</a>.</p>

</div>
</div>
<a id="a95ac7327486a0d44f7f4154ac337bb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac7327486a0d44f7f4154ac337bb85">&#9670;&nbsp;</a></span>_mm_srav_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srav_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in sign bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is 0 or -1 according to the sign bit for that element.</p>
<p>This intrinsic corresponds to the <code>VPSRAVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03863">3863</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04971">_mm_mask_srav_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04979">_mm_maskz_srav_epi32()</a>.</p>

</div>
</div>
<a id="a5eb295f9dbef670b0a134d834e5f279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb295f9dbef670b0a134d834e5f279a">&#9670;&nbsp;</a></span>_mm_srlv_epi32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srlv_epi32 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 32-bit element of the 128-bit vector of [4 x i32] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [4 x i32] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 31, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVD</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [4 x i32] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [4 x i32] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [4 x i32] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03907">3907</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04811">_mm_mask_srlv_epi32()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04819">_mm_maskz_srlv_epi32()</a>.</p>

</div>
</div>
<a id="a619b2e23f9247af334811e4b6ec75f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619b2e23f9247af334811e4b6ec75f40">&#9670;&nbsp;</a></span>_mm_srlv_epi64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __inline__ __m128i <a class="el" href="sm3intrin_8h.html#aa5269551cf777adb9ce7ae4726145df2">__DEFAULT_FN_ATTRS128</a> _mm_srlv_epi64 </td>
          <td>(</td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__m128i&#160;</td>
          <td class="paramname"><em>__Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts each 64-bit element of the 128-bit vector of [2 x i64] in <em>__X</em> right by the number of bits given in the corresponding element of the 128-bit vector of [2 x i64] in <em>__Y</em>, shifting in zero bits, and returns the result. </p>
<p>If the shift count for any element is greater than 63, the result for that element is zero.</p>
<p>This intrinsic corresponds to the <code>VPSRLVQ</code> instruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__X</td><td>A 128-bit vector of [2 x i64] to be shifted. </td></tr>
    <tr><td class="paramname">__Y</td><td>A 128-bit vector of [2 x i64] containing the unsigned shift counts (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 128-bit vector of [2 x i64] containing the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="avx2intrin_8h_source.html#l03951">3951</a> of file <a class="el" href="avx2intrin_8h_source.html">avx2intrin.h</a>.</p>

<p class="reference">References <a class="el" href="ppc__wrappers_2bmi2intrin_8h_source.html#l00019">__Y</a>.</p>

<p class="reference">Referenced by <a class="el" href="avx512vlintrin_8h_source.html#l04779">_mm_mask_srlv_epi64()</a>, and <a class="el" href="avx512vlintrin_8h_source.html#l04787">_mm_maskz_srlv_epi64()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2024 01:35:27 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
