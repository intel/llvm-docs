<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::dataflow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1dataflow.html">dataflow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">clang::dataflow Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dataflow Directional Tag Classes.  
<a href="namespaceclang_1_1dataflow.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1AggregateStorageLocation.html">AggregateStorageLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage location which is subdivided into smaller storage locations that can be traced independently by abstract interpretation.  <a href="classclang_1_1dataflow_1_1AggregateStorageLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1AtomicBoolValue.html">AtomicBoolValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models an atomic boolean.  <a href="classclang_1_1dataflow_1_1AtomicBoolValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1backward__analysis__tag.html">backward_analysis_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1BooleanFormula.html">BooleanFormula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A boolean formula in conjunctive normal form.  <a href="structclang_1_1dataflow_1_1BooleanFormula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a boolean.  <a href="classclang_1_1dataflow_1_1BoolValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1ChromiumCheckModel.html">ChromiumCheckModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models the behavior of Chromium's CHECK, DCHECK, etc.  <a href="classclang_1_1dataflow_1_1ChromiumCheckModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1ConjunctionValue.html">ConjunctionValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a boolean conjunction.  <a href="classclang_1_1dataflow_1_1ConjunctionValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds <a class="el" href="classclang_1_1CFG.html" title="Represents a source-level, intra-procedural CFG that represents the control-flow of a Stmt.">CFG</a> and other derived context that is needed to perform dataflow analysis.  <a href="classclang_1_1dataflow_1_1ControlFlowContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1DataflowAnalysis.html">DataflowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBase.html">Base</a> class template for dataflow analyses built on a single lattice type.  <a href="classclang_1_1dataflow_1_1DataflowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1DataflowAnalysisContext.html">DataflowAnalysisContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Owns objects that encompass the state of a program and stores context that is used during dataflow analysis.  <a href="classclang_1_1dataflow_1_1DataflowAnalysisContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1DataflowAnalysisState.html">DataflowAnalysisState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1DataflowModel.html">DataflowModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for dataflow "models": reusable analysis components that model a particular aspect of program semantics in the <code><a class="el" href="classclang_1_1dataflow_1_1Environment.html" title="Holds the state of the program (store and heap) at a given program point.">Environment</a></code>.  <a href="classclang_1_1dataflow_1_1DataflowModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1DisjunctionValue.html">DisjunctionValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a boolean disjunction.  <a href="classclang_1_1dataflow_1_1DisjunctionValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the state of the program (store and heap) at a given program point.  <a href="classclang_1_1dataflow_1_1Environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1forward__analysis__tag.html">forward_analysis_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1IndirectionValue.html">IndirectionValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBase.html">Base</a> class for values that refer to storage locations.  <a href="classclang_1_1dataflow_1_1IndirectionValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1IntegerValue.html">IntegerValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models an integer.  <a href="classclang_1_1dataflow_1_1IntegerValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1MapLattice.html">MapLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lattice that maps keys to individual lattice elements.  <a href="classclang_1_1dataflow_1_1MapLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1MatchSwitchBuilder.html">MatchSwitchBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects cases of a "match switch": a collection of matchers paired with callbacks, which together define a switch that can be applied to a <code><a class="el" href="classclang_1_1Stmt.html" title="Stmt - This represents one statement.">Stmt</a></code>.  <a href="classclang_1_1dataflow_1_1MatchSwitchBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1NegationValue.html">NegationValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a boolean negation.  <a href="classclang_1_1dataflow_1_1NegationValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1PointerValue.html">PointerValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a symbolic pointer. Specifically, any value of type <code>T*</code>.  <a href="classclang_1_1dataflow_1_1PointerValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1ReferenceValue.html">ReferenceValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a dereferenced pointer.  <a href="classclang_1_1dataflow_1_1ReferenceValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1ScalarStorageLocation.html">ScalarStorageLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage location that is not subdivided further for the purposes of abstract interpretation.  <a href="classclang_1_1dataflow_1_1ScalarStorageLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1Solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for a SAT solver that can be used by dataflow analyses.  <a href="classclang_1_1dataflow_1_1Solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1SourceLocationsLattice.html">SourceLocationsLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lattice for dataflow analysis that keeps track of a set of source locations.  <a href="classclang_1_1dataflow_1_1SourceLocationsLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1StmtToEnvMap.html">StmtToEnvMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps statements to the environments of basic blocks that contain them.  <a href="classclang_1_1dataflow_1_1StmtToEnvMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1StmtToEnvMapImpl.html">StmtToEnvMapImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1StorageLocation.html">StorageLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBase.html">Base</a> class for elements of the local variable store and of the heap.  <a href="classclang_1_1dataflow_1_1StorageLocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1StructValue.html">StructValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models a value of <code>struct</code> or <code>class</code> type.  <a href="classclang_1_1dataflow_1_1StructValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1TerminatorVisitor.html">TerminatorVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the flow condition of an environment based on a terminator statement.  <a href="classclang_1_1dataflow_1_1TerminatorVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1TransferState.html">TransferState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common form of state shared between the cases of a transfer function.  <a href="structclang_1_1dataflow_1_1TransferState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1TransferVisitor.html">TransferVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased base class for dataflow analyses built on a single lattice type.  <a href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased model of the program at a given program point.  <a href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedLattice.html">TypeErasedLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased lattice element container.  <a href="structclang_1_1dataflow_1_1TypeErasedLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1UncheckedOptionalAccessModel.html">UncheckedOptionalAccessModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataflow analysis that discovers unsafe accesses of optional values and adds the respective source locations to the lattice.  <a href="classclang_1_1dataflow_1_1UncheckedOptionalAccessModel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1dataflow_1_1UncheckedOptionalAccessModelOptions.html">UncheckedOptionalAccessModelOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classBase.html">Base</a> class for all values computed by abstract interpretation.  <a href="classclang_1_1dataflow_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1WatchedLiteralsSolver.html">WatchedLiteralsSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SAT solver that is an implementation of Algorithm D from Knuth's The Art of Computer Programming Volume 4: Satisfiability, Fascicle 6.  <a href="classclang_1_1dataflow_1_1WatchedLiteralsSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1dataflow_1_1WatchedLiteralsSolverImpl.html">WatchedLiteralsSolverImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad3b29d6a0866970fca387023263863f0"><td class="memTemplParams" colspan="2">template&lt;typename ElementLattice &gt; </td></tr>
<tr class="memitem:ad3b29d6a0866970fca387023263863f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#ad3b29d6a0866970fca387023263863f0">VarMapLattice</a> = <a class="el" href="classclang_1_1dataflow_1_1MapLattice.html">MapLattice</a>&lt; const <a class="el" href="classclang_1_1VarDecl.html">clang::VarDecl</a> *, ElementLattice &gt;</td></tr>
<tr class="memdesc:ad3b29d6a0866970fca387023263863f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias that captures the common use of map lattices to model in-scope variables.  <a href="namespaceclang_1_1dataflow.html#ad3b29d6a0866970fca387023263863f0">More...</a><br /></td></tr>
<tr class="separator:ad3b29d6a0866970fca387023263863f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26caccdc537b939337adab80da02f030"><td class="memTemplParams" colspan="2">template&lt;typename State &gt; </td></tr>
<tr class="memitem:a26caccdc537b939337adab80da02f030"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a26caccdc537b939337adab80da02f030">MatchSwitch</a> = std::function&lt; void(const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;, <a class="el" href="UnwrappedLineFormatter_8cpp.html#a83e9e4ff6cb05dbdf72ab2a01aa289c0">State</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a26caccdc537b939337adab80da02f030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches against <code><a class="el" href="classclang_1_1Stmt.html" title="Stmt - This represents one statement.">Stmt</a></code> and, based on its structure, dispatches to an appropriate handler.  <a href="namespaceclang_1_1dataflow.html#a26caccdc537b939337adab80da02f030">More...</a><br /></td></tr>
<tr class="separator:a26caccdc537b939337adab80da02f030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b87ef92590f732efb46c7d33a11005"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a> = uint32_t</td></tr>
<tr class="memdesc:ab7b87ef92590f732efb46c7d33a11005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean variables are represented as positive integers.  <a href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">More...</a><br /></td></tr>
<tr class="separator:ab7b87ef92590f732efb46c7d33a11005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b5e84c22bdee7966721cba9133be6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> = uint32_t</td></tr>
<tr class="memdesc:a976b5e84c22bdee7966721cba9133be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literals are represented as positive integers.  <a href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">More...</a><br /></td></tr>
<tr class="separator:a976b5e84c22bdee7966721cba9133be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f189ebd178b6b46a9e9bd70a791d64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a03f189ebd178b6b46a9e9bd70a791d64">ClauseID</a> = uint32_t</td></tr>
<tr class="memdesc:a03f189ebd178b6b46a9e9bd70a791d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clause identifiers are represented as positive integers.  <a href="namespaceclang_1_1dataflow.html#a03f189ebd178b6b46a9e9bd70a791d64">More...</a><br /></td></tr>
<tr class="separator:a03f189ebd178b6b46a9e9bd70a791d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abaa6d295ccea77fdf5752524bc6bdef6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6">SkipPast</a> { <a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6a6adf97f83acf6453d4a6a4b1070f3754">SkipPast::None</a>, 
<a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6a63d5049791d9d79d86e9a108b0a999ca">SkipPast::Reference</a>, 
<a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6a18b65987330c43f5d493e42135d1b869">SkipPast::ReferenceThenPointer</a>
 }</td></tr>
<tr class="memdesc:abaa6d295ccea77fdf5752524bc6bdef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates what kind of indirections should be skipped past when retrieving storage locations or values.  <a href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6">More...</a><br /></td></tr>
<tr class="separator:abaa6d295ccea77fdf5752524bc6bdef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872b9d4684fc7818e8b926594dd8b4cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a872b9d4684fc7818e8b926594dd8b4cc">LatticeJoinEffect</a> { <a class="el" href="namespaceclang_1_1dataflow.html#a872b9d4684fc7818e8b926594dd8b4cca5ff3c6978f87d96febfdc8ed3899a97e">LatticeJoinEffect::Unchanged</a>, 
<a class="el" href="namespaceclang_1_1dataflow.html#a872b9d4684fc7818e8b926594dd8b4cca820dbd2b8f606aff866c0bbfb6b737c1">LatticeJoinEffect::Changed</a>
 }</td></tr>
<tr class="memdesc:a872b9d4684fc7818e8b926594dd8b4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effect indicating whether a lattice join operation resulted in a new value.  <a href="namespaceclang_1_1dataflow.html#a872b9d4684fc7818e8b926594dd8b4cc">More...</a><br /></td></tr>
<tr class="separator:a872b9d4684fc7818e8b926594dd8b4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8e981dcc0f5741c59ca9ee9351565ba"><td class="memTemplParams" colspan="2">template&lt;typename AnalysisT &gt; </td></tr>
<tr class="memitem:ab8e981dcc0f5741c59ca9ee9351565ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1DataflowAnalysisState.html">DataflowAnalysisState</a>&lt; typename AnalysisT::Lattice &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#ab8e981dcc0f5741c59ca9ee9351565ba">runDataflowAnalysis</a> (const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;CFCtx, AnalysisT &amp;Analysis, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;InitEnv)</td></tr>
<tr class="memdesc:ab8e981dcc0f5741c59ca9ee9351565ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dataflow analysis and returns a mapping from basic block IDs to dataflow analysis states that model the respective basic blocks.  <a href="namespaceclang_1_1dataflow.html#ab8e981dcc0f5741c59ca9ee9351565ba">More...</a><br /></td></tr>
<tr class="separator:ab8e981dcc0f5741c59ca9ee9351565ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e369a93a0b5737004b36fe3768fa6a3"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename ElementLattice &gt; </td></tr>
<tr class="memitem:a9e369a93a0b5737004b36fe3768fa6a3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a9e369a93a0b5737004b36fe3768fa6a3">operator&lt;&lt;</a> (std::ostream &amp;Os, const <a class="el" href="classclang_1_1dataflow_1_1MapLattice.html">clang::dataflow::MapLattice</a>&lt; Key, ElementLattice &gt; &amp;M)</td></tr>
<tr class="separator:a9e369a93a0b5737004b36fe3768fa6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2f6410422aac0807f573005d11ab9b"><td class="memTemplParams" colspan="2">template&lt;typename ElementLattice &gt; </td></tr>
<tr class="memitem:adc2f6410422aac0807f573005d11ab9b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#adc2f6410422aac0807f573005d11ab9b">operator&lt;&lt;</a> (std::ostream &amp;Os, const <a class="el" href="namespaceclang_1_1dataflow.html#ad3b29d6a0866970fca387023263863f0">clang::dataflow::VarMapLattice</a>&lt; ElementLattice &gt; &amp;M)</td></tr>
<tr class="separator:adc2f6410422aac0807f573005d11ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf614427f4c851c7cb7ee7bc5cf4e243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#abf614427f4c851c7cb7ee7bc5cf4e243">DebugString</a> (const <a class="el" href="classclang_1_1dataflow_1_1SourceLocationsLattice.html">SourceLocationsLattice</a> &amp;Lattice, const <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:abf614427f4c851c7cb7ee7bc5cf4e243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that represents the source locations of the lattice.  <a href="namespaceclang_1_1dataflow.html#abf614427f4c851c7cb7ee7bc5cf4e243">More...</a><br /></td></tr>
<tr class="separator:abf614427f4c851c7cb7ee7bc5cf4e243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834cbcf9a9ea98e9a7bdbecbe04cf1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a6834cbcf9a9ea98e9a7bdbecbe04cf1c">transfer</a> (const <a class="el" href="classclang_1_1dataflow_1_1StmtToEnvMap.html">StmtToEnvMap</a> &amp;StmtToEnv, const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;S, <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env)</td></tr>
<tr class="memdesc:a6834cbcf9a9ea98e9a7bdbecbe04cf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <code>S</code> and updates <code>Env</code> accordingly.  <a href="namespaceclang_1_1dataflow.html#a6834cbcf9a9ea98e9a7bdbecbe04cf1c">More...</a><br /></td></tr>
<tr class="separator:a6834cbcf9a9ea98e9a7bdbecbe04cf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c26a0b7692f4a4f2de7f5762db4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a470c26a0b7692f4a4f2de7f5762db4db">transferBlock</a> (const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;CFCtx, std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt; &amp;BlockStates, const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;Block, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;InitEnv, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;Analysis, std::function&lt; void(const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;, const <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;)&gt; HandleTransferredStmt=nullptr)</td></tr>
<tr class="memdesc:a470c26a0b7692f4a4f2de7f5762db4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers the state of a basic block by evaluating each of its statements in the context of <code>Analysis</code> and the states of its predecessors that are available in <code>BlockStates</code>.  <a href="namespaceclang_1_1dataflow.html#a470c26a0b7692f4a4f2de7f5762db4db">More...</a><br /></td></tr>
<tr class="separator:a470c26a0b7692f4a4f2de7f5762db4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9270febd6a00626f876570ba50aba62b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a9270febd6a00626f876570ba50aba62b">runTypeErasedDataflowAnalysis</a> (const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;CFCtx, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;Analysis, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;InitEnv)</td></tr>
<tr class="memdesc:a9270febd6a00626f876570ba50aba62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dataflow analysis and returns a mapping from basic block IDs to dataflow analysis states that model the respective basic blocks.  <a href="namespaceclang_1_1dataflow.html#a9270febd6a00626f876570ba50aba62b">More...</a><br /></td></tr>
<tr class="separator:a9270febd6a00626f876570ba50aba62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009ff9691f2fe7f3828592c035ea8ef3"><td class="memItemLeft" align="right" valign="top">static llvm::DenseMap&lt; const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> *, const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a009ff9691f2fe7f3828592c035ea8ef3">buildStmtToBasicBlockMap</a> (const <a class="el" href="classclang_1_1CFG.html">CFG</a> &amp;Cfg)</td></tr>
<tr class="memdesc:a009ff9691f2fe7f3828592c035ea8ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map from statements to basic blocks that contain them.  <a href="namespaceclang_1_1dataflow.html#a009ff9691f2fe7f3828592c035ea8ef3">More...</a><br /></td></tr>
<tr class="separator:a009ff9691f2fe7f3828592c035ea8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9b6a479a8daf649e4733ebb3d99b21"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> *, <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#aad9b6a479a8daf649e4733ebb3d99b21">makeCanonicalBoolValuePair</a> (<a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> &amp;LHS, <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> &amp;RHS)</td></tr>
<tr class="separator:aad9b6a479a8daf649e4733ebb3d99b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027342d8a5f7909f887c10ed3d70c97f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a027342d8a5f7909f887c10ed3d70c97f"><td class="memTemplItemLeft" align="right" valign="top">llvm::DenseMap&lt; K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a027342d8a5f7909f887c10ed3d70c97f">intersectDenseMaps</a> (const llvm::DenseMap&lt; K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> &gt; &amp;Map1, const llvm::DenseMap&lt; K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> &gt; &amp;Map2)</td></tr>
<tr class="memdesc:a027342d8a5f7909f887c10ed3d70c97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map consisting of key-value entries that are present in both maps.  <a href="namespaceclang_1_1dataflow.html#a027342d8a5f7909f887c10ed3d70c97f">More...</a><br /></td></tr>
<tr class="separator:a027342d8a5f7909f887c10ed3d70c97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf4a42fbf430fbf9c759a4984b95de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a5bdf4a42fbf430fbf9c759a4984b95de">equivalentValues</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a> <a class="el" href="classclang_1_1Type.html">Type</a>, <a class="el" href="classclang_1_1dataflow_1_1Value.html">Value</a> *Val1, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env1, <a class="el" href="classclang_1_1dataflow_1_1Value.html">Value</a> *Val2, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env2, <a class="el" href="classclang_1_1dataflow_1_1Environment_1_1ValueModel.html">Environment::ValueModel</a> &amp;Model)</td></tr>
<tr class="memdesc:a5bdf4a42fbf430fbf9c759a4984b95de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if <code>Val1</code> is equivalent to <code>Val2</code>.  <a href="namespaceclang_1_1dataflow.html#a5bdf4a42fbf430fbf9c759a4984b95de">More...</a><br /></td></tr>
<tr class="separator:a5bdf4a42fbf430fbf9c759a4984b95de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41246ac7b532e5c18f45a19badaa0a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#ac41246ac7b532e5c18f45a19badaa0a6">initGlobalVar</a> (const <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &amp;D, <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env)</td></tr>
<tr class="memdesc:ac41246ac7b532e5c18f45a19badaa0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a global storage value.  <a href="namespaceclang_1_1dataflow.html#ac41246ac7b532e5c18f45a19badaa0a6">More...</a><br /></td></tr>
<tr class="separator:ac41246ac7b532e5c18f45a19badaa0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdae54c435195930b571a1851afdfa0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a3fdae54c435195930b571a1851afdfa0">initGlobalVar</a> (const <a class="el" href="classclang_1_1Decl.html">Decl</a> &amp;D, <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env)</td></tr>
<tr class="memdesc:a3fdae54c435195930b571a1851afdfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a global storage value.  <a href="namespaceclang_1_1dataflow.html#a3fdae54c435195930b571a1851afdfa0">More...</a><br /></td></tr>
<tr class="separator:a3fdae54c435195930b571a1851afdfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816ea0529aa6a447700a342699e2f7fa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a816ea0529aa6a447700a342699e2f7fa">initGlobalVars</a> (const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;S, <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;Env)</td></tr>
<tr class="memdesc:a816ea0529aa6a447700a342699e2f7fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes global storage values that are declared or referenced from sub-statements of <code>S</code>.  <a href="namespaceclang_1_1dataflow.html#a816ea0529aa6a447700a342699e2f7fa">More...</a><br /></td></tr>
<tr class="separator:a816ea0529aa6a447700a342699e2f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0675341487335284f09d48dfb6c321d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a0675341487335284f09d48dfb6c321d7">joinConstraints</a> (<a class="el" href="classclang_1_1dataflow_1_1DataflowAnalysisContext.html">DataflowAnalysisContext</a> *Context, const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;Constraints1, const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;Constraints2)</td></tr>
<tr class="memdesc:a0675341487335284f09d48dfb6c321d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constraints that represent the disjunction of <code>Constraints1</code> and <code>Constraints2</code>.  <a href="namespaceclang_1_1dataflow.html#a0675341487335284f09d48dfb6c321d7">More...</a><br /></td></tr>
<tr class="separator:a0675341487335284f09d48dfb6c321d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2455b9efe92804d7cee211327d7418b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a2455b9efe92804d7cee211327d7418b3">isCheckLikeMethod</a> (llvm::SmallDenseSet&lt; const <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> * &gt; &amp;CheckDecls, const <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &amp;D)</td></tr>
<tr class="memdesc:a2455b9efe92804d7cee211327d7418b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <code>D</code> is one of the methods used to implement Chromium's <code>CHECK</code> macros.  <a href="namespaceclang_1_1dataflow.html#a2455b9efe92804d7cee211327d7418b3">More...</a><br /></td></tr>
<tr class="separator:a2455b9efe92804d7cee211327d7418b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c5998642b2607294297bfe3843e2d0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classclang_1_1Expr.html">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a65c5998642b2607294297bfe3843e2d0">skipExprWithCleanups</a> (const <a class="el" href="classclang_1_1Expr.html">Expr</a> *E)</td></tr>
<tr class="separator:a65c5998642b2607294297bfe3843e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba79054f7435e07f5349712defd76a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a6ba79054f7435e07f5349712defd76a5">blockIndexInPredecessor</a> (const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;Pred, const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;Block)</td></tr>
<tr class="memdesc:a6ba79054f7435e07f5349712defd76a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of <code>Block</code> in the successors of <code>Pred</code>.  <a href="namespaceclang_1_1dataflow.html#a6ba79054f7435e07f5349712defd76a5">More...</a><br /></td></tr>
<tr class="separator:a6ba79054f7435e07f5349712defd76a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5436d1f639e40dc1fd61190b75d79da5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a5436d1f639e40dc1fd61190b75d79da5">computeBlockInputState</a> (const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;CFCtx, std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt; &amp;BlockStates, const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;Block, const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;InitEnv, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;Analysis)</td></tr>
<tr class="memdesc:a5436d1f639e40dc1fd61190b75d79da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the input state for a given basic block by joining the output states of its predecessors.  <a href="namespaceclang_1_1dataflow.html#a5436d1f639e40dc1fd61190b75d79da5">More...</a><br /></td></tr>
<tr class="separator:a5436d1f639e40dc1fd61190b75d79da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54934e3c886d841b8e2365fb61a5fd80"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a54934e3c886d841b8e2365fb61a5fd80">transferCFGStmt</a> (const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;CFCtx, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt; BlockStates, const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;CfgStmt, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;Analysis, <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;<a class="el" href="UnwrappedLineFormatter_8cpp.html#a83e9e4ff6cb05dbdf72ab2a01aa289c0">State</a>, std::function&lt; void(const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;, const <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;)&gt; HandleTransferredStmt)</td></tr>
<tr class="memdesc:a54934e3c886d841b8e2365fb61a5fd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers <code>State</code> by evaluating <code>CfgStmt</code> in the context of <code>Analysis</code>.  <a href="namespaceclang_1_1dataflow.html#a54934e3c886d841b8e2365fb61a5fd80">More...</a><br /></td></tr>
<tr class="separator:a54934e3c886d841b8e2365fb61a5fd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f7086aaf7c653d47dbb210b01e3d1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#aa1f7086aaf7c653d47dbb210b01e3d1c">transferCFGInitializer</a> (const <a class="el" href="classclang_1_1CFGInitializer.html">CFGInitializer</a> &amp;CfgInit, <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;<a class="el" href="UnwrappedLineFormatter_8cpp.html#a83e9e4ff6cb05dbdf72ab2a01aa289c0">State</a>)</td></tr>
<tr class="memdesc:aa1f7086aaf7c653d47dbb210b01e3d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers <code>State</code> by evaluating <code>CfgInit</code>.  <a href="namespaceclang_1_1dataflow.html#aa1f7086aaf7c653d47dbb210b01e3d1c">More...</a><br /></td></tr>
<tr class="separator:aa1f7086aaf7c653d47dbb210b01e3d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a12cd68fa7c7f5f23f7807c54d0c736"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a7a12cd68fa7c7f5f23f7807c54d0c736">posLit</a> (<a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a> <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>)</td></tr>
<tr class="memdesc:a7a12cd68fa7c7f5f23f7807c54d0c736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the positive literal <code>V</code>.  <a href="namespaceclang_1_1dataflow.html#a7a12cd68fa7c7f5f23f7807c54d0c736">More...</a><br /></td></tr>
<tr class="separator:a7a12cd68fa7c7f5f23f7807c54d0c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f5dd427c7fac0a27f36cbf8505822a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a26f5dd427c7fac0a27f36cbf8505822a">negLit</a> (<a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a> <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>)</td></tr>
<tr class="memdesc:a26f5dd427c7fac0a27f36cbf8505822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negative literal <code>!V</code>.  <a href="namespaceclang_1_1dataflow.html#a26f5dd427c7fac0a27f36cbf8505822a">More...</a><br /></td></tr>
<tr class="separator:a26f5dd427c7fac0a27f36cbf8505822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcbfb59583a22b0b99263c768ae7305"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a4bcbfb59583a22b0b99263c768ae7305">notLit</a> (<a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> L)</td></tr>
<tr class="memdesc:a4bcbfb59583a22b0b99263c768ae7305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negated literal <code>!L</code>.  <a href="namespaceclang_1_1dataflow.html#a4bcbfb59583a22b0b99263c768ae7305">More...</a><br /></td></tr>
<tr class="separator:a4bcbfb59583a22b0b99263c768ae7305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858fe7ef413718673ced2de8af3b28a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#aa858fe7ef413718673ced2de8af3b28a">var</a> (<a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> L)</td></tr>
<tr class="memdesc:aa858fe7ef413718673ced2de8af3b28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variable of <code>L</code>.  <a href="namespaceclang_1_1dataflow.html#aa858fe7ef413718673ced2de8af3b28a">More...</a><br /></td></tr>
<tr class="separator:aa858fe7ef413718673ced2de8af3b28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2421740b598e1cad84546e9e7763cf30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1dataflow_1_1BooleanFormula.html">BooleanFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a2421740b598e1cad84546e9e7763cf30">buildBooleanFormula</a> (const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;Vals)</td></tr>
<tr class="memdesc:a2421740b598e1cad84546e9e7763cf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the conjunction of <code>Vals</code> into a formula in conjunctive normal form where each clause has at least one and at most three literals.  <a href="namespaceclang_1_1dataflow.html#a2421740b598e1cad84546e9e7763cf30">More...</a><br /></td></tr>
<tr class="separator:a2421740b598e1cad84546e9e7763cf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a74b2491f0e42f80312a2143043106ef0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a74b2491f0e42f80312a2143043106ef0">MaxCompositeValueDepth</a> = 3</td></tr>
<tr class="separator:a74b2491f0e42f80312a2143043106ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c78b043618ceb361b508c495f3cd7af"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a8c78b043618ceb361b508c495f3cd7af">MaxCompositeValueSize</a> = 1000</td></tr>
<tr class="separator:a8c78b043618ceb361b508c495f3cd7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ea08fc194905b51add62e044672472"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a20ea08fc194905b51add62e044672472">NullVar</a> = 0</td></tr>
<tr class="memdesc:a20ea08fc194905b51add62e044672472"><td class="mdescLeft">&#160;</td><td class="mdescRight">A null boolean variable is used as a placeholder in various data structures and algorithms.  <a href="namespaceclang_1_1dataflow.html#a20ea08fc194905b51add62e044672472">More...</a><br /></td></tr>
<tr class="separator:a20ea08fc194905b51add62e044672472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598607161a459c63ed3db33c74c8e84d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a598607161a459c63ed3db33c74c8e84d">NullLit</a> = 0</td></tr>
<tr class="memdesc:a598607161a459c63ed3db33c74c8e84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A null literal is used as a placeholder in various data structures and algorithms.  <a href="namespaceclang_1_1dataflow.html#a598607161a459c63ed3db33c74c8e84d">More...</a><br /></td></tr>
<tr class="separator:a598607161a459c63ed3db33c74c8e84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a8b17ea24b227ff9a3e147fa5114b3"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a03f189ebd178b6b46a9e9bd70a791d64">ClauseID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1dataflow.html#a83a8b17ea24b227ff9a3e147fa5114b3">NullClause</a> = 0</td></tr>
<tr class="memdesc:a83a8b17ea24b227ff9a3e147fa5114b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A null clause identifier is used as a placeholder in various data structures and algorithms.  <a href="namespaceclang_1_1dataflow.html#a83a8b17ea24b227ff9a3e147fa5114b3">More...</a><br /></td></tr>
<tr class="separator:a83a8b17ea24b227ff9a3e147fa5114b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dataflow Directional Tag Classes. </p>
<p>These are used for tag dispatching within the dataflow solver/transfer functions to determine what direction a dataflow analysis flows. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a03f189ebd178b6b46a9e9bd70a791d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f189ebd178b6b46a9e9bd70a791d64">&#9670;&nbsp;</a></span>ClauseID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1dataflow.html#a03f189ebd178b6b46a9e9bd70a791d64">clang::dataflow::ClauseID</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clause identifiers are represented as positive integers. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00074">74</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

</div>
</div>
<a id="a976b5e84c22bdee7966721cba9133be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976b5e84c22bdee7966721cba9133be6">&#9670;&nbsp;</a></span>Literal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">clang::dataflow::Literal</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literals are represented as positive integers. </p>
<p>Specifically, for a boolean variable <code>V</code> that is represented as the positive integer <code>I</code>, the positive literal <code>V</code> is represented as the integer <code>2*I</code> and the negative literal <code>!V</code> is represented as the integer <code>2*I+1</code>. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00055">55</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

</div>
</div>
<a id="a26caccdc537b939337adab80da02f030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26caccdc537b939337adab80da02f030">&#9670;&nbsp;</a></span>MatchSwitch</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename State &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1dataflow.html#a26caccdc537b939337adab80da02f030">clang::dataflow::MatchSwitch</a> = typedef std::function&lt;void(const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;, <a class="el" href="UnwrappedLineFormatter_8cpp.html#a83e9e4ff6cb05dbdf72ab2a01aa289c0">State</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches against <code><a class="el" href="classclang_1_1Stmt.html" title="Stmt - This represents one statement.">Stmt</a></code> and, based on its structure, dispatches to an appropriate handler. </p>

<p class="definition">Definition at line <a class="el" href="MatchSwitch_8h_source.html#l00050">50</a> of file <a class="el" href="MatchSwitch_8h_source.html">MatchSwitch.h</a>.</p>

</div>
</div>
<a id="ab7b87ef92590f732efb46c7d33a11005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b87ef92590f732efb46c7d33a11005">&#9670;&nbsp;</a></span>Variable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">clang::dataflow::Variable</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean variables are represented as positive integers. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00045">45</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

</div>
</div>
<a id="ad3b29d6a0866970fca387023263863f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b29d6a0866970fca387023263863f0">&#9670;&nbsp;</a></span>VarMapLattice</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementLattice &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1dataflow.html#ad3b29d6a0866970fca387023263863f0">clang::dataflow::VarMapLattice</a> = typedef <a class="el" href="classclang_1_1dataflow_1_1MapLattice.html">MapLattice</a>&lt;const <a class="el" href="classclang_1_1VarDecl.html">clang::VarDecl</a> *, ElementLattice&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias that captures the common use of map lattices to model in-scope variables. </p>

<p class="definition">Definition at line <a class="el" href="MapLattice_8h_source.html#l00109">109</a> of file <a class="el" href="MapLattice_8h_source.html">MapLattice.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a872b9d4684fc7818e8b926594dd8b4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872b9d4684fc7818e8b926594dd8b4cc">&#9670;&nbsp;</a></span>LatticeJoinEffect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1dataflow.html#a872b9d4684fc7818e8b926594dd8b4cc">clang::dataflow::LatticeJoinEffect</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Effect indicating whether a lattice join operation resulted in a new value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a872b9d4684fc7818e8b926594dd8b4cca5ff3c6978f87d96febfdc8ed3899a97e"></a>Unchanged&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a872b9d4684fc7818e8b926594dd8b4cca820dbd2b8f606aff866c0bbfb6b737c1"></a>Changed&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataflowLattice_8h_source.html#l00021">21</a> of file <a class="el" href="DataflowLattice_8h_source.html">DataflowLattice.h</a>.</p>

</div>
</div>
<a id="abaa6d295ccea77fdf5752524bc6bdef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa6d295ccea77fdf5752524bc6bdef6">&#9670;&nbsp;</a></span>SkipPast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6">clang::dataflow::SkipPast</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates what kind of indirections should be skipped past when retrieving storage locations or values. </p>
<p>FIXME: Consider renaming this or replacing it with a more appropriate model. See the discussion in <a href="https://reviews.llvm.org/D116596">https://reviews.llvm.org/D116596</a> for context. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abaa6d295ccea77fdf5752524bc6bdef6a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No indirections should be skipped past. </p>
</td></tr>
<tr><td class="fieldname"><a id="abaa6d295ccea77fdf5752524bc6bdef6a63d5049791d9d79d86e9a108b0a999ca"></a>Reference&#160;</td><td class="fielddoc"><p>An optional reference should be skipped past. </p>
</td></tr>
<tr><td class="fieldname"><a id="abaa6d295ccea77fdf5752524bc6bdef6a18b65987330c43f5d493e42135d1b869"></a>ReferenceThenPointer&#160;</td><td class="fielddoc"><p>An optional reference should be skipped past, then an optional pointer should be skipped past. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8h_source.html#l00041">41</a> of file <a class="el" href="DataflowEnvironment_8h_source.html">DataflowEnvironment.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ba79054f7435e07f5349712defd76a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba79054f7435e07f5349712defd76a5">&#9670;&nbsp;</a></span>blockIndexInPredecessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::dataflow::blockIndexInPredecessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>Block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of <code>Block</code> in the successors of <code>Pred</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00061">61</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3ae1e4c8c9ccd9fc39c391da4bcd093fb2">clang::Block</a>, <a class="el" href="CFG_8h_source.html#l00955">clang::CFGBlock::succ_begin()</a>, and <a class="el" href="CFG_8h_source.html#l00965">clang::CFGBlock::succs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00135">computeBlockInputState()</a>.</p>

</div>
</div>
<a id="a2421740b598e1cad84546e9e7763cf30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2421740b598e1cad84546e9e7763cf30">&#9670;&nbsp;</a></span>buildBooleanFormula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1dataflow_1_1BooleanFormula.html">BooleanFormula</a> clang::dataflow::buildBooleanFormula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the conjunction of <code>Vals</code> into a formula in conjunctive normal form where each clause has at least one and at most three literals. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00174">174</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">References <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00139">clang::dataflow::BooleanFormula::addClause()</a>, <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00065">negLit()</a>, and <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00062">posLit()</a>.</p>

</div>
</div>
<a id="a009ff9691f2fe7f3828592c035ea8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009ff9691f2fe7f3828592c035ea8ef3">&#9670;&nbsp;</a></span>buildStmtToBasicBlockMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::DenseMap&lt;const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> *, const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> *&gt; clang::dataflow::buildStmtToBasicBlockMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFG.html">CFG</a> &amp;&#160;</td>
          <td class="paramname"><em>Cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a map from statements to basic blocks that contain them. </p>

<p class="definition">Definition at line <a class="el" href="ControlFlowContext_8cpp_source.html#l00028">28</a> of file <a class="el" href="ControlFlowContext_8cpp_source.html">ControlFlowContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3ae1e4c8c9ccd9fc39c391da4bcd093fb2">clang::Block</a>.</p>

</div>
</div>
<a id="a5436d1f639e40dc1fd61190b75d79da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5436d1f639e40dc1fd61190b75d79da5">&#9670;&nbsp;</a></span>computeBlockInputState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> clang::dataflow::computeBlockInputState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;&#160;</td>
          <td class="paramname"><em>CFCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>BlockStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>Block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>InitEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>Analysis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the input state for a given basic block by joining the output states of its predecessors. </p>
<p>Requirements:</p>
<p>All predecessors of <code>Block</code> except those with loop back edges must have already been transferred. States in <code>BlockStates</code> that are set to <code>llvm::None</code> represent basic blocks that are not evaluated yet. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00135">135</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00083">clang::dataflow::TypeErasedDataflowAnalysis::applyBuiltinTransfer()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3ae1e4c8c9ccd9fc39c391da4bcd093fb2">clang::Block</a>, <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00061">blockIndexInPredecessor()</a>, <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00092">clang::dataflow::TypeErasedDataflowAnalysisState::Env</a>, <a class="el" href="ControlFlowContext_8h_source.html#l00041">clang::dataflow::ControlFlowContext::getStmtToBlock()</a>, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html#a87149e2d2804a048b5b584b41f473fa6">clang::dataflow::TypeErasedDataflowAnalysis::joinTypeErased()</a>, <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00089">clang::dataflow::TypeErasedDataflowAnalysisState::Lattice</a>, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html#a5f93acbbc4dfef2f227cbd3608209a2c">clang::dataflow::TypeErasedDataflowAnalysis::typeErasedInitialElement()</a>, and <a class="el" href="StmtVisitor_8h_source.html#l00043">clang::StmtVisitorBase&lt; Ptr, ImplClass, RetTy, ParamTys &gt;::Visit()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00270">transferBlock()</a>.</p>

</div>
</div>
<a id="abf614427f4c851c7cb7ee7bc5cf4e243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf614427f4c851c7cb7ee7bc5cf4e243">&#9670;&nbsp;</a></span>DebugString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> clang::dataflow::DebugString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1SourceLocationsLattice.html">SourceLocationsLattice</a> &amp;&#160;</td>
          <td class="paramname"><em>Lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that represents the source locations of the lattice. </p>

<p class="definition">Definition at line <a class="el" href="SourceLocationsLattice_8cpp_source.html#l00033">33</a> of file <a class="el" href="SourceLocationsLattice_8cpp_source.html">SourceLocationsLattice.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceLocationsLattice_8h_source.html#l00048">clang::dataflow::SourceLocationsLattice::getSourceLocations()</a>, and <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="a5bdf4a42fbf430fbf9c759a4984b95de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf4a42fbf430fbf9c759a4984b95de">&#9670;&nbsp;</a></span>equivalentValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::dataflow::equivalentValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname"><em>Type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Val1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Val2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Environment_1_1ValueModel.html">Environment::ValueModel</a> &amp;&#160;</td>
          <td class="paramname"><em>Model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if <code>Val1</code> is equivalent to <code>Val2</code>. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00052">52</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataflowEnvironment_8h_source.html#l00075">clang::dataflow::Environment::ValueModel::compareEquivalent()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00196">clang::dataflow::Environment::equivalentTo()</a>, and <a class="el" href="DataflowEnvironment_8cpp_source.html#l00231">clang::dataflow::Environment::join()</a>.</p>

</div>
</div>
<a id="a3fdae54c435195930b571a1851afdfa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdae54c435195930b571a1851afdfa0">&#9670;&nbsp;</a></span>initGlobalVar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::dataflow::initGlobalVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Decl.html">Decl</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a global storage value. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00081">81</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataflowEnvironment_8cpp_source.html#l00069">initGlobalVar()</a>, and <a class="el" href="ASTContext_8h_source.html#l03167">V</a>.</p>

</div>
</div>
<a id="ac41246ac7b532e5c18f45a19badaa0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41246ac7b532e5c18f45a19badaa0a6">&#9670;&nbsp;</a></span>initGlobalVar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::dataflow::initGlobalVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a global storage value. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00069">69</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataflowEnvironment_8cpp_source.html#l00293">clang::dataflow::Environment::createStorageLocation()</a>, <a class="el" href="DataflowEnvironment_8cpp_source.html#l00409">clang::dataflow::Environment::createValue()</a>, <a class="el" href="DataflowEnvironment_8cpp_source.html#l00335">clang::dataflow::Environment::getStorageLocation()</a>, <a class="el" href="Decl_8h_source.html#l00686">clang::ValueDecl::getType()</a>, <a class="el" href="Decl_8h_source.html#l01142">clang::VarDecl::hasGlobalStorage()</a>, <a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6a6adf97f83acf6453d4a6a4b1070f3754">None</a>, <a class="el" href="DataflowEnvironment_8cpp_source.html#l00330">clang::dataflow::Environment::setStorageLocation()</a>, and <a class="el" href="DataflowEnvironment_8cpp_source.html#l00357">clang::dataflow::Environment::setValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00081">initGlobalVar()</a>.</p>

</div>
</div>
<a id="a816ea0529aa6a447700a342699e2f7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816ea0529aa6a447700a342699e2f7fa">&#9670;&nbsp;</a></span>initGlobalVars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::dataflow::initGlobalVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes global storage values that are declared or referenced from sub-statements of <code>S</code>. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00090">90</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00167">clang::dataflow::Environment::Environment()</a>.</p>

</div>
</div>
<a id="a027342d8a5f7909f887c10ed3d70c97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027342d8a5f7909f887c10ed3d70c97f">&#9670;&nbsp;</a></span>intersectDenseMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">llvm::DenseMap&lt;K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a>&gt; clang::dataflow::intersectDenseMaps </td>
          <td>(</td>
          <td class="paramtype">const llvm::DenseMap&lt; K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Map1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::DenseMap&lt; K, <a class="el" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Map2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map consisting of key-value entries that are present in both maps. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00040">40</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00231">clang::dataflow::Environment::join()</a>.</p>

</div>
</div>
<a id="a2455b9efe92804d7cee211327d7418b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2455b9efe92804d7cee211327d7418b3">&#9670;&nbsp;</a></span>isCheckLikeMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::dataflow::isCheckLikeMethod </td>
          <td>(</td>
          <td class="paramtype">llvm::SmallDenseSet&lt; const <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>CheckDecls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <code>D</code> is one of the methods used to implement Chromium's <code>CHECK</code> macros. </p>
<p>Populates <code>CheckDecls</code>, if empty. </p>

<p class="definition">Definition at line <a class="el" href="ChromiumCheckModel_8cpp_source.html#l00019">19</a> of file <a class="el" href="ChromiumCheckModel_8cpp_source.html">ChromiumCheckModel.cpp</a>.</p>

<p class="reference">References <a class="el" href="DeclBase_8h_source.html#l00433">clang::Decl::getDeclContext()</a>, <a class="el" href="Decl_8h_source.html#l00311">clang::NamedDecl::getDeclName()</a>, <a class="el" href="Decl_8h_source.html#l00274">clang::NamedDecl::getName()</a>, <a class="el" href="DeclCXX_8h_source.html#l02083">clang::CXXMethodDecl::getParent()</a>, <a class="el" href="DeclarationName_8h_source.html#l00373">clang::DeclarationName::isIdentifier()</a>, <a class="el" href="DeclCXX_8cpp_source.html#l02092">clang::CXXMethodDecl::isStatic()</a>, and <a class="el" href="DeclCXX_8h_source.html#l00638">clang::CXXRecordDecl::methods()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ChromiumCheckModel_8cpp_source.html#l00053">clang::dataflow::ChromiumCheckModel::transfer()</a>.</p>

</div>
</div>
<a id="a0675341487335284f09d48dfb6c321d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0675341487335284f09d48dfb6c321d7">&#9670;&nbsp;</a></span>joinConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;<a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> *&gt; clang::dataflow::joinConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1DataflowAnalysisContext.html">DataflowAnalysisContext</a> *&#160;</td>
          <td class="paramname"><em>Context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>Constraints2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns constraints that represent the disjunction of <code>Constraints1</code> and <code>Constraints2</code>. </p>
<p>Requirements:</p>
<p>The elements of <code>Constraints1</code> and <code>Constraints2</code> must not be null. </p>

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00117">117</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00231">clang::dataflow::Environment::join()</a>.</p>

</div>
</div>
<a id="aad9b6a479a8daf649e4733ebb3d99b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad9b6a479a8daf649e4733ebb3d99b21">&#9670;&nbsp;</a></span>makeCanonicalBoolValuePair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;<a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> *, <a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> *&gt; clang::dataflow::makeCanonicalBoolValuePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> &amp;&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1BoolValue.html">BoolValue</a> &amp;&#160;</td>
          <td class="paramname"><em>RHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataflowAnalysisContext_8cpp_source.html#l00025">25</a> of file <a class="el" href="DataflowAnalysisContext_8cpp_source.html">DataflowAnalysisContext.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowAnalysisContext_8cpp_source.html#l00033">clang::dataflow::DataflowAnalysisContext::getOrCreateConjunctionValue()</a>, and <a class="el" href="DataflowAnalysisContext_8cpp_source.html#l00047">clang::dataflow::DataflowAnalysisContext::getOrCreateDisjunctionValue()</a>.</p>

</div>
</div>
<a id="a26f5dd427c7fac0a27f36cbf8505822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f5dd427c7fac0a27f36cbf8505822a">&#9670;&nbsp;</a></span>negLit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> clang::dataflow::negLit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negative literal <code>!V</code>. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00065">65</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTContext_8h_source.html#l03167">V</a>.</p>

<p class="reference">Referenced by <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00174">buildBooleanFormula()</a>, <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00357">clang::dataflow::WatchedLiteralsSolverImpl::solve()</a>, and <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00337">clang::dataflow::WatchedLiteralsSolverImpl::WatchedLiteralsSolverImpl()</a>.</p>

</div>
</div>
<a id="a4bcbfb59583a22b0b99263c768ae7305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcbfb59583a22b0b99263c768ae7305">&#9670;&nbsp;</a></span>notLit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> clang::dataflow::notLit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the negated literal <code>!L</code>. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00068">68</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

</div>
</div>
<a id="a9e369a93a0b5737004b36fe3768fa6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e369a93a0b5737004b36fe3768fa6a3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename ElementLattice &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; clang::dataflow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>Os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1MapLattice.html">clang::dataflow::MapLattice</a>&lt; Key, ElementLattice &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MapLattice_8h_source.html#l00113">113</a> of file <a class="el" href="MapLattice_8h_source.html">MapLattice.h</a>.</p>

<p class="reference">References <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="adc2f6410422aac0807f573005d11ab9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2f6410422aac0807f573005d11ab9b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementLattice &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; clang::dataflow::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>Os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceclang_1_1dataflow.html#ad3b29d6a0866970fca387023263863f0">clang::dataflow::VarMapLattice</a>&lt; ElementLattice &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MapLattice_8h_source.html#l00126">126</a> of file <a class="el" href="MapLattice_8h_source.html">MapLattice.h</a>.</p>

<p class="reference">References <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="a7a12cd68fa7c7f5f23f7807c54d0c736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a12cd68fa7c7f5f23f7807c54d0c736">&#9670;&nbsp;</a></span>posLit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> clang::dataflow::posLit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the positive literal <code>V</code>. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00062">62</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTContext_8h_source.html#l03167">V</a>.</p>

<p class="reference">Referenced by <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00174">buildBooleanFormula()</a>, <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00357">clang::dataflow::WatchedLiteralsSolverImpl::solve()</a>, and <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00337">clang::dataflow::WatchedLiteralsSolverImpl::WatchedLiteralsSolverImpl()</a>.</p>

</div>
</div>
<a id="ab8e981dcc0f5741c59ca9ee9351565ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e981dcc0f5741c59ca9ee9351565ba">&#9670;&nbsp;</a></span>runDataflowAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnalysisT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt;std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt;<a class="el" href="structclang_1_1dataflow_1_1DataflowAnalysisState.html">DataflowAnalysisState</a>&lt;typename AnalysisT::Lattice&gt; &gt; &gt; &gt; clang::dataflow::runDataflowAnalysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;&#160;</td>
          <td class="paramname"><em>CFCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnalysisT &amp;&#160;</td>
          <td class="paramname"><em>Analysis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>InitEnv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dataflow analysis and returns a mapping from basic block IDs to dataflow analysis states that model the respective basic blocks. </p>
<p>Indices of the returned vector correspond to basic block IDs. Returns an error if the dataflow analysis cannot be performed successfully. </p>

<p class="definition">Definition at line <a class="el" href="DataflowAnalysis_8h_source.html#l00115">115</a> of file <a class="el" href="DataflowAnalysis_8h_source.html">DataflowAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00299">runTypeErasedDataflowAnalysis()</a>, and <a class="el" href="UnwrappedLineFormatter_8cpp_source.html#l01083">State</a>.</p>

</div>
</div>
<a id="a9270febd6a00626f876570ba50aba62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9270febd6a00626f876570ba50aba62b">&#9670;&nbsp;</a></span>runTypeErasedDataflowAnalysis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Expected.html">llvm::Expected</a>&lt; std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt; &gt; &gt; clang::dataflow::runTypeErasedDataflowAnalysis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;&#160;</td>
          <td class="paramname"><em>CFCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>Analysis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>InitEnv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dataflow analysis and returns a mapping from basic block IDs to dataflow analysis states that model the respective basic blocks. </p>
<p>Indices of the returned vector correspond to basic block IDs. Returns an error if the dataflow analysis cannot be performed successfully. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00299">299</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3ae1e4c8c9ccd9fc39c391da4bcd093fb2">clang::Block</a>, <a class="el" href="DataflowWorklist_8h_source.html#l00042">clang::DataflowWorklistBase&lt; Comp, QueueSize &gt;::dequeue()</a>, <a class="el" href="DataflowWorklist_8h_source.html#l00071">clang::ForwardDataflowWorklist::enqueueSuccessors()</a>, <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00092">clang::dataflow::TypeErasedDataflowAnalysisState::Env</a>, <a class="el" href="CFG_8h_source.html#l01074">clang::CFGBlock::getBlockID()</a>, <a class="el" href="ControlFlowContext_8h_source.html#l00038">clang::dataflow::ControlFlowContext::getCFG()</a>, <a class="el" href="CFG_8h_source.html#l01331">clang::CFG::getEntry()</a>, <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html#abee269c8a611d8eca31c71062271577c">clang::dataflow::TypeErasedDataflowAnalysis::isEqualTypeErased()</a>, <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00089">clang::dataflow::TypeErasedDataflowAnalysisState::Lattice</a>, <a class="el" href="CFG_8h_source.html#l01416">clang::CFG::size()</a>, <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00270">transferBlock()</a>, and <a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html#a5f93acbbc4dfef2f227cbd3608209a2c">clang::dataflow::TypeErasedDataflowAnalysis::typeErasedInitialElement()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowAnalysis_8h_source.html#l00115">runDataflowAnalysis()</a>.</p>

</div>
</div>
<a id="a65c5998642b2607294297bfe3843e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c5998642b2607294297bfe3843e2d0">&#9670;&nbsp;</a></span>skipExprWithCleanups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classclang_1_1Expr.html">Expr</a>* clang::dataflow::skipExprWithCleanups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Expr.html">Expr</a> *&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Transfer_8cpp_source.html#l00034">34</a> of file <a class="el" href="Transfer_8cpp_source.html">Transfer.cpp</a>.</p>

</div>
</div>
<a id="a6834cbcf9a9ea98e9a7bdbecbe04cf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6834cbcf9a9ea98e9a7bdbecbe04cf1c">&#9670;&nbsp;</a></span>transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clang::dataflow::transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1StmtToEnvMap.html">StmtToEnvMap</a> &amp;&#160;</td>
          <td class="paramname"><em>StmtToEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>Env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <code>S</code> and updates <code>Env</code> accordingly. </p>
<p>Requirements:</p>
<p>The type of <code>S</code> must not be <code><a class="el" href="classclang_1_1ParenExpr.html" title="ParenExpr - This represents a parethesized expression, e.g.">ParenExpr</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="Transfer_8cpp_source.html#l00540">540</a> of file <a class="el" href="Transfer_8cpp_source.html">Transfer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowAnalysis_8h_source.html#l00089">clang::dataflow::DataflowAnalysis&lt; UncheckedOptionalAccessModel, SourceLocationsLattice &gt;::transferTypeErased()</a>.</p>

</div>
</div>
<a id="a470c26a0b7692f4a4f2de7f5762db4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c26a0b7692f4a4f2de7f5762db4db">&#9670;&nbsp;</a></span>transferBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> clang::dataflow::transferBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;&#160;</td>
          <td class="paramname"><em>CFCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>BlockStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGBlock.html">CFGBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>Block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1Environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>InitEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>Analysis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;, const <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>HandleTransferredStmt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfers the state of a basic block by evaluating each of its statements in the context of <code>Analysis</code> and the states of its predecessors that are available in <code>BlockStates</code>. </p>
<p><code>HandleTransferredStmt</code> (if provided) will be applied to each statement in the block, after it is evaluated.</p>
<p>Requirements:</p>
<p>All predecessors of <code>Block</code> except those with loop back edges must have already been transferred. States in <code>BlockStates</code> that are set to <code>llvm::None</code> represent basic blocks that are not evaluated yet. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00270">270</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeErasedDataflowAnalysis_8h_source.html#l00083">clang::dataflow::TypeErasedDataflowAnalysis::applyBuiltinTransfer()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3ae1e4c8c9ccd9fc39c391da4bcd093fb2">clang::Block</a>, <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00135">computeBlockInputState()</a>, <a class="el" href="CFG_8h_source.html#l00059">clang::CFGElement::Initializer</a>, <a class="el" href="UnwrappedLineFormatter_8cpp_source.html#l01083">State</a>, <a class="el" href="CFG_8h_source.html#l00066">clang::CFGElement::Statement</a>, <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00236">transferCFGInitializer()</a>, and <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00216">transferCFGStmt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00299">runTypeErasedDataflowAnalysis()</a>.</p>

</div>
</div>
<a id="aa1f7086aaf7c653d47dbb210b01e3d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f7086aaf7c653d47dbb210b01e3d1c">&#9670;&nbsp;</a></span>transferCFGInitializer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::dataflow::transferCFGInitializer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGInitializer.html">CFGInitializer</a> &amp;&#160;</td>
          <td class="paramname"><em>CfgInit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>State</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers <code>State</code> by evaluating <code>CfgInit</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00236">236</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="CFG_8h_source.html#l00230">clang::CFGInitializer::getInitializer()</a>, <a class="el" href="namespaceclang.html#a8cde5fea3e993010e91c2ede956271e1ae807e61ca16dbec95fce00d4e542b9cd">clang::Initializer</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a858ba4765e53c712ef672a9570474b1d">clang::Member</a>, <a class="el" href="namespaceclang_1_1dataflow.html#abaa6d295ccea77fdf5752524bc6bdef6a63d5049791d9d79d86e9a108b0a999ca">Reference</a>, and <a class="el" href="UnwrappedLineFormatter_8cpp_source.html#l01083">State</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00270">transferBlock()</a>.</p>

</div>
</div>
<a id="a54934e3c886d841b8e2365fb61a5fd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54934e3c886d841b8e2365fb61a5fd80">&#9670;&nbsp;</a></span>transferCFGStmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void clang::dataflow::transferCFGStmt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1dataflow_1_1ControlFlowContext.html">ControlFlowContext</a> &amp;&#160;</td>
          <td class="paramname"><em>CFCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>BlockStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;&#160;</td>
          <td class="paramname"><em>CfgStmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1dataflow_1_1TypeErasedDataflowAnalysis.html">TypeErasedDataflowAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>Analysis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>State</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="classclang_1_1CFGStmt.html">CFGStmt</a> &amp;, const <a class="el" href="structclang_1_1dataflow_1_1TypeErasedDataflowAnalysisState.html">TypeErasedDataflowAnalysisState</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>HandleTransferredStmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers <code>State</code> by evaluating <code>CfgStmt</code> in the context of <code>Analysis</code>. </p>
<p><code>HandleTransferredStmt</code> (if provided) will be applied to <code>CfgStmt</code>, after it is evaluated. </p>

<p class="definition">Definition at line <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00216">216</a> of file <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html">TypeErasedDataflowAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeErasedDataflowAnalysis_8cpp_source.html#l00270">transferBlock()</a>.</p>

</div>
</div>
<a id="aa858fe7ef413718673ced2de8af3b28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858fe7ef413718673ced2de8af3b28a">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a> clang::dataflow::var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a>&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the variable of <code>L</code>. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00071">71</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaExpr_8cpp_source.html#l16038">clang::Sema::ActOnBlockStmtExpr()</a>, <a class="el" href="SemaStmt_8cpp_source.html#l00083">clang::Sema::ActOnForEachDeclStmt()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l13253">clang::Sema::CheckCompleteVariableDeclaration()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l15827">considerVariable()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00768">drillIntoBlockVariable()</a>, <a class="el" href="CGCall_8cpp_source.html#l02607">emitArgumentDemotion()</a>, <a class="el" href="CGDecl_8cpp_source.html#l02017">clang::CodeGen::CodeGenFunction::emitAutoVarTypeCleanup()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00650">EmitAutoVarWithLifetime()</a>, <a class="el" href="CGBlocks_8cpp_source.html#l02576">clang::CodeGen::CodeGenFunction::emitBlockByrefAddress()</a>, <a class="el" href="CGExpr_8cpp_source.html#l02721">clang::CodeGen::CodeGenFunction::EmitDeclRefLValue()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00426">clang::CodeGen::CodeGenFunction::EmitStaticVarDecl()</a>, <a class="el" href="CGBlocks_8cpp_source.html#l01447">clang::CodeGen::CodeGenFunction::GenerateBlockFunction()</a>, <a class="el" href="CGBlocks_8h_source.html#l00301">clang::CodeGen::CGBlockInfo::getCapture()</a>, <a class="el" href="CFG_8cpp_source.html#l05110">clang::CFGImplicitDtor::getDestructorDecl()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l06540">clang::Sema::inferObjCARCLifetime()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00686">isAccessedBy()</a>, <a class="el" href="CGExprAgg_8cpp_source.html#l01102">isBlockVarRef()</a>, <a class="el" href="SemaInit_8cpp_source.html#l05431">isInvalidICRSource()</a>, <a class="el" href="CGCleanup_8cpp_source.html#l01213">SetupCleanupBlockActivation()</a>, <a class="el" href="CGObjC_8cpp_source.html#l00288">shouldExtendReceiverForInnerPointerMessage()</a>, <a class="el" href="TransBlockObjCVariable_8cpp_source.html#l00126">clang::arcmt::trans::BlockObjCVariableTraverser::traverseBody()</a>, <a class="el" href="CGBlocks_8cpp_source.html#l00462">tryCaptureAsConstant()</a>, and <a class="el" href="CGExpr_8cpp_source.html#l01481">clang::CodeGen::CodeGenFunction::tryEmitAsConstant()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a74b2491f0e42f80312a2143043106ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b2491f0e42f80312a2143043106ef0">&#9670;&nbsp;</a></span>MaxCompositeValueDepth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::dataflow::MaxCompositeValueDepth = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00035">35</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

</div>
</div>
<a id="a8c78b043618ceb361b508c495f3cd7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c78b043618ceb361b508c495f3cd7af">&#9670;&nbsp;</a></span>MaxCompositeValueSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::dataflow::MaxCompositeValueSize = 1000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DataflowEnvironment_8cpp_source.html#l00036">36</a> of file <a class="el" href="DataflowEnvironment_8cpp_source.html">DataflowEnvironment.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DataflowEnvironment_8cpp_source.html#l00409">clang::dataflow::Environment::createValue()</a>.</p>

</div>
</div>
<a id="a83a8b17ea24b227ff9a3e147fa5114b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a8b17ea24b227ff9a3e147fa5114b3">&#9670;&nbsp;</a></span>NullClause</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a03f189ebd178b6b46a9e9bd70a791d64">ClauseID</a> clang::dataflow::NullClause = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A null clause identifier is used as a placeholder in various data structures and algorithms. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00078">78</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

</div>
</div>
<a id="a598607161a459c63ed3db33c74c8e84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598607161a459c63ed3db33c74c8e84d">&#9670;&nbsp;</a></span>NullLit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceclang_1_1dataflow.html#a976b5e84c22bdee7966721cba9133be6">Literal</a> clang::dataflow::NullLit = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A null literal is used as a placeholder in various data structures and algorithms. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00059">59</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00139">clang::dataflow::BooleanFormula::addClause()</a>.</p>

</div>
</div>
<a id="a20ea08fc194905b51add62e044672472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ea08fc194905b51add62e044672472">&#9670;&nbsp;</a></span>NullVar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceclang_1_1dataflow.html#ab7b87ef92590f732efb46c7d33a11005">Variable</a> clang::dataflow::NullVar = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A null boolean variable is used as a placeholder in various data structures and algorithms. </p>

<p class="definition">Definition at line <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00049">49</a> of file <a class="el" href="WatchedLiteralsSolver_8cpp_source.html">WatchedLiteralsSolver.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="WatchedLiteralsSolver_8cpp_source.html#l00337">clang::dataflow::WatchedLiteralsSolverImpl::WatchedLiteralsSolverImpl()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:28 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
