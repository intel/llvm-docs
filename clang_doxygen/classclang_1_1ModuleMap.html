<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ModuleMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ModuleMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clang::ModuleMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ModuleMap_8h_source.html">clang/Lex/ModuleMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A header that is known to reside within a given module, whether it was included or excluded.  <a href="classclang_1_1ModuleMap_1_1KnownHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> { <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa">NormalHeader</a> = 0x0, 
<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4">PrivateHeader</a> = 0x1, 
<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200">TextualHeader</a> = 0x2
 }</td></tr>
<tr class="memdesc:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the role of a module header.  <a href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">More...</a><br /></td></tr>
<tr class="separator:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1 &gt;</td></tr>
<tr class="separator:ac22c56a8f11f61caa8ab58809a21cca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b352087754574155a198a4cb0d6e197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> = llvm::StringMap&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;::const_iterator</td></tr>
<tr class="separator:a1b352087754574155a198a4cb0d6e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac588ee8d4c631303982ed1c68002f49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">resolveLinkAsDependencies</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:ac588ee8d4c631303982ed1c68002f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases.  <a href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">More...</a><br /></td></tr>
<tr class="separator:ac588ee8d4c631303982ed1c68002f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06068cd4735154ef4218ab96f9462412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">addLinkAsDependency</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:a06068cd4735154ef4218ab96f9462412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise.  <a href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">More...</a><br /></td></tr>
<tr class="separator:a06068cd4735154ef4218ab96f9462412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767bb9d1787801348282cf9b588df471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">ModuleMap</a> (<a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;SourceMgr, <a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;Diags, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *Target, <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;HeaderInfo)</td></tr>
<tr class="memdesc:a767bb9d1787801348282cf9b588df471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new module map.  <a href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">More...</a><br /></td></tr>
<tr class="separator:a767bb9d1787801348282cf9b588df471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">~ModuleMap</a> ()</td></tr>
<tr class="memdesc:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the module map.  <a href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">More...</a><br /></td></tr>
<tr class="separator:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc441df169e00dbd5ab3a5db003d454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">setTarget</a> (const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;Target)</td></tr>
<tr class="memdesc:abc441df169e00dbd5ab3a5db003d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target information.  <a href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">More...</a><br /></td></tr>
<tr class="separator:abc441df169e00dbd5ab3a5db003d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c624a7392febb43c7bb1a19e835ab34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6c624a7392febb43c7bb1a19e835ab34">setBuiltinIncludeDir</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir)</td></tr>
<tr class="memdesc:a6c624a7392febb43c7bb1a19e835ab34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>.  <a href="classclang_1_1ModuleMap.html#a6c624a7392febb43c7bb1a19e835ab34">More...</a><br /></td></tr>
<tr class="separator:a6c624a7392febb43c7bb1a19e835ab34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a9836fc4829507cded4d63e24f6fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1c4a9836fc4829507cded4d63e24f6fc">getBuiltinDir</a> () const</td></tr>
<tr class="memdesc:a1c4a9836fc4829507cded4d63e24f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the directory that contains Clang-supplied include files.  <a href="classclang_1_1ModuleMap.html#a1c4a9836fc4829507cded4d63e24f6fc">More...</a><br /></td></tr>
<tr class="separator:a1c4a9836fc4829507cded4d63e24f6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1e8ca3bc91f0e93e6c706b80f263e521">isBuiltinHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File)</td></tr>
<tr class="separator:a1e8ca3bc91f0e93e6c706b80f263e521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba163200648ee309a8b16ccc0d62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">addModuleMapCallbacks</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt; Callback)</td></tr>
<tr class="memdesc:a516ba163200648ee309a8b16ccc0d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a module map callback.  <a href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">More...</a><br /></td></tr>
<tr class="separator:a516ba163200648ee309a8b16ccc0d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8806b0826524879693983c42a0cd9aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8806b0826524879693983c42a0cd9aa9">findModuleForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowTextual=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a8806b0826524879693983c42a0cd9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module that owns the given header file, if any.  <a href="classclang_1_1ModuleMap.html#a8806b0826524879693983c42a0cd9aa9">More...</a><br /></td></tr>
<tr class="separator:a8806b0826524879693983c42a0cd9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cf9768b587f077bf7916c10754713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File)</td></tr>
<tr class="memdesc:a94cf9768b587f077bf7916c10754713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the modules that contain the given header file.  <a href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">More...</a><br /></td></tr>
<tr class="separator:a94cf9768b587f077bf7916c10754713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569af5b4b731de5a135caf8636681b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7569af5b4b731de5a135caf8636681b3">findResolvedModulesForHeader</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File) const</td></tr>
<tr class="memdesc:a7569af5b4b731de5a135caf8636681b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so.  <a href="classclang_1_1ModuleMap.html#a7569af5b4b731de5a135caf8636681b3">More...</a><br /></td></tr>
<tr class="separator:a7569af5b4b731de5a135caf8636681b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">resolveHeaderDirectives</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File) const</td></tr>
<tr class="memdesc:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all lazy header directives for the specified file.  <a href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">More...</a><br /></td></tr>
<tr class="separator:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7f7d3851e51a8409988c5c182490ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a2a7f7d3851e51a8409988c5c182490ac">resolveHeaderDirectives</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt; File) const</td></tr>
<tr class="memdesc:a2a7f7d3851e51a8409988c5c182490ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve lazy header directives for the specified module.  <a href="classclang_1_1ModuleMap.html#a2a7f7d3851e51a8409988c5c182490ac">More...</a><br /></td></tr>
<tr class="separator:a2a7f7d3851e51a8409988c5c182490ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a53c752925c104a4c429da4adc05da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac2a53c752925c104a4c429da4adc05da">diagnoseHeaderInclusion</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> RequestingModuleIsModuleInterface, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> FilenameLoc, StringRef <a class="el" href="ClangSrcLocDump_8cpp.html#a637a6651de5d8f7041e8e604929b1e94">Filename</a>, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File)</td></tr>
<tr class="memdesc:ac2a53c752925c104a4c429da4adc05da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors if a module must not include a specific file.  <a href="classclang_1_1ModuleMap.html#ac2a53c752925c104a4c429da4adc05da">More...</a><br /></td></tr>
<tr class="separator:ac2a53c752925c104a4c429da4adc05da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc11dbc10f0658870b83753074c3c1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#afc11dbc10f0658870b83753074c3c1d9">isHeaderInUnavailableModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header) const</td></tr>
<tr class="memdesc:afc11dbc10f0658870b83753074c3c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is part of a module marked 'unavailable'.  <a href="classclang_1_1ModuleMap.html#afc11dbc10f0658870b83753074c3c1d9">More...</a><br /></td></tr>
<tr class="separator:afc11dbc10f0658870b83753074c3c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ef9bee13458036c9e4d5d7df58c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a890ef9bee13458036c9e4d5d7df58c8f">isHeaderUnavailableInModule</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *Header, const <a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule) const</td></tr>
<tr class="memdesc:a890ef9bee13458036c9e4d5d7df58c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is unavailable as part of the specified module.  <a href="classclang_1_1ModuleMap.html#a890ef9bee13458036c9e4d5d7df58c8f">More...</a><br /></td></tr>
<tr class="separator:a890ef9bee13458036c9e4d5d7df58c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">findModule</a> (StringRef Name) const</td></tr>
<tr class="memdesc:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name.  <a href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">More...</a><br /></td></tr>
<tr class="separator:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682383d1483005eb8de8ab46275f5e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">lookupModuleUnqualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:a9682383d1483005eb8de8ab46275f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name using lexical name lookup, starting at the given context.  <a href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">More...</a><br /></td></tr>
<tr class="separator:a9682383d1483005eb8de8ab46275f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd056e3b16607ace724463606dd3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">lookupModuleQualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:ac4bd056e3b16607ace724463606dd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name within the given context, using direct (qualified) name lookup.  <a href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">More...</a><br /></td></tr>
<tr class="separator:ac4bd056e3b16607ace724463606dd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a5b7b114346aaa534995084fc3ac0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">findOrCreateModule</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExplicit)</td></tr>
<tr class="memdesc:a115a5b7b114346aaa534995084fc3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new module or submodule, or create it if it does not already exist.  <a href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">More...</a><br /></td></tr>
<tr class="separator:a115a5b7b114346aaa534995084fc3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984430b63c290eb25d0b696d486303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">createGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="memdesc:ab984430b63c290eb25d0b696d486303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module unit.  <a href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">More...</a><br /></td></tr>
<tr class="separator:ab984430b63c290eb25d0b696d486303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">createPrivateModuleFragmentForInterfaceUnit</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc)</td></tr>
<tr class="memdesc:acea4a5b3bc65f0ff822859970c2ecac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">More...</a><br /></td></tr>
<tr class="separator:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3b29c079da00f53ccd31b16f5a413a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6c3b29c079da00f53ccd31b16f5a413a">createModuleForInterfaceUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *GlobalModule)</td></tr>
<tr class="memdesc:a6c3b29c079da00f53ccd31b16f5a413a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#a6c3b29c079da00f53ccd31b16f5a413a">More...</a><br /></td></tr>
<tr class="separator:a6c3b29c079da00f53ccd31b16f5a413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1418097f85910bca7bd12b1f17208b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1a1418097f85910bca7bd12b1f17208b">createHeaderModule</a> (StringRef Name, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> &gt; Headers)</td></tr>
<tr class="memdesc:a1a1418097f85910bca7bd12b1f17208b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a header module from the specified list of headers.  <a href="classclang_1_1ModuleMap.html#a1a1418097f85910bca7bd12b1f17208b">More...</a><br /></td></tr>
<tr class="separator:a1a1418097f85910bca7bd12b1f17208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488004c9aee8ccd0836e58ab114813ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">createHeaderUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> H)</td></tr>
<tr class="memdesc:a488004c9aee8ccd0836e58ab114813ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++20 header unit.  <a href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">More...</a><br /></td></tr>
<tr class="separator:a488004c9aee8ccd0836e58ab114813ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78651ebbabbed8598a8b3d71c0712f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ad78651ebbabbed8598a8b3d71c0712f6">inferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *FrameworkDir, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="memdesc:ad78651ebbabbed8598a8b3d71c0712f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the contents of a framework module map from the given framework directory.  <a href="classclang_1_1ModuleMap.html#ad78651ebbabbed8598a8b3d71c0712f6">More...</a><br /></td></tr>
<tr class="separator:ad78651ebbabbed8598a8b3d71c0712f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a847ae6f15d895ef5808fd4af56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">createShadowedModule</a> (StringRef Name, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="classclang_1_1Module.html">Module</a> *ShadowingModule)</td></tr>
<tr class="memdesc:a031a847ae6f15d895ef5808fd4af56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level module that is shadowed by <code>ShadowingModule</code>.  <a href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">More...</a><br /></td></tr>
<tr class="separator:a031a847ae6f15d895ef5808fd4af56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f6e47e08d60984fca9c6c492d42f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">finishModuleDeclarationScope</a> ()</td></tr>
<tr class="memdesc:a390f6e47e08d60984fca9c6c492d42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope.  <a href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">More...</a><br /></td></tr>
<tr class="separator:a390f6e47e08d60984fca9c6c492d42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3df11cf9b74e240aa373f25c1a63b49f">mayShadowNewModule</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *ExistingModule)</td></tr>
<tr class="separator:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14289476fe5638600e7e1d78f41a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">canInferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir) const</td></tr>
<tr class="memdesc:a3b14289476fe5638600e7e1d78f41a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a framework module can be inferred in the given directory.  <a href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">More...</a><br /></td></tr>
<tr class="separator:a3b14289476fe5638600e7e1d78f41a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ec7ef5400f119c1e95c28dad0371d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab71ec7ef5400f119c1e95c28dad0371d">getContainingModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="memdesc:ab71ec7ef5400f119c1e95c28dad0371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module map file containing the definition of the given module.  <a href="classclang_1_1ModuleMap.html#ab71ec7ef5400f119c1e95c28dad0371d">More...</a><br /></td></tr>
<tr class="separator:ab71ec7ef5400f119c1e95c28dad0371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad77286fb30719f2f516e5a67acaefe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8ad77286fb30719f2f516e5a67acaefe">getModuleMapFileForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="memdesc:a8ad77286fb30719f2f516e5a67acaefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module map file that (along with the module name) uniquely identifies this module.  <a href="classclang_1_1ModuleMap.html#a8ad77286fb30719f2f516e5a67acaefe">More...</a><br /></td></tr>
<tr class="separator:a8ad77286fb30719f2f516e5a67acaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf116b47bb6201a8154feab288cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a64cf116b47bb6201a8154feab288cc65">setInferredModuleAllowedBy</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *ModMap)</td></tr>
<tr class="separator:a64cf116b47bb6201a8154feab288cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">getAdditionalModuleMapFiles</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:a9c2eda49b11b2b5dd41e456d986623e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>.  <a href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">More...</a><br /></td></tr>
<tr class="separator:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748c66535339dbf5b860b72eff5cbadb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a748c66535339dbf5b860b72eff5cbadb">addAdditionalModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *<a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a>)</td></tr>
<tr class="separator:a748c66535339dbf5b860b72eff5cbadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d91ee91e3d302d32885c4d790b3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">resolveExports</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a03d91ee91e3d302d32885c4d790b3915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved exports in the given module.  <a href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">More...</a><br /></td></tr>
<tr class="separator:a03d91ee91e3d302d32885c4d790b3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff262a15ac7933edd463953d969e4f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">resolveUses</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:aff262a15ac7933edd463953d969e4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved uses in the given module.  <a href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">More...</a><br /></td></tr>
<tr class="separator:aff262a15ac7933edd463953d969e4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635593eb7f27a7297eb22afacd08d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">resolveConflicts</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a635593eb7f27a7297eb22afacd08d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved conflicts in the given module.  <a href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">More...</a><br /></td></tr>
<tr class="separator:a635593eb7f27a7297eb22afacd08d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac236ffc11120133f8b4908b175e98172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac236ffc11120133f8b4908b175e98172">setUmbrellaHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *UmbrellaHeader, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:ac236ffc11120133f8b4908b175e98172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella header of the given module to the given header.  <a href="classclang_1_1ModuleMap.html#ac236ffc11120133f8b4908b175e98172">More...</a><br /></td></tr>
<tr class="separator:ac236ffc11120133f8b4908b175e98172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5148fa4f93b67492291bee915c9e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a4c5148fa4f93b67492291bee915c9e27">setUmbrellaDir</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *UmbrellaDir, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a4c5148fa4f93b67492291bee915c9e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella directory of the given module to the given directory.  <a href="classclang_1_1ModuleMap.html#a4c5148fa4f93b67492291bee915c9e27">More...</a><br /></td></tr>
<tr class="separator:a4c5148fa4f93b67492291bee915c9e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">addHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Imported=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this header to the given module.  <a href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">More...</a><br /></td></tr>
<tr class="separator:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836cc1b5aecd0071b6e90837fefa0b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a836cc1b5aecd0071b6e90837fefa0b2a">excludeHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header)</td></tr>
<tr class="memdesc:a836cc1b5aecd0071b6e90837fefa0b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this header as being excluded from the given module.  <a href="classclang_1_1ModuleMap.html#a836cc1b5aecd0071b6e90837fefa0b2a">More...</a><br /></td></tr>
<tr class="separator:a836cc1b5aecd0071b6e90837fefa0b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516cfeb32bb3a464262cf6f369417eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a516cfeb32bb3a464262cf6f369417eab">parseModuleMapFile</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *HomeDir, <a class="el" href="classclang_1_1FileID.html">FileID</a> ID=<a class="el" href="classclang_1_1FileID.html">FileID</a>(), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="Format_8cpp.html#a9fcf84dffafb0ea03c0f9b686ddbf2b3">Offset</a>=nullptr, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> ExternModuleLoc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="memdesc:a516cfeb32bb3a464262cf6f369417eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given module map file, and record any modules we encounter.  <a href="classclang_1_1ModuleMap.html#a516cfeb32bb3a464262cf6f369417eab">More...</a><br /></td></tr>
<tr class="separator:a516cfeb32bb3a464262cf6f369417eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">dump</a> ()</td></tr>
<tr class="memdesc:a0ed1579ac35c5dcb1ab68449949a6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the module map, for debugging purposes.  <a href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">More...</a><br /></td></tr>
<tr class="separator:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6ab65f1f0882fcff9a15da9cfbf0fd02">module_begin</a> () const</td></tr>
<tr class="separator:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9d9e3147d81ec86cf00eea874d9ea95b">module_end</a> () const</td></tr>
<tr class="separator:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memItemLeft" align="right" valign="top">llvm::iterator_range&lt; <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9124c52cfa4df22a479eddbcc8e350d3">modules</a> () const</td></tr>
<tr class="separator:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">cacheModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II, <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:ac61bce84c6ecb21f1f05539c84b855ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache a module load. M might be nullptr.  <a href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">More...</a><br /></td></tr>
<tr class="separator:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52a9df394e4ad6fd8216b1091cca20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ad52a9df394e4ad6fd8216b1091cca20c">getCachedModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II)</td></tr>
<tr class="memdesc:ad52a9df394e4ad6fd8216b1091cca20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cached module load.  <a href="classclang_1_1ModuleMap.html#ad52a9df394e4ad6fd8216b1091cca20c">More...</a><br /></td></tr>
<tr class="separator:ad52a9df394e4ad6fd8216b1091cca20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af95957116dd995616c90e64c864811cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">headerKindToRole</a> (<a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> Kind)</td></tr>
<tr class="memdesc:af95957116dd995616c90e64c864811cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header kind to a role. Requires Kind to not be HK_Excluded.  <a href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">More...</a><br /></td></tr>
<tr class="separator:af95957116dd995616c90e64c864811cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c51efd0ee64aaadd73218544eeeb01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">headerRoleToKind</a> (<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role)</td></tr>
<tr class="memdesc:a32c51efd0ee64aaadd73218544eeeb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header role to a kind.  <a href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">More...</a><br /></td></tr>
<tr class="separator:a32c51efd0ee64aaadd73218544eeeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a40c825f7506d1abd0d9bc54eba6330e6">isBuiltinHeader</a> (StringRef FileName)</td></tr>
<tr class="memdesc:a40c825f7506d1abd0d9bc54eba6330e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a compiler builtin header?  <a href="classclang_1_1ModuleMap.html#a40c825f7506d1abd0d9bc54eba6330e6">More...</a><br /></td></tr>
<tr class="separator:a40c825f7506d1abd0d9bc54eba6330e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a69fccb440615f32e24516ed4e718457d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a69fccb440615f32e24516ed4e718457d">ModuleMapParser</a></td></tr>
<tr class="separator:a69fccb440615f32e24516ed4e718457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00075">75</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac22c56a8f11f61caa8ab58809a21cca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22c56a8f11f61caa8ab58809a21cca3">&#9670;&nbsp;</a></span>AdditionalModMapsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">clang::ModuleMap::AdditionalModMapsSet</a> =  <a class="el" href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet</a>&lt;const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00193">193</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1b352087754574155a198a4cb0d6e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352087754574155a198a4cb0d6e197">&#9670;&nbsp;</a></span>module_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">clang::ModuleMap::module_iterator</a> =  llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00713">713</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac7a2413d4d0a8f29d2dad359bcfd8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">&#9670;&nbsp;</a></span>ModuleHeaderRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">clang::ModuleMap::ModuleHeaderRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags describing the role of a module header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa"></a>NormalHeader&#160;</td><td class="fielddoc"><p>This header is normally included in the module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4"></a>PrivateHeader&#160;</td><td class="fielddoc"><p>This header is included but private. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200"></a>TextualHeader&#160;</td><td class="fielddoc"><p>This header is part of the module (for layering purposes) but should be textually included. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00128">128</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a767bb9d1787801348282cf9b588df471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767bb9d1787801348282cf9b588df471">&#9670;&nbsp;</a></span>ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::ModuleMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>Diags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LangOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *&#160;</td>
          <td class="paramname"><em>Target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;&#160;</td>
          <td class="paramname"><em>HeaderInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new module map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMgr</td><td>The source manager used to find module files and headers. This source manager should be shared with the header-search mechanism, since they will refer to the same headers.</td></tr>
    <tr><td class="paramname">Diags</td><td>A diagnostic engine used for diagnostics.</td></tr>
    <tr><td class="paramname">LangOpts</td><td>Language options for this translation unit.</td></tr>
    <tr><td class="paramname">Target</td><td>The target for this translation unit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00314">314</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#acdf88ec6c845aa781824469fcb0af66cac41a31890959544c6523af684561abe5">clang::Target</a>.</p>

</div>
</div>
<a id="ab8769cd7eba3cb7f8f1cd2dde890603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8769cd7eba3cb7f8f1cd2dde890603d">&#9670;&nbsp;</a></span>~ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::~ModuleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the module map. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00322">322</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748c66535339dbf5b860b72eff5cbadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748c66535339dbf5b860b72eff5cbadb">&#9670;&nbsp;</a></span>addAdditionalModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addAdditionalModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>ModuleMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01298">1298</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acb605a0f3e5ac2213bab92d201fc1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605a0f3e5ac2213bab92d201fc1ec1">&#9670;&nbsp;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Imported</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this header to the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Role</td><td>The role of the header wrt the module. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01238">1238</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00210">clang::Module::Header::Entry</a>, <a class="el" href="FileEntry_8h_source.html#l00364">clang::FileEntry::getName()</a>, <a class="el" href="Module_8h_source.html#l00553">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00076">headerRoleToKind()</a>, <a class="el" href="Module_8h_source.html#l00226">clang::Module::Headers</a>, <a class="el" href="LangOptions_8h_source.html#l00446">clang::LangOptions::isCompilingModule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01335">clang::HeaderSearch::MarkFileModuleHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTReader_8cpp_source.html#l01884">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="a06068cd4735154ef4218ab96f9462412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06068cd4735154ef4218ab96f9462412">&#9670;&nbsp;</a></span>addLinkAsDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addLinkAsDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00069">69</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00158">clang::Module::ExportAsModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00790">findModule()</a>, <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>, and <a class="el" href="Module_8h_source.html#l00404">clang::Module::UseExportAsModuleLinkName</a>.</p>

</div>
</div>
<a id="a516ba163200648ee309a8b16ccc0d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba163200648ee309a8b16ccc0d62a">&#9670;&nbsp;</a></span>addModuleMapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::addModuleMapCallbacks </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt;&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a module map callback. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00418">418</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyFile_8cpp_source.html#l00177">clang::DependencyCollector::attachToPreprocessor()</a>, and <a class="el" href="ModuleDependencyCollector_8cpp_source.html#l00105">clang::ModuleDependencyCollector::attachToPreprocessor()</a>.</p>

</div>
</div>
<a id="ac61bce84c6ecb21f1f05539c84b855ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bce84c6ecb21f1f05539c84b855ad">&#9670;&nbsp;</a></span>cacheModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::cacheModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache a module load. M might be nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00722">722</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01941">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a3b14289476fe5638600e7e1d78f41a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14289476fe5638600e7e1d78f41a0e">&#9670;&nbsp;</a></span>canInferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::canInferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a framework module can be inferred in the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00595">595</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00439">loadModuleMapForModuleBuild()</a>.</p>

</div>
</div>
<a id="ab984430b63c290eb25d0b696d486303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984430b63c290eb25d0b696d486303c">&#9670;&nbsp;</a></span>createGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module unit. </p>
<p>We model the global module fragment as a submodule of the module interface unit. Unfortunately, we can't create the module interface unit's <a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> until later, because we don't know what it will be called usually. See C++20 [module.unit]/7.2 for the case we could know its parent. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00835">835</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00122">clang::Module::GlobalModuleFragment</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>.</p>

</div>
</div>
<a id="a1a1418097f85910bca7bd12b1f17208b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1418097f85910bca7bd12b1f17208b">&#9670;&nbsp;</a></span>createHeaderModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> &gt;&#160;</td>
          <td class="paramname"><em>Headers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a header module from the specified list of headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00885">885</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a488004c9aee8ccd0836e58ab114813ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488004c9aee8ccd0836e58ab114813ed">&#9670;&nbsp;</a></span>createHeaderUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a C++20 header unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00908">908</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a6c3b29c079da00f53ccd31b16f5a413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3b29c079da00f53ccd31b16f5a413a">&#9670;&nbsp;</a></span>createModuleForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>GlobalModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module interface unit. </p>
<p>The module must not already exist, and will be configured for the current compilation.</p>
<p>Note that this also sets the current module to the newly-created module.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00857">857</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acea4a5b3bc65f0ff822859970c2ecac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4a5b3bc65f0ff822859970c2ecac0">&#9670;&nbsp;</a></span>createPrivateModuleFragmentForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createPrivateModuleFragmentForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module interface unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00848">848</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>, and <a class="el" href="Module_8h_source.html#l00125">clang::Module::PrivateModuleFragment</a>.</p>

</div>
</div>
<a id="a031a847ae6f15d895ef5808fd4af56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a847ae6f15d895ef5808fd4af56aa">&#9670;&nbsp;</a></span>createShadowedModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createShadowedModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ShadowingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level module that is shadowed by <code>ShadowingModule</code>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01127">1127</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ac2a53c752925c104a4c429da4adc05da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a53c752925c104a4c429da4adc05da">&#9670;&nbsp;</a></span>diagnoseHeaderInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::diagnoseHeaderInclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>RequestingModuleIsModuleInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>FilenameLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports errors if a module must not include a specific file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RequestingModule</td><td>The module including a file.</td></tr>
    <tr><td class="paramname">RequestingModuleIsModuleInterface</td><td><code>true</code> if the inclusion is in the interface of RequestingModule, <code>false</code> if it's in the implementation of RequestingModule. Value is ignored and meaningless if RequestingModule is nullptr.</td></tr>
    <tr><td class="paramname">FilenameLoc</td><td>The location of the inclusion's filename.</td></tr>
    <tr><td class="paramname">Filename</td><td>The included filename as written.</td></tr>
    <tr><td class="paramname">File</td><td>The included file. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00473">473</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00270">clang::Module::directlyUses()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Format_8cpp_source.html#l02550">Filename</a>, <a class="el" href="Module_8cpp_source.html#l00219">clang::Module::getFullModuleName()</a>, <a class="el" href="ModuleMap_8h_source.html#l00170">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="Module_8h_source.html#l00553">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00469">getTopLevelOrNull()</a>, <a class="el" href="LangOptions_8h_source.html#l00446">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="Module_8h_source.html#l00279">clang::Module::IsFramework</a>, <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l01529">clang::DiagnosticsEngine::Report()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01203">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01338">resolveUses()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00446">violatesPrivateInclude()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00818">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<a id="a0ed1579ac35c5dcb1ab68449949a6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed1579ac35c5dcb1ab68449949a6912">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_DUMP_METHOD void ModuleMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of the module map, for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01303">1303</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00434">clang::Module::print()</a>.</p>

</div>
</div>
<a id="a836cc1b5aecd0071b6e90837fefa0b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836cc1b5aecd0071b6e90837fefa0b2a">&#9670;&nbsp;</a></span>excludeHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::excludeHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>Header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks this header as being excluded from the given module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01266">1266</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00210">clang::Module::Header::Entry</a>, <a class="el" href="Module_8h_source.html#l00226">clang::Module::Headers</a>, and <a class="el" href="Module_8h_source.html#l00201">clang::Module::HK_Excluded</a>.</p>

</div>
</div>
<a id="a94cf9768b587f077bf7916c10754713a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cf9768b587f077bf7916c10754713a">&#9670;&nbsp;</a></span>findAllModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findAllModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all the modules that contain the given header file. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<p>Typically, <a class="el" href="classclang_1_1ModuleMap.html#a8806b0826524879693983c42a0cd9aa9">findModuleForHeader</a> should be used instead, as it picks the preferred module for the header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00670">670</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01513">clang::HeaderSearch::findAllModulesForHeader()</a>.</p>

</div>
</div>
<a id="a35bee9d02a3e7ced6bc9f7dd42ede743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee9d02a3e7ced6bc9f7dd42ede743">&#9670;&nbsp;</a></span>findModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::findModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00790">790</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00069">addLinkAsDependency()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00269">clang::HeaderSearch::lookupModule()</a>, and <a class="el" href="ModuleManager_8cpp_source.html#l00252">clang::serialization::ModuleManager::removeModules()</a>.</p>

</div>
</div>
<a id="a8806b0826524879693983c42a0cd9aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8806b0826524879693983c42a0cd9aa9">&#9670;&nbsp;</a></span>findModuleForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> ModuleMap::findModuleForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowTextual</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module that owns the given header file, if any. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The header file that is likely to be included.</td></tr>
    <tr><td class="paramname">AllowTextual</td><td>If <code>true</code> and <code>File</code> is a textual header, return its owning module. Otherwise, no <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> will be returned if the file is only known as a textual header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The module <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a>, which provides the module that owns the given header file. The <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> is default constructed to indicate that no module owns this header file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00572">572</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="ModuleMap_8h_source.html#l00170">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="Module_8h_source.html#l00553">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00549">isBetterKnownHeader()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01502">clang::HeaderSearch::findModuleForHeader()</a>, and <a class="el" href="PPDirectives_8cpp_source.html#l00731">clang::Preprocessor::getModuleForLocation()</a>.</p>

</div>
</div>
<a id="a115a5b7b114346aaa534995084fc3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a5b7b114346aaa534995084fc3ac0">&#9670;&nbsp;</a></span>findOrCreateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; ModuleMap::findOrCreateModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsExplicit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new module or submodule, or create it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to find or create.</td></tr>
    <tr><td class="paramname">Parent</td><td>The module that will act as the parent of this submodule, or nullptr to indicate that this is a top-level module.</td></tr>
    <tr><td class="paramname">IsFramework</td><td>Whether this is a framework module.</td></tr>
    <tr><td class="paramname">IsExplicit</td><td>Whether this is an explicit submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly-created module, along with a boolean value that will be true if the module is newly-created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00815">815</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a7569af5b4b731de5a135caf8636681b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569af5b4b731de5a135caf8636681b3">&#9670;&nbsp;</a></span>findResolvedModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findResolvedModulesForHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classclang_1_1ModuleMap.html#a94cf9768b587f077bf7916c10754713a">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00682">682</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01203">resolveHeaderDirectives()</a>.</p>

</div>
</div>
<a id="a390f6e47e08d60984fca9c6c492d42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f6e47e08d60984fca9c6c492d42f7">&#9670;&nbsp;</a></span>finishModuleDeclarationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::finishModuleDeclarationScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> names from earlier scopes will shadow names from the new scope, which is the opposite of how shadowing works for variables. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00586">586</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a9c2eda49b11b2b5dd41e456d986623e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2eda49b11b2b5dd41e456d986623e8">&#9670;&nbsp;</a></span>getAdditionalModuleMapFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#ac22c56a8f11f61caa8ab58809a21cca3">AdditionalModMapsSet</a>* clang::ModuleMap::getAdditionalModuleMapFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>. </p>
<p>This is cheaper than getting the module map file for each submodule individually, since the expected number of results is very small. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00626">626</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1c4a9836fc4829507cded4d63e24f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4a9836fc4829507cded4d63e24f6fc">&#9670;&nbsp;</a></span>getBuiltinDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a>* clang::ModuleMap::getBuiltinDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the directory that contains Clang-supplied include files. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00409">409</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="ad52a9df394e4ad6fd8216b1091cca20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52a9df394e4ad6fd8216b1091cca20c">&#9670;&nbsp;</a></span>getCachedModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt; clang::ModuleMap::getCachedModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cached module load. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00727">727</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01941">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="ab71ec7ef5400f119c1e95c28dad0371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71ec7ef5400f119c1e95c28dad0371d">&#9670;&nbsp;</a></span>getContainingModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * ModuleMap::getContainingModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Module</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module map file containing the definition of the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a></td><td>The module whose module map file will be returned, if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file entry for the module map file containing the given module, or nullptr if the module definition was inferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01277">1277</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00102">clang::Module::DefinitionLoc</a>, <a class="el" href="SourceManager_8h_source.html#l01030">clang::SourceManager::getFileEntryForID()</a>, <a class="el" href="SourceManager_8h_source.html#l01103">clang::SourceManager::getFileID()</a>, and <a class="el" href="SourceLocation_8h_source.html#l00111">clang::SourceLocation::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01286">compileModule()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01285">getModuleMapFileForUniquing()</a>.</p>

</div>
</div>
<a id="a8ad77286fb30719f2f516e5a67acaefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad77286fb30719f2f516e5a67acaefe">&#9670;&nbsp;</a></span>getModuleMapFileForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * ModuleMap::getModuleMapFileForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module map file that (along with the module name) uniquely identifies this module. </p>
<p>The particular module that <code>Name</code> refers to may depend on how the module was found in header search. However, the combination of <code>Name</code> and this module map will be globally unique for top-level modules. In the case of inferred modules, returns the module map that allowed the inference (e.g. contained 'module *'). Otherwise, returns <a class="el" href="classclang_1_1ModuleMap.html#ab71ec7ef5400f119c1e95c28dad0371d" title="Retrieve the module map file containing the definition of the given module.">getContainingModuleMapFile()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01285">1285</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01277">getContainingModuleMapFile()</a>, and <a class="el" href="Module_8h_source.html#l00294">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01286">compileModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00172">clang::HeaderSearch::getCachedModuleFileName()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00204">clang::HeaderSearch::getPrebuiltImplicitModuleFileName()</a>.</p>

</div>
</div>
<a id="af95957116dd995616c90e64c864811cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95957116dd995616c90e64c864811cd">&#9670;&nbsp;</a></span>headerKindToRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleMap::ModuleHeaderRole</a> ModuleMap::headerKindToRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header kind to a role. Requires Kind to not be HK_Excluded. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00091">91</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00201">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00197">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00199">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00200">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00198">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00133">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

</div>
</div>
<a id="a32c51efd0ee64aaadd73218544eeeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c51efd0ee64aaadd73218544eeeb01">&#9670;&nbsp;</a></span>headerRoleToKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> ModuleMap::headerRoleToKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header role to a kind. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00197">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00199">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00200">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00198">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00133">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01238">addHeader()</a>.</p>

</div>
</div>
<a id="ad78651ebbabbed8598a8b3d71c0712f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78651ebbabbed8598a8b3d71c0712f6">&#9670;&nbsp;</a></span>inferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::inferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>FrameworkDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the contents of a framework module map from the given framework directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00946">946</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00286">clang::Module::IsSystem</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00192">Parent</a>.</p>

</div>
</div>
<a id="a1e8ca3bc91f0e93e6c706b80f263e521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8ca3bc91f0e93e6c706b80f263e521">&#9670;&nbsp;</a></span>isBuiltinHeader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00391">391</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00375">isBuiltinHeader()</a>.</p>

</div>
</div>
<a id="a40c825f7506d1abd0d9bc54eba6330e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c825f7506d1abd0d9bc54eba6330e6">&#9670;&nbsp;</a></span>isBuiltinHeader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a compiler builtin header? </p>
<p>Determine whether the given file name is the name of a builtin header, supplied by Clang to replace, override, or augment existing system headers. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00375">375</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00391">isBuiltinHeader()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l01354">clang::HeaderSearch::ShouldEnterIncludeFile()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01522">suggestModule()</a>.</p>

</div>
</div>
<a id="afc11dbc10f0658870b83753074c3c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc11dbc10f0658870b83753074c3c1d9">&#9670;&nbsp;</a></span>isHeaderInUnavailableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderInUnavailableModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>Header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is part of a module marked 'unavailable'. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00691">691</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00696">isHeaderUnavailableInModule()</a>.</p>

</div>
</div>
<a id="a890ef9bee13458036c9e4d5d7df58c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ef9bee13458036c9e4d5d7df58c8f">&#9670;&nbsp;</a></span>isHeaderUnavailableInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderUnavailableInModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is unavailable as part of the specified module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00696">696</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00375">clang::FileEntry::getDir()</a>, <a class="el" href="DirectoryEntry_8h_source.html#l00041">clang::DirectoryEntry::getName()</a>, <a class="el" href="Module_8cpp_source.html#l00244">clang::Module::getUmbrellaDir()</a>, <a class="el" href="RecursiveASTVisitor_8h_source.html#l01009">clang::if()</a>, <a class="el" href="Module_8h_source.html#l00300">clang::Module::InferSubmodules</a>, <a class="el" href="Module_8h_source.html#l00462">clang::Module::isAvailable()</a>, <a class="el" href="Module_8cpp_source.html#l00173">clang::Module::isSubModuleOf()</a>, <a class="el" href="Module_8h_source.html#l00133">clang::Module::Parent</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01203">resolveHeaderDirectives()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00137">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00691">isHeaderInUnavailableModule()</a>.</p>

</div>
</div>
<a id="ac4bd056e3b16607ace724463606dd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd056e3b16607ace724463606dd3d5">&#9670;&nbsp;</a></span>lookupModuleQualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleQualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name within the given context, using direct (qualified) name lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module for which we will look for a submodule. If null, we will look for a top-level module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named submodule, if known; otherwose, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00808">808</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a9682383d1483005eb8de8ab46275f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682383d1483005eb8de8ab46275f5e5">&#9670;&nbsp;</a></span>lookupModuleUnqualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleUnqualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name using lexical name lookup, starting at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module context, from which we will perform lexical name lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00798">798</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a3df11cf9b74e240aa373f25c1a63b49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df11cf9b74e240aa373f25c1a63b49f">&#9670;&nbsp;</a></span>mayShadowNewModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::mayShadowNewModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ExistingModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00588">588</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00133">clang::Module::Parent</a>.</p>

</div>
</div>
<a id="a6ab65f1f0882fcff9a15da9cfbf0fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">&#9670;&nbsp;</a></span>module_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00715">715</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02190">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00717">modules()</a>.</p>

</div>
</div>
<a id="a9d9e3147d81ec86cf00eea874d9ea95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e3147d81ec86cf00eea874d9ea95b">&#9670;&nbsp;</a></span>module_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00716">716</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02190">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00717">modules()</a>.</p>

</div>
</div>
<a id="a9124c52cfa4df22a479eddbcc8e350d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124c52cfa4df22a479eddbcc8e350d3">&#9670;&nbsp;</a></span>modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::iterator_range&lt;<a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&gt; clang::ModuleMap::modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00717">717</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00715">module_begin()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00716">module_end()</a>.</p>

</div>
</div>
<a id="a516cfeb32bb3a464262cf6f369417eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516cfeb32bb3a464262cf6f369417eab">&#9670;&nbsp;</a></span>parseModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::parseModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>HomeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td>
          <td class="paramname"><em>ID</em> = <code><a class="el" href="classclang_1_1FileID.html">FileID</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>ExternModuleLoc</em> = <code><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given module map file, and record any modules we encounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The file to be parsed.</td></tr>
    <tr><td class="paramname">IsSystem</td><td>Whether this module map file is in a system header directory, and therefore should be considered a system module.</td></tr>
    <tr><td class="paramname">HomeDir</td><td>The directory in which relative paths within this module map file will be resolved.</td></tr>
    <tr><td class="paramname">ID</td><td>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> of the file to process, if we've already entered it.</td></tr>
    <tr><td class="paramname">Offset</td><td>[inout] On input the offset at which to start parsing. On output, the offset at which the module map terminated.</td></tr>
    <tr><td class="paramname">ExternModuleLoc</td><td>The location of the "extern module" declaration that caused us to load this module map file, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error occurred, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l03021">3021</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l00083">clang::SrcMgr::C_System_ModuleMap</a>, <a class="el" href="SourceManager_8h_source.html#l00082">clang::SrcMgr::C_User_ModuleMap</a>, <a class="el" href="SourceManager_8cpp_source.html#l00532">clang::SourceManager::createFileID()</a>, <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="SourceManager_8h_source.html#l01011">clang::SourceManager::getBufferOrNone()</a>, <a class="el" href="SourceManager_8h_source.html#l01236">clang::SourceManager::getDecomposedLoc()</a>, <a class="el" href="SourceManager_8h_source.html#l01118">clang::SourceManager::getLocForStartOfFile()</a>, <a class="el" href="Lexer_8cpp_source.html#l01149">clang::Lexer::getSourceLocation()</a>, and <a class="el" href="Format_8cpp_source.html#l02552">Offset</a>.</p>

</div>
</div>
<a id="a635593eb7f27a7297eb22afacd08d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635593eb7f27a7297eb22afacd08d104">&#9670;&nbsp;</a></span>resolveConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveConflicts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved conflicts in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose conflicts should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving conflicts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01351">1351</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00433">clang::Module::Conflicts</a>, <a class="el" href="Module_8h_source.html#l00429">clang::Module::Conflict::Message</a>, <a class="el" href="Module_8h_source.html#l00426">clang::Module::Conflict::Other</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00421">clang::Module::UnresolvedConflicts</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00689">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a03d91ee91e3d302d32885c4d790b3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d91ee91e3d302d32885c4d790b3915">&#9670;&nbsp;</a></span>resolveExports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveExports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved exports in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose exports should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving exports, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01325">1325</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00351">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00369">clang::Module::UnresolvedExports</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00689">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a64ce2c7a23bcff10e7ae4bfcda637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce2c7a23bcff10e7ae4bfcda637182">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all lazy header directives for the specified file. </p>
<p>This ensures that the <a class="el" href="structclang_1_1HeaderFileInfo.html" title="The preprocessor keeps track of this information for each file that is #included.">HeaderFileInfo</a> on <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> is up to date. This is effectively internal, but is exposed so <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> can call it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01203">1203</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00326">collectModuleHeaderIncludes()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00473">diagnoseHeaderInclusion()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00682">findResolvedModulesForHeader()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00696">isHeaderUnavailableInModule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01354">clang::HeaderSearch::ShouldEnterIncludeFile()</a>.</p>

</div>
</div>
<a id="a2a7f7d3851e51a8409988c5c182490ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7f7d3851e51a8409988c5c182490ac">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt;&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve lazy header directives for the specified module. </p>
<p>If File is provided, only headers with same size and modtime are resolved. If File is not set, all headers are resolved. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01219">1219</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#a7379bdfd074341d981e1a31d6de2cff3a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Module_8h_source.html#l00237">clang::Module::UnresolvedHeaderDirective::ModTime</a>, <a class="el" href="Module_8h_source.html#l00236">clang::Module::UnresolvedHeaderDirective::Size</a>, and <a class="el" href="Module_8h_source.html#l00242">clang::Module::UnresolvedHeaders</a>.</p>

</div>
</div>
<a id="ac588ee8d4c631303982ed1c68002f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588ee8d4c631303982ed1c68002f49d">&#9670;&nbsp;</a></span>resolveLinkAsDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveLinkAsDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00058">58</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00099">clang::Module::Name</a>.</p>

</div>
</div>
<a id="aff262a15ac7933edd463953d969e4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff262a15ac7933edd463953d969e4f6b">&#9670;&nbsp;</a></span>resolveUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved uses in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose uses should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving uses, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01338">1338</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00372">clang::Module::DirectUses</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00375">clang::Module::UnresolvedDirectUses</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00473">diagnoseHeaderInclusion()</a>, <a class="el" href="PPLexerChange_8cpp_source.html#l00689">clang::Preprocessor::EnterSubmodule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01522">suggestModule()</a>.</p>

</div>
</div>
<a id="a6c624a7392febb43c7bb1a19e835ab34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c624a7392febb43c7bb1a19e835ab34">&#9670;&nbsp;</a></span>setBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::setBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00404">404</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitHeaderSearch_8cpp_source.html#l00655">clang::ApplyHeaderSearchOptions()</a>.</p>

</div>
</div>
<a id="a64cf116b47bb6201a8154feab288cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf116b47bb6201a8154feab288cc65">&#9670;&nbsp;</a></span>setInferredModuleAllowedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setInferredModuleAllowedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>ModMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01293">1293</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00294">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00480">prepareToBuildModule()</a>.</p>

</div>
</div>
<a id="abc441df169e00dbd5ab3a5db003d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc441df169e00dbd5ab3a5db003d454f">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>Target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target information. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00329">329</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#acdf88ec6c845aa781824469fcb0af66cac41a31890959544c6523af684561abe5">clang::Target</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l00712">clang::HeaderSearch::setTarget()</a>.</p>

</div>
</div>
<a id="a4c5148fa4f93b67492291bee915c9e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5148fa4f93b67492291bee915c9e27">&#9670;&nbsp;</a></span>setUmbrellaDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>UmbrellaDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella directory of the given module to the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01157">1157</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00145">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00151">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="ac236ffc11120133f8b4908b175e98172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac236ffc11120133f8b4908b175e98172">&#9670;&nbsp;</a></span>setUmbrellaHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>UmbrellaHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella header of the given module to the given header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01142">1142</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00375">clang::FileEntry::getDir()</a>, <a class="el" href="SourceManager_8h_source.html#l00806">clang::SourceManager::getFileManager()</a>, <a class="el" href="ModuleMap_8h_source.html#l00130">NormalHeader</a>, <a class="el" href="Module_8h_source.html#l00145">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00151">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00154">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a69fccb440615f32e24516ed4e718457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fccb440615f32e24516ed4e718457d">&#9670;&nbsp;</a></span>ModuleMapParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ModuleMapParser.html">ModuleMapParser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00196">196</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/Lex/<a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a></li>
<li>lib/Lex/<a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:15 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
