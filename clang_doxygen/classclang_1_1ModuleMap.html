<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ModuleMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">19.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classclang_1_1ModuleMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clang::ModuleMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="ModuleMap_8h_source.html">clang/Lex/ModuleMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A header that is known to reside within a given module, whether it was included or excluded.  <a href="classclang_1_1ModuleMap_1_1KnownHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> { <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa">NormalHeader</a> = 0x0
, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4">PrivateHeader</a> = 0x1
, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200">TextualHeader</a> = 0x2
, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877">ExcludedHeader</a> = 0x4
 }</td></tr>
<tr class="memdesc:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing the role of a module header.  <a href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">More...</a><br /></td></tr>
<tr class="separator:ac7a2413d4d0a8f29d2dad359bcfd8dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c29c953accc6a4454b0280b7480882"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a93c29c953accc6a4454b0280b7480882">AdditionalModMapsSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> &gt;</td></tr>
<tr class="separator:a93c29c953accc6a4454b0280b7480882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b352087754574155a198a4cb0d6e197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> = llvm::StringMap&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;::const_iterator</td></tr>
<tr class="separator:a1b352087754574155a198a4cb0d6e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac588ee8d4c631303982ed1c68002f49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">resolveLinkAsDependencies</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:ac588ee8d4c631303982ed1c68002f49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases.  <a href="classclang_1_1ModuleMap.html#ac588ee8d4c631303982ed1c68002f49d">More...</a><br /></td></tr>
<tr class="separator:ac588ee8d4c631303982ed1c68002f49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06068cd4735154ef4218ab96f9462412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">addLinkAsDependency</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod)</td></tr>
<tr class="memdesc:a06068cd4735154ef4218ab96f9462412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise.  <a href="classclang_1_1ModuleMap.html#a06068cd4735154ef4218ab96f9462412">More...</a><br /></td></tr>
<tr class="separator:a06068cd4735154ef4218ab96f9462412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767bb9d1787801348282cf9b588df471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">ModuleMap</a> (<a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;SourceMgr, <a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;Diags, const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;LangOpts, const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *<a class="el" href="MachO_8h.html#ad7b5947ec34e5466040e8b829b542ee6">Target</a>, <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;HeaderInfo)</td></tr>
<tr class="memdesc:a767bb9d1787801348282cf9b588df471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new module map.  <a href="classclang_1_1ModuleMap.html#a767bb9d1787801348282cf9b588df471">More...</a><br /></td></tr>
<tr class="separator:a767bb9d1787801348282cf9b588df471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">~ModuleMap</a> ()</td></tr>
<tr class="memdesc:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the module map.  <a href="classclang_1_1ModuleMap.html#ab8769cd7eba3cb7f8f1cd2dde890603d">More...</a><br /></td></tr>
<tr class="separator:ab8769cd7eba3cb7f8f1cd2dde890603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc441df169e00dbd5ab3a5db003d454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">setTarget</a> (const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;<a class="el" href="MachO_8h.html#ad7b5947ec34e5466040e8b829b542ee6">Target</a>)</td></tr>
<tr class="memdesc:abc441df169e00dbd5ab3a5db003d454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target information.  <a href="classclang_1_1ModuleMap.html#abc441df169e00dbd5ab3a5db003d454f">More...</a><br /></td></tr>
<tr class="separator:abc441df169e00dbd5ab3a5db003d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af87b750c2e1f3b11a77b99a40a755f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a5af87b750c2e1f3b11a77b99a40a755f">setBuiltinIncludeDir</a> (<a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> Dir)</td></tr>
<tr class="memdesc:a5af87b750c2e1f3b11a77b99a40a755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>.  <a href="classclang_1_1ModuleMap.html#a5af87b750c2e1f3b11a77b99a40a755f">More...</a><br /></td></tr>
<tr class="separator:a5af87b750c2e1f3b11a77b99a40a755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9db4bf1da20795a60daebbba3857355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a3f819cd7627b94dae14d1044dfb9576c">OptionalDirectoryEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aa9db4bf1da20795a60daebbba3857355">getBuiltinDir</a> () const</td></tr>
<tr class="memdesc:aa9db4bf1da20795a60daebbba3857355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the directory that contains Clang-supplied include files.  <a href="classclang_1_1ModuleMap.html#aa9db4bf1da20795a60daebbba3857355">More...</a><br /></td></tr>
<tr class="separator:aa9db4bf1da20795a60daebbba3857355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e2d0400d837a69d22557ff10e3c537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a99e2d0400d837a69d22557ff10e3c537">isBuiltinHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File)</td></tr>
<tr class="memdesc:a99e2d0400d837a69d22557ff10e3c537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a compiler builtin header?  <a href="classclang_1_1ModuleMap.html#a99e2d0400d837a69d22557ff10e3c537">More...</a><br /></td></tr>
<tr class="separator:a99e2d0400d837a69d22557ff10e3c537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dfd3616275cfb7ccf145978b876591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a70dfd3616275cfb7ccf145978b876591">shouldImportRelativeToBuiltinIncludeDir</a> (StringRef FileName, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="separator:a70dfd3616275cfb7ccf145978b876591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ba163200648ee309a8b16ccc0d62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">addModuleMapCallbacks</a> (std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt; Callback)</td></tr>
<tr class="memdesc:a516ba163200648ee309a8b16ccc0d62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a module map callback.  <a href="classclang_1_1ModuleMap.html#a516ba163200648ee309a8b16ccc0d62a">More...</a><br /></td></tr>
<tr class="separator:a516ba163200648ee309a8b16ccc0d62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2312745196384b06b31469fa258bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a45c2312745196384b06b31469fa258bd">findModuleForHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowTextual=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowExcluded=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a45c2312745196384b06b31469fa258bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module that owns the given header file, if any.  <a href="classclang_1_1ModuleMap.html#a45c2312745196384b06b31469fa258bd">More...</a><br /></td></tr>
<tr class="separator:a45c2312745196384b06b31469fa258bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e5e7b75c6545c48d6b4765d826e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File)</td></tr>
<tr class="memdesc:ae33e5e7b75c6545c48d6b4765d826e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the modules that contain the given header file.  <a href="classclang_1_1ModuleMap.html#ae33e5e7b75c6545c48d6b4765d826e80">More...</a><br /></td></tr>
<tr class="separator:ae33e5e7b75c6545c48d6b4765d826e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b26cfebdc052957edada81dd3aeef7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">KnownHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6b26cfebdc052957edada81dd3aeef7f">findResolvedModulesForHeader</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File) const</td></tr>
<tr class="memdesc:a6b26cfebdc052957edada81dd3aeef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classclang_1_1ModuleMap.html#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so.  <a href="classclang_1_1ModuleMap.html#a6b26cfebdc052957edada81dd3aeef7f">More...</a><br /></td></tr>
<tr class="separator:a6b26cfebdc052957edada81dd3aeef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">resolveHeaderDirectives</a> (const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *File) const</td></tr>
<tr class="memdesc:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all lazy header directives for the specified file.  <a href="classclang_1_1ModuleMap.html#a64ce2c7a23bcff10e7ae4bfcda637182">More...</a><br /></td></tr>
<tr class="separator:a64ce2c7a23bcff10e7ae4bfcda637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dcd87105f5059bc55a3f3db230e9bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a41dcd87105f5059bc55a3f3db230e9bb">resolveHeaderDirectives</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt; File) const</td></tr>
<tr class="memdesc:a41dcd87105f5059bc55a3f3db230e9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve lazy header directives for the specified module.  <a href="classclang_1_1ModuleMap.html#a41dcd87105f5059bc55a3f3db230e9bb">More...</a><br /></td></tr>
<tr class="separator:a41dcd87105f5059bc55a3f3db230e9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a22cfc8d05dbf3c2cceb132f4c789b8d1">diagnoseHeaderInclusion</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> RequestingModuleIsModuleInterface, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> FilenameLoc, StringRef <a class="el" href="ClangSrcLocDump_8cpp.html#a637a6651de5d8f7041e8e604929b1e94">Filename</a>, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File)</td></tr>
<tr class="memdesc:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports errors if a module must not include a specific file.  <a href="classclang_1_1ModuleMap.html#a22cfc8d05dbf3c2cceb132f4c789b8d1">More...</a><br /></td></tr>
<tr class="separator:a22cfc8d05dbf3c2cceb132f4c789b8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4894e6adb8982448b6724c996d0f5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aa4894e6adb8982448b6724c996d0f5e4">isHeaderInUnavailableModule</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> Header) const</td></tr>
<tr class="memdesc:aa4894e6adb8982448b6724c996d0f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is part of a module marked 'unavailable'.  <a href="classclang_1_1ModuleMap.html#aa4894e6adb8982448b6724c996d0f5e4">More...</a><br /></td></tr>
<tr class="separator:aa4894e6adb8982448b6724c996d0f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a648ba5f0cd274dd3acd6ee14aeae1cdc">isHeaderUnavailableInModule</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> Header, const <a class="el" href="classclang_1_1Module.html">Module</a> *RequestingModule) const</td></tr>
<tr class="memdesc:a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given header is unavailable as part of the specified module.  <a href="classclang_1_1ModuleMap.html#a648ba5f0cd274dd3acd6ee14aeae1cdc">More...</a><br /></td></tr>
<tr class="separator:a648ba5f0cd274dd3acd6ee14aeae1cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">findModule</a> (StringRef Name) const</td></tr>
<tr class="memdesc:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name.  <a href="classclang_1_1ModuleMap.html#a35bee9d02a3e7ced6bc9f7dd42ede743">More...</a><br /></td></tr>
<tr class="separator:a35bee9d02a3e7ced6bc9f7dd42ede743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682383d1483005eb8de8ab46275f5e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">lookupModuleUnqualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:a9682383d1483005eb8de8ab46275f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name using lexical name lookup, starting at the given context.  <a href="classclang_1_1ModuleMap.html#a9682383d1483005eb8de8ab46275f5e5">More...</a><br /></td></tr>
<tr class="separator:a9682383d1483005eb8de8ab46275f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bd056e3b16607ace724463606dd3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">lookupModuleQualified</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *Context) const</td></tr>
<tr class="memdesc:ac4bd056e3b16607ace724463606dd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a module with the given name within the given context, using direct (qualified) name lookup.  <a href="classclang_1_1ModuleMap.html#ac4bd056e3b16607ace724463606dd3d5">More...</a><br /></td></tr>
<tr class="separator:ac4bd056e3b16607ace724463606dd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115a5b7b114346aaa534995084fc3ac0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">findOrCreateModule</a> (StringRef Name, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsExplicit)</td></tr>
<tr class="memdesc:a115a5b7b114346aaa534995084fc3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a new module or submodule, or create it if it does not already exist.  <a href="classclang_1_1ModuleMap.html#a115a5b7b114346aaa534995084fc3ac0">More...</a><br /></td></tr>
<tr class="separator:a115a5b7b114346aaa534995084fc3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984430b63c290eb25d0b696d486303c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">createGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>=nullptr)</td></tr>
<tr class="memdesc:ab984430b63c290eb25d0b696d486303c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module unit.  <a href="classclang_1_1ModuleMap.html#ab984430b63c290eb25d0b696d486303c">More...</a><br /></td></tr>
<tr class="separator:ab984430b63c290eb25d0b696d486303c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b51f4c1d8b938248d11624bd468b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ae55b51f4c1d8b938248d11624bd468b3">createImplicitGlobalModuleFragmentForModuleUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="separator:ae55b51f4c1d8b938248d11624bd468b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">createPrivateModuleFragmentForInterfaceUnit</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc)</td></tr>
<tr class="memdesc:acea4a5b3bc65f0ff822859970c2ecac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a global module fragment for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#acea4a5b3bc65f0ff822859970c2ecac0">More...</a><br /></td></tr>
<tr class="separator:acea4a5b3bc65f0ff822859970c2ecac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f1f85e8474bddc3b2c4d0938540457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#af6f1f85e8474bddc3b2c4d0938540457">createModuleUnitWithKind</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="classclang_1_1Module.html#acdab95b809e6c2a027d4ca2763c90b70">Module::ModuleKind</a> Kind)</td></tr>
<tr class="memdesc:af6f1f85e8474bddc3b2c4d0938540457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new C++ module with the specified kind, and reparent any pending global module fragment(s) to it.  <a href="classclang_1_1ModuleMap.html#af6f1f85e8474bddc3b2c4d0938540457">More...</a><br /></td></tr>
<tr class="separator:af6f1f85e8474bddc3b2c4d0938540457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aca8dfb44af54446f37a943a9dd4b9c4f">createModuleForInterfaceUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name)</td></tr>
<tr class="memdesc:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module interface unit.  <a href="classclang_1_1ModuleMap.html#aca8dfb44af54446f37a943a9dd4b9c4f">More...</a><br /></td></tr>
<tr class="separator:aca8dfb44af54446f37a943a9dd4b9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d721452cbf7773605b71193c7a762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a759d721452cbf7773605b71193c7a762">createModuleForImplementationUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name)</td></tr>
<tr class="memdesc:a759d721452cbf7773605b71193c7a762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new module for a C++ module implementation unit.  <a href="classclang_1_1ModuleMap.html#a759d721452cbf7773605b71193c7a762">More...</a><br /></td></tr>
<tr class="separator:a759d721452cbf7773605b71193c7a762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488004c9aee8ccd0836e58ab114813ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">createHeaderUnit</a> (<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> Loc, StringRef Name, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> H)</td></tr>
<tr class="memdesc:a488004c9aee8ccd0836e58ab114813ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++20 header unit.  <a href="classclang_1_1ModuleMap.html#a488004c9aee8ccd0836e58ab114813ed">More...</a><br /></td></tr>
<tr class="separator:a488004c9aee8ccd0836e58ab114813ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68b0b03f415bfbaedc292c33b881c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#af68b0b03f415bfbaedc292c33b881c41">inferFrameworkModule</a> (<a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> FrameworkDir, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a>)</td></tr>
<tr class="memdesc:af68b0b03f415bfbaedc292c33b881c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the contents of a framework module map from the given framework directory.  <a href="classclang_1_1ModuleMap.html#af68b0b03f415bfbaedc292c33b881c41">More...</a><br /></td></tr>
<tr class="separator:af68b0b03f415bfbaedc292c33b881c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a847ae6f15d895ef5808fd4af56aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">createShadowedModule</a> (StringRef Name, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsFramework, <a class="el" href="classclang_1_1Module.html">Module</a> *ShadowingModule)</td></tr>
<tr class="memdesc:a031a847ae6f15d895ef5808fd4af56aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new top-level module that is shadowed by <code>ShadowingModule</code>.  <a href="classclang_1_1ModuleMap.html#a031a847ae6f15d895ef5808fd4af56aa">More...</a><br /></td></tr>
<tr class="separator:a031a847ae6f15d895ef5808fd4af56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f6e47e08d60984fca9c6c492d42f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">finishModuleDeclarationScope</a> ()</td></tr>
<tr class="memdesc:a390f6e47e08d60984fca9c6c492d42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope.  <a href="classclang_1_1ModuleMap.html#a390f6e47e08d60984fca9c6c492d42f7">More...</a><br /></td></tr>
<tr class="separator:a390f6e47e08d60984fca9c6c492d42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3df11cf9b74e240aa373f25c1a63b49f">mayShadowNewModule</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *ExistingModule)</td></tr>
<tr class="separator:a3df11cf9b74e240aa373f25c1a63b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b14289476fe5638600e7e1d78f41a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">canInferFrameworkModule</a> (const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *Dir) const</td></tr>
<tr class="memdesc:a3b14289476fe5638600e7e1d78f41a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a framework module can be inferred in the given directory.  <a href="classclang_1_1ModuleMap.html#a3b14289476fe5638600e7e1d78f41a0e">More...</a><br /></td></tr>
<tr class="separator:a3b14289476fe5638600e7e1d78f41a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ad888db0b2b51d7da1231ff0f732be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aa7ad888db0b2b51d7da1231ff0f732be">getContainingModuleMapFileID</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="memdesc:aa7ad888db0b2b51d7da1231ff0f732be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the module map file containing the definition of the given module.  <a href="classclang_1_1ModuleMap.html#aa7ad888db0b2b51d7da1231ff0f732be">More...</a><br /></td></tr>
<tr class="separator:aa7ad888db0b2b51d7da1231ff0f732be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d98d21ca4002f64a8efe0d0861897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a303d98d21ca4002f64a8efe0d0861897">getContainingModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *<a class="el" href="classclang_1_1Module.html">Module</a>) const</td></tr>
<tr class="separator:a303d98d21ca4002f64a8efe0d0861897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845749f24dbf1e59be50cc7db786808d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a845749f24dbf1e59be50cc7db786808d">getModuleMapFileIDForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="memdesc:a845749f24dbf1e59be50cc7db786808d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the module map file that (along with the module name) uniquely identifies this module.  <a href="classclang_1_1ModuleMap.html#a845749f24dbf1e59be50cc7db786808d">More...</a><br /></td></tr>
<tr class="separator:a845749f24dbf1e59be50cc7db786808d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079336099f427b383128cfa445dd4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7079336099f427b383128cfa445dd4ea">getModuleMapFileForUniquing</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M) const</td></tr>
<tr class="separator:a7079336099f427b383128cfa445dd4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8630da8d0808e9956b74b03e30f57314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8630da8d0808e9956b74b03e30f57314">setInferredModuleAllowedBy</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *M, <a class="el" href="classclang_1_1FileID.html">FileID</a> ModMapFID)</td></tr>
<tr class="separator:a8630da8d0808e9956b74b03e30f57314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1261e559ef2565d078189e60f96b85"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a7a1261e559ef2565d078189e60f96b85">canonicalizeModuleMapPath</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;Path)</td></tr>
<tr class="memdesc:a7a1261e559ef2565d078189e60f96b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize <code>Path</code> in a manner suitable for a module map file.  <a href="classclang_1_1ModuleMap.html#a7a1261e559ef2565d078189e60f96b85">More...</a><br /></td></tr>
<tr class="separator:a7a1261e559ef2565d078189e60f96b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a93c29c953accc6a4454b0280b7480882">AdditionalModMapsSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">getAdditionalModuleMapFiles</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:a9c2eda49b11b2b5dd41e456d986623e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>.  <a href="classclang_1_1ModuleMap.html#a9c2eda49b11b2b5dd41e456d986623e8">More...</a><br /></td></tr>
<tr class="separator:a9c2eda49b11b2b5dd41e456d986623e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2547baacaf16c89fe6c017a8d7847eab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a2547baacaf16c89fe6c017a8d7847eab">addAdditionalModuleMapFile</a> (const <a class="el" href="classclang_1_1Module.html">Module</a> *M, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> <a class="el" href="classclang_1_1ModuleMap.html">ModuleMap</a>)</td></tr>
<tr class="separator:a2547baacaf16c89fe6c017a8d7847eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d91ee91e3d302d32885c4d790b3915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">resolveExports</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a03d91ee91e3d302d32885c4d790b3915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved exports in the given module.  <a href="classclang_1_1ModuleMap.html#a03d91ee91e3d302d32885c4d790b3915">More...</a><br /></td></tr>
<tr class="separator:a03d91ee91e3d302d32885c4d790b3915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff262a15ac7933edd463953d969e4f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">resolveUses</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:aff262a15ac7933edd463953d969e4f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved uses in the given module.  <a href="classclang_1_1ModuleMap.html#aff262a15ac7933edd463953d969e4f6b">More...</a><br /></td></tr>
<tr class="separator:aff262a15ac7933edd463953d969e4f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635593eb7f27a7297eb22afacd08d104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">resolveConflicts</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Complain)</td></tr>
<tr class="memdesc:a635593eb7f27a7297eb22afacd08d104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all of the unresolved conflicts in the given module.  <a href="classclang_1_1ModuleMap.html#a635593eb7f27a7297eb22afacd08d104">More...</a><br /></td></tr>
<tr class="separator:a635593eb7f27a7297eb22afacd08d104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4201bac04ec898145e7fd1b94cd9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8d4201bac04ec898145e7fd1b94cd9e9">setUmbrellaHeaderAsWritten</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> UmbrellaHeader, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a8d4201bac04ec898145e7fd1b94cd9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella header of the given module to the given header.  <a href="classclang_1_1ModuleMap.html#a8d4201bac04ec898145e7fd1b94cd9e9">More...</a><br /></td></tr>
<tr class="separator:a8d4201bac04ec898145e7fd1b94cd9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d290fccdf570de977224a277e24b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a202d290fccdf570de977224a277e24b9">setUmbrellaDirAsWritten</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> UmbrellaDir, const Twine &amp;NameAsWritten, const Twine &amp;PathRelativeToRootModuleDirectory)</td></tr>
<tr class="memdesc:a202d290fccdf570de977224a277e24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the umbrella directory of the given module to the given directory.  <a href="classclang_1_1ModuleMap.html#a202d290fccdf570de977224a277e24b9">More...</a><br /></td></tr>
<tr class="separator:a202d290fccdf570de977224a277e24b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">addHeader</a> (<a class="el" href="classclang_1_1Module.html">Module</a> *Mod, <a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a> Header, <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> Imported=<a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds this header to the given module.  <a href="classclang_1_1ModuleMap.html#acb605a0f3e5ac2213bab92d201fc1ec1">More...</a><br /></td></tr>
<tr class="separator:acb605a0f3e5ac2213bab92d201fc1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea0621e4b0eaf401c03cddf4114eae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#aaea0621e4b0eaf401c03cddf4114eae7">parseModuleMapFile</a> (<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a> File, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> IsSystem, <a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a> HomeDir, <a class="el" href="classclang_1_1FileID.html">FileID</a> <a class="el" href="Arena_8cpp.html#a595f6ff5c8c7b1538e28f9b6cb97113f">ID</a>=<a class="el" href="classclang_1_1FileID.html">FileID</a>(), <a class="el" href="classunsigned.html">unsigned</a> *<a class="el" href="Format_8cpp.html#a9fcf84dffafb0ea03c0f9b686ddbf2b3">Offset</a>=nullptr, <a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a> ExternModuleLoc=<a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>())</td></tr>
<tr class="memdesc:aaea0621e4b0eaf401c03cddf4114eae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the given module map file, and record any modules we encounter.  <a href="classclang_1_1ModuleMap.html#aaea0621e4b0eaf401c03cddf4114eae7">More...</a><br /></td></tr>
<tr class="separator:aaea0621e4b0eaf401c03cddf4114eae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">dump</a> ()</td></tr>
<tr class="memdesc:a0ed1579ac35c5dcb1ab68449949a6912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of the module map, for debugging purposes.  <a href="classclang_1_1ModuleMap.html#a0ed1579ac35c5dcb1ab68449949a6912">More...</a><br /></td></tr>
<tr class="separator:a0ed1579ac35c5dcb1ab68449949a6912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a6ab65f1f0882fcff9a15da9cfbf0fd02">module_begin</a> () const</td></tr>
<tr class="separator:a6ab65f1f0882fcff9a15da9cfbf0fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9d9e3147d81ec86cf00eea874d9ea95b">module_end</a> () const</td></tr>
<tr class="separator:a9d9e3147d81ec86cf00eea874d9ea95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memItemLeft" align="right" valign="top">llvm::iterator_range&lt; <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a9124c52cfa4df22a479eddbcc8e350d3">modules</a> () const</td></tr>
<tr class="separator:a9124c52cfa4df22a479eddbcc8e350d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">cacheModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II, <a class="el" href="classclang_1_1Module.html">Module</a> *M)</td></tr>
<tr class="memdesc:ac61bce84c6ecb21f1f05539c84b855ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache a module load. M might be nullptr.  <a href="classclang_1_1ModuleMap.html#ac61bce84c6ecb21f1f05539c84b855ad">More...</a><br /></td></tr>
<tr class="separator:ac61bce84c6ecb21f1f05539c84b855ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8673ca4aacbe3e404597553a4c298005"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classclang_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a8673ca4aacbe3e404597553a4c298005">getCachedModuleLoad</a> (const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;II)</td></tr>
<tr class="memdesc:a8673ca4aacbe3e404597553a4c298005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a cached module load.  <a href="classclang_1_1ModuleMap.html#a8673ca4aacbe3e404597553a4c298005">More...</a><br /></td></tr>
<tr class="separator:a8673ca4aacbe3e404597553a4c298005"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af95957116dd995616c90e64c864811cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">headerKindToRole</a> (<a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> Kind)</td></tr>
<tr class="memdesc:af95957116dd995616c90e64c864811cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header kind to a role. Requires Kind to not be HK_Excluded.  <a href="classclang_1_1ModuleMap.html#af95957116dd995616c90e64c864811cd">More...</a><br /></td></tr>
<tr class="separator:af95957116dd995616c90e64c864811cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c51efd0ee64aaadd73218544eeeb01"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">headerRoleToKind</a> (<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role)</td></tr>
<tr class="memdesc:a32c51efd0ee64aaadd73218544eeeb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a header role to a kind.  <a href="classclang_1_1ModuleMap.html#a32c51efd0ee64aaadd73218544eeeb01">More...</a><br /></td></tr>
<tr class="separator:a32c51efd0ee64aaadd73218544eeeb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a5ddbcfb5014e3bd0bcf33a30b41cc511">isModular</a> (<a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a> Role)</td></tr>
<tr class="memdesc:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the header with the given role is a modular one.  <a href="classclang_1_1ModuleMap.html#a5ddbcfb5014e3bd0bcf33a30b41cc511">More...</a><br /></td></tr>
<tr class="separator:a5ddbcfb5014e3bd0bcf33a30b41cc511"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a69fccb440615f32e24516ed4e718457d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ModuleMap.html#a69fccb440615f32e24516ed4e718457d">ModuleMapParser</a></td></tr>
<tr class="separator:a69fccb440615f32e24516ed4e718457d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00074">74</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a93c29c953accc6a4454b0280b7480882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c29c953accc6a4454b0280b7480882">&#9670;&nbsp;</a></span>AdditionalModMapsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#a93c29c953accc6a4454b0280b7480882">clang::ModuleMap::AdditionalModMapsSet</a> =  <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;<a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00197">197</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a1b352087754574155a198a4cb0d6e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b352087754574155a198a4cb0d6e197">&#9670;&nbsp;</a></span>module_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">clang::ModuleMap::module_iterator</a> =  llvm::StringMap&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00735">735</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac7a2413d4d0a8f29d2dad359bcfd8dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a2413d4d0a8f29d2dad359bcfd8dec">&#9670;&nbsp;</a></span>ModuleHeaderRole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">clang::ModuleMap::ModuleHeaderRole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags describing the role of a module header. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca50b6dee47a2d5b1f50f46dc46e4c96aa"></a>NormalHeader&#160;</td><td class="fielddoc"><p>This header is normally included in the module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca0500e1f1c1ee8f9e6c76c993aa48b0d4"></a>PrivateHeader&#160;</td><td class="fielddoc"><p>This header is included but private. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8decad7e8857e09c5d0fbe70ad90e0e584200"></a>TextualHeader&#160;</td><td class="fielddoc"><p>This header is part of the module (for layering purposes) but should be textually included. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac7a2413d4d0a8f29d2dad359bcfd8deca29ca8d089c3fd646d54e611219d0d877"></a>ExcludedHeader&#160;</td><td class="fielddoc"><p>This header is explicitly excluded from the module. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00127">127</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a767bb9d1787801348282cf9b588df471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767bb9d1787801348282cf9b588df471">&#9670;&nbsp;</a></span>ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::ModuleMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceManager.html">SourceManager</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DiagnosticsEngine.html">DiagnosticsEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>Diags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1LangOptions.html">LangOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>LangOpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> *&#160;</td>
          <td class="paramname"><em>Target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a> &amp;&#160;</td>
          <td class="paramname"><em>HeaderInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new module map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SourceMgr</td><td>The source manager used to find module files and headers. This source manager should be shared with the header-search mechanism, since they will refer to the same headers.</td></tr>
    <tr><td class="paramname">Diags</td><td>A diagnostic engine used for diagnostics.</td></tr>
    <tr><td class="paramname">LangOpts</td><td>Language options for this translation unit.</td></tr>
    <tr><td class="paramname">Target</td><td>The target for this translation unit. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00357">357</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ab8769cd7eba3cb7f8f1cd2dde890603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8769cd7eba3cb7f8f1cd2dde890603d">&#9670;&nbsp;</a></span>~ModuleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModuleMap::~ModuleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the module map. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00365">365</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2547baacaf16c89fe6c017a8d7847eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2547baacaf16c89fe6c017a8d7847eab">&#9670;&nbsp;</a></span>addAdditionalModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addAdditionalModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>ModuleMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01372">1372</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acb605a0f3e5ac2213bab92d201fc1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb605a0f3e5ac2213bab92d201fc1ec1">&#9670;&nbsp;</a></span>addHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Imported</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds this header to the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Role</td><td>The role of the header wrt the module. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01282">1282</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00253">clang::Module::Header::Entry</a>, <a class="el" href="FileEntry_8h_source.html#l00061">clang::FileEntryRef::getName()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00076">headerRoleToKind()</a>, <a class="el" href="Module_8h_source.html#l00265">clang::Module::Headers</a>, <a class="el" href="Module_8cpp_source.html#l00160">clang::Module::isForBuilding()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01427">clang::HeaderSearch::MarkFileModuleHeader()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTReader_8cpp_source.html#l02035">clang::serialization::reader::HeaderFileInfoTrait::ReadData()</a>.</p>

</div>
</div>
<a id="a06068cd4735154ef4218ab96f9462412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06068cd4735154ef4218ab96f9462412">&#9670;&nbsp;</a></span>addLinkAsDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::addLinkAsDependency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make module to use export_as as the link dependency name if enough information is available or add it to a pending list otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00069">69</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00179">clang::Module::ExportAsModule</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00826">findModule()</a>, <a class="el" href="Module_8h_source.html#l00108">clang::Module::Name</a>, and <a class="el" href="Module_8h_source.html#l00467">clang::Module::UseExportAsModuleLinkName</a>.</p>

</div>
</div>
<a id="a516ba163200648ee309a8b16ccc0d62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516ba163200648ee309a8b16ccc0d62a">&#9670;&nbsp;</a></span>addModuleMapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::addModuleMapCallbacks </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classclang_1_1ModuleMapCallbacks.html">ModuleMapCallbacks</a> &gt;&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a module map callback. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00424">424</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyFile_8cpp_source.html#l00184">clang::DependencyCollector::attachToPreprocessor()</a>, and <a class="el" href="ModuleDependencyCollector_8cpp_source.html#l00088">clang::ModuleDependencyCollector::attachToPreprocessor()</a>.</p>

</div>
</div>
<a id="ac61bce84c6ecb21f1f05539c84b855ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61bce84c6ecb21f1f05539c84b855ad">&#9670;&nbsp;</a></span>cacheModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::cacheModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cache a module load. M might be nullptr. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00744">744</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02016">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a3b14289476fe5638600e7e1d78f41a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b14289476fe5638600e7e1d78f41a0e">&#9670;&nbsp;</a></span>canInferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::canInferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DirectoryEntry.html">DirectoryEntry</a> *&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a framework module can be inferred in the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00610">610</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00446">loadModuleMapForModuleBuild()</a>.</p>

</div>
</div>
<a id="a7a1261e559ef2565d078189e60f96b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1261e559ef2565d078189e60f96b85">&#9670;&nbsp;</a></span>canonicalizeModuleMapPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code ModuleMap::canonicalizeModuleMapPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>Path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize <code>Path</code> in a manner suitable for a module map file. </p>
<p>In particular, this canonicalizes the parent directory separately from the filename so that it does not affect header resolution relative to the modulemap.</p>
<dl class="section return"><dt>Returns</dt><dd>an error code if any filesystem operations failed. In this case <code>Path</code> is not modified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01340">1340</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileManager_8cpp_source.html#l00613">clang::FileManager::getCanonicalName()</a>, <a class="el" href="FileManager_8cpp_source.html#l00118">clang::FileManager::getDirectoryRef()</a>, <a class="el" href="SourceManager_8h_source.html#l00850">clang::SourceManager::getFileManager()</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="ab984430b63c290eb25d0b696d486303c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984430b63c290eb25d0b696d486303c">&#9670;&nbsp;</a></span>createGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module unit. </p>
<p>We model the global module fragment as a submodule of the module interface unit. Unfortunately, we can't create the module interface unit's <a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> until later, because we don't know what it will be called usually. See C++20 [module.unit]/7.2 for the case we could know its parent. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00871">871</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00138">clang::Module::ExplicitGlobalModuleFragment</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a488004c9aee8ccd0836e58ab114813ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488004c9aee8ccd0836e58ab114813ed">&#9670;&nbsp;</a></span>createHeaderUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createHeaderUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1Module_1_1Header.html">Module::Header</a>&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a C++20 header unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00966">966</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="ae55b51f4c1d8b938248d11624bd468b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55b51f4c1d8b938248d11624bd468b3">&#9670;&nbsp;</a></span>createImplicitGlobalModuleFragmentForModuleUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createImplicitGlobalModuleFragmentForModuleUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00884">884</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00146">clang::Module::ImplicitGlobalModuleFragment</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a759d721452cbf7773605b71193c7a762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d721452cbf7773605b71193c7a762">&#9670;&nbsp;</a></span>createModuleForImplementationUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForImplementationUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module implementation unit. </p>
<p>The interface module for this implementation (implicitly imported) must exist and be loaded and present in the modules map.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00942">942</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="aca8dfb44af54446f37a943a9dd4b9c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8dfb44af54446f37a943a9dd4b9c4f">&#9670;&nbsp;</a></span>createModuleForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new module for a C++ module interface unit. </p>
<p>The module must not already exist, and will be configured for the current compilation.</p>
<p>Note that this also sets the current module to the newly-created module.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly-created module. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00924">924</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="af6f1f85e8474bddc3b2c4d0938540457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f1f85e8474bddc3b2c4d0938540457">&#9670;&nbsp;</a></span>createModuleUnitWithKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createModuleUnitWithKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#acdab95b809e6c2a027d4ca2763c90b70">Module::ModuleKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new C++ module with the specified kind, and reparent any pending global module fragment(s) to it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00908">908</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="acea4a5b3bc65f0ff822859970c2ecac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea4a5b3bc65f0ff822859970c2ecac0">&#9670;&nbsp;</a></span>createPrivateModuleFragmentForInterfaceUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createPrivateModuleFragmentForInterfaceUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>Loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a global module fragment for a C++ module interface unit. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00899">899</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>, and <a class="el" href="Module_8h_source.html#l00141">clang::Module::PrivateModuleFragment</a>.</p>

</div>
</div>
<a id="a031a847ae6f15d895ef5808fd4af56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a847ae6f15d895ef5808fd4af56aa">&#9670;&nbsp;</a></span>createShadowedModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::createShadowedModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ShadowingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new top-level module that is shadowed by <code>ShadowingModule</code>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01171">1171</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a22cfc8d05dbf3c2cceb132f4c789b8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cfc8d05dbf3c2cceb132f4c789b8d1">&#9670;&nbsp;</a></span>diagnoseHeaderInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::diagnoseHeaderInclusion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>RequestingModuleIsModuleInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>FilenameLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports errors if a module must not include a specific file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RequestingModule</td><td>The module including a file.</td></tr>
    <tr><td class="paramname">RequestingModuleIsModuleInterface</td><td><code>true</code> if the inclusion is in the interface of RequestingModule, <code>false</code> if it's in the implementation of RequestingModule. <a class="el" href="classclang_1_1Value.html">Value</a> is ignored and meaningless if RequestingModule is nullptr.</td></tr>
    <tr><td class="paramname">FilenameLoc</td><td>The location of the inclusion's filename.</td></tr>
    <tr><td class="paramname">Filename</td><td>The included filename as written.</td></tr>
    <tr><td class="paramname">File</td><td>The included file. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00496">496</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00293">clang::Module::directlyUses()</a>, <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Format_8cpp_source.html#l02972">Filename</a>, <a class="el" href="Module_8cpp_source.html#l00244">clang::Module::getFullModuleName()</a>, <a class="el" href="ModuleMap_8h_source.html#l00174">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00177">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00665">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00492">getTopLevelOrNull()</a>, <a class="el" href="LangOptions_8h_source.html#l00636">clang::LangOptions::isCompilingModule()</a>, <a class="el" href="Module_8h_source.html#l00323">clang::Module::IsFramework</a>, <a class="el" href="Module_8h_source.html#l00108">clang::Module::Name</a>, <a class="el" href="namespaceclang.html#a015889db1a9bb17e9d7103a8e79c2a2ca47f9082fc380ca62d531096aa1d110f1">clang::Private</a>, <a class="el" href="Basic_2Diagnostic_8h_source.html#l01553">clang::DiagnosticsEngine::Report()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01247">resolveHeaderDirectives()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01412">resolveUses()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00471">violatesPrivateInclude()</a>.</p>

</div>
</div>
<a id="a0ed1579ac35c5dcb1ab68449949a6912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed1579ac35c5dcb1ab68449949a6912">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVM_DUMP_METHOD void ModuleMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump the contents of the module map, for debugging purposes. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01377">1377</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00482">clang::Module::print()</a>.</p>

</div>
</div>
<a id="ae33e5e7b75c6545c48d6b4765d826e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e5e7b75c6545c48d6b4765d826e80">&#9670;&nbsp;</a></span>findAllModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findAllModulesForHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve all the modules that contain the given header file. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<p>Typically, <a class="el" href="classclang_1_1ModuleMap.html#a45c2312745196384b06b31469fa258bd">findModuleForHeader</a> should be used instead, as it picks the preferred module for the header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00707">707</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01663">clang::HeaderSearch::findAllModulesForHeader()</a>.</p>

</div>
</div>
<a id="a35bee9d02a3e7ced6bc9f7dd42ede743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee9d02a3e7ced6bc9f7dd42ede743">&#9670;&nbsp;</a></span>findModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::findModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00826">826</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00069">addLinkAsDependency()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00292">clang::HeaderSearch::lookupModule()</a>.</p>

</div>
</div>
<a id="a45c2312745196384b06b31469fa258bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c2312745196384b06b31469fa258bd">&#9670;&nbsp;</a></span>findModuleForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> ModuleMap::findModuleForHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowTextual</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowExcluded</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module that owns the given header file, if any. </p>
<p>Note that this does not implicitly load module maps, except for builtin headers, and does not consult the external source. (Those checks are the responsibility of <a class="el" href="classclang_1_1HeaderSearch.html">HeaderSearch</a>.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The header file that is likely to be included.</td></tr>
    <tr><td class="paramname">AllowTextual</td><td>If <code>true</code> and <code>File</code> is a textual header, return its owning module. Otherwise, no <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> will be returned if the file is only known as a textual header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The module <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a>, which provides the module that owns the given header file. The <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html" title="A header that is known to reside within a given module, whether it was included or excluded.">KnownHeader</a> is default constructed to indicate that no module owns this header file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00606">606</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="ModuleMap_8h_source.html#l00174">clang::ModuleMap::KnownHeader::getModule()</a>, <a class="el" href="ModuleMap_8h_source.html#l00177">clang::ModuleMap::KnownHeader::getRole()</a>, <a class="el" href="Module_8h_source.html#l00665">clang::Module::getTopLevelModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00578">isBetterKnownHeader()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01652">clang::HeaderSearch::findModuleForHeader()</a>, and <a class="el" href="PPDirectives_8cpp_source.html#l00859">clang::Preprocessor::getModuleForLocation()</a>.</p>

</div>
</div>
<a id="a115a5b7b114346aaa534995084fc3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115a5b7b114346aaa534995084fc3ac0">&#9670;&nbsp;</a></span>findOrCreateModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classclang_1_1Module.html">Module</a> *, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; ModuleMap::findOrCreateModule </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsFramework</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsExplicit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a new module or submodule, or create it if it does not already exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to find or create.</td></tr>
    <tr><td class="paramname">Parent</td><td>The module that will act as the parent of this submodule, or nullptr to indicate that this is a top-level module.</td></tr>
    <tr><td class="paramname">IsFramework</td><td>Whether this is a framework module.</td></tr>
    <tr><td class="paramname">IsExplicit</td><td>Whether this is an explicit submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The found or newly-created module, along with a boolean value that will be true if the module is newly-created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00851">851</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a6b26cfebdc052957edada81dd3aeef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b26cfebdc052957edada81dd3aeef7f">&#9670;&nbsp;</a></span>findResolvedModulesForHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classclang_1_1ModuleMap_1_1KnownHeader.html">ModuleMap::KnownHeader</a> &gt; ModuleMap::findResolvedModulesForHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classclang_1_1ModuleMap.html#ae33e5e7b75c6545c48d6b4765d826e80">findAllModulesForHeader</a>, but do not attempt to infer module ownership from umbrella headers if we've not already done so. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00719">719</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01247">resolveHeaderDirectives()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01673">clang::HeaderSearch::findResolvedModulesForHeader()</a>.</p>

</div>
</div>
<a id="a390f6e47e08d60984fca9c6c492d42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390f6e47e08d60984fca9c6c492d42f7">&#9670;&nbsp;</a></span>finishModuleDeclarationScope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::finishModuleDeclarationScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new declaration scope for module names, allowing previously defined modules to shadow definitions from the new scope. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a> names from earlier scopes will shadow names from the new scope, which is the opposite of how shadowing works for variables. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00601">601</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="a9c2eda49b11b2b5dd41e456d986623e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2eda49b11b2b5dd41e456d986623e8">&#9670;&nbsp;</a></span>getAdditionalModuleMapFiles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a93c29c953accc6a4454b0280b7480882">AdditionalModMapsSet</a>* clang::ModuleMap::getAdditionalModuleMapFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any module map files other than getModuleMapFileForUniquing(M) that define submodules of a top-level module <code>M</code>. </p>
<p>This is cheaper than getting the module map file for each submodule individually, since the expected number of results is very small. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00652">652</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<a id="aa9db4bf1da20795a60daebbba3857355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9db4bf1da20795a60daebbba3857355">&#9670;&nbsp;</a></span>getBuiltinDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a3f819cd7627b94dae14d1044dfb9576c">OptionalDirectoryEntryRef</a> clang::ModuleMap::getBuiltinDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the directory that contains Clang-supplied include files. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00415">415</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00951">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<a id="a8673ca4aacbe3e404597553a4c298005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8673ca4aacbe3e404597553a4c298005">&#9670;&nbsp;</a></span>getCachedModuleLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classclang_1_1Module.html">Module</a> *&gt; clang::ModuleMap::getCachedModuleLoad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1IdentifierInfo.html">IdentifierInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>II</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a cached module load. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00749">749</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02016">clang::CompilerInstance::loadModule()</a>.</p>

</div>
</div>
<a id="a303d98d21ca4002f64a8efe0d0861897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d98d21ca4002f64a8efe0d0861897">&#9670;&nbsp;</a></span>getContainingModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a> ModuleMap::getContainingModuleMapFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Module</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01317">1317</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01309">getContainingModuleMapFileID()</a>, and <a class="el" href="SourceManager_8h_source.html#l01073">clang::SourceManager::getFileEntryRefForID()</a>.</p>

</div>
</div>
<a id="aa7ad888db0b2b51d7da1231ff0f732be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ad888db0b2b51d7da1231ff0f732be">&#9670;&nbsp;</a></span>getContainingModuleMapFileID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1FileID.html">FileID</a> ModuleMap::getContainingModuleMapFileID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Module</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the module map file containing the definition of the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classclang_1_1Module.html" title="Describes a module or submodule.">Module</a></td><td>The module whose module map file will be returned, if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> for the module map file containing the given module, invalid if the module definition was inferred. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01309">1309</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00111">clang::Module::DefinitionLoc</a>, <a class="el" href="SourceManager_8h_source.html#l01141">clang::SourceManager::getFileID()</a>, and <a class="el" href="SourceLocation_8h_source.html#l00113">clang::SourceLocation::isInvalid()</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l01330">compileModule()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01317">getContainingModuleMapFile()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01321">getModuleMapFileIDForUniquing()</a>.</p>

</div>
</div>
<a id="a7079336099f427b383128cfa445dd4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7079336099f427b383128cfa445dd4ea">&#9670;&nbsp;</a></span>getModuleMapFileForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceclang.html#a7e226bbdf107c8ffd9cca41873bbdd2d">OptionalFileEntryRef</a> ModuleMap::getModuleMapFileForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01330">1330</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l01073">clang::SourceManager::getFileEntryRefForID()</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l01321">getModuleMapFileIDForUniquing()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleDepCollector_8cpp_source.html#l00358">clang::tooling::dependencies::ModuleDepCollector::applyDiscoveredDependencies()</a>, <a class="el" href="CompilerInstance_8cpp_source.html#l01330">compileModule()</a>, <a class="el" href="HeaderSearch_8cpp_source.html#l00193">clang::HeaderSearch::getCachedModuleFileName()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l00234">clang::HeaderSearch::getPrebuiltImplicitModuleFileName()</a>.</p>

</div>
</div>
<a id="a845749f24dbf1e59be50cc7db786808d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845749f24dbf1e59be50cc7db786808d">&#9670;&nbsp;</a></span>getModuleMapFileIDForUniquing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1FileID.html">FileID</a> ModuleMap::getModuleMapFileIDForUniquing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the module map file that (along with the module name) uniquely identifies this module. </p>
<p>The particular module that <code>Name</code> refers to may depend on how the module was found in header search. However, the combination of <code>Name</code> and this module map will be globally unique for top-level modules. In the case of inferred modules, returns the module map that allowed the inference (e.g. contained 'module *'). Otherwise, returns <a class="el" href="classclang_1_1ModuleMap.html#a303d98d21ca4002f64a8efe0d0861897">getContainingModuleMapFile()</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01321">1321</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l01309">getContainingModuleMapFileID()</a>, and <a class="el" href="Module_8h_source.html#l00342">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01330">getModuleMapFileForUniquing()</a>.</p>

</div>
</div>
<a id="af95957116dd995616c90e64c864811cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95957116dd995616c90e64c864811cd">&#9670;&nbsp;</a></span>headerKindToRole()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleMap::ModuleHeaderRole</a> ModuleMap::headerKindToRole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a>&#160;</td>
          <td class="paramname"><em>Kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header kind to a role. Requires Kind to not be HK_Excluded. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00093">93</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00244">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00240">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00242">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00243">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00241">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00132">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

</div>
</div>
<a id="a32c51efd0ee64aaadd73218544eeeb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c51efd0ee64aaadd73218544eeeb01">&#9670;&nbsp;</a></span>headerRoleToKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html#a359f634f3c9358d7c969744e25beb826">Module::HeaderKind</a> ModuleMap::headerRoleToKind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a header role to a kind. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00076">76</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="Module_8h_source.html#l00244">clang::Module::HK_Excluded</a>, <a class="el" href="Module_8h_source.html#l00240">clang::Module::HK_Normal</a>, <a class="el" href="Module_8h_source.html#l00242">clang::Module::HK_Private</a>, <a class="el" href="Module_8h_source.html#l00243">clang::Module::HK_PrivateTextual</a>, <a class="el" href="Module_8h_source.html#l00241">clang::Module::HK_Textual</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="ModuleMap_8h_source.html#l00132">PrivateHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l01282">addHeader()</a>.</p>

</div>
</div>
<a id="af68b0b03f415bfbaedc292c33b881c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68b0b03f415bfbaedc292c33b881c41">&#9670;&nbsp;</a></span>inferFrameworkModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::inferFrameworkModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a>&#160;</td>
          <td class="paramname"><em>FrameworkDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the contents of a framework module map from the given framework directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00992">992</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00332">clang::Module::IsSystem</a>, and <a class="el" href="ASTDiff_8cpp_source.html#l00191">Parent</a>.</p>

</div>
</div>
<a id="a99e2d0400d837a69d22557ff10e3c537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e2d0400d837a69d22557ff10e3c537">&#9670;&nbsp;</a></span>isBuiltinHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isBuiltinHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this a compiler builtin header? </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00415">415</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, and <a class="el" href="ModuleMap_8cpp_source.html#l00259">isBuiltinHeaderName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01444">clang::HeaderSearch::ShouldEnterIncludeFile()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01682">suggestModule()</a>.</p>

</div>
</div>
<a id="aa4894e6adb8982448b6724c996d0f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4894e6adb8982448b6724c996d0f5e4">&#9670;&nbsp;</a></span>isHeaderInUnavailableModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderInUnavailableModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>Header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is part of a module marked 'unavailable'. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00728">728</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8cpp_source.html#l00732">isHeaderUnavailableInModule()</a>.</p>

</div>
</div>
<a id="a648ba5f0cd274dd3acd6ee14aeae1cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648ba5f0cd274dd3acd6ee14aeae1cdc">&#9670;&nbsp;</a></span>isHeaderUnavailableInModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isHeaderUnavailableInModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>Header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>RequestingModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the given header is unavailable as part of the specified module. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00732">732</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, <a class="el" href="FileEntry_8h_source.html#l00073">clang::FileEntryRef::getDir()</a>, <a class="el" href="Module_8cpp_source.html#l00269">clang::Module::getEffectiveUmbrellaDir()</a>, <a class="el" href="DirectoryEntry_8h_source.html#l00052">clang::DirectoryEntryRef::getName()</a>, <a class="el" href="RecursiveASTVisitor_8h_source.html#l01091">clang::if()</a>, <a class="el" href="Module_8h_source.html#l00349">clang::Module::InferSubmodules</a>, <a class="el" href="Module_8h_source.html#l00528">clang::Module::isAvailable()</a>, <a class="el" href="Module_8cpp_source.html#l00198">clang::Module::isSubModuleOf()</a>, <a class="el" href="Module_8h_source.html#l00154">clang::Module::Parent</a>, <a class="el" href="ModuleMap_8cpp_source.html#l01247">resolveHeaderDirectives()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00728">isHeaderInUnavailableModule()</a>.</p>

</div>
</div>
<a id="a5ddbcfb5014e3bd0bcf33a30b41cc511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddbcfb5014e3bd0bcf33a30b41cc511">&#9670;&nbsp;</a></span>isModular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::isModular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ModuleMap.html#ac7a2413d4d0a8f29d2dad359bcfd8dec">ModuleHeaderRole</a>&#160;</td>
          <td class="paramname"><em>Role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the header with the given role is a modular one. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00109">109</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00139">ExcludedHeader</a>, and <a class="el" href="ModuleMap_8h_source.html#l00136">TextualHeader</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l01328">clang::HeaderFileInfo::mergeModuleMembership()</a>.</p>

</div>
</div>
<a id="ac4bd056e3b16607ace724463606dd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bd056e3b16607ace724463606dd3d5">&#9670;&nbsp;</a></span>lookupModuleQualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleQualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name within the given context, using direct (qualified) name lookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module for which we will look for a submodule. If null, we will look for a top-level module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named submodule, if known; otherwose, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00844">844</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a9682383d1483005eb8de8ab46275f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682383d1483005eb8de8ab46275f5e5">&#9670;&nbsp;</a></span>lookupModuleUnqualified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1Module.html">Module</a> * ModuleMap::lookupModuleUnqualified </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a module with the given name using lexical name lookup, starting at the given context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>The name of the module to look up.</td></tr>
    <tr><td class="paramname">Context</td><td>The module context, from which we will perform lexical name lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The named module, if known; otherwise, returns null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00834">834</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

</div>
</div>
<a id="a3df11cf9b74e240aa373f25c1a63b49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df11cf9b74e240aa373f25c1a63b49f">&#9670;&nbsp;</a></span>mayShadowNewModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::ModuleMap::mayShadowNewModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>ExistingModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00603">603</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00154">clang::Module::Parent</a>.</p>

</div>
</div>
<a id="a6ab65f1f0882fcff9a15da9cfbf0fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab65f1f0882fcff9a15da9cfbf0fd02">&#9670;&nbsp;</a></span>module_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00737">737</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02266">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00739">modules()</a>.</p>

</div>
</div>
<a id="a9d9e3147d81ec86cf00eea874d9ea95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9e3147d81ec86cf00eea874d9ea95b">&#9670;&nbsp;</a></span>module_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a> clang::ModuleMap::module_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00738">738</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="CompilerInstance_8cpp_source.html#l02266">clang::CompilerInstance::loadGlobalModuleIndex()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00739">modules()</a>.</p>

</div>
</div>
<a id="a9124c52cfa4df22a479eddbcc8e350d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124c52cfa4df22a479eddbcc8e350d3">&#9670;&nbsp;</a></span>modules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::iterator_range&lt;<a class="el" href="classclang_1_1ModuleMap.html#a1b352087754574155a198a4cb0d6e197">module_iterator</a>&gt; clang::ModuleMap::modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00739">739</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">References <a class="el" href="ModuleMap_8h_source.html#l00737">module_begin()</a>, and <a class="el" href="ModuleMap_8h_source.html#l00738">module_end()</a>.</p>

</div>
</div>
<a id="aaea0621e4b0eaf401c03cddf4114eae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea0621e4b0eaf401c03cddf4114eae7">&#9670;&nbsp;</a></span>parseModuleMapFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::parseModuleMapFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>File</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>IsSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a>&#160;</td>
          <td class="paramname"><em>HomeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td>
          <td class="paramname"><em>ID</em> = <code><a class="el" href="classclang_1_1FileID.html">FileID</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>&#160;</td>
          <td class="paramname"><em>ExternModuleLoc</em> = <code><a class="el" href="classclang_1_1SourceLocation.html">SourceLocation</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the given module map file, and record any modules we encounter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>The file to be parsed.</td></tr>
    <tr><td class="paramname">IsSystem</td><td>Whether this module map file is in a system header directory, and therefore should be considered a system module.</td></tr>
    <tr><td class="paramname">HomeDir</td><td>The directory in which relative paths within this module map file will be resolved.</td></tr>
    <tr><td class="paramname">ID</td><td>The <a class="el" href="classclang_1_1FileID.html" title="An opaque identifier used by SourceManager which refers to a source file (MemoryBuffer) along with it...">FileID</a> of the file to process, if we've already entered it.</td></tr>
    <tr><td class="paramname">Offset</td><td>[inout] On input the offset at which to start parsing. On output, the offset at which the module map terminated.</td></tr>
    <tr><td class="paramname">ExternModuleLoc</td><td>The location of the "extern module" declaration that caused us to load this module map file, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an error occurred, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l03119">3119</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="SourceManager_8h_source.html#l00086">clang::SrcMgr::C_System_ModuleMap</a>, <a class="el" href="SourceManager_8h_source.html#l00085">clang::SrcMgr::C_User_ModuleMap</a>, <a class="el" href="SourceManager_8cpp_source.html#l00533">clang::SourceManager::createFileID()</a>, <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="SourceManager_8h_source.html#l01047">clang::SourceManager::getBufferOrNone()</a>, <a class="el" href="SourceManager_8h_source.html#l01268">clang::SourceManager::getDecomposedLoc()</a>, <a class="el" href="SourceManager_8h_source.html#l01150">clang::SourceManager::getLocForStartOfFile()</a>, <a class="el" href="Lexer_8cpp_source.html#l01213">clang::Lexer::getSourceLocation()</a>, <a class="el" href="Arena_8cpp_source.html#l00183">ID</a>, and <a class="el" href="Format_8cpp_source.html#l02974">Offset</a>.</p>

</div>
</div>
<a id="a635593eb7f27a7297eb22afacd08d104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635593eb7f27a7297eb22afacd08d104">&#9670;&nbsp;</a></span>resolveConflicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveConflicts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved conflicts in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose conflicts should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving conflicts, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01426">1426</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00496">clang::Module::Conflicts</a>, <a class="el" href="Module_8h_source.html#l00492">clang::Module::Conflict::Message</a>, <a class="el" href="Module_8h_source.html#l00489">clang::Module::Conflict::Other</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00484">clang::Module::UnresolvedConflicts</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00699">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a03d91ee91e3d302d32885c4d790b3915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d91ee91e3d302d32885c4d790b3915">&#9670;&nbsp;</a></span>resolveExports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveExports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved exports in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose exports should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving exports, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01399">1399</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00414">clang::Module::Exports</a>, <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>, and <a class="el" href="Module_8h_source.html#l00432">clang::Module::UnresolvedExports</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPLexerChange_8cpp_source.html#l00699">clang::Preprocessor::EnterSubmodule()</a>.</p>

</div>
</div>
<a id="a64ce2c7a23bcff10e7ae4bfcda637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ce2c7a23bcff10e7ae4bfcda637182">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> *&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all lazy header directives for the specified file. </p>
<p>This ensures that the <a class="el" href="structclang_1_1HeaderFileInfo.html" title="The preprocessor keeps track of this information for each file that is #included.">HeaderFileInfo</a> on <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> is up to date. This is effectively internal, but is exposed so <a class="el" href="classclang_1_1HeaderSearch.html" title="Encapsulates the information needed to find the file referenced by a #include or #include_next,...">HeaderSearch</a> can call it. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01247">1247</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00496">diagnoseHeaderInclusion()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00719">findResolvedModulesForHeader()</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00732">isHeaderUnavailableInModule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01444">clang::HeaderSearch::ShouldEnterIncludeFile()</a>.</p>

</div>
</div>
<a id="a41dcd87105f5059bc55a3f3db230e9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dcd87105f5059bc55a3f3db230e9bb">&#9670;&nbsp;</a></span>resolveHeaderDirectives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveHeaderDirectives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; const <a class="el" href="classclang_1_1FileEntry.html">FileEntry</a> * &gt;&#160;</td>
          <td class="paramname"><em>File</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve lazy header directives for the specified module. </p>
<p>If File is provided, only headers with same size and modtime are resolved. If File is not set, all headers are resolved. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01263">1263</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a0b27918290ff5323bea1e3b78a9cf04e">clang::File</a>, <a class="el" href="Module_8h_source.html#l00276">clang::Module::UnresolvedHeaderDirective::ModTime</a>, <a class="el" href="Module_8h_source.html#l00275">clang::Module::UnresolvedHeaderDirective::Size</a>, and <a class="el" href="Module_8h_source.html#l00281">clang::Module::UnresolvedHeaders</a>.</p>

</div>
</div>
<a id="ac588ee8d4c631303982ed1c68002f49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588ee8d4c631303982ed1c68002f49d">&#9670;&nbsp;</a></span>resolveLinkAsDependencies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::resolveLinkAsDependencies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use PendingLinkAsModule information to mark top level link names that are going to be replaced by export_as aliases. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00058">58</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00108">clang::Module::Name</a>.</p>

</div>
</div>
<a id="aff262a15ac7933edd463953d969e4f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff262a15ac7933edd463953d969e4f6b">&#9670;&nbsp;</a></span>resolveUses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::resolveUses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>Complain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve all of the unresolved uses in the given module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mod</td><td>The module whose uses should be resolved.</td></tr>
    <tr><td class="paramname">Complain</td><td>Whether to emit diagnostics for failures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any errors were encountered while resolving uses, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01412">1412</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00665">clang::Module::getTopLevelModule()</a>, and <a class="el" href="namespaceclang.html#addf89b16eec81ec256e98fa0cc9cdd65a4a3b76ab214699973b85cc072788ff7d">clang::Unresolved</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleMap_8cpp_source.html#l00496">diagnoseHeaderInclusion()</a>, <a class="el" href="PPLexerChange_8cpp_source.html#l00699">clang::Preprocessor::EnterSubmodule()</a>, and <a class="el" href="HeaderSearch_8cpp_source.html#l01682">suggestModule()</a>.</p>

</div>
</div>
<a id="a5af87b750c2e1f3b11a77b99a40a755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af87b750c2e1f3b11a77b99a40a755f">&#9670;&nbsp;</a></span>setBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clang::ModuleMap::setBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a>&#160;</td>
          <td class="paramname"><em>Dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the directory that contains Clang-supplied include files, such as our <a class="el" href="stdarg_8h.html">stdarg.h</a> or <a class="el" href="tgmath_8h.html">tgmath.h</a>. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00412">412</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="InitHeaderSearch_8cpp_source.html#l00543">clang::ApplyHeaderSearchOptions()</a>.</p>

</div>
</div>
<a id="a8630da8d0808e9956b74b03e30f57314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630da8d0808e9956b74b03e30f57314">&#9670;&nbsp;</a></span>setInferredModuleAllowedBy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setInferredModuleAllowedBy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileID.html">FileID</a>&#160;</td>
          <td class="paramname"><em>ModMapFID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01334">1334</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00342">clang::Module::IsInferred</a>.</p>

<p class="reference">Referenced by <a class="el" href="FrontendAction_8cpp_source.html#l00489">prepareToBuildModule()</a>.</p>

</div>
</div>
<a id="abc441df169e00dbd5ab3a5db003d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc441df169e00dbd5ab3a5db003d454f">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classclang_1_1TargetInfo.html">TargetInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>Target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target information. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00372">372</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="HeaderSearch_8cpp_source.html#l00767">clang::HeaderSearch::setTarget()</a>.</p>

</div>
</div>
<a id="a202d290fccdf570de977224a277e24b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202d290fccdf570de977224a277e24b9">&#9670;&nbsp;</a></span>setUmbrellaDirAsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaDirAsWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1DirectoryEntryRef.html">DirectoryEntryRef</a>&#160;</td>
          <td class="paramname"><em>UmbrellaDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella directory of the given module to the given directory. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01201">1201</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8h_source.html#l00166">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00172">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00175">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="a8d4201bac04ec898145e7fd1b94cd9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4201bac04ec898145e7fd1b94cd9e9">&#9670;&nbsp;</a></span>setUmbrellaHeaderAsWritten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModuleMap::setUmbrellaHeaderAsWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1FileEntryRef.html">FileEntryRef</a>&#160;</td>
          <td class="paramname"><em>UmbrellaHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>NameAsWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>PathRelativeToRootModuleDirectory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the umbrella header of the given module to the given header. </p>

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l01186">1186</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="FileEntry_8h_source.html#l00073">clang::FileEntryRef::getDir()</a>, <a class="el" href="ModuleMap_8h_source.html#l00129">NormalHeader</a>, <a class="el" href="Module_8h_source.html#l00166">clang::Module::Umbrella</a>, <a class="el" href="Module_8h_source.html#l00172">clang::Module::UmbrellaAsWritten</a>, and <a class="el" href="Module_8h_source.html#l00175">clang::Module::UmbrellaRelativeToRootModuleDirectory</a>.</p>

</div>
</div>
<a id="a70dfd3616275cfb7ccf145978b876591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dfd3616275cfb7ccf145978b876591">&#9670;&nbsp;</a></span>shouldImportRelativeToBuiltinIncludeDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> ModuleMap::shouldImportRelativeToBuiltinIncludeDir </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>Module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8cpp_source.html#l00420">420</a> of file <a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespaceclang.html#aefe73d958ffa86ef7fef81f2ac045b57a1e621df39e053ff6bc7db7bb1c616cc1">clang::FileName</a>, <a class="el" href="ModuleMap_8cpp_source.html#l00259">isBuiltinHeaderName()</a>, <a class="el" href="Module_8h_source.html#l00567">clang::Module::isPartOfFramework()</a>, and <a class="el" href="Module_8h_source.html#l00332">clang::Module::IsSystem</a>.</p>

<p class="reference">Referenced by <a class="el" href="PPDirectives_8cpp_source.html#l00951">clang::Preprocessor::LookupFile()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a69fccb440615f32e24516ed4e718457d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fccb440615f32e24516ed4e718457d">&#9670;&nbsp;</a></span>ModuleMapParser</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classclang_1_1ModuleMapParser.html">ModuleMapParser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ModuleMap_8h_source.html#l00200">200</a> of file <a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/clang/Lex/<a class="el" href="ModuleMap_8h_source.html">ModuleMap.h</a></li>
<li>lib/Lex/<a class="el" href="ModuleMap_8cpp_source.html">ModuleMap.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2024 01:35:36 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
