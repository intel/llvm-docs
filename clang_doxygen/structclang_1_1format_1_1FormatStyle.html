<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::format::FormatStyle Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">19.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1format.html">format</a></li><li class="navelem"><a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structclang_1_1format_1_1FormatStyle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">clang::format::FormatStyle Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="structclang_1_1format_1_1FormatStyle.html" title="The FormatStyle is used to configure the formatting to follow specific guidelines.">FormatStyle</a></code> is used to configure the formatting to follow specific guidelines.  
 <a href="structclang_1_1format_1_1FormatStyle.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Format_8h_source.html">clang/Format/Format.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment options.  <a href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html">BraceWrappingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise control over the wrapping of braces.  <a href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1FormatStyleSet.html">FormatStyleSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1IntegerLiteralSeparatorStyle.html">IntegerLiteralSeparatorStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separator format of integer literals of different bases.  <a href="structclang_1_1format_1_1FormatStyle_1_1IntegerLiteralSeparatorStyle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1RawStringFormat.html">RawStringFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See documentation of <code>RawStringFormats</code>.  <a href="structclang_1_1format_1_1FormatStyle_1_1RawStringFormat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1ShortCaseStatementsAlignmentStyle.html">ShortCaseStatementsAlignmentStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment options.  <a href="structclang_1_1format_1_1FormatStyle_1_1ShortCaseStatementsAlignmentStyle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpaceBeforeParensCustom.html">SpaceBeforeParensCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise control over the spacing before parentheses.  <a href="structclang_1_1format_1_1FormatStyle_1_1SpaceBeforeParensCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInLineComment.html">SpacesInLineComment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces may be inserted into C style casts.  <a href="structclang_1_1format_1_1FormatStyle_1_1SpacesInLineComment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInParensCustom.html">SpacesInParensCustom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precise control over the spacing in parentheses.  <a href="structclang_1_1format_1_1FormatStyle_1_1SpacesInParensCustom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1TrailingCommentsAlignmentStyle.html">TrailingCommentsAlignmentStyle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alignment options.  <a href="structclang_1_1format_1_1FormatStyle_1_1TrailingCommentsAlignmentStyle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a442fa38afc320ec9b6d9e1f569c81060"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060">BracketAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060ac33c64a6bce2e25d9f7a4894727a9a9a">BAS_Align</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060a4b171eda48af6a398909c9a40fe4d4e3">BAS_DontAlign</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060a5031bf7df909e2bcd7d9a08850f7d1bf">BAS_AlwaysBreak</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060aa87adad0d79820a483c0998ca54bed27">BAS_BlockIndent</a>
 }</td></tr>
<tr class="memdesc:a442fa38afc320ec9b6d9e1f569c81060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for aligning after open brackets.  <a href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060">More...</a><br /></td></tr>
<tr class="separator:a442fa38afc320ec9b6d9e1f569c81060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1754a0481292dcc9959bf6fbebcd6b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1">ArrayInitializerAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1a50fcc31497238d6b29539cc9fd543eae">AIAS_Left</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1a74e3de4277f5f147442134a0f9e3091e">AIAS_Right</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1ac9d8829b59844f43bc795f01a4c3ab86">AIAS_None</a>
 }</td></tr>
<tr class="memdesc:ac1754a0481292dcc9959bf6fbebcd6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different style for aligning array initializers.  <a href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1">More...</a><br /></td></tr>
<tr class="separator:ac1754a0481292dcc9959bf6fbebcd6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfc28e8e1e440535df98dbf25b10c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3">EscapedNewlineAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3a86f6ce26b0ff956213c5b541ac30b00a">ENAS_DontAlign</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3a88c07f69f780b920cc5fe0857f46ce06">ENAS_Left</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3a97139aea4f632f028d2ed431db5fa9df">ENAS_Right</a>
 }</td></tr>
<tr class="memdesc:ac8cfc28e8e1e440535df98dbf25b10c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for aligning escaped newlines.  <a href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3">More...</a><br /></td></tr>
<tr class="separator:ac8cfc28e8e1e440535df98dbf25b10c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3421b3510c1cf937d2ed651942e3db6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6">OperandAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6ad9f83b1c5b619e10799dd0f8cd486286">OAS_DontAlign</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6a3be333b353f4180354569bd46a67c2c4">OAS_Align</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6ac63b010eecb5202e8629fb7530b436af">OAS_AlignAfterOperator</a>
 }</td></tr>
<tr class="memdesc:af3421b3510c1cf937d2ed651942e3db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for aligning operands.  <a href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6">More...</a><br /></td></tr>
<tr class="separator:af3421b3510c1cf937d2ed651942e3db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4bc5b96e644e54bb925b361652d0a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6">TrailingCommentsAlignmentKinds</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6a4e026d897be750c5d085056a0fdcb292">TCAS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6a79149cbc5a45eee6532e1cc30180891a">TCAS_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6a46d41ad83e9746c2fc4477b642778361">TCAS_Never</a>
 }</td></tr>
<tr class="memdesc:a3b4bc5b96e644e54bb925b361652d0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enums for AlignTrailingComments.  <a href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6">More...</a><br /></td></tr>
<tr class="separator:a3b4bc5b96e644e54bb925b361652d0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cc60ebba19ff17e09ed2dd63d22cba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cba">BreakBeforeNoexceptSpecifierStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cbaa18e5651184ffd2ebf654359cbe476096">BBNSS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cbaa7c93a67ad33e3e60f06de2f48b33737f">BBNSS_OnlyWithParen</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cbaa6f97baef8b9654a48bfab6666c25e40e">BBNSS_Always</a>
 }</td></tr>
<tr class="memdesc:a87cc60ebba19ff17e09ed2dd63d22cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break before a noexcept specifier.  <a href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cba">More...</a><br /></td></tr>
<tr class="separator:a87cc60ebba19ff17e09ed2dd63d22cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594a2f875200530674b48f806d31a227"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227">ShortBlockStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227af0ba6f2cd98d4f1d956bd6e7af1dcc46">SBS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227ac6a6c9c36df9aa151e194e530b5692b3">SBS_Empty</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227a7e2722ea9652fea1f69486aa5d1be0f9">SBS_Always</a>
 }</td></tr>
<tr class="memdesc:a594a2f875200530674b48f806d31a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for merging short blocks containing at most one statement.  <a href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227">More...</a><br /></td></tr>
<tr class="separator:a594a2f875200530674b48f806d31a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e649ad0d631fb02b66f55f1cb291c7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7b">ShortFunctionStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7ba70bcff26a3b413dee5bb6d156e243421">SFS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7bab47fdf3a99e6d4eb9e41d4fdd996731b">SFS_InlineOnly</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7ba5705f074de510b309057df11f8d36841">SFS_Empty</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7ba06a035dbc253ac7728a90df65a68d56b">SFS_Inline</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7ba146a389b511103c51c317bdda131cd43">SFS_All</a>
<br />
 }</td></tr>
<tr class="memdesc:a9e649ad0d631fb02b66f55f1cb291c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for merging short functions containing at most one statement.  <a href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7b">More...</a><br /></td></tr>
<tr class="separator:a9e649ad0d631fb02b66f55f1cb291c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1cf3879fa6bc4459d4737e440b6ec5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5">ShortIfStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5a34e813a131f75fd56e70e37ef2ce20f2">SIS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5a2c55ff0cdfb118149c91b9b2546287fc">SIS_WithoutElse</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5aebacd27c0f517ae08d76ccd1891a6da4">SIS_OnlyFirstIf</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5afa89d6181788abc9ab5b36bf6d16e452">SIS_AllIfsAndElse</a>
 }</td></tr>
<tr class="memdesc:a5b1cf3879fa6bc4459d4737e440b6ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for handling short if statements.  <a href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5">More...</a><br /></td></tr>
<tr class="separator:a5b1cf3879fa6bc4459d4737e440b6ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1443da0f05d0355c0073b16343fd3065"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065">ShortLambdaStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065a8fb420194603ef010557d98be64a242e">SLS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065afbf70aa74708c1c5a19bef4430ae3197">SLS_Empty</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065a463b4bfed474a2b0c9e134b523018670">SLS_Inline</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065a22d2d5b75110a749fb95cd64d68fd5dd">SLS_All</a>
 }</td></tr>
<tr class="memdesc:a1443da0f05d0355c0073b16343fd3065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for merging short lambdas containing at most one statement.  <a href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065">More...</a><br /></td></tr>
<tr class="separator:a1443da0f05d0355c0073b16343fd3065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc06eef4565a8cdcd858356750a4181"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181">DefinitionReturnTypeBreakingStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181aff5139d2fea20ac5f0acd864be525ad0">DRTBS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181a0b175c67d5aa73f775a9eb3c6dcdbb99">DRTBS_All</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181a7dd0a60474b73a0c3c1643cfca22ccff">DRTBS_TopLevel</a>
 }</td></tr>
<tr class="memdesc:abdc06eef4565a8cdcd858356750a4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break after the function definition return type.  <a href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181">More...</a><br /></td></tr>
<tr class="separator:abdc06eef4565a8cdcd858356750a4181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ce7f7cb26f4a6d278dd9b37a5b5d93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">ReturnTypeBreakingStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a828730b5d67acb44b86204ce2a726ce9">RTBS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a8540fa764d956a7732b05d4c26d01005">RTBS_Automatic</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a3b41972e4630f2a35aa653097c980ebf">RTBS_ExceptShortType</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a7bcfb4d547cd2e60a58228d3b0021b7c">RTBS_All</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a817ef42fecd4c11fab2b274249669d7e">RTBS_TopLevel</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93abe1ad5bdf13fd57f28005dff20bf4fa2">RTBS_AllDefinitions</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93a2ab2cf999a0b68dc6b097f9c7732a7dd">RTBS_TopLevelDefinitions</a>
<br />
 }</td></tr>
<tr class="memdesc:ae8ce7f7cb26f4a6d278dd9b37a5b5d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break after the function definition or declaration return type.  <a href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">More...</a><br /></td></tr>
<tr class="separator:ae8ce7f7cb26f4a6d278dd9b37a5b5d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633755f5bf183748346c97afa9578a0c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0c">BreakTemplateDeclarationsStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0cacbcee241ea93a28c5d430eb468585cbf">BTDS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0ca4be5aa5d52aeb733972530bc2adac9d2">BTDS_No</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0ca557bfcf068a872b935807115ed262c9d">BTDS_MultiLine</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0caa2f1c37eaed2de6087bf393e7da23f8e">BTDS_Yes</a>
 }</td></tr>
<tr class="memdesc:a633755f5bf183748346c97afa9578a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break after the template declaration.  <a href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0c">More...</a><br /></td></tr>
<tr class="separator:a633755f5bf183748346c97afa9578a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aab3da546bc93a6c14047372d920b4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4">BitFieldColonSpacingStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4a66b04c683bcb08ce80edbae4f5ff69ef">BFCS_Both</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4a7c9d73fbbff8b21140713df7b6862c91">BFCS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4a725a5c3bd20c40de91d9f0d9714b8d29">BFCS_Before</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4ae2c32801a32193bd4e745c4eb8ed70b3">BFCS_After</a>
 }</td></tr>
<tr class="memdesc:a97aab3da546bc93a6c14047372d920b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Styles for adding spacing around <code>:</code> in bitfield definitions.  <a href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4">More...</a><br /></td></tr>
<tr class="separator:a97aab3da546bc93a6c14047372d920b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d75612e11d2b3f9881d67d141b2dace"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2dace">BraceWrappingAfterControlStatementStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2daceae79ccd4bfb9d6a9c985ac2124e5b2d81">BWACS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2daceaee7c71e0aa38ebbde62c0768efe77f52">BWACS_MultiLine</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2daceae123131341d968f4827e2dbce8d45869">BWACS_Always</a>
 }</td></tr>
<tr class="memdesc:a8d75612e11d2b3f9881d67d141b2dace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to wrap braces after control statements.  <a href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2dace">More...</a><br /></td></tr>
<tr class="separator:a8d75612e11d2b3f9881d67d141b2dace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937ce324270bf866adf43576f0eec42a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42a">AttributeBreakingStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42aa9822cd1742e1afa43ebedbcfc1d5945d">ABS_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42aa0689eac5930ddc74fe4616c67d2ab0b7">ABS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42aa587768dd4bdb784de605863818dcdb38">ABS_Never</a>
 }</td></tr>
<tr class="memdesc:a937ce324270bf866adf43576f0eec42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break after attributes.  <a href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42a">More...</a><br /></td></tr>
<tr class="separator:a937ce324270bf866adf43576f0eec42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299636b6bf3abfe22e688270dd44c3b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2">BinPackStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2a1f7ce6adb0c445ad64ea4f36fb7ae777">BPS_Auto</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2aa26312a15114d0f05c1d2528e4f8f88c">BPS_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2a125523cc4dd0cf72acd2dc07c505d583">BPS_Never</a>
 }</td></tr>
<tr class="memdesc:a299636b6bf3abfe22e688270dd44c3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style of wrapping parameters on the same line (bin-packed) or on one line each.  <a href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2">More...</a><br /></td></tr>
<tr class="separator:a299636b6bf3abfe22e688270dd44c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f7b0cd30443b4c10869175b520e934"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934">BinaryOperatorStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934a9d57aa85a8ceeb7d5e6d4edba98f7381">BOS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934aeab59ce2d6f6ae021be6e620185f4912">BOS_NonAssignment</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934a64dd76a9db3b40a67d4654176227ca2c">BOS_All</a>
 }</td></tr>
<tr class="memdesc:a34f7b0cd30443b4c10869175b520e934"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style of breaking before or after binary operators.  <a href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934">More...</a><br /></td></tr>
<tr class="separator:a34f7b0cd30443b4c10869175b520e934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e5c3eb76618e18dfdcff4677d98d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7">BraceBreakingStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7aea9196ec59731ddd6e997f063ae9cabc">BS_Attach</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a90651ce12fddb7c4099d48b10457059b">BS_Linux</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a47593c47a7e5af86555000f16f3e140e">BS_Mozilla</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a791f92a5bb45f402345d9c92669a02a6">BS_Stroustrup</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a7916b04cf2c230741a0f9d7c18fd86ff">BS_Allman</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a475d68c91e641fcea210d216fafddb57">BS_Whitesmiths</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7aba9d6211d1102561c47c7c503c866e00">BS_GNU</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7a9e4e3f5416dfb66c84e061f00ba80339">BS_WebKit</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7ab88e9ff5c5c751874ff5ebb85f5bff0a">BS_Custom</a>
<br />
 }</td></tr>
<tr class="memdesc:a931e5c3eb76618e18dfdcff4677d98d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to attach braces to their surrounding context.  <a href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7">More...</a><br /></td></tr>
<tr class="separator:a931e5c3eb76618e18dfdcff4677d98d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3afcf7e5f9283420a641641e1d449d7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7">BreakBeforeConceptDeclarationsStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7aa9515259259e80421c6734ffd4e410de">BBCDS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7a7799d7006881adc1f084ab98ce2f2a9a">BBCDS_Allowed</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7addc77038584b1de1ec6c647c7a9c49b5">BBCDS_Always</a>
 }</td></tr>
<tr class="memdesc:aa3afcf7e5f9283420a641641e1d449d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break before concept declarations.  <a href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7">More...</a><br /></td></tr>
<tr class="separator:aa3afcf7e5f9283420a641641e1d449d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a1ef53a5e87b6bfecc81141f250d98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98">BreakBeforeInlineASMColonStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98aa019fbaee682d2c67fff81bece6d7266">BBIAS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98a38a97a050d5f995cc74cab76e8c0b9cc">BBIAS_OnlyMultiline</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98a0997d42789ec9f24c2b4eb4e1b764ec7">BBIAS_Always</a>
 }</td></tr>
<tr class="memdesc:a47a1ef53a5e87b6bfecc81141f250d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break ASM parameters.  <a href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98">More...</a><br /></td></tr>
<tr class="separator:a47a1ef53a5e87b6bfecc81141f250d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d560a46760acc52913885971cd50790"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790">BreakConstructorInitializersStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790adf0f16c8dd6847ba88d88982b7747764">BCIS_BeforeColon</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790ae824b840b6e16d8ec3f8d2510a95ce18">BCIS_BeforeComma</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790a3a3a0499c51e4ee5ba592ac10fad4c0f">BCIS_AfterColon</a>
 }</td></tr>
<tr class="memdesc:a2d560a46760acc52913885971cd50790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break initializers.  <a href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790">More...</a><br /></td></tr>
<tr class="separator:a2d560a46760acc52913885971cd50790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbc9f42236eefecf84f381fedf1fa98"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98">BreakInheritanceListStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98a6b7874b172bd466d534a7d91228259f3">BILS_BeforeColon</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98a6dd5fa85b18b8b065bf338ad633b3f0d">BILS_BeforeComma</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98a427999218a4aae73d51dbb8e4c322a7d">BILS_AfterColon</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98a4c6e599af52e47842b5bc9464f533503">BILS_AfterComma</a>
 }</td></tr>
<tr class="memdesc:a7bbc9f42236eefecf84f381fedf1fa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to break inheritance list.  <a href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98">More...</a><br /></td></tr>
<tr class="separator:a7bbc9f42236eefecf84f381fedf1fa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd49000e263fa5f5ebcd7a490a108422"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422">EmptyLineAfterAccessModifierStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422a7ccd6a24affb7af9940f3d263f22bfc1">ELAAMS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422ac023d36aed05144c42e8ea358a58244d">ELAAMS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422a4d550afebd682ab7aa2b3dd5e8f81b63">ELAAMS_Always</a>
 }</td></tr>
<tr class="memdesc:abd49000e263fa5f5ebcd7a490a108422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for empty line after access modifiers.  <a href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422">More...</a><br /></td></tr>
<tr class="separator:abd49000e263fa5f5ebcd7a490a108422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c08778fc0e59e3f1f2888da08f854d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5">EmptyLineBeforeAccessModifierStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5a66ee6e5192a7a21da3f06c8ff93e2618">ELBAMS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5ab53e2520a121e8a22fbbe9199bfd227c">ELBAMS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5a5bf2bf5683607166542a6ae434767b14">ELBAMS_LogicalBlock</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5a953605f9b5c8c7f90f8edf5d488f8a6e">ELBAMS_Always</a>
 }</td></tr>
<tr class="memdesc:a2c08778fc0e59e3f1f2888da08f854d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different styles for empty line before access modifiers.  <a href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5">More...</a><br /></td></tr>
<tr class="separator:a2c08778fc0e59e3f1f2888da08f854d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db12bb7ed75faac357b59e0a34a08f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6">IndentExternBlockStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6a4c263042111cd04992d8100039f151e5">IEBS_AfterExternBlock</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6ad1388b96f5ca4596c51625ddb27c78f7">IEBS_NoIndent</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6a842a2f317f26f0f291d4c927338ba71d">IEBS_Indent</a>
 }</td></tr>
<tr class="memdesc:a2db12bb7ed75faac357b59e0a34a08f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indents extern blocks.  <a href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6">More...</a><br /></td></tr>
<tr class="separator:a2db12bb7ed75faac357b59e0a34a08f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ffe13e89a74f5faa3b1f13f4dd6393"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393">PPDirectiveIndentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393aad83c8f8d2db21b2ec7ec3e986a8fa20">PPDIS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393abc42abccfa3abcef78d9efbce29d6660">PPDIS_AfterHash</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393a9ff077700ecb94600341cb365bb07780">PPDIS_BeforeHash</a>
 }</td></tr>
<tr class="memdesc:a48ffe13e89a74f5faa3b1f13f4dd6393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for indenting preprocessor directives.  <a href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393">More...</a><br /></td></tr>
<tr class="separator:a48ffe13e89a74f5faa3b1f13f4dd6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c259c49568c00e32091c1e1ff2c0f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9">TrailingCommaStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9ac7967c60d08348f0e552f3216aa4e93c">TCS_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9a4bb8aed37b78787d100031827353d8a6">TCS_Wrapped</a>
 }</td></tr>
<tr class="memdesc:a20c259c49568c00e32091c1e1ff2c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style of inserting trailing commas into container literals.  <a href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9">More...</a><br /></td></tr>
<tr class="separator:a20c259c49568c00e32091c1e1ff2c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daad6d27cb88ae2796e2603faef4131"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131">JavaScriptQuoteStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131aa0c94ef85bf0bb8d2611321e196eef21">JSQS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131a4793f6a583579bdc9f7b71314b2e56a0">JSQS_Single</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131a25666015392debaeddb9aa45db85ad88">JSQS_Double</a>
 }</td></tr>
<tr class="memdesc:a8daad6d27cb88ae2796e2603faef4131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quotation styles for JavaScript strings.  <a href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131">More...</a><br /></td></tr>
<tr class="separator:a8daad6d27cb88ae2796e2603faef4131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa34a2ee0f9c4f37aa0823ee37a1ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ff">LambdaBodyIndentationKind</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ffab07c5425730a3c292f6f7add6c641afa">LBI_Signature</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ffa32326fefff5993f586320a7159ea52f2">LBI_OuterScope</a>
 }</td></tr>
<tr class="memdesc:a49fa34a2ee0f9c4f37aa0823ee37a1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indentation logic for lambda bodies.  <a href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ff">More...</a><br /></td></tr>
<tr class="separator:a49fa34a2ee0f9c4f37aa0823ee37a1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3e163ea545132563cad08dc8598e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">LanguageKind</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6a4968cb40f73594906451261a928e4a30">LK_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6a7a36eddae7a21dcff4e1e24e7c1fb977">LK_Cpp</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6a29ee42e9cfaf8f4f0419b16e595ad61c">LK_CSharp</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6a6475e29252ad0cc07fc1311f4902f32f">LK_Java</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6a910850fd7f356fec458c6d3e89fa9549">LK_JavaScript</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6ab1e0175f4b4ffe62194e32abec987f61">LK_Json</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6aa001fec3f664464ef941c266d2820d6c">LK_ObjC</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6aa9fa032dac725538adef82b61c8f345f">LK_Proto</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6aa7353f60b0884372b03707da8fa0d9f2">LK_TableGen</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6ac721680ad8ad0076ab751a91868130f6">LK_TextProto</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6aa73358ab961ab618376ee563ef3b5632">LK_Verilog</a>
<br />
 }</td></tr>
<tr class="memdesc:a06e3e163ea545132563cad08dc8598e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported languages.  <a href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">More...</a><br /></td></tr>
<tr class="separator:a06e3e163ea545132563cad08dc8598e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35260df344afa7ec64c80750d37b3a5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5d">LineEndingStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5dae7aa50330928f7aece19664149fb307f">LE_LF</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5da580bc0b6ebaffb775a16e5f02a567e57">LE_CRLF</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5da2a380ca243d10c5f358b9665663e146d">LE_DeriveLF</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5da966cf51f0637b0f6223106a5a214f175">LE_DeriveCRLF</a>
 }</td></tr>
<tr class="memdesc:a35260df344afa7ec64c80750d37b3a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line ending style.  <a href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5d">More...</a><br /></td></tr>
<tr class="separator:a35260df344afa7ec64c80750d37b3a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26cac0d904a16d43ac52c049d9db622"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622">NamespaceIndentationKind</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622a3c968534afc99a13a8b0bcbe43f9cc63">NI_None</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622af27aaa38ae3f4444e11ed3395f2152e4">NI_Inner</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622a621fbb46f7cdc63d335e071054b18f1b">NI_All</a>
 }</td></tr>
<tr class="memdesc:ae26cac0d904a16d43ac52c049d9db622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to indent namespace contents.  <a href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622">More...</a><br /></td></tr>
<tr class="separator:ae26cac0d904a16d43ac52c049d9db622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a9eec5aa0372a3e5094d1011675d23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23">PackConstructorInitializersStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23a3671df39a9e176b1ddcee19d1d079c37">PCIS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23a933db01522cbf817b01f24a9aba70242">PCIS_BinPack</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23a36a7e09cb0a90f38ea99866963abec1f">PCIS_CurrentLine</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23ad588a2a138cc6364a2793f85018ec84d">PCIS_NextLine</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23a326204f09e336ba5e01e687f3c452216">PCIS_NextLineOnly</a>
<br />
 }</td></tr>
<tr class="memdesc:a73a9eec5aa0372a3e5094d1011675d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to try to fit all constructor initializers on a line.  <a href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23">More...</a><br /></td></tr>
<tr class="separator:a73a9eec5aa0372a3e5094d1011675d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add72d7e5bd931e683d671940ee98a172"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172">PointerAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172a569e57995aaf6ad19c46e6309ad6483a">PAS_Left</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172ad0269239c6db56f256a9d8a06bddf515">PAS_Right</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172a91002b9a99d1801057afa45a3a4609be">PAS_Middle</a>
 }</td></tr>
<tr class="memdesc:add72d7e5bd931e683d671940ee98a172"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>&amp;</code>, <code>&amp;&amp;</code> and <code>*</code> alignment style.  <a href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172">More...</a><br /></td></tr>
<tr class="separator:add72d7e5bd931e683d671940ee98a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1153efd05d9632bcc0f364abfcb22ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22ef">QualifierAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22efacac34201f377739f795951365c036f13">QAS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22efac0720914b91f396d5b2f5d365e611e5a">QAS_Left</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22efa3adf2ad904c4a3bbaf664f0da8bbe42e">QAS_Right</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22efa891e29e9f0914c8735cb94aca1efcace">QAS_Custom</a>
 }</td></tr>
<tr class="memdesc:af1153efd05d9632bcc0f364abfcb22ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different specifiers and qualifiers alignment styles.  <a href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22ef">More...</a><br /></td></tr>
<tr class="separator:af1153efd05d9632bcc0f364abfcb22ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae910a8281f74d90f22d702e35f3c0ef6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6">ReferenceAlignmentStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6ab931a16f1b9649a86813bd19aa870198">RAS_Pointer</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6ab90c8bc8fee7c3a3af7b3d9be65577c4">RAS_Left</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6a1a855682c243f7788a8347891a23136f">RAS_Right</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6ae6eaa1844ac64e0dea1db42eacf86782">RAS_Middle</a>
 }</td></tr>
<tr class="memdesc:ae910a8281f74d90f22d702e35f3c0ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>&amp;</code> and <code>&amp;&amp;</code> alignment style.  <a href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6">More...</a><br /></td></tr>
<tr class="separator:ae910a8281f74d90f22d702e35f3c0ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fc6504442bd361923176076e427425"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425">RemoveParenthesesStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425a10d32c808feea39a9afb644d2c1b5afa">RPS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425a54e35c9df9f3c88ef60b78b0014bdf22">RPS_MultipleParentheses</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425a3a45e975fc83a39aad1fb8403433bd44">RPS_ReturnStatement</a>
 }</td></tr>
<tr class="memdesc:ad2fc6504442bd361923176076e427425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of redundant parentheses to remove.  <a href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425">More...</a><br /></td></tr>
<tr class="separator:ad2fc6504442bd361923176076e427425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28e9d93da683fcceb043d62fc76f34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34">RequiresClausePositionStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34a8e5b51ba9c091dc77a74fa5a48220af4">RCPS_OwnLine</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34a92dcc7226b3c9fc3e8abfee36de8cdc3">RCPS_WithPreceding</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34ae92346715573a8fd1f93219ca1f2193b">RCPS_WithFollowing</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34aabf0cfd6d1aeedd7babcb2cd0f4c61a5">RCPS_SingleLine</a>
 }</td></tr>
<tr class="memdesc:a8a28e9d93da683fcceb043d62fc76f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible positions for the requires clause.  <a href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34">More...</a><br /></td></tr>
<tr class="separator:a8a28e9d93da683fcceb043d62fc76f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe26352e2222d3d490fde5a0effead7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7">RequiresExpressionIndentationKind</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7a98a487af32aa678e779a149fcf64c475">REI_OuterScope</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7a8d1d021a41ec6b0a9bdc1517cc2822cb">REI_Keyword</a>
 }</td></tr>
<tr class="memdesc:a9fe26352e2222d3d490fde5a0effead7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indentation logic for requires expression bodies.  <a href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7">More...</a><br /></td></tr>
<tr class="separator:a9fe26352e2222d3d490fde5a0effead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152054fb26dfc5f9345e538a61f98f65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65">SeparateDefinitionStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65aa311154f3d996d786ad49d5f9a9a4a35">SDS_Leave</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65a2c4241464a33caedad314b610464a662">SDS_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65a216319c547f678440cdb834274a8916b">SDS_Never</a>
 }</td></tr>
<tr class="memdesc:a152054fb26dfc5f9345e538a61f98f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The style if definition blocks should be separated.  <a href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65">More...</a><br /></td></tr>
<tr class="separator:a152054fb26dfc5f9345e538a61f98f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272ef822f048b5121b17f9b64c0127de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127de">SortIncludesOptions</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127dea3081d16d65eb658875a56acb08d958a0">SI_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127dea7ac9ec62c79aeaee4d12e50b37c99238">SI_CaseSensitive</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127dea89083f41e68527d1b9a0fb14c6f051f9">SI_CaseInsensitive</a>
 }</td></tr>
<tr class="memdesc:a272ef822f048b5121b17f9b64c0127de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include sorting options.  <a href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127de">More...</a><br /></td></tr>
<tr class="separator:a272ef822f048b5121b17f9b64c0127de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac22b24b73abd5283a29a49e5129c4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4e">SortJavaStaticImportOptions</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4ea569fc8b96ee665516ad4b4f47d002734">SJSIO_Before</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4ead9177c5c6cfc492c19c155b61a27680d">SJSIO_After</a>
 }</td></tr>
<tr class="memdesc:a1ac22b24b73abd5283a29a49e5129c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position for Java Static imports.  <a href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4e">More...</a><br /></td></tr>
<tr class="separator:a1ac22b24b73abd5283a29a49e5129c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecae06d9d6888f0feb23d55f169fbfe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfe">SortUsingDeclarationsOptions</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfeafd979b73dfa3c93942cddcaba682eb9a">SUD_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfea91d40ed5f91a1828185755bf868099ae">SUD_Lexicographic</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfea7ec1089b092225113d2aee2421d24990">SUD_LexicographicNumeric</a>
 }</td></tr>
<tr class="memdesc:acecae06d9d6888f0feb23d55f169fbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using declaration sorting options.  <a href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfe">More...</a><br /></td></tr>
<tr class="separator:acecae06d9d6888f0feb23d55f169fbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae0b9d459d2a3e76e7595a0d50ad3b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9">SpaceAroundPointerQualifiersStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9a8906f327373cd54eb8d28a6344824689">SAPQ_Default</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9ac6008e39203a65846135339c4ccdcad4">SAPQ_Before</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9a4c13d03a770cd16c5c7c872c96784697">SAPQ_After</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9a902a96d58a74fc8cb4464f65e6ad3ae9">SAPQ_Both</a>
 }</td></tr>
<tr class="memdesc:abae0b9d459d2a3e76e7595a0d50ad3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to put a space before opening parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9">More...</a><br /></td></tr>
<tr class="separator:abae0b9d459d2a3e76e7595a0d50ad3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7112fd8006c061310b6a28e404b73fd9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9">SpaceBeforeParensStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9a25690e04257958b8eddbacce355bdcd9">SBPO_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9ac5f2bdc66207290ce3737624d6733528">SBPO_ControlStatements</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9aa2920582e18496c5d60967e5c047a54d">SBPO_ControlStatementsExceptControlMacros</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9a8b177b28e0fab8d4ec2cefb5f62ad7bc">SBPO_NonEmptyParentheses</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9af93a26544e3347e21b68dfe7d8601fea">SBPO_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9a5672406c509769e0d4e0f8650a4deded">SBPO_Custom</a>
<br />
 }</td></tr>
<tr class="memdesc:a7112fd8006c061310b6a28e404b73fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to put a space before opening parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9">More...</a><br /></td></tr>
<tr class="separator:a7112fd8006c061310b6a28e404b73fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf8ff95ca21cdc0868d2b226b6d8917"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917">SpacesInAnglesStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917a2cc9ed6752f8b7413053985a6cf5cb0e">SIAS_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917a3777a4f93a838fc9638823f7370b7c4f">SIAS_Always</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917aa41d3c554910d2dfee9c5a5212559c72">SIAS_Leave</a>
 }</td></tr>
<tr class="memdesc:acaf8ff95ca21cdc0868d2b226b6d8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Styles for adding spacing after <code>&lt;</code> and before <code>&gt;</code> in template argument lists.  <a href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917">More...</a><br /></td></tr>
<tr class="separator:acaf8ff95ca21cdc0868d2b226b6d8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a2fb2e5d055e7858aca7bd99c0fe4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4">SpacesInParensStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4a1690397be4b132cbe044f6c95e836a74">SIPO_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4a0ce73ed05edf0d60ae86250adb3eb897">SIPO_Custom</a>
 }</td></tr>
<tr class="memdesc:a404a2fb2e5d055e7858aca7bd99c0fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to put a space before opening and closing parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4">More...</a><br /></td></tr>
<tr class="separator:a404a2fb2e5d055e7858aca7bd99c0fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d27b8311dfb0b882b264771cbb33cb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8">LanguageStandard</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8ad690e77384ec0503c47e9f4e238a58a5">LS_Cpp03</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8ac2adca34064745a7171f70ba7e600095">LS_Cpp11</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8adee7873afb157b20eab594d2939f5de7">LS_Cpp14</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8a0cd9ac9d8fa729b14ebe95b434cc096c">LS_Cpp17</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8ae4210fe562c7220729f098953cfb38e2">LS_Cpp20</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8a8379bde7f910bb6d1d40b85ef699c467">LS_Latest</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8ad54fa310d0a1bb4f4893fab021db1eaf">LS_Auto</a>
<br />
 }</td></tr>
<tr class="memdesc:a8d27b8311dfb0b882b264771cbb33cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported language standards for parsing and formatting C++ constructs.  <a href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8">More...</a><br /></td></tr>
<tr class="separator:a8d27b8311dfb0b882b264771cbb33cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8738b2eed1291b5c9984003dd5a306f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6">DAGArgStyle</a> : int8_t { <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6a71fe0df8e05821437af50a99ec275b5d">DAS_DontBreak</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6a0638c6b7b3661783fa196fd5c96751c3">DAS_BreakElements</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6afe6e8fccc240026e67dc75af000fa17f">DAS_BreakAll</a>
 }</td></tr>
<tr class="memdesc:a8738b2eed1291b5c9984003dd5a306f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to control the format inside TableGen DAGArg.  <a href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6">More...</a><br /></td></tr>
<tr class="separator:a8738b2eed1291b5c9984003dd5a306f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cb5a1ecf0fa97b2496c35ab59619c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619c">UseTabStyle</a> : int8_t { <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619cafd12c70df29dd36bbb5971672f08bd12">UT_Never</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619ca98348a0ed9ac4d191ce1bb3cb3e541fb">UT_ForIndentation</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619ca74a5d824d84616bdc37b42b2b58d2bd2">UT_ForContinuationAndIndentation</a>
, <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619ca43e18d76b2fbadc8856468ead948ac63">UT_AlignWithSpaces</a>
, <br />
&#160;&#160;<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619cac5fc60e5d09b7daadafd5e12d266d30a">UT_Always</a>
<br />
 }</td></tr>
<tr class="memdesc:a020cb5a1ecf0fa97b2496c35ab59619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is <b>deprecated</b>.  <a href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619c">More...</a><br /></td></tr>
<tr class="separator:a020cb5a1ecf0fa97b2496c35ab59619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a290942979cd05cb38b9aece3972fd53f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a290942979cd05cb38b9aece3972fd53f">isCpp</a> () const</td></tr>
<tr class="separator:a290942979cd05cb38b9aece3972fd53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c578e3dc0b6dfcca89a3f5f261ee080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7c578e3dc0b6dfcca89a3f5f261ee080">isCSharp</a> () const</td></tr>
<tr class="separator:a7c578e3dc0b6dfcca89a3f5f261ee080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477a73fe8749386a6dba865191b8ede0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a477a73fe8749386a6dba865191b8ede0">isJson</a> () const</td></tr>
<tr class="separator:a477a73fe8749386a6dba865191b8ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67aa2db9f9578e227305b70ec42eb9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab67aa2db9f9578e227305b70ec42eb9a">isJavaScript</a> () const</td></tr>
<tr class="separator:ab67aa2db9f9578e227305b70ec42eb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad02ccc6b28e8dffe00d83d7341676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab2ad02ccc6b28e8dffe00d83d7341676">isVerilog</a> () const</td></tr>
<tr class="separator:ab2ad02ccc6b28e8dffe00d83d7341676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaeaf97eabc19c4045ecc987b2283f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aaaaeaf97eabc19c4045ecc987b2283f1">isProto</a> () const</td></tr>
<tr class="separator:aaaaeaf97eabc19c4045ecc987b2283f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065037978abb87672c3cfa553193d175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a065037978abb87672c3cfa553193d175">isTableGen</a> () const</td></tr>
<tr class="separator:a065037978abb87672c3cfa553193d175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b470c3ac3bd72ea02de155cd2ef32c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8b470c3ac3bd72ea02de155cd2ef32c4">operator==</a> (const <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &amp;R) const</td></tr>
<tr class="separator:a8b470c3ac3bd72ea02de155cd2ef32c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999265cdeff66d190d55b027eb9a027"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5999265cdeff66d190d55b027eb9a027">GetLanguageStyle</a> (<a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">LanguageKind</a> <a class="el" href="namespaceclang.html#a6f904bf7056cbce941d51eeebe3bfd5c">Language</a>) const</td></tr>
<tr class="separator:a5999265cdeff66d190d55b027eb9a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a471da659034079173f5a2aaa04aedb03"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structclang_1_1format_1_1FormatStyle_1_1FormatStyleSet.html">FormatStyleSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a471da659034079173f5a2aaa04aedb03">BuildStyleSetFromConfiguration</a> (const <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &amp;MainStyle, const std::vector&lt; <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &gt; &amp;ConfigurationStyles)</td></tr>
<tr class="separator:a471da659034079173f5a2aaa04aedb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae6e2a44d24d6b6651fb6750531daab0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae6e2a44d24d6b6651fb6750531daab0a">InheritsParentConfig</a></td></tr>
<tr class="separator:ae6e2a44d24d6b6651fb6750531daab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534fd6ed422571ccff12fc5864b49bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a534fd6ed422571ccff12fc5864b49bc3">AccessModifierOffset</a></td></tr>
<tr class="memdesc:a534fd6ed422571ccff12fc5864b49bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extra indent or outdent of access modifiers, e.g.  <a href="structclang_1_1format_1_1FormatStyle.html#a534fd6ed422571ccff12fc5864b49bc3">More...</a><br /></td></tr>
<tr class="separator:a534fd6ed422571ccff12fc5864b49bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa920e43c7189e9b90300239d276de797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060">BracketAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa920e43c7189e9b90300239d276de797">AlignAfterOpenBracket</a></td></tr>
<tr class="memdesc:aa920e43c7189e9b90300239d276de797"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, horizontally aligns arguments after an open bracket.  <a href="structclang_1_1format_1_1FormatStyle.html#aa920e43c7189e9b90300239d276de797">More...</a><br /></td></tr>
<tr class="separator:aa920e43c7189e9b90300239d276de797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dbc256848c7bed31bd6173014e8ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1">ArrayInitializerAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae1dbc256848c7bed31bd6173014e8ab2">AlignArrayOfStructures</a></td></tr>
<tr class="memdesc:ae1dbc256848c7bed31bd6173014e8ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">if not <code>None</code>, when using initialization for an array of structs aligns the fields into columns.  <a href="structclang_1_1format_1_1FormatStyle.html#ae1dbc256848c7bed31bd6173014e8ab2">More...</a><br /></td></tr>
<tr class="separator:ae1dbc256848c7bed31bd6173014e8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b5f84cb5fc804f5596cefc6937e0d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac9b5f84cb5fc804f5596cefc6937e0d5">AlignConsecutiveMacros</a></td></tr>
<tr class="memdesc:ac9b5f84cb5fc804f5596cefc6937e0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive macro definitions.  <a href="structclang_1_1format_1_1FormatStyle.html#ac9b5f84cb5fc804f5596cefc6937e0d5">More...</a><br /></td></tr>
<tr class="separator:ac9b5f84cb5fc804f5596cefc6937e0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa62bac28235d2d852aa6b1c74e2d80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acfa62bac28235d2d852aa6b1c74e2d80">AlignConsecutiveAssignments</a></td></tr>
<tr class="memdesc:acfa62bac28235d2d852aa6b1c74e2d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive assignments.  <a href="structclang_1_1format_1_1FormatStyle.html#acfa62bac28235d2d852aa6b1c74e2d80">More...</a><br /></td></tr>
<tr class="separator:acfa62bac28235d2d852aa6b1c74e2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df4cf092a1d50fc6096465195aebba3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8df4cf092a1d50fc6096465195aebba3">AlignConsecutiveBitFields</a></td></tr>
<tr class="memdesc:a8df4cf092a1d50fc6096465195aebba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive bit fields.  <a href="structclang_1_1format_1_1FormatStyle.html#a8df4cf092a1d50fc6096465195aebba3">More...</a><br /></td></tr>
<tr class="separator:a8df4cf092a1d50fc6096465195aebba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9927d5d1e4da6fb9c65a7d1a25a791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8e9927d5d1e4da6fb9c65a7d1a25a791">AlignConsecutiveDeclarations</a></td></tr>
<tr class="memdesc:a8e9927d5d1e4da6fb9c65a7d1a25a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive declarations.  <a href="structclang_1_1format_1_1FormatStyle.html#a8e9927d5d1e4da6fb9c65a7d1a25a791">More...</a><br /></td></tr>
<tr class="separator:a8e9927d5d1e4da6fb9c65a7d1a25a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc26b335162d910bfbad3f9569dd27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1ShortCaseStatementsAlignmentStyle.html">ShortCaseStatementsAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab2cc26b335162d910bfbad3f9569dd27">AlignConsecutiveShortCaseStatements</a></td></tr>
<tr class="memdesc:ab2cc26b335162d910bfbad3f9569dd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive short case labels.  <a href="structclang_1_1format_1_1FormatStyle.html#ab2cc26b335162d910bfbad3f9569dd27">More...</a><br /></td></tr>
<tr class="separator:ab2cc26b335162d910bfbad3f9569dd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3889e3d68b1eec733bb6c0cc60d832cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3889e3d68b1eec733bb6c0cc60d832cc">AlignConsecutiveTableGenBreakingDAGArgColons</a></td></tr>
<tr class="memdesc:a3889e3d68b1eec733bb6c0cc60d832cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive TableGen DAGArg operator colons.  <a href="structclang_1_1format_1_1FormatStyle.html#a3889e3d68b1eec733bb6c0cc60d832cc">More...</a><br /></td></tr>
<tr class="separator:a3889e3d68b1eec733bb6c0cc60d832cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f3dde678b43bf25c4f4abb816c7ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa9f3dde678b43bf25c4f4abb816c7ee0">AlignConsecutiveTableGenCondOperatorColons</a></td></tr>
<tr class="memdesc:aa9f3dde678b43bf25c4f4abb816c7ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive TableGen cond operator colons.  <a href="structclang_1_1format_1_1FormatStyle.html#aa9f3dde678b43bf25c4f4abb816c7ee0">More...</a><br /></td></tr>
<tr class="separator:aa9f3dde678b43bf25c4f4abb816c7ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69974864c61d994bcb5992a7391d4f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a69974864c61d994bcb5992a7391d4f42">AlignConsecutiveTableGenDefinitionColons</a></td></tr>
<tr class="memdesc:a69974864c61d994bcb5992a7391d4f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style of aligning consecutive TableGen definition colons.  <a href="structclang_1_1format_1_1FormatStyle.html#a69974864c61d994bcb5992a7391d4f42">More...</a><br /></td></tr>
<tr class="separator:a69974864c61d994bcb5992a7391d4f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3934e5d2eaf82b086b87ed2f623934e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3">EscapedNewlineAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab3934e5d2eaf82b086b87ed2f623934e">AlignEscapedNewlines</a></td></tr>
<tr class="memdesc:ab3934e5d2eaf82b086b87ed2f623934e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for aligning backslashes in escaped newlines.  <a href="structclang_1_1format_1_1FormatStyle.html#ab3934e5d2eaf82b086b87ed2f623934e">More...</a><br /></td></tr>
<tr class="separator:ab3934e5d2eaf82b086b87ed2f623934e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610668e19a4d6e7813157686803587a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6">OperandAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a610668e19a4d6e7813157686803587a9">AlignOperands</a></td></tr>
<tr class="memdesc:a610668e19a4d6e7813157686803587a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, horizontally align operands of binary and ternary expressions.  <a href="structclang_1_1format_1_1FormatStyle.html#a610668e19a4d6e7813157686803587a9">More...</a><br /></td></tr>
<tr class="separator:a610668e19a4d6e7813157686803587a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e80d6e4a1c2b00d438abeaa8dd13bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1TrailingCommentsAlignmentStyle.html">TrailingCommentsAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac0e80d6e4a1c2b00d438abeaa8dd13bc">AlignTrailingComments</a></td></tr>
<tr class="memdesc:ac0e80d6e4a1c2b00d438abeaa8dd13bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of trailing comments.  <a href="structclang_1_1format_1_1FormatStyle.html#ac0e80d6e4a1c2b00d438abeaa8dd13bc">More...</a><br /></td></tr>
<tr class="separator:ac0e80d6e4a1c2b00d438abeaa8dd13bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b5b18225adbe632496fd2b927d4296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae4b5b18225adbe632496fd2b927d4296">AllowAllArgumentsOnNextLine</a></td></tr>
<tr class="memdesc:ae4b5b18225adbe632496fd2b927d4296"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a function call or braced initializer list doesn't fit on a line, allow putting all arguments onto the next line, even if <code>BinPackArguments</code> is <code>false</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#ae4b5b18225adbe632496fd2b927d4296">More...</a><br /></td></tr>
<tr class="separator:ae4b5b18225adbe632496fd2b927d4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eeb36c958dfb1e4f15876c82cef2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa6eeb36c958dfb1e4f15876c82cef2ce">AllowAllParametersOfDeclarationOnNextLine</a></td></tr>
<tr class="memdesc:aa6eeb36c958dfb1e4f15876c82cef2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is <b>deprecated</b>.  <a href="structclang_1_1format_1_1FormatStyle.html#aa6eeb36c958dfb1e4f15876c82cef2ce">More...</a><br /></td></tr>
<tr class="separator:aa6eeb36c958dfb1e4f15876c82cef2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da36904d4175e98433ea03b8756848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cba">BreakBeforeNoexceptSpecifierStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad8da36904d4175e98433ea03b8756848">AllowBreakBeforeNoexceptSpecifier</a></td></tr>
<tr class="memdesc:ad8da36904d4175e98433ea03b8756848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls if there could be a line break before a <code>noexcept</code> specifier.  <a href="structclang_1_1format_1_1FormatStyle.html#ad8da36904d4175e98433ea03b8756848">More...</a><br /></td></tr>
<tr class="separator:ad8da36904d4175e98433ea03b8756848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35813d4f6867282560971273b02a966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227">ShortBlockStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae35813d4f6867282560971273b02a966">AllowShortBlocksOnASingleLine</a></td></tr>
<tr class="memdesc:ae35813d4f6867282560971273b02a966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependent on the value, <code>while (true) { continue; }</code> can be put on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#ae35813d4f6867282560971273b02a966">More...</a><br /></td></tr>
<tr class="separator:ae35813d4f6867282560971273b02a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35e1a6d4a13246530cd1760e78cf84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a4e35e1a6d4a13246530cd1760e78cf84">AllowShortCaseLabelsOnASingleLine</a></td></tr>
<tr class="memdesc:a4e35e1a6d4a13246530cd1760e78cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, short case labels will be contracted to a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#a4e35e1a6d4a13246530cd1760e78cf84">More...</a><br /></td></tr>
<tr class="separator:a4e35e1a6d4a13246530cd1760e78cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d44a5e918725c77a166607a2086ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a64d44a5e918725c77a166607a2086ecf">AllowShortCompoundRequirementOnASingleLine</a></td></tr>
<tr class="memdesc:a64d44a5e918725c77a166607a2086ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow short compound requirement on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#a64d44a5e918725c77a166607a2086ecf">More...</a><br /></td></tr>
<tr class="separator:a64d44a5e918725c77a166607a2086ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f83d1e629eaf3312db75a57e42782d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a53f83d1e629eaf3312db75a57e42782d">AllowShortEnumsOnASingleLine</a></td></tr>
<tr class="memdesc:a53f83d1e629eaf3312db75a57e42782d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow short enums on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#a53f83d1e629eaf3312db75a57e42782d">More...</a><br /></td></tr>
<tr class="separator:a53f83d1e629eaf3312db75a57e42782d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c557926bf65d7d94806f5e4001239d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7b">ShortFunctionStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae3c557926bf65d7d94806f5e4001239d">AllowShortFunctionsOnASingleLine</a></td></tr>
<tr class="memdesc:ae3c557926bf65d7d94806f5e4001239d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependent on the value, <code>int f() { return 0; }</code> can be put on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#ae3c557926bf65d7d94806f5e4001239d">More...</a><br /></td></tr>
<tr class="separator:ae3c557926bf65d7d94806f5e4001239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad268e2b06c2521b80b2b36bf0ce99fd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5">ShortIfStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad268e2b06c2521b80b2b36bf0ce99fd8">AllowShortIfStatementsOnASingleLine</a></td></tr>
<tr class="memdesc:ad268e2b06c2521b80b2b36bf0ce99fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependent on the value, <code>if (a) return;</code> can be put on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#ad268e2b06c2521b80b2b36bf0ce99fd8">More...</a><br /></td></tr>
<tr class="separator:ad268e2b06c2521b80b2b36bf0ce99fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94289f5cf7855d4856ecd6861f1f0a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065">ShortLambdaStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a94289f5cf7855d4856ecd6861f1f0a66">AllowShortLambdasOnASingleLine</a></td></tr>
<tr class="memdesc:a94289f5cf7855d4856ecd6861f1f0a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependent on the value, <code>auto lambda []() { return 0; }</code> can be put on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#a94289f5cf7855d4856ecd6861f1f0a66">More...</a><br /></td></tr>
<tr class="separator:a94289f5cf7855d4856ecd6861f1f0a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca039b50313d5b5de5207a8c9b2dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a52ca039b50313d5b5de5207a8c9b2dfa">AllowShortLoopsOnASingleLine</a></td></tr>
<tr class="memdesc:a52ca039b50313d5b5de5207a8c9b2dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, <code>while (true) continue;</code> can be put on a single line.  <a href="structclang_1_1format_1_1FormatStyle.html#a52ca039b50313d5b5de5207a8c9b2dfa">More...</a><br /></td></tr>
<tr class="separator:a52ca039b50313d5b5de5207a8c9b2dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b34f83ffd78f27d2a7dd21fa4fe223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181">DefinitionReturnTypeBreakingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a90b34f83ffd78f27d2a7dd21fa4fe223">AlwaysBreakAfterDefinitionReturnType</a></td></tr>
<tr class="memdesc:a90b34f83ffd78f27d2a7dd21fa4fe223"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function definition return type breaking style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a90b34f83ffd78f27d2a7dd21fa4fe223">More...</a><br /></td></tr>
<tr class="separator:a90b34f83ffd78f27d2a7dd21fa4fe223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a80b6fa3e1785c7c59becbc621212d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a03a80b6fa3e1785c7c59becbc621212d">AlwaysBreakBeforeMultilineStrings</a></td></tr>
<tr class="memdesc:a03a80b6fa3e1785c7c59becbc621212d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is renamed to <code>BreakAfterReturnType</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a03a80b6fa3e1785c7c59becbc621212d">More...</a><br /></td></tr>
<tr class="separator:a03a80b6fa3e1785c7c59becbc621212d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1344658016b418e7d3a8d915c3304fa7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1344658016b418e7d3a8d915c3304fa7">AttributeMacros</a></td></tr>
<tr class="memdesc:a1344658016b418e7d3a8d915c3304fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is renamed to <code>BreakTemplateDeclarations</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a1344658016b418e7d3a8d915c3304fa7">More...</a><br /></td></tr>
<tr class="separator:a1344658016b418e7d3a8d915c3304fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94112c67cd7e8e4f69ff6edb9b17fd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a94112c67cd7e8e4f69ff6edb9b17fd59">BinPackArguments</a></td></tr>
<tr class="memdesc:a94112c67cd7e8e4f69ff6edb9b17fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, a function call's arguments will either be all on the same line or will have one line each.  <a href="structclang_1_1format_1_1FormatStyle.html#a94112c67cd7e8e4f69ff6edb9b17fd59">More...</a><br /></td></tr>
<tr class="separator:a94112c67cd7e8e4f69ff6edb9b17fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861528acbc8f4088e276034ce4dbbe1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a861528acbc8f4088e276034ce4dbbe1b">BinPackParameters</a></td></tr>
<tr class="memdesc:a861528acbc8f4088e276034ce4dbbe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, a function declaration's or function definition's parameters will either all be on the same line or will have one line each.  <a href="structclang_1_1format_1_1FormatStyle.html#a861528acbc8f4088e276034ce4dbbe1b">More...</a><br /></td></tr>
<tr class="separator:a861528acbc8f4088e276034ce4dbbe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6fbb51998b53d831f284c982e74b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4">BitFieldColonSpacingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a29c6fbb51998b53d831f284c982e74b0">BitFieldColonSpacing</a></td></tr>
<tr class="memdesc:a29c6fbb51998b53d831f284c982e74b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BitFieldColonSpacingStyle to use for bitfields.  <a href="structclang_1_1format_1_1FormatStyle.html#a29c6fbb51998b53d831f284c982e74b0">More...</a><br /></td></tr>
<tr class="separator:a29c6fbb51998b53d831f284c982e74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bceb5ed304b784c4b65b9a68212c1c1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5bceb5ed304b784c4b65b9a68212c1c1">BracedInitializerIndentWidth</a></td></tr>
<tr class="memdesc:a5bceb5ed304b784c4b65b9a68212c1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns to use to indent the contents of braced init lists.  <a href="structclang_1_1format_1_1FormatStyle.html#a5bceb5ed304b784c4b65b9a68212c1c1">More...</a><br /></td></tr>
<tr class="separator:a5bceb5ed304b784c4b65b9a68212c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88441d1706049a6098e892dd6e730df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html">BraceWrappingFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac88441d1706049a6098e892dd6e730df">BraceWrapping</a></td></tr>
<tr class="memdesc:ac88441d1706049a6098e892dd6e730df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of individual brace wrapping cases.  <a href="structclang_1_1format_1_1FormatStyle.html#ac88441d1706049a6098e892dd6e730df">More...</a><br /></td></tr>
<tr class="separator:ac88441d1706049a6098e892dd6e730df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047bd610318dd6e2f02497151ca7ec90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a047bd610318dd6e2f02497151ca7ec90">BreakAdjacentStringLiterals</a></td></tr>
<tr class="memdesc:a047bd610318dd6e2f02497151ca7ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break between adjacent string literals.  <a href="structclang_1_1format_1_1FormatStyle.html#a047bd610318dd6e2f02497151ca7ec90">More...</a><br /></td></tr>
<tr class="separator:a047bd610318dd6e2f02497151ca7ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09d889793e2461ec809003aabdfb5bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42a">AttributeBreakingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac09d889793e2461ec809003aabdfb5bb">BreakAfterAttributes</a></td></tr>
<tr class="memdesc:ac09d889793e2461ec809003aabdfb5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break after a group of C++11 attributes before variable or function (including constructor/destructor) declaration/definition names or before control statements, i.e.  <a href="structclang_1_1format_1_1FormatStyle.html#ac09d889793e2461ec809003aabdfb5bb">More...</a><br /></td></tr>
<tr class="separator:ac09d889793e2461ec809003aabdfb5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eed919d54a8731c24e720f8f700d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">ReturnTypeBreakingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a04eed919d54a8731c24e720f8f700d40">BreakAfterReturnType</a></td></tr>
<tr class="memdesc:a04eed919d54a8731c24e720f8f700d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function declaration return type breaking style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a04eed919d54a8731c24e720f8f700d40">More...</a><br /></td></tr>
<tr class="separator:a04eed919d54a8731c24e720f8f700d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a1ef6079c3420b70bdcd547a3b5bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5a9a1ef6079c3420b70bdcd547a3b5bd">BreakArrays</a></td></tr>
<tr class="memdesc:a5a9a1ef6079c3420b70bdcd547a3b5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, clang-format will always break after a Json array <code>[</code> otherwise it will scan until the closing <code>]</code> to determine if it should add newlines between elements (prettier compatible).  <a href="structclang_1_1format_1_1FormatStyle.html#a5a9a1ef6079c3420b70bdcd547a3b5bd">More...</a><br /></td></tr>
<tr class="separator:a5a9a1ef6079c3420b70bdcd547a3b5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e7cc5dc54042fe2cd21fabfd1b4225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934">BinaryOperatorStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a26e7cc5dc54042fe2cd21fabfd1b4225">BreakBeforeBinaryOperators</a></td></tr>
<tr class="memdesc:a26e7cc5dc54042fe2cd21fabfd1b4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">The way to wrap binary operators.  <a href="structclang_1_1format_1_1FormatStyle.html#a26e7cc5dc54042fe2cd21fabfd1b4225">More...</a><br /></td></tr>
<tr class="separator:a26e7cc5dc54042fe2cd21fabfd1b4225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb74cb37f57d469d6760ec09e466647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7">BraceBreakingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bb74cb37f57d469d6760ec09e466647">BreakBeforeBraces</a></td></tr>
<tr class="memdesc:a7bb74cb37f57d469d6760ec09e466647"><td class="mdescLeft">&#160;</td><td class="mdescRight">The brace breaking style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a7bb74cb37f57d469d6760ec09e466647">More...</a><br /></td></tr>
<tr class="separator:a7bb74cb37f57d469d6760ec09e466647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d55b546a66d24cee65141755f71048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7">BreakBeforeConceptDeclarationsStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a30d55b546a66d24cee65141755f71048">BreakBeforeConceptDeclarations</a></td></tr>
<tr class="memdesc:a30d55b546a66d24cee65141755f71048"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept declaration style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a30d55b546a66d24cee65141755f71048">More...</a><br /></td></tr>
<tr class="separator:a30d55b546a66d24cee65141755f71048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e52ec1ebefbfa0a47d014689a6599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98">BreakBeforeInlineASMColonStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a929e52ec1ebefbfa0a47d014689a6599">BreakBeforeInlineASMColon</a></td></tr>
<tr class="memdesc:a929e52ec1ebefbfa0a47d014689a6599"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inline ASM colon style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a929e52ec1ebefbfa0a47d014689a6599">More...</a><br /></td></tr>
<tr class="separator:a929e52ec1ebefbfa0a47d014689a6599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83c3653a76e6e749391f7d3663a8ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af83c3653a76e6e749391f7d3663a8ce5">BreakBeforeTernaryOperators</a></td></tr>
<tr class="memdesc:af83c3653a76e6e749391f7d3663a8ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, ternary operators will be placed after line breaks.  <a href="structclang_1_1format_1_1FormatStyle.html#af83c3653a76e6e749391f7d3663a8ce5">More...</a><br /></td></tr>
<tr class="separator:af83c3653a76e6e749391f7d3663a8ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1d6ad0e075233214fff5e298f432e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790">BreakConstructorInitializersStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6d1d6ad0e075233214fff5e298f432e8">BreakConstructorInitializers</a></td></tr>
<tr class="memdesc:a6d1d6ad0e075233214fff5e298f432e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The break constructor initializers style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a6d1d6ad0e075233214fff5e298f432e8">More...</a><br /></td></tr>
<tr class="separator:a6d1d6ad0e075233214fff5e298f432e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f42df3954dc827999fed609f452f9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9f42df3954dc827999fed609f452f9fb">BreakFunctionDefinitionParameters</a></td></tr>
<tr class="memdesc:a9f42df3954dc827999fed609f452f9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, clang-format will always break before function definition parameters.  <a href="structclang_1_1format_1_1FormatStyle.html#a9f42df3954dc827999fed609f452f9fb">More...</a><br /></td></tr>
<tr class="separator:a9f42df3954dc827999fed609f452f9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad505c244da9a1dc2827726dd409f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5ad505c244da9a1dc2827726dd409f94">BreakAfterJavaFieldAnnotations</a></td></tr>
<tr class="memdesc:a5ad505c244da9a1dc2827726dd409f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break after each annotation on a field in Java files.  <a href="structclang_1_1format_1_1FormatStyle.html#a5ad505c244da9a1dc2827726dd409f94">More...</a><br /></td></tr>
<tr class="separator:a5ad505c244da9a1dc2827726dd409f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3b6f0a6153c976227e11093093bf29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6f3b6f0a6153c976227e11093093bf29">BreakStringLiterals</a></td></tr>
<tr class="memdesc:a6f3b6f0a6153c976227e11093093bf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow breaking string literals when formatting.  <a href="structclang_1_1format_1_1FormatStyle.html#a6f3b6f0a6153c976227e11093093bf29">More...</a><br /></td></tr>
<tr class="separator:a6f3b6f0a6153c976227e11093093bf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9550cc9c7c93fbc3506cb0b140593c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#afe9550cc9c7c93fbc3506cb0b140593c">ColumnLimit</a></td></tr>
<tr class="memdesc:afe9550cc9c7c93fbc3506cb0b140593c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The column limit.  <a href="structclang_1_1format_1_1FormatStyle.html#afe9550cc9c7c93fbc3506cb0b140593c">More...</a><br /></td></tr>
<tr class="separator:afe9550cc9c7c93fbc3506cb0b140593c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66e80203947743add360933aa7a2256"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab66e80203947743add360933aa7a2256">CommentPragmas</a></td></tr>
<tr class="memdesc:ab66e80203947743add360933aa7a2256"><td class="mdescLeft">&#160;</td><td class="mdescRight">A regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed.  <a href="structclang_1_1format_1_1FormatStyle.html#ab66e80203947743add360933aa7a2256">More...</a><br /></td></tr>
<tr class="separator:ab66e80203947743add360933aa7a2256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a84fddb46ef4546c5a1e246c266d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98">BreakInheritanceListStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a09a84fddb46ef4546c5a1e246c266d67">BreakInheritanceList</a></td></tr>
<tr class="memdesc:a09a84fddb46ef4546c5a1e246c266d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inheritance list style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a09a84fddb46ef4546c5a1e246c266d67">More...</a><br /></td></tr>
<tr class="separator:a09a84fddb46ef4546c5a1e246c266d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3193ddb985519cf0d38ffb17d4d12221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0c">BreakTemplateDeclarationsStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3193ddb985519cf0d38ffb17d4d12221">BreakTemplateDeclarations</a></td></tr>
<tr class="memdesc:a3193ddb985519cf0d38ffb17d4d12221"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template declaration breaking style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a3193ddb985519cf0d38ffb17d4d12221">More...</a><br /></td></tr>
<tr class="separator:a3193ddb985519cf0d38ffb17d4d12221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8901d6700758105da858cc31d2ba1862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8901d6700758105da858cc31d2ba1862">CompactNamespaces</a></td></tr>
<tr class="memdesc:a8901d6700758105da858cc31d2ba1862"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, consecutive namespace declarations will be on the same line.  <a href="structclang_1_1format_1_1FormatStyle.html#a8901d6700758105da858cc31d2ba1862">More...</a><br /></td></tr>
<tr class="separator:a8901d6700758105da858cc31d2ba1862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a31c95b98c7ba6c606237473f61981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87a31c95b98c7ba6c606237473f61981">ConstructorInitializerIndentWidth</a></td></tr>
<tr class="memdesc:a87a31c95b98c7ba6c606237473f61981"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is <b>deprecated</b>.  <a href="structclang_1_1format_1_1FormatStyle.html#a87a31c95b98c7ba6c606237473f61981">More...</a><br /></td></tr>
<tr class="separator:a87a31c95b98c7ba6c606237473f61981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0384417b961b70560004a52de799d7cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a0384417b961b70560004a52de799d7cc">ContinuationIndentWidth</a></td></tr>
<tr class="memdesc:a0384417b961b70560004a52de799d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent width for line continuations.  <a href="structclang_1_1format_1_1FormatStyle.html#a0384417b961b70560004a52de799d7cc">More...</a><br /></td></tr>
<tr class="separator:a0384417b961b70560004a52de799d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082f72ed255395cea133365999de70a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a082f72ed255395cea133365999de70a1">Cpp11BracedListStyle</a></td></tr>
<tr class="memdesc:a082f72ed255395cea133365999de70a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, format braced lists as best suited for C++11 braced lists.  <a href="structclang_1_1format_1_1FormatStyle.html#a082f72ed255395cea133365999de70a1">More...</a><br /></td></tr>
<tr class="separator:a082f72ed255395cea133365999de70a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329af409f225a629965c88cfb686feec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a329af409f225a629965c88cfb686feec">DerivePointerAlignment</a></td></tr>
<tr class="memdesc:a329af409f225a629965c88cfb686feec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option is <b>deprecated</b>.  <a href="structclang_1_1format_1_1FormatStyle.html#a329af409f225a629965c88cfb686feec">More...</a><br /></td></tr>
<tr class="separator:a329af409f225a629965c88cfb686feec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9a7cd35c99de4dac239136a3060108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abc9a7cd35c99de4dac239136a3060108">DisableFormat</a></td></tr>
<tr class="memdesc:abc9a7cd35c99de4dac239136a3060108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables formatting completely.  <a href="structclang_1_1format_1_1FormatStyle.html#abc9a7cd35c99de4dac239136a3060108">More...</a><br /></td></tr>
<tr class="separator:abc9a7cd35c99de4dac239136a3060108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ed6f0bb2c3809daf8e9a5f06f381d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422">EmptyLineAfterAccessModifierStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae97ed6f0bb2c3809daf8e9a5f06f381d">EmptyLineAfterAccessModifier</a></td></tr>
<tr class="memdesc:ae97ed6f0bb2c3809daf8e9a5f06f381d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines when to put an empty line after access modifiers.  <a href="structclang_1_1format_1_1FormatStyle.html#ae97ed6f0bb2c3809daf8e9a5f06f381d">More...</a><br /></td></tr>
<tr class="separator:ae97ed6f0bb2c3809daf8e9a5f06f381d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7872685696a4070aea7032539266e62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5">EmptyLineBeforeAccessModifierStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad7872685696a4070aea7032539266e62">EmptyLineBeforeAccessModifier</a></td></tr>
<tr class="memdesc:ad7872685696a4070aea7032539266e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines in which cases to put empty line before access modifiers.  <a href="structclang_1_1format_1_1FormatStyle.html#ad7872685696a4070aea7032539266e62">More...</a><br /></td></tr>
<tr class="separator:ad7872685696a4070aea7032539266e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecc064cf590382856b68c4568c0ce24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5ecc064cf590382856b68c4568c0ce24">ExperimentalAutoDetectBinPacking</a></td></tr>
<tr class="memdesc:a5ecc064cf590382856b68c4568c0ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, clang-format detects whether function calls and definitions are formatted with one parameter per line.  <a href="structclang_1_1format_1_1FormatStyle.html#a5ecc064cf590382856b68c4568c0ce24">More...</a><br /></td></tr>
<tr class="separator:a5ecc064cf590382856b68c4568c0ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad1fe5d6b71f7b8f57a46cb81358f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3ad1fe5d6b71f7b8f57a46cb81358f3e">FixNamespaceComments</a></td></tr>
<tr class="memdesc:a3ad1fe5d6b71f7b8f57a46cb81358f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, clang-format adds missing namespace end comments for namespaces and fixes invalid existing ones.  <a href="structclang_1_1format_1_1FormatStyle.html#a3ad1fe5d6b71f7b8f57a46cb81358f3e">More...</a><br /></td></tr>
<tr class="separator:a3ad1fe5d6b71f7b8f57a46cb81358f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6796db39ca57a3bb76d09051e3aeefb8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6796db39ca57a3bb76d09051e3aeefb8">ForEachMacros</a></td></tr>
<tr class="memdesc:a6796db39ca57a3bb76d09051e3aeefb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros that should be interpreted as foreach loops instead of as function calls.  <a href="structclang_1_1format_1_1FormatStyle.html#a6796db39ca57a3bb76d09051e3aeefb8">More...</a><br /></td></tr>
<tr class="separator:a6796db39ca57a3bb76d09051e3aeefb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5c317444cf95ed94d84580c96f7b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1tooling_1_1IncludeStyle.html">tooling::IncludeStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#afe5c317444cf95ed94d84580c96f7b36">IncludeStyle</a></td></tr>
<tr class="separator:afe5c317444cf95ed94d84580c96f7b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c3c0a900da46f6533abac8446e43ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a59c3c0a900da46f6533abac8446e43ae">IfMacros</a></td></tr>
<tr class="memdesc:a59c3c0a900da46f6533abac8446e43ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros that should be interpreted as conditionals instead of as function calls.  <a href="structclang_1_1format_1_1FormatStyle.html#a59c3c0a900da46f6533abac8446e43ae">More...</a><br /></td></tr>
<tr class="separator:a59c3c0a900da46f6533abac8446e43ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbb2cb8e04b9114557c59c4b9de0e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aebbb2cb8e04b9114557c59c4b9de0e51">IndentAccessModifiers</a></td></tr>
<tr class="memdesc:aebbb2cb8e04b9114557c59c4b9de0e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether access modifiers should have their own indentation level.  <a href="structclang_1_1format_1_1FormatStyle.html#aebbb2cb8e04b9114557c59c4b9de0e51">More...</a><br /></td></tr>
<tr class="separator:aebbb2cb8e04b9114557c59c4b9de0e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2c8c3ab1814b00243c816deb29b538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2e2c8c3ab1814b00243c816deb29b538">IndentCaseBlocks</a></td></tr>
<tr class="memdesc:a2e2c8c3ab1814b00243c816deb29b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent case label blocks one level from the case label.  <a href="structclang_1_1format_1_1FormatStyle.html#a2e2c8c3ab1814b00243c816deb29b538">More...</a><br /></td></tr>
<tr class="separator:a2e2c8c3ab1814b00243c816deb29b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178999cdea92868a4f3dc332b36cc285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a178999cdea92868a4f3dc332b36cc285">IndentCaseLabels</a></td></tr>
<tr class="memdesc:a178999cdea92868a4f3dc332b36cc285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent case labels one level from the switch statement.  <a href="structclang_1_1format_1_1FormatStyle.html#a178999cdea92868a4f3dc332b36cc285">More...</a><br /></td></tr>
<tr class="separator:a178999cdea92868a4f3dc332b36cc285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699b89a78eca1b92eee91f7c8b4be3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac699b89a78eca1b92eee91f7c8b4be3c">IndentGotoLabels</a></td></tr>
<tr class="memdesc:ac699b89a78eca1b92eee91f7c8b4be3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent goto labels.  <a href="structclang_1_1format_1_1FormatStyle.html#ac699b89a78eca1b92eee91f7c8b4be3c">More...</a><br /></td></tr>
<tr class="separator:ac699b89a78eca1b92eee91f7c8b4be3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0c1858076c92847069daa7b3f5cb1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6">IndentExternBlockStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#afd0c1858076c92847069daa7b3f5cb1f">IndentExternBlock</a></td></tr>
<tr class="memdesc:afd0c1858076c92847069daa7b3f5cb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">IndentExternBlockStyle is the type of indenting of extern blocks.  <a href="structclang_1_1format_1_1FormatStyle.html#afd0c1858076c92847069daa7b3f5cb1f">More...</a><br /></td></tr>
<tr class="separator:afd0c1858076c92847069daa7b3f5cb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bea71409a0008ea6c19026cd942cedf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393">PPDirectiveIndentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1bea71409a0008ea6c19026cd942cedf">IndentPPDirectives</a></td></tr>
<tr class="memdesc:a1bea71409a0008ea6c19026cd942cedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preprocessor directive indenting style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#a1bea71409a0008ea6c19026cd942cedf">More...</a><br /></td></tr>
<tr class="separator:a1bea71409a0008ea6c19026cd942cedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f6f3a42d514c21624e6f03c6b8cf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a15f6f3a42d514c21624e6f03c6b8cf40">IndentRequiresClause</a></td></tr>
<tr class="memdesc:a15f6f3a42d514c21624e6f03c6b8cf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent the requires clause in a template.  <a href="structclang_1_1format_1_1FormatStyle.html#a15f6f3a42d514c21624e6f03c6b8cf40">More...</a><br /></td></tr>
<tr class="separator:a15f6f3a42d514c21624e6f03c6b8cf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1f96ea453f4d8fc16ab55bc31baeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a0e1f96ea453f4d8fc16ab55bc31baeb2">IndentWidth</a></td></tr>
<tr class="memdesc:a0e1f96ea453f4d8fc16ab55bc31baeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns to use for indentation.  <a href="structclang_1_1format_1_1FormatStyle.html#a0e1f96ea453f4d8fc16ab55bc31baeb2">More...</a><br /></td></tr>
<tr class="separator:a0e1f96ea453f4d8fc16ab55bc31baeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376802535e897befd601fc35d5f6f58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a376802535e897befd601fc35d5f6f58e">IndentWrappedFunctionNames</a></td></tr>
<tr class="memdesc:a376802535e897befd601fc35d5f6f58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indent if a function definition or declaration is wrapped after the type.  <a href="structclang_1_1format_1_1FormatStyle.html#a376802535e897befd601fc35d5f6f58e">More...</a><br /></td></tr>
<tr class="separator:a376802535e897befd601fc35d5f6f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e134cb4fa5c2d73a7cd8d16359655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2e2e134cb4fa5c2d73a7cd8d16359655">InsertBraces</a></td></tr>
<tr class="memdesc:a2e2e134cb4fa5c2d73a7cd8d16359655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert braces after control statements (<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, and <code>while</code>) in C++ unless the control statements are inside macro definitions or the braces would enclose preprocessor directives.  <a href="structclang_1_1format_1_1FormatStyle.html#a2e2e134cb4fa5c2d73a7cd8d16359655">More...</a><br /></td></tr>
<tr class="separator:a2e2e134cb4fa5c2d73a7cd8d16359655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4e7d40aeebee0fe9d5f62da1d72122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aec4e7d40aeebee0fe9d5f62da1d72122">InsertNewlineAtEOF</a></td></tr>
<tr class="memdesc:aec4e7d40aeebee0fe9d5f62da1d72122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a newline at end of file if missing.  <a href="structclang_1_1format_1_1FormatStyle.html#aec4e7d40aeebee0fe9d5f62da1d72122">More...</a><br /></td></tr>
<tr class="separator:aec4e7d40aeebee0fe9d5f62da1d72122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a604df2cc8e1935448f065ef42a5e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9">TrailingCommaStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6a604df2cc8e1935448f065ef42a5e51">InsertTrailingCommas</a></td></tr>
<tr class="memdesc:a6a604df2cc8e1935448f065ef42a5e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to <code>TCS_Wrapped</code> will insert trailing commas in container literals (arrays and objects) that wrap across multiple lines.  <a href="structclang_1_1format_1_1FormatStyle.html#a6a604df2cc8e1935448f065ef42a5e51">More...</a><br /></td></tr>
<tr class="separator:a6a604df2cc8e1935448f065ef42a5e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f118ef9ae093a08781c49c190f1fe91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1IntegerLiteralSeparatorStyle.html">IntegerLiteralSeparatorStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8f118ef9ae093a08781c49c190f1fe91">IntegerLiteralSeparator</a></td></tr>
<tr class="memdesc:a8f118ef9ae093a08781c49c190f1fe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format integer literal separators (<code>'</code> for C++ and <code>_</code> for C#, Java, and JavaScript).  <a href="structclang_1_1format_1_1FormatStyle.html#a8f118ef9ae093a08781c49c190f1fe91">More...</a><br /></td></tr>
<tr class="separator:a8f118ef9ae093a08781c49c190f1fe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a710cbb8d487c2d555ab410dd8351d0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a4a710cbb8d487c2d555ab410dd8351d0">JavaImportGroups</a></td></tr>
<tr class="memdesc:a4a710cbb8d487c2d555ab410dd8351d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of prefixes ordered by the desired groups for Java imports.  <a href="structclang_1_1format_1_1FormatStyle.html#a4a710cbb8d487c2d555ab410dd8351d0">More...</a><br /></td></tr>
<tr class="separator:a4a710cbb8d487c2d555ab410dd8351d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab727d146cfab5867722ff9f017ec7d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131">JavaScriptQuoteStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab727d146cfab5867722ff9f017ec7d43">JavaScriptQuotes</a></td></tr>
<tr class="memdesc:ab727d146cfab5867722ff9f017ec7d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JavaScriptQuoteStyle to use for JavaScript strings.  <a href="structclang_1_1format_1_1FormatStyle.html#ab727d146cfab5867722ff9f017ec7d43">More...</a><br /></td></tr>
<tr class="separator:ab727d146cfab5867722ff9f017ec7d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ee69af675ea748e8f5782eb779f606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad8ee69af675ea748e8f5782eb779f606">JavaScriptWrapImports</a></td></tr>
<tr class="memdesc:ad8ee69af675ea748e8f5782eb779f606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to wrap JavaScript import/export statements.  <a href="structclang_1_1format_1_1FormatStyle.html#ad8ee69af675ea748e8f5782eb779f606">More...</a><br /></td></tr>
<tr class="separator:ad8ee69af675ea748e8f5782eb779f606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3197474d55d0fd650e0f7ace1263659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae3197474d55d0fd650e0f7ace1263659">KeepEmptyLinesAtEOF</a></td></tr>
<tr class="memdesc:ae3197474d55d0fd650e0f7ace1263659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep empty lines (up to <code>MaxEmptyLinesToKeep</code>) at end of file.  <a href="structclang_1_1format_1_1FormatStyle.html#ae3197474d55d0fd650e0f7ace1263659">More...</a><br /></td></tr>
<tr class="separator:ae3197474d55d0fd650e0f7ace1263659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dbf64fe3deb97c962fed5ae2c85fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae5dbf64fe3deb97c962fed5ae2c85fff">KeepEmptyLinesAtTheStartOfBlocks</a></td></tr>
<tr class="memdesc:ae5dbf64fe3deb97c962fed5ae2c85fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the empty line at the start of blocks is kept.  <a href="structclang_1_1format_1_1FormatStyle.html#ae5dbf64fe3deb97c962fed5ae2c85fff">More...</a><br /></td></tr>
<tr class="separator:ae5dbf64fe3deb97c962fed5ae2c85fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21906e890daa15742d40bdfe6566613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ff">LambdaBodyIndentationKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac21906e890daa15742d40bdfe6566613">LambdaBodyIndentation</a></td></tr>
<tr class="memdesc:ac21906e890daa15742d40bdfe6566613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indentation style of lambda bodies.  <a href="structclang_1_1format_1_1FormatStyle.html#ac21906e890daa15742d40bdfe6566613">More...</a><br /></td></tr>
<tr class="separator:ac21906e890daa15742d40bdfe6566613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e83ab348f7a48c1eefbc866a134cfe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">LanguageKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3e83ab348f7a48c1eefbc866a134cfe9">Language</a></td></tr>
<tr class="memdesc:a3e83ab348f7a48c1eefbc866a134cfe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Language, this format style is targeted at.  <a href="structclang_1_1format_1_1FormatStyle.html#a3e83ab348f7a48c1eefbc866a134cfe9">More...</a><br /></td></tr>
<tr class="separator:a3e83ab348f7a48c1eefbc866a134cfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6269937f6158ee331ff67af7519ecc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5d">LineEndingStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af6269937f6158ee331ff67af7519ecc1">LineEnding</a></td></tr>
<tr class="memdesc:af6269937f6158ee331ff67af7519ecc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line ending style (<code>\n</code> or <code>\r\n</code>) to use.  <a href="structclang_1_1format_1_1FormatStyle.html#af6269937f6158ee331ff67af7519ecc1">More...</a><br /></td></tr>
<tr class="separator:af6269937f6158ee331ff67af7519ecc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d09aa93387fc5d95def63c59d0692a3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3d09aa93387fc5d95def63c59d0692a3">MacroBlockBegin</a></td></tr>
<tr class="memdesc:a3d09aa93387fc5d95def63c59d0692a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A regular expression matching macros that start a block.  <a href="structclang_1_1format_1_1FormatStyle.html#a3d09aa93387fc5d95def63c59d0692a3">More...</a><br /></td></tr>
<tr class="separator:a3d09aa93387fc5d95def63c59d0692a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35d37ff2d74806696a34f969de7dddc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae35d37ff2d74806696a34f969de7dddc">MacroBlockEnd</a></td></tr>
<tr class="memdesc:ae35d37ff2d74806696a34f969de7dddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A regular expression matching macros that end a block.  <a href="structclang_1_1format_1_1FormatStyle.html#ae35d37ff2d74806696a34f969de7dddc">More...</a><br /></td></tr>
<tr class="separator:ae35d37ff2d74806696a34f969de7dddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b4d144014285bf9f1255ef3c6b6a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1d3b4d144014285bf9f1255ef3c6b6a1">Macros</a></td></tr>
<tr class="memdesc:a1d3b4d144014285bf9f1255ef3c6b6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of macros of the form <code></code> &lt;definition&gt;=&lt;expansion&gt; .  <a href="structclang_1_1format_1_1FormatStyle.html#a1d3b4d144014285bf9f1255ef3c6b6a1">More...</a><br /></td></tr>
<tr class="separator:a1d3b4d144014285bf9f1255ef3c6b6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca7a61d6d72ab0adf276ace30155d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aafca7a61d6d72ab0adf276ace30155d5">MaxEmptyLinesToKeep</a></td></tr>
<tr class="memdesc:aafca7a61d6d72ab0adf276ace30155d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of consecutive empty lines to keep.  <a href="structclang_1_1format_1_1FormatStyle.html#aafca7a61d6d72ab0adf276ace30155d5">More...</a><br /></td></tr>
<tr class="separator:aafca7a61d6d72ab0adf276ace30155d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a74c72d0ca5b345b9d5cf6d40da0adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622">NamespaceIndentationKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5a74c72d0ca5b345b9d5cf6d40da0adf">NamespaceIndentation</a></td></tr>
<tr class="memdesc:a5a74c72d0ca5b345b9d5cf6d40da0adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indentation used for namespaces.  <a href="structclang_1_1format_1_1FormatStyle.html#a5a74c72d0ca5b345b9d5cf6d40da0adf">More...</a><br /></td></tr>
<tr class="separator:a5a74c72d0ca5b345b9d5cf6d40da0adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0724e85bdea3e79ccff8812339536d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac0724e85bdea3e79ccff8812339536d5">NamespaceMacros</a></td></tr>
<tr class="memdesc:ac0724e85bdea3e79ccff8812339536d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros which are used to open namespace blocks.  <a href="structclang_1_1format_1_1FormatStyle.html#ac0724e85bdea3e79ccff8812339536d5">More...</a><br /></td></tr>
<tr class="separator:ac0724e85bdea3e79ccff8812339536d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1db225068abf27cba93aec1a485d863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2">BinPackStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab1db225068abf27cba93aec1a485d863">ObjCBinPackProtocolList</a></td></tr>
<tr class="memdesc:ab1db225068abf27cba93aec1a485d863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls bin-packing Objective-C protocol conformance list items into as few lines as possible when they go over <code>ColumnLimit</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#ab1db225068abf27cba93aec1a485d863">More...</a><br /></td></tr>
<tr class="separator:ab1db225068abf27cba93aec1a485d863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5112a40bafcc47664ab0d751bd84b44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5112a40bafcc47664ab0d751bd84b44b">ObjCBlockIndentWidth</a></td></tr>
<tr class="memdesc:a5112a40bafcc47664ab0d751bd84b44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of characters to use for indentation of ObjC blocks.  <a href="structclang_1_1format_1_1FormatStyle.html#a5112a40bafcc47664ab0d751bd84b44b">More...</a><br /></td></tr>
<tr class="separator:a5112a40bafcc47664ab0d751bd84b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f68fffff5cf94f20ed706d1980c02db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5f68fffff5cf94f20ed706d1980c02db">ObjCBreakBeforeNestedBlockParam</a></td></tr>
<tr class="memdesc:a5f68fffff5cf94f20ed706d1980c02db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break parameters list into lines when there is nested block parameters in a function call.  <a href="structclang_1_1format_1_1FormatStyle.html#a5f68fffff5cf94f20ed706d1980c02db">More...</a><br /></td></tr>
<tr class="separator:a5f68fffff5cf94f20ed706d1980c02db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbff44c01f8a9231fdde63a20da497c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5cbff44c01f8a9231fdde63a20da497c">ObjCPropertyAttributeOrder</a></td></tr>
<tr class="memdesc:a5cbff44c01f8a9231fdde63a20da497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The order in which ObjC property attributes should appear.  <a href="structclang_1_1format_1_1FormatStyle.html#a5cbff44c01f8a9231fdde63a20da497c">More...</a><br /></td></tr>
<tr class="separator:a5cbff44c01f8a9231fdde63a20da497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7725ac1f55bfd9fff0e3555974cfb1c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7725ac1f55bfd9fff0e3555974cfb1c4">ObjCSpaceAfterProperty</a></td></tr>
<tr class="memdesc:a7725ac1f55bfd9fff0e3555974cfb1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a space after <code>@property</code> in Objective-C, i.e.  <a href="structclang_1_1format_1_1FormatStyle.html#a7725ac1f55bfd9fff0e3555974cfb1c4">More...</a><br /></td></tr>
<tr class="separator:a7725ac1f55bfd9fff0e3555974cfb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0c9f0c4bb6b9b4e07704865a4acde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b0c9f0c4bb6b9b4e07704865a4acde6">ObjCSpaceBeforeProtocolList</a></td></tr>
<tr class="memdesc:a3b0c9f0c4bb6b9b4e07704865a4acde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a space in front of an Objective-C protocol list, i.e.  <a href="structclang_1_1format_1_1FormatStyle.html#a3b0c9f0c4bb6b9b4e07704865a4acde6">More...</a><br /></td></tr>
<tr class="separator:a3b0c9f0c4bb6b9b4e07704865a4acde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06db12bb3595e1a043c2d0487d1272b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23">PackConstructorInitializersStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa06db12bb3595e1a043c2d0487d1272b">PackConstructorInitializers</a></td></tr>
<tr class="memdesc:aa06db12bb3595e1a043c2d0487d1272b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pack constructor initializers style to use.  <a href="structclang_1_1format_1_1FormatStyle.html#aa06db12bb3595e1a043c2d0487d1272b">More...</a><br /></td></tr>
<tr class="separator:aa06db12bb3595e1a043c2d0487d1272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb712c347a057da49196cbcfbdcfa72f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#adb712c347a057da49196cbcfbdcfa72f">PenaltyBreakAssignment</a></td></tr>
<tr class="memdesc:adb712c347a057da49196cbcfbdcfa72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking around an assignment operator.  <a href="structclang_1_1format_1_1FormatStyle.html#adb712c347a057da49196cbcfbdcfa72f">More...</a><br /></td></tr>
<tr class="separator:adb712c347a057da49196cbcfbdcfa72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2256bfa6b34a5916077066fb05ad92d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2256bfa6b34a5916077066fb05ad92d2">PenaltyBreakBeforeFirstCallParameter</a></td></tr>
<tr class="memdesc:a2256bfa6b34a5916077066fb05ad92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking a function call after <code>call(</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a2256bfa6b34a5916077066fb05ad92d2">More...</a><br /></td></tr>
<tr class="separator:a2256bfa6b34a5916077066fb05ad92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b9c9cefa83f57a7075e9115bceac5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae6b9c9cefa83f57a7075e9115bceac5c">PenaltyBreakComment</a></td></tr>
<tr class="memdesc:ae6b9c9cefa83f57a7075e9115bceac5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for each line break introduced inside a comment.  <a href="structclang_1_1format_1_1FormatStyle.html#ae6b9c9cefa83f57a7075e9115bceac5c">More...</a><br /></td></tr>
<tr class="separator:ae6b9c9cefa83f57a7075e9115bceac5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7375a939438afdd39c267da5bda3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a4e7375a939438afdd39c267da5bda3ec">PenaltyBreakFirstLessLess</a></td></tr>
<tr class="memdesc:a4e7375a939438afdd39c267da5bda3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking before the first <code>&lt;&lt;</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a4e7375a939438afdd39c267da5bda3ec">More...</a><br /></td></tr>
<tr class="separator:a4e7375a939438afdd39c267da5bda3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616f9ce31a1db0c94835d21f2d693448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a616f9ce31a1db0c94835d21f2d693448">PenaltyBreakOpenParenthesis</a></td></tr>
<tr class="memdesc:a616f9ce31a1db0c94835d21f2d693448"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking after <code>(</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a616f9ce31a1db0c94835d21f2d693448">More...</a><br /></td></tr>
<tr class="separator:a616f9ce31a1db0c94835d21f2d693448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9689730aea8b71f3417a23057fe84388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9689730aea8b71f3417a23057fe84388">PenaltyBreakScopeResolution</a></td></tr>
<tr class="memdesc:a9689730aea8b71f3417a23057fe84388"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking after <code>::</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a9689730aea8b71f3417a23057fe84388">More...</a><br /></td></tr>
<tr class="separator:a9689730aea8b71f3417a23057fe84388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade360c8aa3ede11110a1e13d31a7516f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ade360c8aa3ede11110a1e13d31a7516f">PenaltyBreakString</a></td></tr>
<tr class="memdesc:ade360c8aa3ede11110a1e13d31a7516f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for each line break introduced inside a string literal.  <a href="structclang_1_1format_1_1FormatStyle.html#ade360c8aa3ede11110a1e13d31a7516f">More...</a><br /></td></tr>
<tr class="separator:ade360c8aa3ede11110a1e13d31a7516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b73633f0cb705c699188b780b6905bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6b73633f0cb705c699188b780b6905bc">PenaltyBreakTemplateDeclaration</a></td></tr>
<tr class="memdesc:a6b73633f0cb705c699188b780b6905bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for breaking after template declaration.  <a href="structclang_1_1format_1_1FormatStyle.html#a6b73633f0cb705c699188b780b6905bc">More...</a><br /></td></tr>
<tr class="separator:a6b73633f0cb705c699188b780b6905bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2b485ba27597314723b0b11e47f099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7f2b485ba27597314723b0b11e47f099">PenaltyExcessCharacter</a></td></tr>
<tr class="memdesc:a7f2b485ba27597314723b0b11e47f099"><td class="mdescLeft">&#160;</td><td class="mdescRight">The penalty for each character outside of the column limit.  <a href="structclang_1_1format_1_1FormatStyle.html#a7f2b485ba27597314723b0b11e47f099">More...</a><br /></td></tr>
<tr class="separator:a7f2b485ba27597314723b0b11e47f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1750316d05566314cc864c01e8af62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae1750316d05566314cc864c01e8af62f">PenaltyIndentedWhitespace</a></td></tr>
<tr class="memdesc:ae1750316d05566314cc864c01e8af62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Penalty for each character of whitespace indentation (counted relative to leading non-whitespace column).  <a href="structclang_1_1format_1_1FormatStyle.html#ae1750316d05566314cc864c01e8af62f">More...</a><br /></td></tr>
<tr class="separator:ae1750316d05566314cc864c01e8af62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96be8e4382866d0ce27a63786d5f8057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a96be8e4382866d0ce27a63786d5f8057">PenaltyReturnTypeOnItsOwnLine</a></td></tr>
<tr class="memdesc:a96be8e4382866d0ce27a63786d5f8057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Penalty for putting the return type of a function onto its own line.  <a href="structclang_1_1format_1_1FormatStyle.html#a96be8e4382866d0ce27a63786d5f8057">More...</a><br /></td></tr>
<tr class="separator:a96be8e4382866d0ce27a63786d5f8057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e120bc3116361bd6d92f9191a6c3c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172">PointerAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a></td></tr>
<tr class="memdesc:a97e120bc3116361bd6d92f9191a6c3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer and reference alignment style.  <a href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">More...</a><br /></td></tr>
<tr class="separator:a97e120bc3116361bd6d92f9191a6c3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6733256cfc8ae8a47c288c86743b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8e6733256cfc8ae8a47c288c86743b11">PPIndentWidth</a></td></tr>
<tr class="memdesc:a8e6733256cfc8ae8a47c288c86743b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns to use for indentation of preprocessor statements.  <a href="structclang_1_1format_1_1FormatStyle.html#a8e6733256cfc8ae8a47c288c86743b11">More...</a><br /></td></tr>
<tr class="separator:a8e6733256cfc8ae8a47c288c86743b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26b33f834e61a32e53ecc466ac0ec12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22ef">QualifierAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac26b33f834e61a32e53ecc466ac0ec12">QualifierAlignment</a></td></tr>
<tr class="memdesc:ac26b33f834e61a32e53ecc466ac0ec12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways to arrange specifiers and qualifiers (e.g.  <a href="structclang_1_1format_1_1FormatStyle.html#ac26b33f834e61a32e53ecc466ac0ec12">More...</a><br /></td></tr>
<tr class="separator:ac26b33f834e61a32e53ecc466ac0ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53777b5478ec7f9751c93ce8d23e71fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a53777b5478ec7f9751c93ce8d23e71fe">QualifierOrder</a></td></tr>
<tr class="memdesc:a53777b5478ec7f9751c93ce8d23e71fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The order in which the qualifiers appear.  <a href="structclang_1_1format_1_1FormatStyle.html#a53777b5478ec7f9751c93ce8d23e71fe">More...</a><br /></td></tr>
<tr class="separator:a53777b5478ec7f9751c93ce8d23e71fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18daec6fe8444a5efaae0832e124ef62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structclang_1_1format_1_1FormatStyle_1_1RawStringFormat.html">RawStringFormat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a18daec6fe8444a5efaae0832e124ef62">RawStringFormats</a></td></tr>
<tr class="memdesc:a18daec6fe8444a5efaae0832e124ef62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines hints for detecting supported languages code blocks in raw strings.  <a href="structclang_1_1format_1_1FormatStyle.html#a18daec6fe8444a5efaae0832e124ef62">More...</a><br /></td></tr>
<tr class="separator:a18daec6fe8444a5efaae0832e124ef62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679827432d81baa1e09fab263e31622d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6">ReferenceAlignmentStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a679827432d81baa1e09fab263e31622d">ReferenceAlignment</a></td></tr>
<tr class="memdesc:a679827432d81baa1e09fab263e31622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference alignment style (overrides <code>PointerAlignment</code> for references).  <a href="structclang_1_1format_1_1FormatStyle.html#a679827432d81baa1e09fab263e31622d">More...</a><br /></td></tr>
<tr class="separator:a679827432d81baa1e09fab263e31622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9878977b6ca4e6918b4c1bbe6bce8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aae9878977b6ca4e6918b4c1bbe6bce8c">ReflowComments</a></td></tr>
<tr class="memdesc:aae9878977b6ca4e6918b4c1bbe6bce8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, clang-format will attempt to re-flow comments.  <a href="structclang_1_1format_1_1FormatStyle.html#aae9878977b6ca4e6918b4c1bbe6bce8c">More...</a><br /></td></tr>
<tr class="separator:aae9878977b6ca4e6918b4c1bbe6bce8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258513bdccfd48e8b59ff583d486359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a4258513bdccfd48e8b59ff583d486359">RemoveBracesLLVM</a></td></tr>
<tr class="memdesc:a4258513bdccfd48e8b59ff583d486359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove optional braces of control statements (<code>if</code>, <code>else</code>, <code>for</code>, and <code>while</code>) in C++ according to the LLVM coding style.  <a href="structclang_1_1format_1_1FormatStyle.html#a4258513bdccfd48e8b59ff583d486359">More...</a><br /></td></tr>
<tr class="separator:a4258513bdccfd48e8b59ff583d486359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc3e6e221104d26745b1852df21c6b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425">RemoveParenthesesStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3cc3e6e221104d26745b1852df21c6b1">RemoveParentheses</a></td></tr>
<tr class="memdesc:a3cc3e6e221104d26745b1852df21c6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#a3cc3e6e221104d26745b1852df21c6b1">More...</a><br /></td></tr>
<tr class="separator:a3cc3e6e221104d26745b1852df21c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf975c5e663bb661b3bf5267f78eca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1cf975c5e663bb661b3bf5267f78eca1">RemoveSemicolon</a></td></tr>
<tr class="memdesc:a1cf975c5e663bb661b3bf5267f78eca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove semicolons after the closing braces of functions and constructors/destructors.  <a href="structclang_1_1format_1_1FormatStyle.html#a1cf975c5e663bb661b3bf5267f78eca1">More...</a><br /></td></tr>
<tr class="separator:a1cf975c5e663bb661b3bf5267f78eca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d77e1af5beec5bbb82a2f84d5e693a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34">RequiresClausePositionStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d77e1af5beec5bbb82a2f84d5e693a1">RequiresClausePosition</a></td></tr>
<tr class="memdesc:a8d77e1af5beec5bbb82a2f84d5e693a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of the <code>requires</code> clause.  <a href="structclang_1_1format_1_1FormatStyle.html#a8d77e1af5beec5bbb82a2f84d5e693a1">More...</a><br /></td></tr>
<tr class="separator:a8d77e1af5beec5bbb82a2f84d5e693a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2b68b5bc6c3b1bc1a706eef46dcb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7">RequiresExpressionIndentationKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#adf2b68b5bc6c3b1bc1a706eef46dcb34">RequiresExpressionIndentation</a></td></tr>
<tr class="memdesc:adf2b68b5bc6c3b1bc1a706eef46dcb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indentation used for requires expression bodies.  <a href="structclang_1_1format_1_1FormatStyle.html#adf2b68b5bc6c3b1bc1a706eef46dcb34">More...</a><br /></td></tr>
<tr class="separator:adf2b68b5bc6c3b1bc1a706eef46dcb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2bf70cb519b1de1ee80675aa0266dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65">SeparateDefinitionStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#afe2bf70cb519b1de1ee80675aa0266dc">SeparateDefinitionBlocks</a></td></tr>
<tr class="memdesc:afe2bf70cb519b1de1ee80675aa0266dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions.  <a href="structclang_1_1format_1_1FormatStyle.html#afe2bf70cb519b1de1ee80675aa0266dc">More...</a><br /></td></tr>
<tr class="separator:afe2bf70cb519b1de1ee80675aa0266dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d9721a18038a30fdba3f272728f188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">ShortNamespaceLines</a></td></tr>
<tr class="memdesc:af9d9721a18038a30fdba3f272728f188"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximal number of unwrapped lines that a short namespace spans.  <a href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">More...</a><br /></td></tr>
<tr class="separator:af9d9721a18038a30fdba3f272728f188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6cab7c8d5500cc4e111bb95a8d2952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#adb6cab7c8d5500cc4e111bb95a8d2952">SkipMacroDefinitionBody</a></td></tr>
<tr class="memdesc:adb6cab7c8d5500cc4e111bb95a8d2952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not format macro definition body.  <a href="structclang_1_1format_1_1FormatStyle.html#adb6cab7c8d5500cc4e111bb95a8d2952">More...</a><br /></td></tr>
<tr class="separator:adb6cab7c8d5500cc4e111bb95a8d2952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba2a005f71a10648ca736b3bec198e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127de">SortIncludesOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a08ba2a005f71a10648ca736b3bec198e">SortIncludes</a></td></tr>
<tr class="memdesc:a08ba2a005f71a10648ca736b3bec198e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls if and how clang-format will sort <code>#includes</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a08ba2a005f71a10648ca736b3bec198e">More...</a><br /></td></tr>
<tr class="separator:a08ba2a005f71a10648ca736b3bec198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9357c565fe3f6af3dc05c04d7466402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4e">SortJavaStaticImportOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab9357c565fe3f6af3dc05c04d7466402">SortJavaStaticImport</a></td></tr>
<tr class="memdesc:ab9357c565fe3f6af3dc05c04d7466402"><td class="mdescLeft">&#160;</td><td class="mdescRight">When sorting Java imports, by default static imports are placed before non-static imports.  <a href="structclang_1_1format_1_1FormatStyle.html#ab9357c565fe3f6af3dc05c04d7466402">More...</a><br /></td></tr>
<tr class="separator:ab9357c565fe3f6af3dc05c04d7466402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba5ba7b53c084932261abc3d3e056ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfe">SortUsingDeclarationsOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#afba5ba7b53c084932261abc3d3e056ca">SortUsingDeclarations</a></td></tr>
<tr class="memdesc:afba5ba7b53c084932261abc3d3e056ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls if and how clang-format will sort using declarations.  <a href="structclang_1_1format_1_1FormatStyle.html#afba5ba7b53c084932261abc3d3e056ca">More...</a><br /></td></tr>
<tr class="separator:afba5ba7b53c084932261abc3d3e056ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dde150dbe50489f513fa23cee1d6184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8dde150dbe50489f513fa23cee1d6184">SpaceAfterCStyleCast</a></td></tr>
<tr class="memdesc:a8dde150dbe50489f513fa23cee1d6184"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, a space is inserted after C style casts.  <a href="structclang_1_1format_1_1FormatStyle.html#a8dde150dbe50489f513fa23cee1d6184">More...</a><br /></td></tr>
<tr class="separator:a8dde150dbe50489f513fa23cee1d6184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7027e26ae8145780c54337207a02f1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7027e26ae8145780c54337207a02f1e9">SpaceAfterLogicalNot</a></td></tr>
<tr class="memdesc:a7027e26ae8145780c54337207a02f1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, a space is inserted after the logical not operator (<code>!</code>).  <a href="structclang_1_1format_1_1FormatStyle.html#a7027e26ae8145780c54337207a02f1e9">More...</a><br /></td></tr>
<tr class="separator:a7027e26ae8145780c54337207a02f1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11bcd0560111449a29b0843cf1dfcdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae11bcd0560111449a29b0843cf1dfcdc">SpaceAfterTemplateKeyword</a></td></tr>
<tr class="memdesc:ae11bcd0560111449a29b0843cf1dfcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, a space will be inserted after the 'template' keyword.  <a href="structclang_1_1format_1_1FormatStyle.html#ae11bcd0560111449a29b0843cf1dfcdc">More...</a><br /></td></tr>
<tr class="separator:ae11bcd0560111449a29b0843cf1dfcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903713a1801f5cf5d4ede442400389e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9">SpaceAroundPointerQualifiersStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a903713a1801f5cf5d4ede442400389e1">SpaceAroundPointerQualifiers</a></td></tr>
<tr class="memdesc:a903713a1801f5cf5d4ede442400389e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines in which cases to put a space before or after pointer qualifiers.  <a href="structclang_1_1format_1_1FormatStyle.html#a903713a1801f5cf5d4ede442400389e1">More...</a><br /></td></tr>
<tr class="separator:a903713a1801f5cf5d4ede442400389e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915fe4216df56e63f64b37568b82a3c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a915fe4216df56e63f64b37568b82a3c3">SpaceBeforeAssignmentOperators</a></td></tr>
<tr class="memdesc:a915fe4216df56e63f64b37568b82a3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, spaces will be removed before assignment operators.  <a href="structclang_1_1format_1_1FormatStyle.html#a915fe4216df56e63f64b37568b82a3c3">More...</a><br /></td></tr>
<tr class="separator:a915fe4216df56e63f64b37568b82a3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8afba0cad571a6091b457a896bfe6d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad8afba0cad571a6091b457a896bfe6d3">SpaceBeforeCaseColon</a></td></tr>
<tr class="memdesc:ad8afba0cad571a6091b457a896bfe6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, spaces will be removed before case colon.  <a href="structclang_1_1format_1_1FormatStyle.html#ad8afba0cad571a6091b457a896bfe6d3">More...</a><br /></td></tr>
<tr class="separator:ad8afba0cad571a6091b457a896bfe6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee44e1eba8c06428af3df132b88cfab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aee44e1eba8c06428af3df132b88cfab7">SpaceBeforeCpp11BracedList</a></td></tr>
<tr class="memdesc:aee44e1eba8c06428af3df132b88cfab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, a space will be inserted before a C++11 braced list used to initialize an object (after the preceding identifier or type).  <a href="structclang_1_1format_1_1FormatStyle.html#aee44e1eba8c06428af3df132b88cfab7">More...</a><br /></td></tr>
<tr class="separator:aee44e1eba8c06428af3df132b88cfab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243596081d48af8d962a2526faa0ab9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a243596081d48af8d962a2526faa0ab9b">SpaceBeforeCtorInitializerColon</a></td></tr>
<tr class="memdesc:a243596081d48af8d962a2526faa0ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, spaces will be removed before constructor initializer colon.  <a href="structclang_1_1format_1_1FormatStyle.html#a243596081d48af8d962a2526faa0ab9b">More...</a><br /></td></tr>
<tr class="separator:a243596081d48af8d962a2526faa0ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e26231f68ff129b287fa28cd958b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a02e26231f68ff129b287fa28cd958b86">SpaceBeforeInheritanceColon</a></td></tr>
<tr class="memdesc:a02e26231f68ff129b287fa28cd958b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, spaces will be removed before inheritance colon.  <a href="structclang_1_1format_1_1FormatStyle.html#a02e26231f68ff129b287fa28cd958b86">More...</a><br /></td></tr>
<tr class="separator:a02e26231f68ff129b287fa28cd958b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eccedeecce047a2673fbf220fd46257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1eccedeecce047a2673fbf220fd46257">SpaceBeforeJsonColon</a></td></tr>
<tr class="memdesc:a1eccedeecce047a2673fbf220fd46257"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, a space will be added before a JSON colon.  <a href="structclang_1_1format_1_1FormatStyle.html#a1eccedeecce047a2673fbf220fd46257">More...</a><br /></td></tr>
<tr class="separator:a1eccedeecce047a2673fbf220fd46257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed53a0a0f38d3cf168bc155ba65c0262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9">SpaceBeforeParensStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aed53a0a0f38d3cf168bc155ba65c0262">SpaceBeforeParens</a></td></tr>
<tr class="memdesc:aed53a0a0f38d3cf168bc155ba65c0262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines in which cases to put a space before opening parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#aed53a0a0f38d3cf168bc155ba65c0262">More...</a><br /></td></tr>
<tr class="separator:aed53a0a0f38d3cf168bc155ba65c0262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1bffa3ec200d641f9d7eb40fb1d588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpaceBeforeParensCustom.html">SpaceBeforeParensCustom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6d1bffa3ec200d641f9d7eb40fb1d588">SpaceBeforeParensOptions</a></td></tr>
<tr class="memdesc:a6d1bffa3ec200d641f9d7eb40fb1d588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of individual space before parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#a6d1bffa3ec200d641f9d7eb40fb1d588">More...</a><br /></td></tr>
<tr class="separator:a6d1bffa3ec200d641f9d7eb40fb1d588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a45e899ec8efc6d2a86ffaebed9257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab1a45e899ec8efc6d2a86ffaebed9257">SpaceBeforeSquareBrackets</a></td></tr>
<tr class="memdesc:ab1a45e899ec8efc6d2a86ffaebed9257"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces will be before <code>[</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#ab1a45e899ec8efc6d2a86ffaebed9257">More...</a><br /></td></tr>
<tr class="separator:ab1a45e899ec8efc6d2a86ffaebed9257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc50a8b81b8abfd535d64a5a95053001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abc50a8b81b8abfd535d64a5a95053001">SpaceBeforeRangeBasedForLoopColon</a></td></tr>
<tr class="memdesc:abc50a8b81b8abfd535d64a5a95053001"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>false</code>, spaces will be removed before range-based for loop colon.  <a href="structclang_1_1format_1_1FormatStyle.html#abc50a8b81b8abfd535d64a5a95053001">More...</a><br /></td></tr>
<tr class="separator:abc50a8b81b8abfd535d64a5a95053001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5643e0f29b9348d93c1bc3197996ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3e5643e0f29b9348d93c1bc3197996ba">SpaceInEmptyBlock</a></td></tr>
<tr class="memdesc:a3e5643e0f29b9348d93c1bc3197996ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces will be inserted into <code>{}</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a3e5643e0f29b9348d93c1bc3197996ba">More...</a><br /></td></tr>
<tr class="separator:a3e5643e0f29b9348d93c1bc3197996ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c45bd6563a2837d105771d0c3ea7882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c45bd6563a2837d105771d0c3ea7882">SpacesBeforeTrailingComments</a></td></tr>
<tr class="memdesc:a2c45bd6563a2837d105771d0c3ea7882"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces may be inserted into <code>()</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a2c45bd6563a2837d105771d0c3ea7882">More...</a><br /></td></tr>
<tr class="separator:a2c45bd6563a2837d105771d0c3ea7882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169cfd68a1f826466cb0aa5602c6328b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917">SpacesInAnglesStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a169cfd68a1f826466cb0aa5602c6328b">SpacesInAngles</a></td></tr>
<tr class="memdesc:a169cfd68a1f826466cb0aa5602c6328b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SpacesInAnglesStyle to use for template argument lists.  <a href="structclang_1_1format_1_1FormatStyle.html#a169cfd68a1f826466cb0aa5602c6328b">More...</a><br /></td></tr>
<tr class="separator:a169cfd68a1f826466cb0aa5602c6328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab910a6a480c2a63971f6b83ec2bdee4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab910a6a480c2a63971f6b83ec2bdee4f">SpacesInContainerLiterals</a></td></tr>
<tr class="memdesc:ab910a6a480c2a63971f6b83ec2bdee4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces will be inserted around if/for/switch/while conditions.  <a href="structclang_1_1format_1_1FormatStyle.html#ab910a6a480c2a63971f6b83ec2bdee4f">More...</a><br /></td></tr>
<tr class="separator:ab910a6a480c2a63971f6b83ec2bdee4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a3cb6f9679a1b42038c733559af48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInLineComment.html">SpacesInLineComment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab5a3cb6f9679a1b42038c733559af48f">SpacesInLineCommentPrefix</a></td></tr>
<tr class="memdesc:ab5a3cb6f9679a1b42038c733559af48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many spaces are allowed at the start of a line comment.  <a href="structclang_1_1format_1_1FormatStyle.html#ab5a3cb6f9679a1b42038c733559af48f">More...</a><br /></td></tr>
<tr class="separator:ab5a3cb6f9679a1b42038c733559af48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6648491ea9a25deb2d5f2eeb06088857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4">SpacesInParensStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a6648491ea9a25deb2d5f2eeb06088857">SpacesInParens</a></td></tr>
<tr class="memdesc:a6648491ea9a25deb2d5f2eeb06088857"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a6648491ea9a25deb2d5f2eeb06088857">More...</a><br /></td></tr>
<tr class="separator:a6648491ea9a25deb2d5f2eeb06088857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675cfe4217900a9fac74b48e774c8563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInParensCustom.html">SpacesInParensCustom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a675cfe4217900a9fac74b48e774c8563">SpacesInParensOptions</a></td></tr>
<tr class="memdesc:a675cfe4217900a9fac74b48e774c8563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of individual spaces in parentheses.  <a href="structclang_1_1format_1_1FormatStyle.html#a675cfe4217900a9fac74b48e774c8563">More...</a><br /></td></tr>
<tr class="separator:a675cfe4217900a9fac74b48e774c8563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3644fa886992352c66a8de6de4ac8147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3644fa886992352c66a8de6de4ac8147">SpacesInSquareBrackets</a></td></tr>
<tr class="memdesc:a3644fa886992352c66a8de6de4ac8147"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>.  <a href="structclang_1_1format_1_1FormatStyle.html#a3644fa886992352c66a8de6de4ac8147">More...</a><br /></td></tr>
<tr class="separator:a3644fa886992352c66a8de6de4ac8147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e29dde38856beac53b1a307e444da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8">LanguageStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a044e29dde38856beac53b1a307e444da">Standard</a></td></tr>
<tr class="memdesc:a044e29dde38856beac53b1a307e444da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and format C++ constructs compatible with this standard.  <a href="structclang_1_1format_1_1FormatStyle.html#a044e29dde38856beac53b1a307e444da">More...</a><br /></td></tr>
<tr class="separator:a044e29dde38856beac53b1a307e444da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ece88e4de318c7b0e4b6c487b216bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a50ece88e4de318c7b0e4b6c487b216bf">StatementAttributeLikeMacros</a></td></tr>
<tr class="memdesc:a50ece88e4de318c7b0e4b6c487b216bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros which are ignored in front of a statement, as if they were an attribute.  <a href="structclang_1_1format_1_1FormatStyle.html#a50ece88e4de318c7b0e4b6c487b216bf">More...</a><br /></td></tr>
<tr class="separator:a50ece88e4de318c7b0e4b6c487b216bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf853d01318db5e3c97dfc0f3bc3481"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf853d01318db5e3c97dfc0f3bc3481">StatementMacros</a></td></tr>
<tr class="memdesc:acaf853d01318db5e3c97dfc0f3bc3481"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros that should be interpreted as complete statements.  <a href="structclang_1_1format_1_1FormatStyle.html#acaf853d01318db5e3c97dfc0f3bc3481">More...</a><br /></td></tr>
<tr class="separator:acaf853d01318db5e3c97dfc0f3bc3481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45374984e04b0dfd3394edb1f00fec5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad45374984e04b0dfd3394edb1f00fec5">TableGenBreakingDAGArgOperators</a></td></tr>
<tr class="memdesc:ad45374984e04b0dfd3394edb1f00fec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Works only when TableGenBreakInsideDAGArg is not DontBreak.  <a href="structclang_1_1format_1_1FormatStyle.html#ad45374984e04b0dfd3394edb1f00fec5">More...</a><br /></td></tr>
<tr class="separator:ad45374984e04b0dfd3394edb1f00fec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c70fbc15680b3d4b95a3e85d0b40c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6">DAGArgStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ab6c70fbc15680b3d4b95a3e85d0b40c9">TableGenBreakInsideDAGArg</a></td></tr>
<tr class="memdesc:ab6c70fbc15680b3d4b95a3e85d0b40c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The styles of the line break inside the DAGArg in TableGen.  <a href="structclang_1_1format_1_1FormatStyle.html#ab6c70fbc15680b3d4b95a3e85d0b40c9">More...</a><br /></td></tr>
<tr class="separator:ab6c70fbc15680b3d4b95a3e85d0b40c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488265e26e22037ba7fed6489a21028e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a488265e26e22037ba7fed6489a21028e">TabWidth</a></td></tr>
<tr class="memdesc:a488265e26e22037ba7fed6489a21028e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns used for tab stops.  <a href="structclang_1_1format_1_1FormatStyle.html#a488265e26e22037ba7fed6489a21028e">More...</a><br /></td></tr>
<tr class="separator:a488265e26e22037ba7fed6489a21028e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e816a0e37a1ad440ff2b68db915e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a763e816a0e37a1ad440ff2b68db915e2">TypeNames</a></td></tr>
<tr class="memdesc:a763e816a0e37a1ad440ff2b68db915e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of non-keyword identifiers that should be interpreted as type names.  <a href="structclang_1_1format_1_1FormatStyle.html#a763e816a0e37a1ad440ff2b68db915e2">More...</a><br /></td></tr>
<tr class="separator:a763e816a0e37a1ad440ff2b68db915e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b710117042d24d98e0645e56566b63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af2b710117042d24d98e0645e56566b63">TypenameMacros</a></td></tr>
<tr class="memdesc:af2b710117042d24d98e0645e56566b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros that should be interpreted as type declarations instead of as function calls.  <a href="structclang_1_1format_1_1FormatStyle.html#af2b710117042d24d98e0645e56566b63">More...</a><br /></td></tr>
<tr class="separator:af2b710117042d24d98e0645e56566b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d526918c493f4e47259fa33beddf81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619c">UseTabStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af0d526918c493f4e47259fa33beddf81">UseTab</a></td></tr>
<tr class="memdesc:af0d526918c493f4e47259fa33beddf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The way to use tab characters in the resulting file.  <a href="structclang_1_1format_1_1FormatStyle.html#af0d526918c493f4e47259fa33beddf81">More...</a><br /></td></tr>
<tr class="separator:af0d526918c493f4e47259fa33beddf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c3a88f58b630814a1b38f64ca1195d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47c3a88f58b630814a1b38f64ca1195d">VerilogBreakBetweenInstancePorts</a></td></tr>
<tr class="memdesc:a47c3a88f58b630814a1b38f64ca1195d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For Verilog, put each port on its own line in module instantiations.  <a href="structclang_1_1format_1_1FormatStyle.html#a47c3a88f58b630814a1b38f64ca1195d">More...</a><br /></td></tr>
<tr class="separator:a47c3a88f58b630814a1b38f64ca1195d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f69dade79f2f4a16b6dae5f7382b60d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7f69dade79f2f4a16b6dae5f7382b60d">WhitespaceSensitiveMacros</a></td></tr>
<tr class="memdesc:a7f69dade79f2f4a16b6dae5f7382b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of macros which are whitespace-sensitive and should not be touched.  <a href="structclang_1_1format_1_1FormatStyle.html#a7f69dade79f2f4a16b6dae5f7382b60d">More...</a><br /></td></tr>
<tr class="separator:a7f69dade79f2f4a16b6dae5f7382b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a65b31df3483b1e1830e682fe75ba9b50"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a65b31df3483b1e1830e682fe75ba9b50">parseConfiguration</a> (llvm::MemoryBufferRef Config, <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> *Style, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> AllowUnknownOptions, llvm::SourceMgr::DiagHandlerTy DiagHandler, void *DiagHandlerCtxt)</td></tr>
<tr class="memdesc:a65b31df3483b1e1830e682fe75ba9b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse configuration from YAML-formatted text.  <a href="structclang_1_1format_1_1FormatStyle.html#a65b31df3483b1e1830e682fe75ba9b50">More...</a><br /></td></tr>
<tr class="separator:a65b31df3483b1e1830e682fe75ba9b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structclang_1_1format_1_1FormatStyle.html" title="The FormatStyle is used to configure the formatting to follow specific guidelines.">FormatStyle</a></code> is used to configure the formatting to follow specific guidelines. </p>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00055">55</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac1754a0481292dcc9959bf6fbebcd6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1754a0481292dcc9959bf6fbebcd6b1">&#9670;&nbsp;</a></span>ArrayInitializerAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1">clang::format::FormatStyle::ArrayInitializerAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different style for aligning array initializers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac1754a0481292dcc9959bf6fbebcd6b1a50fcc31497238d6b29539cc9fd543eae"></a>AIAS_Left&#160;</td><td class="fielddoc"><p>Align array column and left justify the columns e.g. </p>
<p>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>test demo[] =</div>
<div class="line">{</div>
<div class="line">    {56, 23,    <span class="stringliteral">&quot;hello&quot;</span>},</div>
<div class="line">    {-1, 93463, <span class="stringliteral">&quot;world&quot;</span>},</div>
<div class="line">    {7,  5,     <span class="stringliteral">&quot;!!&quot;</span>   }</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ac1754a0481292dcc9959bf6fbebcd6b1a74e3de4277f5f147442134a0f9e3091e"></a>AIAS_Right&#160;</td><td class="fielddoc"><p>Align array column and right justify the columns e.g. </p>
<p>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>test demo[] =</div>
<div class="line">{</div>
<div class="line">    {56,    23, <span class="stringliteral">&quot;hello&quot;</span>},</div>
<div class="line">    {-1, 93463, <span class="stringliteral">&quot;world&quot;</span>},</div>
<div class="line">    { 7,     5,    <span class="stringliteral">&quot;!!&quot;</span>}</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ac1754a0481292dcc9959bf6fbebcd6b1ac9d8829b59844f43bc795f01a4c3ab86"></a>AIAS_None&#160;</td><td class="fielddoc"><p>Don't align array initializer columns. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00110">110</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a937ce324270bf866adf43576f0eec42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937ce324270bf866adf43576f0eec42a">&#9670;&nbsp;</a></span>AttributeBreakingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42a">clang::format::FormatStyle::AttributeBreakingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break after attributes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a937ce324270bf866adf43576f0eec42aa9822cd1742e1afa43ebedbcfc1d5945d"></a>ABS_Always&#160;</td><td class="fielddoc"><p>Always break after attributes. </p>
<div class="fragment"><div class="line">[[maybe_unused]]</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> i;</div>
<div class="line">[[gnu::const]] [[maybe_unused]]</div>
<div class="line"><span class="keywordtype">int</span> j;</div>
<div class="line"> </div>
<div class="line">[[nodiscard]]</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">int</span> f();</div>
<div class="line">[[gnu::const]] [[nodiscard]]</div>
<div class="line"><span class="keywordtype">int</span> g();</div>
<div class="line"> </div>
<div class="line">[[likely]]</div>
<div class="line"><span class="keywordflow">if</span> (a)</div>
<div class="line">  f();</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  g();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">[[unlikely]]</div>
<div class="line"><span class="keywordflow">case</span> 1:</div>
<div class="line">  ++<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">[[likely]]</div>
<div class="line"><span class="keywordflow">default</span>:</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a373e9fc646873cd20f2c9fdb7125a207"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div><div class="ttdeci">__device__ __2f16 b</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00303">__clang_hip_libdevice_declares.h:303</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a937ce324270bf866adf43576f0eec42aa0689eac5930ddc74fe4616c67d2ab0b7"></a>ABS_Leave&#160;</td><td class="fielddoc"><p>Leave the line breaking after attributes as is. </p>
<div class="fragment"><div class="line">[[maybe_unused]] <span class="keyword">const</span> <span class="keywordtype">int</span> i;</div>
<div class="line">[[gnu::const]] [[maybe_unused]]</div>
<div class="line"><span class="keywordtype">int</span> j;</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">inline</span> <span class="keywordtype">int</span> f();</div>
<div class="line">[[gnu::const]] [[nodiscard]]</div>
<div class="line"><span class="keywordtype">int</span> g();</div>
<div class="line"> </div>
<div class="line">[[likely]] <span class="keywordflow">if</span> (a)</div>
<div class="line">  f();</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  g();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">[[unlikely]] <span class="keywordflow">case</span> 1:</div>
<div class="line">  ++<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">[[likely]]</div>
<div class="line"><span class="keywordflow">default</span>:</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a937ce324270bf866adf43576f0eec42aa587768dd4bdb784de605863818dcdb38"></a>ABS_Never&#160;</td><td class="fielddoc"><p>Never break after attributes. </p>
<div class="fragment"><div class="line">[[maybe_unused]] <span class="keyword">const</span> <span class="keywordtype">int</span> i;</div>
<div class="line">[[gnu::const]] [[maybe_unused]] <span class="keywordtype">int</span> j;</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">inline</span> <span class="keywordtype">int</span> f();</div>
<div class="line">[[gnu::const]] [[nodiscard]] <span class="keywordtype">int</span> g();</div>
<div class="line"> </div>
<div class="line">[[likely]] <span class="keywordflow">if</span> (a)</div>
<div class="line">  f();</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  g();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">[[unlikely]] <span class="keywordflow">case</span> 1:</div>
<div class="line">  ++<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">[[likely]] <span class="keywordflow">default</span>:</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01529">1529</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a34f7b0cd30443b4c10869175b520e934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f7b0cd30443b4c10869175b520e934">&#9670;&nbsp;</a></span>BinaryOperatorStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934">clang::format::FormatStyle::BinaryOperatorStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The style of breaking before or after binary operators. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34f7b0cd30443b4c10869175b520e934a9d57aa85a8ceeb7d5e6d4edba98f7381"></a>BOS_None&#160;</td><td class="fielddoc"><p>Break after operators. </p>
<div class="fragment"><div class="line">LooooooooooongType loooooooooooooooooooooongVariable =</div>
<div class="line">    someLooooooooooooooooongFunction();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +</div>
<div class="line">                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==</div>
<div class="line">                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;</div>
<div class="line">             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;</div>
<div class="line">                 ccccccccccccccccccccccccccccccccccccccccc;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a34f7b0cd30443b4c10869175b520e934aeab59ce2d6f6ae021be6e620185f4912"></a>BOS_NonAssignment&#160;</td><td class="fielddoc"><p>Break before operators that aren't assignments. </p>
<div class="fragment"><div class="line">LooooooooooongType loooooooooooooooooooooongVariable =</div>
<div class="line">    someLooooooooooooooooongFunction();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                 == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">             &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                    &gt; ccccccccccccccccccccccccccccccccccccccccc;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a34f7b0cd30443b4c10869175b520e934a64dd76a9db3b40a67d4654176227ca2c"></a>BOS_All&#160;</td><td class="fielddoc"><p>Break before operators. </p>
<div class="fragment"><div class="line">LooooooooooongType loooooooooooooooooooooongVariable</div>
<div class="line">    = someLooooooooooooooooongFunction();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                 == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">             &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</div>
<div class="line">                    &gt; ccccccccccccccccccccccccccccccccccccccccc;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01650">1650</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a299636b6bf3abfe22e688270dd44c3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299636b6bf3abfe22e688270dd44c3b2">&#9670;&nbsp;</a></span>BinPackStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2">clang::format::FormatStyle::BinPackStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The style of wrapping parameters on the same line (bin-packed) or on one line each. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a299636b6bf3abfe22e688270dd44c3b2a1f7ce6adb0c445ad64ea4f36fb7ae777"></a>BPS_Auto&#160;</td><td class="fielddoc"><p>Automatically determine parameter bin-packing behavior. </p>
</td></tr>
<tr><td class="fieldname"><a id="a299636b6bf3abfe22e688270dd44c3b2aa26312a15114d0f05c1d2528e4f8f88c"></a>BPS_Always&#160;</td><td class="fielddoc"><p>Always bin-pack parameters. </p>
</td></tr>
<tr><td class="fieldname"><a id="a299636b6bf3abfe22e688270dd44c3b2a125523cc4dd0cf72acd2dc07c505d583"></a>BPS_Never&#160;</td><td class="fielddoc"><p>Never bin-pack parameters. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01640">1640</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a97aab3da546bc93a6c14047372d920b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97aab3da546bc93a6c14047372d920b4">&#9670;&nbsp;</a></span>BitFieldColonSpacingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4">clang::format::FormatStyle::BitFieldColonSpacingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Styles for adding spacing around <code>:</code> in bitfield definitions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a97aab3da546bc93a6c14047372d920b4a66b04c683bcb08ce80edbae4f5ff69ef"></a>BFCS_Both&#160;</td><td class="fielddoc"><p>Add one space on each side of the <code>:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> bf : 2;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a97aab3da546bc93a6c14047372d920b4a7c9d73fbbff8b21140713df7b6862c91"></a>BFCS_None&#160;</td><td class="fielddoc"><p>Add no space around the <code>:</code> (except when needed for <code>AlignConsecutiveBitFields</code>). </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> bf:2;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a97aab3da546bc93a6c14047372d920b4a725a5c3bd20c40de91d9f0d9714b8d29"></a>BFCS_Before&#160;</td><td class="fielddoc"><p>Add space before the <code>:</code> only. </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> bf :2;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a97aab3da546bc93a6c14047372d920b4ae2c32801a32193bd4e745c4eb8ed70b3"></a>BFCS_After&#160;</td><td class="fielddoc"><p>Add space after the <code>:</code> only (space may be added before if needed for <code>AlignConsecutiveBitFields</code>). </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> bf: 2;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01173">1173</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a931e5c3eb76618e18dfdcff4677d98d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931e5c3eb76618e18dfdcff4677d98d7">&#9670;&nbsp;</a></span>BraceBreakingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7">clang::format::FormatStyle::BraceBreakingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to attach braces to their surrounding context. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7aea9196ec59731ddd6e997f063ae9cabc"></a>BS_Attach&#160;</td><td class="fielddoc"><p>Always attach braces to surrounding context. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> (i) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>: {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    baz(2);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
<div class="ttc" id="anamespaceAttributeLangSupport_html_a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e"><div class="ttname"><a href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">AttributeLangSupport::C</a></div><div class="ttdeci">@ C</div><div class="ttdef"><b>Definition:</b> <a href="SemaDeclAttr_8cpp_source.html#l00062">SemaDeclAttr.cpp:62</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a90651ce12fddb7c4099d48b10457059b"></a>BS_Linux&#160;</td><td class="fielddoc"><p>Like <code>Attach</code>, but break before braces on function, namespace and class definitions. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N</div>
<div class="line">{</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> (i) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>: {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    baz(2);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a47593c47a7e5af86555000f16f3e140e"></a>BS_Mozilla&#160;</td><td class="fielddoc"><p>Like <code>Attach</code>, but break before braces on enum, function, and record definitions. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line"><span class="keyword">enum</span> E</div>
<div class="line">{</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> (i) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>: {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    baz(2);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a791f92a5bb45f402345d9c92669a02a6"></a>BS_Stroustrup&#160;</td><td class="fielddoc"><p>Like <code>Attach</code>, but break before function definitions, <code>catch</code>, and <code>else</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> (i) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>: {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    baz(2);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a7916b04cf2c230741a0f9d7c18fd86ff"></a>BS_Allman&#160;</td><td class="fielddoc"><p>Always break before braces. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N</div>
<div class="line">{</div>
<div class="line"><span class="keyword">enum</span> E</div>
<div class="line">{</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (i)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> 1:</div>
<div class="line">      {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  {</div>
<div class="line">    baz(2);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a475d68c91e641fcea210d216fafddb57"></a>BS_Whitesmiths&#160;</td><td class="fielddoc"><p>Like <code>Allman</code> but always indent braces and line up code with braces. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N</div>
<div class="line">  {</div>
<div class="line"><span class="keyword">enum</span> E</div>
<div class="line">  {</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">  {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">  {</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">switch</span> (i)</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> 1:</div>
<div class="line">        {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line">      } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  {</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">    {</div>
<div class="line">    baz(2);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">    baz(5);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">  } <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7aba9d6211d1102561c47c7c503c866e00"></a>BS_GNU&#160;</td><td class="fielddoc"><p>Always break before braces and add an extra level of indentation to braces of control statements, not to those of class, function or other definitions. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N</div>
<div class="line">{</div>
<div class="line"><span class="keyword">enum</span> E</div>
<div class="line">{</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">do</span></div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">switch</span> (i)</div>
<div class="line">            {</div>
<div class="line">            <span class="keywordflow">case</span> 1:</div>
<div class="line">              {</div>
<div class="line">                foobar();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">              }</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">              {</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">      <span class="keywordflow">while</span> (--i);</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      handleError();</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">    {</div>
<div class="line">      baz(2);</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      baz(5);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7a9e4e3f5416dfb66c84e061f00ba80339"></a>BS_WebKit&#160;</td><td class="fielddoc"><p>Like <code>Attach</code>, but break before functions. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  E1,</div>
<div class="line">  E2,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> baz(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">switch</span> (i) {</div>
<div class="line">      <span class="keywordflow">case</span> 1: {</div>
<div class="line">        foobar();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">default</span>: {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">while</span> (--i);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">    handleError();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    baz(2);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    baz(5);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() { foo(<span class="keyword">true</span>); }</div>
<div class="line">} <span class="comment">// namespace N</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a931e5c3eb76618e18dfdcff4677d98d7ab88e9ff5c5c751874ff5ebb85f5bff0a"></a>BS_Custom&#160;</td><td class="fielddoc"><p>Configure each individual brace in <code>BraceWrapping</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01694">1694</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a8d75612e11d2b3f9881d67d141b2dace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d75612e11d2b3f9881d67d141b2dace">&#9670;&nbsp;</a></span>BraceWrappingAfterControlStatementStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d75612e11d2b3f9881d67d141b2dace">clang::format::FormatStyle::BraceWrappingAfterControlStatementStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to wrap braces after control statements. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d75612e11d2b3f9881d67d141b2daceae79ccd4bfb9d6a9c985ac2124e5b2d81"></a>BWACS_Never&#160;</td><td class="fielddoc"><p>Never wrap braces after a control statement. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (foo()) {</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8d75612e11d2b3f9881d67d141b2daceaee7c71e0aa38ebbde62c0768efe77f52"></a>BWACS_MultiLine&#160;</td><td class="fielddoc"><p>Only wrap braces after a multi-line control statement. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (foo &amp;&amp; bar &amp;&amp;</div>
<div class="line">    baz)</div>
<div class="line">{</div>
<div class="line">  quux();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span> (foo || bar) {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8d75612e11d2b3f9881d67d141b2daceae123131341d968f4827e2dbce8d45869"></a>BWACS_Always&#160;</td><td class="fielddoc"><p>Always wrap braces after a control statement. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (foo())</div>
<div class="line">{</div>
<div class="line">} <span class="keywordflow">else</span></div>
<div class="line">{}</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i)</div>
<div class="line">{}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01235">1235</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a442fa38afc320ec9b6d9e1f569c81060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442fa38afc320ec9b6d9e1f569c81060">&#9670;&nbsp;</a></span>BracketAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060">clang::format::FormatStyle::BracketAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for aligning after open brackets. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a442fa38afc320ec9b6d9e1f569c81060ac33c64a6bce2e25d9f7a4894727a9a9a"></a>BAS_Align&#160;</td><td class="fielddoc"><p>Align parameters on the open bracket, e.g. </p>
<p>: </p><div class="fragment"><div class="line">someLongFunction(argument1,</div>
<div class="line">                 argument2);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a442fa38afc320ec9b6d9e1f569c81060a4b171eda48af6a398909c9a40fe4d4e3"></a>BAS_DontAlign&#160;</td><td class="fielddoc"><p>Don't align, instead use <code>ContinuationIndentWidth</code>, e.g. </p>
<p>: </p><div class="fragment"><div class="line">someLongFunction(argument1,</div>
<div class="line">    argument2);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a442fa38afc320ec9b6d9e1f569c81060a5031bf7df909e2bcd7d9a08850f7d1bf"></a>BAS_AlwaysBreak&#160;</td><td class="fielddoc"><p>Always break after an open bracket, if the parameters don't fit on a single line, e.g. </p>
<p>: </p><div class="fragment"><div class="line">someLongFunction(</div>
<div class="line">    argument1, argument2);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a442fa38afc320ec9b6d9e1f569c81060aa87adad0d79820a483c0998ca54bed27"></a>BAS_BlockIndent&#160;</td><td class="fielddoc"><p>Always break after an open bracket, if the parameters don't fit on a single line. </p>
<p>Closing brackets will be placed on a new line. E.g.: </p><div class="fragment"><div class="line">someLongFunction(</div>
<div class="line">    argument1, argument2</div>
<div class="line">)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This currently only applies to braced initializer lists (when <code>Cpp11BracedListStyle</code> is <code>true</code>) and parentheses. \endnote </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00066">66</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="aa3afcf7e5f9283420a641641e1d449d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3afcf7e5f9283420a641641e1d449d7">&#9670;&nbsp;</a></span>BreakBeforeConceptDeclarationsStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7">clang::format::FormatStyle::BreakBeforeConceptDeclarationsStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break before concept declarations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3afcf7e5f9283420a641641e1d449d7aa9515259259e80421c6734ffd4e410de"></a>BBCDS_Never&#160;</td><td class="fielddoc"><p>Keep the template declaration line together with <code>concept</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; concept <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> = ...;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="aa3afcf7e5f9283420a641641e1d449d7a7799d7006881adc1f084ab98ce2f2a9a"></a>BBCDS_Allowed&#160;</td><td class="fielddoc"><p>Breaking between template declaration and <code>concept</code> is allowed. </p>
<p>The actual behavior depends on the content and line breaking rules and penalties. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3afcf7e5f9283420a641641e1d449d7addc77038584b1de1ec6c647c7a9c49b5"></a>BBCDS_Always&#160;</td><td class="fielddoc"><p>Always break before <code>concept</code>, putting it in the line after the template declaration. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">concept <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> = ...;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02129">2129</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a47a1ef53a5e87b6bfecc81141f250d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a1ef53a5e87b6bfecc81141f250d98">&#9670;&nbsp;</a></span>BreakBeforeInlineASMColonStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98">clang::format::FormatStyle::BreakBeforeInlineASMColonStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break ASM parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a47a1ef53a5e87b6bfecc81141f250d98aa019fbaee682d2c67fff81bece6d7266"></a>BBIAS_Never&#160;</td><td class="fielddoc"><p>No break before inline ASM colon. </p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;string&quot;</span>, : : val);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a47a1ef53a5e87b6bfecc81141f250d98a38a97a050d5f995cc74cab76e8c0b9cc"></a>BBIAS_OnlyMultiline&#160;</td><td class="fielddoc"><p>Break before inline ASM colon if the line length is longer than column limit. </p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;string&quot;</span>, : : val);</div>
<div class="line"><span class="keyword">asm</span>(<span class="stringliteral">&quot;cmoveq %1, %2, %[result]&quot;</span></div>
<div class="line">    : [result] <span class="stringliteral">&quot;=r&quot;</span>(result)</div>
<div class="line">    : <span class="stringliteral">&quot;r&quot;</span>(test), <span class="stringliteral">&quot;r&quot;</span>(<span class="keyword">new</span>), <span class="stringliteral">&quot;[result]&quot;</span>(old));</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a47a1ef53a5e87b6bfecc81141f250d98a0997d42789ec9f24c2b4eb4e1b764ec7"></a>BBIAS_Always&#160;</td><td class="fielddoc"><p>Always break before inline ASM colon. </p>
<div class="fragment"><div class="line"><span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;string&quot;</span>,</div>
<div class="line">             :</div>
<div class="line">             : val);</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02153">2153</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a87cc60ebba19ff17e09ed2dd63d22cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cc60ebba19ff17e09ed2dd63d22cba">&#9670;&nbsp;</a></span>BreakBeforeNoexceptSpecifierStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cba">clang::format::FormatStyle::BreakBeforeNoexceptSpecifierStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break before a noexcept specifier. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a87cc60ebba19ff17e09ed2dd63d22cbaa18e5651184ffd2ebf654359cbe476096"></a>BBNSS_Never&#160;</td><td class="fielddoc"><p>No line break allowed. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> arg1,</div>
<div class="line">         <span class="keywordtype">double</span> arg2) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar(<span class="keywordtype">int</span> arg1, <span class="keywordtype">double</span> arg2) noexcept(</div>
<div class="line">    noexcept(baz(arg1)) &amp;&amp;</div>
<div class="line">    noexcept(baz(arg2)));</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a87cc60ebba19ff17e09ed2dd63d22cbaa7c93a67ad33e3e60f06de2f48b33737f"></a>BBNSS_OnlyWithParen&#160;</td><td class="fielddoc"><p>For a simple <code>noexcept</code> there is no line break allowed, but when we have a condition it is. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> arg1,</div>
<div class="line">         <span class="keywordtype">double</span> arg2) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar(<span class="keywordtype">int</span> arg1, <span class="keywordtype">double</span> arg2)</div>
<div class="line">    noexcept(noexcept(baz(arg1)) &amp;&amp;</div>
<div class="line">             noexcept(baz(arg2)));</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a87cc60ebba19ff17e09ed2dd63d22cbaa6f97baef8b9654a48bfab6666c25e40e"></a>BBNSS_Always&#160;</td><td class="fielddoc"><p>Line breaks are allowed. </p>
<p>But note that because of the associated penalties <code>clang-format</code> often prefers not to break before the <code>noexcept</code>. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> arg1,</div>
<div class="line">         <span class="keywordtype">double</span> arg2) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar(<span class="keywordtype">int</span> arg1, <span class="keywordtype">double</span> arg2)</div>
<div class="line">    noexcept(noexcept(baz(arg1)) &amp;&amp;</div>
<div class="line">             noexcept(baz(arg2)));</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00654">654</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a2d560a46760acc52913885971cd50790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d560a46760acc52913885971cd50790">&#9670;&nbsp;</a></span>BreakConstructorInitializersStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790">clang::format::FormatStyle::BreakConstructorInitializersStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break initializers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2d560a46760acc52913885971cd50790adf0f16c8dd6847ba88d88982b7747764"></a>BCIS_BeforeColon&#160;</td><td class="fielddoc"><p>Break constructor initializers before the colon and after the commas. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : initializer1(),</div>
<div class="line">      initializer2()</div>
<div class="ttc" id="anamespaceclang_1_1index_html_a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6"><div class="ttname"><a href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">clang::index::SymbolKind::Constructor</a></div><div class="ttdeci">@ Constructor</div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2d560a46760acc52913885971cd50790ae824b840b6e16d8ec3f8d2510a95ce18"></a>BCIS_BeforeComma&#160;</td><td class="fielddoc"><p>Break constructor initializers before the colon and commas, and align the commas with the colon. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : initializer1()</div>
<div class="line">    , initializer2()</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2d560a46760acc52913885971cd50790a3a3a0499c51e4ee5ba592ac10fad4c0f"></a>BCIS_AfterColon&#160;</td><td class="fielddoc"><p>Break constructor initializers after the colon and commas. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>() :</div>
<div class="line">    initializer1(),</div>
<div class="line">    initializer2()</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02197">2197</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a7bbc9f42236eefecf84f381fedf1fa98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbc9f42236eefecf84f381fedf1fa98">&#9670;&nbsp;</a></span>BreakInheritanceListStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98">clang::format::FormatStyle::BreakInheritanceListStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break inheritance list. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7bbc9f42236eefecf84f381fedf1fa98a6b7874b172bd466d534a7d91228259f3"></a>BILS_BeforeColon&#160;</td><td class="fielddoc"><p>Break inheritance list before the colon and after the commas. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">    : Base1,</div>
<div class="line">      Base2</div>
<div class="line">{};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7bbc9f42236eefecf84f381fedf1fa98a6dd5fa85b18b8b065bf338ad633b3f0d"></a>BILS_BeforeComma&#160;</td><td class="fielddoc"><p>Break inheritance list before the colon and commas, and align the commas with the colon. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div>
<div class="line">    : Base1</div>
<div class="line">    , Base2</div>
<div class="line">{};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7bbc9f42236eefecf84f381fedf1fa98a427999218a4aae73d51dbb8e4c322a7d"></a>BILS_AfterColon&#160;</td><td class="fielddoc"><p>Break inheritance list after the colon and commas. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo :</div>
<div class="line">    Base1,</div>
<div class="line">    Base2</div>
<div class="line">{};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7bbc9f42236eefecf84f381fedf1fa98a4c6e599af52e47842b5bc9464f533503"></a>BILS_AfterComma&#160;</td><td class="fielddoc"><p>Break inheritance list only after the commas. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo : Base1,</div>
<div class="line">            Base2</div>
<div class="line">{};</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02312">2312</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a633755f5bf183748346c97afa9578a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633755f5bf183748346c97afa9578a0c">&#9670;&nbsp;</a></span>BreakTemplateDeclarationsStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0c">clang::format::FormatStyle::BreakTemplateDeclarationsStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break after the template declaration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a633755f5bf183748346c97afa9578a0cacbcee241ea93a28c5d430eb468585cbf"></a>BTDS_Leave&#160;</td><td class="fielddoc"><p>Do not change the line breaking before the declaration. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo() {</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">                            <span class="keywordtype">int</span> bbbbbbbbbbbbbbbbbbbbb) {</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceclang_html_acb831cdeb9db42e534558aeff11c9b8b"><div class="ttname"><a href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">clang::T</a></div><div class="ttdeci">const FunctionProtoType * T</div><div class="ttdef"><b>Definition:</b> <a href="RecursiveASTVisitor_8h_source.html#l01339">RecursiveASTVisitor.h:1339</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a633755f5bf183748346c97afa9578a0ca4be5aa5d52aeb733972530bc2adac9d2"></a>BTDS_No&#160;</td><td class="fielddoc"><p>Do not force break before declaration. </p>
<p><code>PenaltyBreakTemplateDeclaration</code> is taken into account. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo() {</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">                            <span class="keywordtype">int</span> bbbbbbbbbbbbbbbbbbbbb) {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a633755f5bf183748346c97afa9578a0ca557bfcf068a872b935807115ed262c9d"></a>BTDS_MultiLine&#160;</td><td class="fielddoc"><p>Force break after template declaration only when the following declaration spans multiple lines. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo() {</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">      <span class="keywordtype">int</span> bbbbbbbbbbbbbbbbbbbbb) {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a633755f5bf183748346c97afa9578a0caa2f1c37eaed2de6087bf393e7da23f8e"></a>BTDS_Yes&#160;</td><td class="fielddoc"><p>Always break after template declaration. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo() {</div>
<div class="line">}</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> foo(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">      <span class="keywordtype">int</span> bbbbbbbbbbbbbbbbbbbbb) {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01069">1069</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a8738b2eed1291b5c9984003dd5a306f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8738b2eed1291b5c9984003dd5a306f6">&#9670;&nbsp;</a></span>DAGArgStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6">clang::format::FormatStyle::DAGArgStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to control the format inside TableGen DAGArg. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8738b2eed1291b5c9984003dd5a306f6a71fe0df8e05821437af50a99ec275b5d"></a>DAS_DontBreak&#160;</td><td class="fielddoc"><p>Never break inside DAGArg. </p>
<div class="fragment"><div class="line">let DAGArgIns = (ins i32:$src1, i32:$src2);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8738b2eed1291b5c9984003dd5a306f6a0638c6b7b3661783fa196fd5c96751c3"></a>DAS_BreakElements&#160;</td><td class="fielddoc"><p>Break inside DAGArg after each list element but for the last. </p>
<p>This aligns to the first element. </p><div class="fragment"><div class="line">let DAGArgIns = (ins i32:$src1,</div>
<div class="line">                     i32:$src2);</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8738b2eed1291b5c9984003dd5a306f6afe6e8fccc240026e67dc75af000fa17f"></a>DAS_BreakAll&#160;</td><td class="fielddoc"><p>Break inside DAGArg after the operator and the all elements. </p>
<div class="fragment"><div class="line">let DAGArgIns = (ins</div>
<div class="line">    i32:$src1,</div>
<div class="line">    i32:$src2</div>
<div class="line">);</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04787">4787</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="abdc06eef4565a8cdcd858356750a4181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc06eef4565a8cdcd858356750a4181">&#9670;&nbsp;</a></span>DefinitionReturnTypeBreakingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181">clang::format::FormatStyle::DefinitionReturnTypeBreakingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break after the function definition return type. </p>
<p>This option is <b>deprecated</b> and is retained for backwards compatibility. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abdc06eef4565a8cdcd858356750a4181aff5139d2fea20ac5f0acd864be525ad0"></a>DRTBS_None&#160;</td><td class="fielddoc"><p>Break after return type automatically. </p>
<p><code>PenaltyReturnTypeOnItsOwnLine</code> is taken into account. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdc06eef4565a8cdcd858356750a4181a0b175c67d5aa73f775a9eb3c6dcdbb99"></a>DRTBS_All&#160;</td><td class="fielddoc"><p>Always break after the return type. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdc06eef4565a8cdcd858356750a4181a7dd0a60474b73a0c3c1643cfca22ccff"></a>DRTBS_TopLevel&#160;</td><td class="fielddoc"><p>Always break after the return types of top-level functions. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00939">939</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="abd49000e263fa5f5ebcd7a490a108422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd49000e263fa5f5ebcd7a490a108422">&#9670;&nbsp;</a></span>EmptyLineAfterAccessModifierStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422">clang::format::FormatStyle::EmptyLineAfterAccessModifierStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for empty line after access modifiers. </p>
<p><code>EmptyLineBeforeAccessModifier</code> configuration handles the number of empty lines between two access modifiers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd49000e263fa5f5ebcd7a490a108422a7ccd6a24affb7af9940f3d263f22bfc1"></a>ELAAMS_Never&#160;</td><td class="fielddoc"><p>Remove all empty lines after access modifiers. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">int</span> j;</div>
<div class="line">  <span class="comment">/* comment */</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  foo() {}</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="abd49000e263fa5f5ebcd7a490a108422ac023d36aed05144c42e8ea358a58244d"></a>ELAAMS_Leave&#160;</td><td class="fielddoc"><p>Keep existing empty lines after access modifiers. </p>
<p>MaxEmptyLinesToKeep is applied instead. </p>
</td></tr>
<tr><td class="fieldname"><a id="abd49000e263fa5f5ebcd7a490a108422a4d550afebd682ab7aa2b3dd5e8f81b63"></a>ELAAMS_Always&#160;</td><td class="fielddoc"><p>Always add empty line after access modifiers if there are none. </p>
<p>MaxEmptyLinesToKeep is applied also. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> j;</div>
<div class="line">  <span class="comment">/* comment */</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">  foo() {}</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02443">2443</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a2c08778fc0e59e3f1f2888da08f854d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c08778fc0e59e3f1f2888da08f854d5">&#9670;&nbsp;</a></span>EmptyLineBeforeAccessModifierStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5">clang::format::FormatStyle::EmptyLineBeforeAccessModifierStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for empty line before access modifiers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2c08778fc0e59e3f1f2888da08f854d5a66ee6e5192a7a21da3f06c8ff93e2618"></a>ELBAMS_Never&#160;</td><td class="fielddoc"><p>Remove all empty lines before access modifiers. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">int</span> j;</div>
<div class="line">  <span class="comment">/* comment */</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  foo() {}</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2c08778fc0e59e3f1f2888da08f854d5ab53e2520a121e8a22fbbe9199bfd227c"></a>ELBAMS_Leave&#160;</td><td class="fielddoc"><p>Keep existing empty lines before access modifiers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2c08778fc0e59e3f1f2888da08f854d5a5bf2bf5683607166542a6ae434767b14"></a>ELBAMS_LogicalBlock&#160;</td><td class="fielddoc"><p>Add empty line only when access modifier starts a new logical block. </p>
<p>Logical block is a group of one or more member fields or functions. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">int</span> j;</div>
<div class="line">  <span class="comment">/* comment */</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  foo() {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2c08778fc0e59e3f1f2888da08f854d5a953605f9b5c8c7f90f8edf5d488f8a6e"></a>ELBAMS_Always&#160;</td><td class="fielddoc"><p>Always add empty line before access modifiers unless access modifier is at the start of struct or class definition. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keywordtype">int</span> j;</div>
<div class="line">  <span class="comment">/* comment */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  foo() {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02492">2492</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ac8cfc28e8e1e440535df98dbf25b10c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfc28e8e1e440535df98dbf25b10c3">&#9670;&nbsp;</a></span>EscapedNewlineAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3">clang::format::FormatStyle::EscapedNewlineAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for aligning escaped newlines. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac8cfc28e8e1e440535df98dbf25b10c3a86f6ce26b0ff956213c5b541ac30b00a"></a>ENAS_DontAlign&#160;</td><td class="fielddoc"><p>Don't align escaped newlines. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define A \</span></div>
<div class="line"><span class="preprocessor">  int aaaa; \</span></div>
<div class="line"><span class="preprocessor">  int b; \</span></div>
<div class="line"><span class="preprocessor">  int dddddddddd;</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ac8cfc28e8e1e440535df98dbf25b10c3a88c07f69f780b920cc5fe0857f46ce06"></a>ENAS_Left&#160;</td><td class="fielddoc"><p>Align escaped newlines as far left as possible. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="preprocessor">#define A   \</span></div>
<div class="line"><span class="preprocessor">  int aaaa; \</span></div>
<div class="line"><span class="preprocessor">  int b;    \</span></div>
<div class="line"><span class="preprocessor">  int dddddddddd;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ac8cfc28e8e1e440535df98dbf25b10c3a97139aea4f632f028d2ed431db5fa9df"></a>ENAS_Right&#160;</td><td class="fielddoc"><p>Align escaped newlines in the right-most column. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define A                                                                      \</span></div>
<div class="line"><span class="preprocessor">  int aaaa;                                                                    \</span></div>
<div class="line"><span class="preprocessor">  int b;                                                                       \</span></div>
<div class="line"><span class="preprocessor">  int dddddddddd;</span></div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00453">453</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a2db12bb7ed75faac357b59e0a34a08f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db12bb7ed75faac357b59e0a34a08f6">&#9670;&nbsp;</a></span>IndentExternBlockStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6">clang::format::FormatStyle::IndentExternBlockStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indents extern blocks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2db12bb7ed75faac357b59e0a34a08f6a4c263042111cd04992d8100039f151e5"></a>IEBS_AfterExternBlock&#160;</td><td class="fielddoc"><p>Backwards compatible with AfterExternBlock's indenting. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#afd0c1858076c92847069daa7b3f5cb1f">IndentExternBlock</a>: AfterExternBlock</div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#ac88441d1706049a6098e892dd6e730df">BraceWrapping</a>.<a class="code" href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html#afdc9285b5f00c4ee81e85afd56b08db8">AfterExternBlock</a>: <span class="keyword">true</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> foo();</div>
<div class="line">}</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags_html_afdc9285b5f00c4ee81e85afd56b08db8"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html#afdc9285b5f00c4ee81e85afd56b08db8">clang::format::FormatStyle::BraceWrappingFlags::AfterExternBlock</a></div><div class="ttdeci">bool AfterExternBlock</div><div class="ttdoc">Wrap extern blocks.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l01396">Format.h:1396</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_ac88441d1706049a6098e892dd6e730df"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#ac88441d1706049a6098e892dd6e730df">clang::format::FormatStyle::BraceWrapping</a></div><div class="ttdeci">BraceWrappingFlags BraceWrapping</div><div class="ttdoc">Control of individual brace wrapping cases.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l01513">Format.h:1513</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_afd0c1858076c92847069daa7b3f5cb1f"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#afd0c1858076c92847069daa7b3f5cb1f">clang::format::FormatStyle::IndentExternBlock</a></div><div class="ttdeci">IndentExternBlockStyle IndentExternBlock</div><div class="ttdoc">IndentExternBlockStyle is the type of indenting of extern blocks.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l02750">Format.h:2750</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#afd0c1858076c92847069daa7b3f5cb1f">IndentExternBlock</a>: AfterExternBlock</div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#ac88441d1706049a6098e892dd6e730df">BraceWrapping</a>.<a class="code" href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html#afdc9285b5f00c4ee81e85afd56b08db8">AfterExternBlock</a>: <span class="keyword">false</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="keywordtype">void</span> foo();</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2db12bb7ed75faac357b59e0a34a08f6ad1388b96f5ca4596c51625ddb27c78f7"></a>IEBS_NoIndent&#160;</td><td class="fielddoc"><p>Does not indent extern blocks. </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line"><span class="keywordtype">void</span> foo();</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a2db12bb7ed75faac357b59e0a34a08f6a842a2f317f26f0f291d4c927338ba71d"></a>IEBS_Indent&#160;</td><td class="fielddoc"><p>Indents extern blocks. </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">  <span class="keywordtype">void</span> foo();</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02713">2713</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a8daad6d27cb88ae2796e2603faef4131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daad6d27cb88ae2796e2603faef4131">&#9670;&nbsp;</a></span>JavaScriptQuoteStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131">clang::format::FormatStyle::JavaScriptQuoteStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quotation styles for JavaScript strings. </p>
<p>Does not affect template strings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8daad6d27cb88ae2796e2603faef4131aa0c94ef85bf0bb8d2611321e196eef21"></a>JSQS_Leave&#160;</td><td class="fielddoc"><p>Leave string quotes as they are. </p>
<div class="fragment"><div class="line">string1 = &quot;foo&quot;;</div>
<div class="line">string2 = &#39;bar&#39;;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8daad6d27cb88ae2796e2603faef4131a4793f6a583579bdc9f7b71314b2e56a0"></a>JSQS_Single&#160;</td><td class="fielddoc"><p>Always use single quotes. </p>
<div class="fragment"><div class="line">string1 = &#39;foo&#39;;</div>
<div class="line">string2 = &#39;bar&#39;;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8daad6d27cb88ae2796e2603faef4131a25666015392debaeddb9aa45db85ad88"></a>JSQS_Double&#160;</td><td class="fielddoc"><p>Always use double quotes. </p>
<div class="fragment"><div class="line">string1 = &quot;foo&quot;;</div>
<div class="line">string2 = &quot;bar&quot;;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03018">3018</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a49fa34a2ee0f9c4f37aa0823ee37a1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fa34a2ee0f9c4f37aa0823ee37a1ff">&#9670;&nbsp;</a></span>LambdaBodyIndentationKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ff">clang::format::FormatStyle::LambdaBodyIndentationKind</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indentation logic for lambda bodies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a49fa34a2ee0f9c4f37aa0823ee37a1ffab07c5425730a3c292f6f7add6c641afa"></a>LBI_Signature&#160;</td><td class="fielddoc"><p>Align lambda body relative to the lambda signature. </p>
<p>This is the default. </p><div class="fragment"><div class="line">someMethod(</div>
<div class="line">    [](SomeReallyLongLambdaSignatureArgument foo) {</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    });</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a49fa34a2ee0f9c4f37aa0823ee37a1ffa32326fefff5993f586320a7159ea52f2"></a>LBI_OuterScope&#160;</td><td class="fielddoc"><p>For statements within block scope, align lambda body relative to the indentation level of the outer scope the lambda signature resides in. </p>
<div class="fragment"><div class="line">someMethod(</div>
<div class="line">    [](SomeReallyLongLambdaSignatureArgument foo) {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">someMethod(someOtherMethod(</div>
<div class="line">    [](SomeReallyLongLambdaSignatureArgument foo) {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}));</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03076">3076</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a06e3e163ea545132563cad08dc8598e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3e163ea545132563cad08dc8598e6">&#9670;&nbsp;</a></span>LanguageKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">clang::format::FormatStyle::LanguageKind</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported languages. </p>
<p>When stored in a configuration file, specifies the language, that the configuration targets. When passed to the <code><a class="el" href="namespaceclang_1_1format.html#abbb16de58509fb43d8264bcd2967d484" title="Reformats the given Ranges in Code.">reformat()</a></code> function, enables syntax features specific to the language. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6a4968cb40f73594906451261a928e4a30"></a>LK_None&#160;</td><td class="fielddoc"><p>Do not use. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6a7a36eddae7a21dcff4e1e24e7c1fb977"></a>LK_Cpp&#160;</td><td class="fielddoc"><p>Should be used for C, C++. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6a29ee42e9cfaf8f4f0419b16e595ad61c"></a>LK_CSharp&#160;</td><td class="fielddoc"><p>Should be used for C#. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6a6475e29252ad0cc07fc1311f4902f32f"></a>LK_Java&#160;</td><td class="fielddoc"><p>Should be used for Java. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6a910850fd7f356fec458c6d3e89fa9549"></a>LK_JavaScript&#160;</td><td class="fielddoc"><p>Should be used for JavaScript. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6ab1e0175f4b4ffe62194e32abec987f61"></a>LK_Json&#160;</td><td class="fielddoc"><p>Should be used for JSON. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6aa001fec3f664464ef941c266d2820d6c"></a>LK_ObjC&#160;</td><td class="fielddoc"><p>Should be used for Objective-C, Objective-C++. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6aa9fa032dac725538adef82b61c8f345f"></a>LK_Proto&#160;</td><td class="fielddoc"><p>Should be used for Protocol Buffers (<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6aa7353f60b0884372b03707da8fa0d9f2"></a>LK_TableGen&#160;</td><td class="fielddoc"><p>Should be used for TableGen code. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6ac721680ad8ad0076ab751a91868130f6"></a>LK_TextProto&#160;</td><td class="fielddoc"><p>Should be used for Protocol Buffer messages in text format (<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a06e3e163ea545132563cad08dc8598e6aa73358ab961ab618376ee563ef3b5632"></a>LK_Verilog&#160;</td><td class="fielddoc"><p>Should be used for Verilog and SystemVerilog. </p>
<p><a href="https://standards.ieee.org/ieee/1800/6700/">https://standards.ieee.org/ieee/1800/6700/</a> <a href="https://sci-hub.st/10.1109/IEEESTD.2018.8299595">https://sci-hub.st/10.1109/IEEESTD.2018.8299595</a> </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03114">3114</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a8d27b8311dfb0b882b264771cbb33cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d27b8311dfb0b882b264771cbb33cb8">&#9670;&nbsp;</a></span>LanguageStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8">clang::format::FormatStyle::LanguageStandard</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported language standards for parsing and formatting C++ constructs. </p>
<div class="fragment"><div class="line">Latest:                                vector&lt;set&lt;int&gt;&gt;</div>
<div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>++03                          vs.     vector&lt;set&lt;int&gt; &gt;</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_ad55181c98da0de5b29a5afc3060fc6d0"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a></div><div class="ttdeci">__device__ __2f16 float c</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00304">__clang_hip_libdevice_declares.h:304</a></div></div>
</div><!-- fragment --><p>The correct way to spell a specific language version is e.g. <code>c++11</code>. The historical aliases <code>Cpp03</code> and <code>Cpp11</code> are deprecated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8ad690e77384ec0503c47e9f4e238a58a5"></a>LS_Cpp03&#160;</td><td class="fielddoc"><p>Parse and format as C++03. </p>
<p><code>Cpp03</code> is a deprecated alias for <code>c++03</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8ac2adca34064745a7171f70ba7e600095"></a>LS_Cpp11&#160;</td><td class="fielddoc"><p>Parse and format as C++11. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8adee7873afb157b20eab594d2939f5de7"></a>LS_Cpp14&#160;</td><td class="fielddoc"><p>Parse and format as C++14. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8a0cd9ac9d8fa729b14ebe95b434cc096c"></a>LS_Cpp17&#160;</td><td class="fielddoc"><p>Parse and format as C++17. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8ae4210fe562c7220729f098953cfb38e2"></a>LS_Cpp20&#160;</td><td class="fielddoc"><p>Parse and format as C++20. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8a8379bde7f910bb6d1d40b85ef699c467"></a>LS_Latest&#160;</td><td class="fielddoc"><p>Parse and format using the latest supported language version. </p>
<p><code>Cpp11</code> is a deprecated alias for <code>Latest</code> </p>
</td></tr>
<tr><td class="fieldname"><a id="a8d27b8311dfb0b882b264771cbb33cb8ad54fa310d0a1bb4f4893fab021db1eaf"></a>LS_Auto&#160;</td><td class="fielddoc"><p>Automatic detection based on the input. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04705">4705</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a35260df344afa7ec64c80750d37b3a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35260df344afa7ec64c80750d37b3a5d">&#9670;&nbsp;</a></span>LineEndingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5d">clang::format::FormatStyle::LineEndingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line ending style. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a35260df344afa7ec64c80750d37b3a5dae7aa50330928f7aece19664149fb307f"></a>LE_LF&#160;</td><td class="fielddoc"><p>Use <code>\n</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a35260df344afa7ec64c80750d37b3a5da580bc0b6ebaffb775a16e5f02a567e57"></a>LE_CRLF&#160;</td><td class="fielddoc"><p>Use <code>\r\n</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a35260df344afa7ec64c80750d37b3a5da2a380ca243d10c5f358b9665663e146d"></a>LE_DeriveLF&#160;</td><td class="fielddoc"><p>Use <code>\n</code> unless the input has more lines ending in <code>\r\n</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a35260df344afa7ec64c80750d37b3a5da966cf51f0637b0f6223106a5a214f175"></a>LE_DeriveCRLF&#160;</td><td class="fielddoc"><p>Use <code>\r\n</code> unless the input has more lines ending in <code>\n</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03157">3157</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ae26cac0d904a16d43ac52c049d9db622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26cac0d904a16d43ac52c049d9db622">&#9670;&nbsp;</a></span>NamespaceIndentationKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622">clang::format::FormatStyle::NamespaceIndentationKind</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to indent namespace contents. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae26cac0d904a16d43ac52c049d9db622a3c968534afc99a13a8b0bcbe43f9cc63"></a>NI_None&#160;</td><td class="fielddoc"><p>Don't indent in namespaces. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>out {</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keyword">namespace </span>in {</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae26cac0d904a16d43ac52c049d9db622af27aaa38ae3f4444e11ed3395f2152e4"></a>NI_Inner&#160;</td><td class="fielddoc"><p>Indent only in inner namespaces (nested in other namespaces). </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>out {</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keyword">namespace </span>in {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae26cac0d904a16d43ac52c049d9db622a621fbb46f7cdc63d335e071054b18f1b"></a>NI_All&#160;</td><td class="fielddoc"><p>Indent in all namespaces. </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>out {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keyword">namespace </span>in {</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03260">3260</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="af3421b3510c1cf937d2ed651942e3db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3421b3510c1cf937d2ed651942e3db6">&#9670;&nbsp;</a></span>OperandAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6">clang::format::FormatStyle::OperandAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for aligning operands. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3421b3510c1cf937d2ed651942e3db6ad9f83b1c5b619e10799dd0f8cd486286"></a>OAS_DontAlign&#160;</td><td class="fielddoc"><p>Do not align operands of binary and ternary expressions. </p>
<p>The wrapped lines are indented <code>ContinuationIndentWidth</code> spaces from the start of the line. </p>
</td></tr>
<tr><td class="fieldname"><a id="af3421b3510c1cf937d2ed651942e3db6a3be333b353f4180354569bd46a67c2c4"></a>OAS_Align&#160;</td><td class="fielddoc"><p>Horizontally align operands of binary and ternary expressions. </p>
<pre class="fragment">Specifically, this aligns operands of a single expression that needs
to be split over multiple lines, e.g.:
\code
  int aaa = bbbbbbbbbbbbbbb +
            ccccccccccccccc;
\endcode

When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is
aligned with the operand on the first line.
\code
  int aaa = bbbbbbbbbbbbbbb
            + ccccccccccccccc;
\endcode 
</pre> </td></tr>
<tr><td class="fieldname"><a id="af3421b3510c1cf937d2ed651942e3db6ac63b010eecb5202e8629fb7530b436af"></a>OAS_AlignAfterOperator&#160;</td><td class="fielddoc"><p>Horizontally align operands of binary and ternary expressions. </p>
<pre class="fragment">This is similar to ``AO_Align``, except when
``BreakBeforeBinaryOperators`` is set, the operator is un-indented so
that the wrapped operand is aligned with the operand on the first line.
\code
  int aaa = bbbbbbbbbbbbbbb
          + ccccccccccccccc;
\endcode 
</pre> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00488">488</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a73a9eec5aa0372a3e5094d1011675d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a9eec5aa0372a3e5094d1011675d23">&#9670;&nbsp;</a></span>PackConstructorInitializersStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23">clang::format::FormatStyle::PackConstructorInitializersStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to try to fit all constructor initializers on a line. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a73a9eec5aa0372a3e5094d1011675d23a3671df39a9e176b1ddcee19d1d079c37"></a>PCIS_Never&#160;</td><td class="fielddoc"><p>Always put each constructor initializer on its own line. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : a(),</div>
<div class="line">      <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a73a9eec5aa0372a3e5094d1011675d23a933db01522cbf817b01f24a9aba70242"></a>PCIS_BinPack&#160;</td><td class="fielddoc"><p>Bin-pack constructor initializers. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),</div>
<div class="line">      cccccccccccccccccccc()</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a73a9eec5aa0372a3e5094d1011675d23a36a7e09cb0a90f38ea99866963abec1f"></a>PCIS_CurrentLine&#160;</td><td class="fielddoc"><p>Put all constructor initializers on the current line if they fit. </p>
<p>Otherwise, put each one on its own line. </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>() : a(), <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(),</div>
<div class="line">      bbbbbbbbbbbbbbbbbbbb(),</div>
<div class="line">      ddddddddddddd()</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a73a9eec5aa0372a3e5094d1011675d23ad588a2a138cc6364a2793f85018ec84d"></a>PCIS_NextLine&#160;</td><td class="fielddoc"><p>Same as <code>PCIS_CurrentLine</code> except that if all constructor initializers do not fit on the current line, try to fit them on the next line. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>() : a(), <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(),</div>
<div class="line">      bbbbbbbbbbbbbbbbbbbb(),</div>
<div class="line">      cccccccccccccccccccc()</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a73a9eec5aa0372a3e5094d1011675d23a326204f09e336ba5e01e687f3c452216"></a>PCIS_NextLineOnly&#160;</td><td class="fielddoc"><p>Put all constructor initializers on the next line if they fit. </p>
<p>Otherwise, put each one on its own line. </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : a(), <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd()</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceclang_1_1index.html#a2f70a3d61ba9b8a97d8e609dcdf069dea678d0a4421b60dc59999ac02837496a6">Constructor</a>()</div>
<div class="line">    : aaaaaaaaaaaaaaaaaaaa(),</div>
<div class="line">      bbbbbbbbbbbbbbbbbbbb(),</div>
<div class="line">      cccccccccccccccccccc()</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03412">3412</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="add72d7e5bd931e683d671940ee98a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add72d7e5bd931e683d671940ee98a172">&#9670;&nbsp;</a></span>PointerAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172">clang::format::FormatStyle::PointerAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>&amp;</code>, <code>&amp;&amp;</code> and <code>*</code> alignment style. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add72d7e5bd931e683d671940ee98a172a569e57995aaf6ad19c46e6309ad6483a"></a>PAS_Left&#160;</td><td class="fielddoc"><p>Align pointer to the left. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="add72d7e5bd931e683d671940ee98a172ad0269239c6db56f256a9d8a06bddf515"></a>PAS_Right&#160;</td><td class="fielddoc"><p>Align pointer to the right. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="add72d7e5bd931e683d671940ee98a172a91002b9a99d1801057afa45a3a4609be"></a>PAS_Middle&#160;</td><td class="fielddoc"><p>Align pointer in the middle. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> * a;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03519">3519</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a48ffe13e89a74f5faa3b1f13f4dd6393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ffe13e89a74f5faa3b1f13f4dd6393">&#9670;&nbsp;</a></span>PPDirectiveIndentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393">clang::format::FormatStyle::PPDirectiveIndentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for indenting preprocessor directives. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a48ffe13e89a74f5faa3b1f13f4dd6393aad83c8f8d2db21b2ec7ec3e986a8fa20"></a>PPDIS_None&#160;</td><td class="fielddoc"><p>Does not indent any directives. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#if FOO</span></div>
<div class="line"><span class="preprocessor">#if BAR</span></div>
<div class="line"><span class="preprocessor">#include &lt;foo&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a48ffe13e89a74f5faa3b1f13f4dd6393abc42abccfa3abcef78d9efbce29d6660"></a>PPDIS_AfterHash&#160;</td><td class="fielddoc"><p>Indents directives after the hash. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#if FOO</span></div>
<div class="line"><span class="preprocessor">#  if BAR</span></div>
<div class="line"><span class="preprocessor">#    include &lt;foo&gt;</span></div>
<div class="line"><span class="preprocessor">#  endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a48ffe13e89a74f5faa3b1f13f4dd6393a9ff077700ecb94600341cb365bb07780"></a>PPDIS_BeforeHash&#160;</td><td class="fielddoc"><p>Indents directives before the hash. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#if FOO</span></div>
<div class="line"><span class="preprocessor">  #if BAR</span></div>
<div class="line"><span class="preprocessor">    #include &lt;foo&gt;</span></div>
<div class="line"><span class="preprocessor">  #endif</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02753">2753</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="af1153efd05d9632bcc0f364abfcb22ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1153efd05d9632bcc0f364abfcb22ef">&#9670;&nbsp;</a></span>QualifierAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22ef">clang::format::FormatStyle::QualifierAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different specifiers and qualifiers alignment styles. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af1153efd05d9632bcc0f364abfcb22efacac34201f377739f795951365c036f13"></a>QAS_Leave&#160;</td><td class="fielddoc"><p>Don't change specifiers/qualifiers to either Left or Right alignment (default). </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> a;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="af1153efd05d9632bcc0f364abfcb22efac0720914b91f396d5b2f5d365e611e5a"></a>QAS_Left&#160;</td><td class="fielddoc"><p>Change specifiers/qualifiers to be left-aligned. </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> *a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="af1153efd05d9632bcc0f364abfcb22efa3adf2ad904c4a3bbaf664f0da8bbe42e"></a>QAS_Right&#160;</td><td class="fielddoc"><p>Change specifiers/qualifiers to be right-aligned. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> a;</div>
<div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> *a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="af1153efd05d9632bcc0f364abfcb22efa891e29e9f0914c8735cb94aca1efcace"></a>QAS_Custom&#160;</td><td class="fielddoc"><p>Change specifiers/qualifiers to be aligned based on <code>QualifierOrder</code>. </p>
<p>With: </p><div class="fragment"><div class="line">QualifierOrder: [&#39;inline&#39;, &#39;static&#39;, &#39;type&#39;, &#39;const&#39;]</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> a;</div>
<div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> *a;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03557">3557</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ae910a8281f74d90f22d702e35f3c0ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae910a8281f74d90f22d702e35f3c0ef6">&#9670;&nbsp;</a></span>ReferenceAlignmentStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6">clang::format::FormatStyle::ReferenceAlignmentStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>&amp;</code> and <code>&amp;&amp;</code> alignment style. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae910a8281f74d90f22d702e35f3c0ef6ab931a16f1b9649a86813bd19aa870198"></a>RAS_Pointer&#160;</td><td class="fielddoc"><p>Align reference like <code>PointerAlignment</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae910a8281f74d90f22d702e35f3c0ef6ab90c8bc8fee7c3a3af7b3d9be65577c4"></a>RAS_Left&#160;</td><td class="fielddoc"><p>Align reference to the left. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>&amp; a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae910a8281f74d90f22d702e35f3c0ef6a1a855682c243f7788a8347891a23136f"></a>RAS_Right&#160;</td><td class="fielddoc"><p>Align reference to the right. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> &amp;a;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae910a8281f74d90f22d702e35f3c0ef6ae6eaa1844ac64e0dea1db42eacf86782"></a>RAS_Middle&#160;</td><td class="fielddoc"><p>Align reference in the middle. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> &amp; a;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03689">3689</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ad2fc6504442bd361923176076e427425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fc6504442bd361923176076e427425">&#9670;&nbsp;</a></span>RemoveParenthesesStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425">clang::format::FormatStyle::RemoveParenthesesStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of redundant parentheses to remove. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2fc6504442bd361923176076e427425a10d32c808feea39a9afb644d2c1b5afa"></a>RPS_Leave&#160;</td><td class="fielddoc"><p>Do not remove parentheses. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>__declspec((dllimport)) <a class="code" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a> {};</div>
<div class="line">co_return (((0)));</div>
<div class="line"><span class="keywordflow">return</span> ((a + <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) - ((<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> + d)));</div>
<div class="ttc" id="aInterpreter_2Value_8h_html_a094c3d875c5b3d55fb5307c29cfc2c18"><div class="ttname"><a href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a></div><div class="ttdeci">#define X(type, name)</div><div class="ttdef"><b>Definition:</b> <a href="Interpreter_2Value_8h_source.html#l00143">Value.h:143</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ad2fc6504442bd361923176076e427425a54e35c9df9f3c88ef60b78b0014bdf22"></a>RPS_MultipleParentheses&#160;</td><td class="fielddoc"><p>Replace multiple parentheses with single parentheses. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><span class="keyword">__declspec(dllimport)</span> <a class="code" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a> {};</div>
<div class="line">co_return (0);</div>
<div class="line"><span class="keywordflow">return</span> ((a + <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) - (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> + d));</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ad2fc6504442bd361923176076e427425a3a45e975fc83a39aad1fb8403433bd44"></a>RPS_ReturnStatement&#160;</td><td class="fielddoc"><p>Also remove parentheses enclosing the expression in a <code>return</code>/<code>co_return</code> statement. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span><span class="keyword">__declspec(dllimport)</span> <a class="code" href="Interpreter_2Value_8h.html#a094c3d875c5b3d55fb5307c29cfc2c18">X</a> {};</div>
<div class="line">co_return 0;</div>
<div class="line"><span class="keywordflow">return</span> (a + <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) - (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> + d);</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03788">3788</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a8a28e9d93da683fcceb043d62fc76f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a28e9d93da683fcceb043d62fc76f34">&#9670;&nbsp;</a></span>RequiresClausePositionStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34">clang::format::FormatStyle::RequiresClausePositionStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible positions for the requires clause. </p>
<p>The <code>IndentRequires</code> option is only used if the <code>requires</code> is put on the start of a line. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8a28e9d93da683fcceb043d62fc76f34a8e5b51ba9c091dc77a74fa5a48220af4"></a>RCPS_OwnLine&#160;</td><td class="fielddoc"><p>Always put the <code>requires</code> clause on its own line. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">requires C&lt;T&gt;</div>
<div class="line"><span class="keyword">struct </span>Foo {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt;</div>
<div class="line">requires C&lt;T&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt;</div>
<div class="line"><span class="keywordtype">void</span> baz(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t)</div>
<div class="line">requires C&lt;T&gt;</div>
<div class="line">{...</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8a28e9d93da683fcceb043d62fc76f34a92dcc7226b3c9fc3e8abfee36de8cdc3"></a>RCPS_WithPreceding&#160;</td><td class="fielddoc"><p>Try to put the clause together with the preceding part of a declaration. </p>
<p>For class templates: stick to the template declaration. For function templates: stick to the template declaration. For function declaration followed by a requires clause: stick to the parameter list. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; requires C&lt;T&gt;</div>
<div class="line"><span class="keyword">struct </span>Foo {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt; requires C&lt;T&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt;</div>
<div class="line"><span class="keywordtype">void</span> baz(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) requires C&lt;T&gt;</div>
<div class="line">{...</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8a28e9d93da683fcceb043d62fc76f34ae92346715573a8fd1f93219ca1f2193b"></a>RCPS_WithFollowing&#160;</td><td class="fielddoc"><p>Try to put the <code>requires</code> clause together with the class or function declaration. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">requires C&lt;T&gt; <span class="keyword">struct </span>Foo {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt;</div>
<div class="line">requires C&lt;T&gt; <span class="keywordtype">void</span> bar(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt;</div>
<div class="line"><span class="keywordtype">void</span> baz(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t)</div>
<div class="line">requires C&lt;T&gt; {...</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a8a28e9d93da683fcceb043d62fc76f34aabf0cfd6d1aeedd7babcb2cd0f4c61a5"></a>RCPS_SingleLine&#160;</td><td class="fielddoc"><p>Try to put everything in the same line if possible. </p>
<p>Otherwise normal line breaking rules take over. </p><div class="fragment"><div class="line"><span class="comment">// Fitting:</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; requires C&lt;T&gt; <span class="keyword">struct </span>Foo {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt; requires C&lt;T&gt; <span class="keywordtype">void</span> bar(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> <a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>&gt; <span class="keywordtype">void</span> bar(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) requires C&lt;T&gt; {...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Not fitting, one possible example:</span></div>
<div class="line">template &lt;<span class="keyword">typename</span> LongName&gt;</div>
<div class="line">requires C&lt;LongName&gt;</div>
<div class="line"><span class="keyword">struct </span>Foo {...</div>
<div class="line"> </div>
<div class="line">template &lt;<span class="keyword">typename</span> LongName&gt;</div>
<div class="line">requires C&lt;LongName&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar(LongName ln) {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> LongName&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar(LongName ln)</div>
<div class="line">    requires C&lt;LongName&gt; {</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03844">3844</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a9fe26352e2222d3d490fde5a0effead7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe26352e2222d3d490fde5a0effead7">&#9670;&nbsp;</a></span>RequiresExpressionIndentationKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7">clang::format::FormatStyle::RequiresExpressionIndentationKind</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indentation logic for requires expression bodies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fe26352e2222d3d490fde5a0effead7a98a487af32aa678e779a149fcf64c475"></a>REI_OuterScope&#160;</td><td class="fielddoc"><p>Align requires expression body relative to the indentation level of the outer scope the requires expression resides in. </p>
<p>This is the default. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">concept <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> = requires(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a9fe26352e2222d3d490fde5a0effead7a8d1d021a41ec6b0a9bdc1517cc2822cb"></a>REI_Keyword&#160;</td><td class="fielddoc"><p>Align requires expression body relative to the <code>requires</code> keyword. </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">concept <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> = requires(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> t) {</div>
<div class="line">              ...</div>
<div class="line">            }</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03923">3923</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">&#9670;&nbsp;</a></span>ReturnTypeBreakingStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">clang::format::FormatStyle::ReturnTypeBreakingStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to break after the function definition or declaration return type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a828730b5d67acb44b86204ce2a726ce9"></a>RTBS_None&#160;</td><td class="fielddoc"><p>This is <b>deprecated</b>. See <code>Automatic</code> below. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a8540fa764d956a7732b05d4c26d01005"></a>RTBS_Automatic&#160;</td><td class="fielddoc"><p>Break after return type based on <code>PenaltyReturnTypeOnItsOwnLine</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span> f();</div>
<div class="line"><span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 1; }</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">LongName::AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a3b41972e4630f2a35aa653097c980ebf"></a>RTBS_ExceptShortType&#160;</td><td class="fielddoc"><p>Same as <code>Automatic</code> above, except that there is no break after short return types. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span> f();</div>
<div class="line"><span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 1; }</div>
<div class="line"><span class="keywordtype">int</span> LongName::</div>
<div class="line">    AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a7bcfb4d547cd2e60a58228d3b0021b7c"></a>RTBS_All&#160;</td><td class="fielddoc"><p>Always break after the return type. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span></div>
<div class="line">  f() {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f();</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f() {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">LongName::AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a817ef42fecd4c11fab2b274249669d7e"></a>RTBS_TopLevel&#160;</td><td class="fielddoc"><p>Always break after the return types of top-level functions. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f();</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f() {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">LongName::AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93abe1ad5bdf13fd57f28005dff20bf4fa2"></a>RTBS_AllDefinitions&#160;</td><td class="fielddoc"><p>Always break after the return type of function definitions. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span></div>
<div class="line">  f() {</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span> f();</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f() {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">LongName::AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ae8ce7f7cb26f4a6d278dd9b37a5b5d93a2ab2cf999a0b68dc6b097f9c7732a7dd"></a>RTBS_TopLevelDefinitions&#160;</td><td class="fielddoc"><p>Always break after the return type of top-level definitions. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 0; };</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">int</span> f();</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">f() {</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">LongName::AnotherLongName();</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00951">951</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a152054fb26dfc5f9345e538a61f98f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152054fb26dfc5f9345e538a61f98f65">&#9670;&nbsp;</a></span>SeparateDefinitionStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65">clang::format::FormatStyle::SeparateDefinitionStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The style if definition blocks should be separated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a152054fb26dfc5f9345e538a61f98f65aa311154f3d996d786ad49d5f9a9a4a35"></a>SDS_Leave&#160;</td><td class="fielddoc"><p>Leave definition blocks as they are. </p>
</td></tr>
<tr><td class="fieldname"><a id="a152054fb26dfc5f9345e538a61f98f65a2c4241464a33caedad314b610464a662"></a>SDS_Always&#160;</td><td class="fielddoc"><p>Insert an empty line between definition blocks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a152054fb26dfc5f9345e538a61f98f65a216319c547f678440cdb834274a8916b"></a>SDS_Never&#160;</td><td class="fielddoc"><p>Remove any empty line between definition blocks. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03949">3949</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a594a2f875200530674b48f806d31a227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594a2f875200530674b48f806d31a227">&#9670;&nbsp;</a></span>ShortBlockStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227">clang::format::FormatStyle::ShortBlockStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for merging short blocks containing at most one statement. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a594a2f875200530674b48f806d31a227af0ba6f2cd98d4f1d956bd6e7af1dcc46"></a>SBS_Never&#160;</td><td class="fielddoc"><p>Never merge blocks into a single line. </p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  <span class="keywordflow">continue</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a594a2f875200530674b48f806d31a227ac6a6c9c36df9aa151e194e530b5692b3"></a>SBS_Empty&#160;</td><td class="fielddoc"><p>Only merge empty blocks. </p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {}</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">  <span class="keywordflow">continue</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a594a2f875200530674b48f806d31a227a7e2722ea9652fea1f69486aa5d1be0f9"></a>SBS_Always&#160;</td><td class="fielddoc"><p>Always merge short blocks into a single line. </p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {}</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { <span class="keywordflow">continue</span>; }</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00696">696</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a9e649ad0d631fb02b66f55f1cb291c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e649ad0d631fb02b66f55f1cb291c7b">&#9670;&nbsp;</a></span>ShortFunctionStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7b">clang::format::FormatStyle::ShortFunctionStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for merging short functions containing at most one statement. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e649ad0d631fb02b66f55f1cb291c7ba70bcff26a3b413dee5bb6d156e243421"></a>SFS_None&#160;</td><td class="fielddoc"><p>Never merge functions into a single line. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9e649ad0d631fb02b66f55f1cb291c7bab47fdf3a99e6d4eb9e41d4fdd996731b"></a>SFS_InlineOnly&#160;</td><td class="fielddoc"><p>Only merge functions defined inside a class. </p>
<p>Same as "inline", except it does not implies "empty": i.e. top level empty functions are not merged either. </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> f() { foo(); }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  foo();</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a9e649ad0d631fb02b66f55f1cb291c7ba5705f074de510b309057df11f8d36841"></a>SFS_Empty&#160;</td><td class="fielddoc"><p>Only merge empty functions. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keywordtype">void</span> f2() {</div>
<div class="line">  bar2();</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a9e649ad0d631fb02b66f55f1cb291c7ba06a035dbc253ac7728a90df65a68d56b"></a>SFS_Inline&#160;</td><td class="fielddoc"><p>Only merge functions defined inside a class. </p>
<p>Implies "empty". </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> f() { foo(); }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  foo();</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> f() {}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a9e649ad0d631fb02b66f55f1cb291c7ba146a389b511103c51c317bdda131cd43"></a>SFS_All&#160;</td><td class="fielddoc"><p>Merge all functions fitting on a single line. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  <span class="keywordtype">void</span> f() { foo(); }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> f() { bar(); }</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00776">776</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a5b1cf3879fa6bc4459d4737e440b6ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1cf3879fa6bc4459d4737e440b6ec5">&#9670;&nbsp;</a></span>ShortIfStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5">clang::format::FormatStyle::ShortIfStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for handling short if statements. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b1cf3879fa6bc4459d4737e440b6ec5a34e813a131f75fd56e70e37ef2ce20f2"></a>SIS_Never&#160;</td><td class="fielddoc"><p>Never put short ifs on the same line. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a5b1cf3879fa6bc4459d4737e440b6ec5a2c55ff0cdfb118149c91b9b2546287fc"></a>SIS_WithoutElse&#160;</td><td class="fielddoc"><p>Put short ifs on the same line only if there is no else statement. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a5b1cf3879fa6bc4459d4737e440b6ec5aebacd27c0f517ae08d76ccd1891a6da4"></a>SIS_OnlyFirstIf&#160;</td><td class="fielddoc"><p>Put short ifs, but not else ifs nor else statements, on the same line. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a5b1cf3879fa6bc4459d4737e440b6ec5afa89d6181788abc9ab5b36bf6d16e452"></a>SIS_AllIfsAndElse&#160;</td><td class="fielddoc"><p>Always put short ifs, else ifs and else statements on the same line. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (a) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00828">828</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a1443da0f05d0355c0073b16343fd3065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1443da0f05d0355c0073b16343fd3065">&#9670;&nbsp;</a></span>ShortLambdaStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065">clang::format::FormatStyle::ShortLambdaStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different styles for merging short lambdas containing at most one statement. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1443da0f05d0355c0073b16343fd3065a8fb420194603ef010557d98be64a242e"></a>SLS_None&#160;</td><td class="fielddoc"><p>Never merge lambdas into a single line. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1443da0f05d0355c0073b16343fd3065afbf70aa74708c1c5a19bef4430ae3197"></a>SLS_Empty&#160;</td><td class="fielddoc"><p>Only merge empty lambdas. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lambda = [](<span class="keywordtype">int</span> a) {};</div>
<div class="line"><span class="keyword">auto</span> lambda2 = [](<span class="keywordtype">int</span> a) {</div>
<div class="line">    <span class="keywordflow">return</span> a;</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a1443da0f05d0355c0073b16343fd3065a463b4bfed474a2b0c9e134b523018670"></a>SLS_Inline&#160;</td><td class="fielddoc"><p>Merge lambda into a single line if the lambda is argument of a function. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lambda = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {</div>
<div class="line">    <span class="keywordflow">return</span> x &lt; y;</div>
<div class="line">};</div>
<div class="line">sort(a.begin(), a.end(), [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { return x &lt; y; });</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a1443da0f05d0355c0073b16343fd3065a22d2d5b75110a749fb95cd64d68fd5dd"></a>SLS_All&#160;</td><td class="fielddoc"><p>Merge all lambdas fitting on a single line. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> lambda = [](<span class="keywordtype">int</span> a) {};</div>
<div class="line"><span class="keyword">auto</span> lambda2 = [](<span class="keywordtype">int</span> a) { <span class="keywordflow">return</span> a; };</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00900">900</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a272ef822f048b5121b17f9b64c0127de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272ef822f048b5121b17f9b64c0127de">&#9670;&nbsp;</a></span>SortIncludesOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127de">clang::format::FormatStyle::SortIncludesOptions</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Include sorting options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a272ef822f048b5121b17f9b64c0127dea3081d16d65eb658875a56acb08d958a0"></a>SI_Never&#160;</td><td class="fielddoc"><p>Includes are never sorted. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;B/A.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;A/B.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;a/b.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;A/b.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;B/a.h&quot;</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a272ef822f048b5121b17f9b64c0127dea7ac9ec62c79aeaee4d12e50b37c99238"></a>SI_CaseSensitive&#160;</td><td class="fielddoc"><p>Includes are sorted in an ASCIIbetical or case sensitive fashion. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;A/B.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;A/b.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;B/A.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;B/a.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;a/b.h&quot;</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a272ef822f048b5121b17f9b64c0127dea89083f41e68527d1b9a0fb14c6f051f9"></a>SI_CaseInsensitive&#160;</td><td class="fielddoc"><p>Includes are sorted in an alphabetical or case insensitive fashion. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;A/B.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;A/b.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;a/b.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;B/A.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;B/a.h&quot;</span></div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04033">4033</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a1ac22b24b73abd5283a29a49e5129c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac22b24b73abd5283a29a49e5129c4e">&#9670;&nbsp;</a></span>SortJavaStaticImportOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4e">clang::format::FormatStyle::SortJavaStaticImportOptions</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position for Java Static imports. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ac22b24b73abd5283a29a49e5129c4ea569fc8b96ee665516ad4b4f47d002734"></a>SJSIO_Before&#160;</td><td class="fielddoc"><p>Static imports are placed before non-static imports. </p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.function1;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> org.example.ClassA;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a1ac22b24b73abd5283a29a49e5129c4ead9177c5c6cfc492c19c155b61a27680d"></a>SJSIO_After&#160;</td><td class="fielddoc"><p>Static imports are placed after non-static imports. </p>
<div class="fragment"><div class="line"><span class="keyword">import</span> org.example.ClassA;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.function1;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04068">4068</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="acecae06d9d6888f0feb23d55f169fbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecae06d9d6888f0feb23d55f169fbfe">&#9670;&nbsp;</a></span>SortUsingDeclarationsOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfe">clang::format::FormatStyle::SortUsingDeclarationsOptions</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using declaration sorting options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acecae06d9d6888f0feb23d55f169fbfeafd979b73dfa3c93942cddcaba682eb9a"></a>SUD_Never&#160;</td><td class="fielddoc"><p>Using declarations are never sorted. </p>
<div class="fragment"><div class="line"><span class="keyword">using</span> std::chrono::duration_cast;</div>
<div class="line"><span class="keyword">using</span> std::move;</div>
<div class="line"><span class="keyword">using</span> boost::regex;</div>
<div class="line"><span class="keyword">using</span> boost::regex_constants::icase;</div>
<div class="line"><span class="keyword">using</span> std::string;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="acecae06d9d6888f0feb23d55f169fbfea91d40ed5f91a1828185755bf868099ae"></a>SUD_Lexicographic&#160;</td><td class="fielddoc"><p>Using declarations are sorted in the order defined as follows: Split the strings by "::" and discard any initial empty strings. </p>
<p>Sort the lists of names lexicographically, and within those groups, names are in case-insensitive lexicographic order. </p><div class="fragment"><div class="line"><span class="keyword">using</span> boost::regex;</div>
<div class="line"><span class="keyword">using</span> boost::regex_constants::icase;</div>
<div class="line"><span class="keyword">using</span> std::chrono::duration_cast;</div>
<div class="line"><span class="keyword">using</span> std::move;</div>
<div class="line"><span class="keyword">using</span> std::string;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="acecae06d9d6888f0feb23d55f169fbfea7ec1089b092225113d2aee2421d24990"></a>SUD_LexicographicNumeric&#160;</td><td class="fielddoc"><p>Using declarations are sorted in the order defined as follows: Split the strings by "::" and discard any initial empty strings. </p>
<p>The last element of each list is a non-namespace name; all others are namespace names. Sort the lists of names lexicographically, where the sort order of individual names is that all non-namespace names come before all namespace names, and within those groups, names are in case-insensitive lexicographic order. </p><div class="fragment"><div class="line"><span class="keyword">using</span> boost::regex;</div>
<div class="line"><span class="keyword">using</span> boost::regex_constants::icase;</div>
<div class="line"><span class="keyword">using</span> std::move;</div>
<div class="line"><span class="keyword">using</span> std::string;</div>
<div class="line"><span class="keyword">using</span> std::chrono::duration_cast;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04092">4092</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="abae0b9d459d2a3e76e7595a0d50ad3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae0b9d459d2a3e76e7595a0d50ad3b9">&#9670;&nbsp;</a></span>SpaceAroundPointerQualifiersStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9">clang::format::FormatStyle::SpaceAroundPointerQualifiersStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to put a space before opening parentheses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abae0b9d459d2a3e76e7595a0d50ad3b9a8906f327373cd54eb8d28a6344824689"></a>SAPQ_Default&#160;</td><td class="fielddoc"><p>Don't ensure spaces around pointer qualifiers and use PointerAlignment instead. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Left                 <a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Right</div>
<div class="line"><span class="keywordtype">void</span>* <span class="keyword">const</span>* x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;         vs.     <span class="keywordtype">void</span> *<span class="keyword">const</span> *x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="ttc" id="a____stddef__null_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="____stddef__null_8h_source.html#l00026">__stddef_null.h:26</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a97e120bc3116361bd6d92f9191a6c3c3"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">clang::format::FormatStyle::PointerAlignment</a></div><div class="ttdeci">PointerAlignmentStyle PointerAlignment</div><div class="ttdoc">Pointer and reference alignment style.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l03539">Format.h:3539</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="abae0b9d459d2a3e76e7595a0d50ad3b9ac6008e39203a65846135339c4ccdcad4"></a>SAPQ_Before&#160;</td><td class="fielddoc"><p>Ensure that there is a space before pointer qualifiers. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Left                 <a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Right</div>
<div class="line"><span class="keywordtype">void</span>* <span class="keyword">const</span>* x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;         vs.     <span class="keywordtype">void</span> * <span class="keyword">const</span> *x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="abae0b9d459d2a3e76e7595a0d50ad3b9a4c13d03a770cd16c5c7c872c96784697"></a>SAPQ_After&#160;</td><td class="fielddoc"><p>Ensure that there is a space after pointer qualifiers. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Left                 <a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Right</div>
<div class="line"><span class="keywordtype">void</span>* <span class="keyword">const</span> * x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;         vs.     <span class="keywordtype">void</span> *<span class="keyword">const</span> *x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="abae0b9d459d2a3e76e7595a0d50ad3b9a902a96d58a74fc8cb4464f65e6ad3ae9"></a>SAPQ_Both&#160;</td><td class="fielddoc"><p>Ensure that there is a space both before and after pointer qualifiers. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Left                 <a class="code" href="structclang_1_1format_1_1FormatStyle.html#a97e120bc3116361bd6d92f9191a6c3c3">PointerAlignment</a>: Right</div>
<div class="line"><span class="keywordtype">void</span>* <span class="keyword">const</span> * x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;         vs.     <span class="keywordtype">void</span> * <span class="keyword">const</span> *x = <a class="code" href="____stddef__null_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04160">4160</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a7112fd8006c061310b6a28e404b73fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7112fd8006c061310b6a28e404b73fd9">&#9670;&nbsp;</a></span>SpaceBeforeParensStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9">clang::format::FormatStyle::SpaceBeforeParensStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to put a space before opening parentheses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9a25690e04257958b8eddbacce355bdcd9"></a>SBPO_Never&#160;</td><td class="fielddoc"><p>This is <b>deprecated</b> and replaced by <code>Custom</code> below, with all <code>SpaceBeforeParensOptions</code> but <code>AfterPlacementOperator</code> set to <code>false</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9ac5f2bdc66207290ce3737624d6733528"></a>SBPO_ControlStatements&#160;</td><td class="fielddoc"><p>Put a space before opening parentheses only after control statement keywords (<code>for/if/while...</code>). </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">true</span>) {</div>
<div class="line">    f();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9aa2920582e18496c5d60967e5c047a54d"></a>SBPO_ControlStatementsExceptControlMacros&#160;</td><td class="fielddoc"><p>Same as <code>SBPO_ControlStatements</code> except this option doesn't apply to ForEach and If macros. </p>
<p>This is useful in projects where ForEach/If macros are treated as function calls instead of control statements. <code>SBPO_ControlStatementsExceptForEachMacros</code> remains an alias for backward compatibility. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  Q_FOREACH(...) {</div>
<div class="line">    f();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9a8b177b28e0fab8d4ec2cefb5f62ad7bc"></a>SBPO_NonEmptyParentheses&#160;</td><td class="fielddoc"><p>Put a space before opening parentheses only if the parentheses are not empty i.e. </p>
<p>'()' </p><div class="fragment"><div class="line">void() {</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">true</span>) {</div>
<div class="line">    f();</div>
<div class="line">    g (x, y, z);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9af93a26544e3347e21b68dfe7d8601fea"></a>SBPO_Always&#160;</td><td class="fielddoc"><p>Always put a space before opening parentheses, except when it's prohibited by the syntax rules (in function-like macro definitions) or when determined by other style rules (after unary operators, opening parentheses, etc.) </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f () {</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">true</span>) {</div>
<div class="line">    f ();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a7112fd8006c061310b6a28e404b73fd9a5672406c509769e0d4e0f8650a4deded"></a>SBPO_Custom&#160;</td><td class="fielddoc"><p>Configure each individual space before parentheses in <code>SpaceBeforeParensOptions</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04252">4252</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="acaf8ff95ca21cdc0868d2b226b6d8917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf8ff95ca21cdc0868d2b226b6d8917">&#9670;&nbsp;</a></span>SpacesInAnglesStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917">clang::format::FormatStyle::SpacesInAnglesStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Styles for adding spacing after <code>&lt;</code> and before <code>&gt;</code> in template argument lists. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acaf8ff95ca21cdc0868d2b226b6d8917a2cc9ed6752f8b7413053985a6cf5cb0e"></a>SIAS_Never&#160;</td><td class="fielddoc"><p>Remove spaces after <code>&lt;</code> and before <code>&gt;</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="namespacestd.html#abc7307bd3d6368059069bfe77bee0439">arg</a>);</div>
<div class="line">std::function&lt;void(<span class="keywordtype">int</span>)&gt; fct;</div>
<div class="ttc" id="anamespacestd_html_abc7307bd3d6368059069bfe77bee0439"><div class="ttname"><a href="namespacestd.html#abc7307bd3d6368059069bfe77bee0439">std::arg</a></div><div class="ttdeci">__DEVICE__ _Tp arg(const std::complex&lt; _Tp &gt; &amp;__c)</div><div class="ttdef"><b>Definition:</b> <a href="complex__cmath_8h_source.html#l00040">complex_cmath.h:40</a></div></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="acaf8ff95ca21cdc0868d2b226b6d8917a3777a4f93a838fc9638823f7370b7c4f"></a>SIAS_Always&#160;</td><td class="fielddoc"><p>Add spaces after <code>&lt;</code> and before <code>&gt;</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>(<a class="code" href="namespacestd.html#abc7307bd3d6368059069bfe77bee0439">arg</a>);</div>
<div class="line">std::function&lt; void(<span class="keywordtype">int</span>) &gt; fct;</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="acaf8ff95ca21cdc0868d2b226b6d8917aa41d3c554910d2dfee9c5a5212559c72"></a>SIAS_Leave&#160;</td><td class="fielddoc"><p>Keep a single space after <code>&lt;</code> and before <code>&gt;</code> if any spaces were present. </p>
<p>Option <code>Standard: Cpp03</code> takes precedence. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04494">4494</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a404a2fb2e5d055e7858aca7bd99c0fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404a2fb2e5d055e7858aca7bd99c0fe4">&#9670;&nbsp;</a></span>SpacesInParensStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4">clang::format::FormatStyle::SpacesInParensStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to put a space before opening and closing parentheses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a404a2fb2e5d055e7858aca7bd99c0fe4a1690397be4b132cbe044f6c95e836a74"></a>SIPO_Never&#160;</td><td class="fielddoc"><p>Never put a space in parentheses. </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">true</span>) {</div>
<div class="line">    f();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a404a2fb2e5d055e7858aca7bd99c0fe4a0ce73ed05edf0d60ae86250adb3eb897"></a>SIPO_Custom&#160;</td><td class="fielddoc"><p>Configure each individual space in parentheses in <code>SpacesInParensOptions</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04582">4582</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a20c259c49568c00e32091c1e1ff2c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c259c49568c00e32091c1e1ff2c0f9">&#9670;&nbsp;</a></span>TrailingCommaStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9">clang::format::FormatStyle::TrailingCommaStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The style of inserting trailing commas into container literals. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a20c259c49568c00e32091c1e1ff2c0f9ac7967c60d08348f0e552f3216aa4e93c"></a>TCS_None&#160;</td><td class="fielddoc"><p>Do not insert trailing commas. </p>
</td></tr>
<tr><td class="fieldname"><a id="a20c259c49568c00e32091c1e1ff2c0f9a4bb8aed37b78787d100031827353d8a6"></a>TCS_Wrapped&#160;</td><td class="fielddoc"><p>Insert trailing commas in container literals that were wrapped over multiple lines. </p>
<p>Note that this is conceptually incompatible with bin-packing, because the trailing comma is used as an indicator that a container should be formatted one-per-line (i.e. not bin-packed). So inserting a trailing comma counteracts bin-packing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02874">2874</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a3b4bc5b96e644e54bb925b361652d0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4bc5b96e644e54bb925b361652d0a6">&#9670;&nbsp;</a></span>TrailingCommentsAlignmentKinds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a3b4bc5b96e644e54bb925b361652d0a6">clang::format::FormatStyle::TrailingCommentsAlignmentKinds</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enums for AlignTrailingComments. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b4bc5b96e644e54bb925b361652d0a6a4e026d897be750c5d085056a0fdcb292"></a>TCAS_Leave&#160;</td><td class="fielddoc"><p>Leave trailing comments as they are. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a;    <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> ab;       <span class="comment">// comment</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> abc;  <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> abcd;     <span class="comment">// comment</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a3b4bc5b96e644e54bb925b361652d0a6a79149cbc5a45eee6532e1cc30180891a"></a>TCAS_Always&#160;</td><td class="fielddoc"><p>Align trailing comments. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a;  <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> ab; <span class="comment">// comment</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> abc;  <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> abcd; <span class="comment">// comment</span></div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="a3b4bc5b96e644e54bb925b361652d0a6a46d41ad83e9746c2fc4477b642778361"></a>TCAS_Never&#160;</td><td class="fielddoc"><p>Don't align trailing comments but other formatter applies. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a; <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> ab; <span class="comment">// comment</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> abc; <span class="comment">// comment</span></div>
<div class="line"><span class="keywordtype">int</span> abcd; <span class="comment">// comment</span></div>
</div><!-- fragment --> </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00527">527</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<a id="a020cb5a1ecf0fa97b2496c35ab59619c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020cb5a1ecf0fa97b2496c35ab59619c">&#9670;&nbsp;</a></span>UseTabStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619c">clang::format::FormatStyle::UseTabStyle</a> : int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is <b>deprecated</b>. </p>
<p>See <code>LF</code> and <code>CRLF</code> of <code>LineEnding</code>. </p><dl class="section version"><dt>Version</dt><dd>10 Different ways to use tab in formatting. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a020cb5a1ecf0fa97b2496c35ab59619cafd12c70df29dd36bbb5971672f08bd12"></a>UT_Never&#160;</td><td class="fielddoc"><p>Never use tab. </p>
</td></tr>
<tr><td class="fieldname"><a id="a020cb5a1ecf0fa97b2496c35ab59619ca98348a0ed9ac4d191ce1bb3cb3e541fb"></a>UT_ForIndentation&#160;</td><td class="fielddoc"><p>Use tabs only for indentation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a020cb5a1ecf0fa97b2496c35ab59619ca74a5d824d84616bdc37b42b2b58d2bd2"></a>UT_ForContinuationAndIndentation&#160;</td><td class="fielddoc"><p>Fill all leading whitespace with tabs, and use spaces for alignment that appears within a line (e.g. </p>
<p>consecutive assignments and declarations). </p>
</td></tr>
<tr><td class="fieldname"><a id="a020cb5a1ecf0fa97b2496c35ab59619ca43e18d76b2fbadc8856468ead948ac63"></a>UT_AlignWithSpaces&#160;</td><td class="fielddoc"><p>Use tabs for line continuation and indentation, and spaces for alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a020cb5a1ecf0fa97b2496c35ab59619cac5fc60e5d09b7daadafd5e12d266d30a"></a>UT_Always&#160;</td><td class="fielddoc"><p>Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04850">4850</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a471da659034079173f5a2aaa04aedb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471da659034079173f5a2aaa04aedb03">&#9670;&nbsp;</a></span>BuildStyleSetFromConfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structclang_1_1format_1_1FormatStyle_1_1FormatStyleSet.html">FormatStyleSet</a> clang::format::FormatStyle::BuildStyleSetFromConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &amp;&#160;</td>
          <td class="paramname"><em>MainStyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ConfigurationStyles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5999265cdeff66d190d55b027eb9a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5999265cdeff66d190d55b027eb9a027">&#9670;&nbsp;</a></span>GetLanguageStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &gt; clang::format::FormatStyle::GetLanguageStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">FormatStyle::LanguageKind</a>&#160;</td>
          <td class="paramname"><em>Language</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l02100">2100</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

<p class="reference">References <a class="el" href="Format_8cpp_source.html#l02075">clang::format::FormatStyle::FormatStyleSet::Get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00196">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="a290942979cd05cb38b9aece3972fd53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290942979cd05cb38b9aece3972fd53f">&#9670;&nbsp;</a></span>isCpp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isCpp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03142">3142</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03118">LK_Cpp</a>, and <a class="el" href="Format_8h_source.html#l03128">LK_ObjC</a>.</p>

</div>
</div>
<a id="a7c578e3dc0b6dfcca89a3f5f261ee080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c578e3dc0b6dfcca89a3f5f261ee080">&#9670;&nbsp;</a></span>isCSharp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isCSharp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03143">3143</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03120">LK_CSharp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FormatTokenLexer_8cpp_source.html#l00079">clang::format::FormatTokenLexer::lex()</a>.</p>

</div>
</div>
<a id="ab67aa2db9f9578e227305b70ec42eb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67aa2db9f9578e227305b70ec42eb9a">&#9670;&nbsp;</a></span>isJavaScript()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isJavaScript </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03145">3145</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03124">LK_JavaScript</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00696">clang::format::BreakableBlockComment::getContentIndent()</a>, and <a class="el" href="FormatTokenLexer_8cpp_source.html#l00079">clang::format::FormatTokenLexer::lex()</a>.</p>

</div>
</div>
<a id="a477a73fe8749386a6dba865191b8ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477a73fe8749386a6dba865191b8ede0">&#9670;&nbsp;</a></span>isJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03144">3144</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03126">LK_Json</a>.</p>

</div>
</div>
<a id="aaaaeaf97eabc19c4045ecc987b2283f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaeaf97eabc19c4045ecc987b2283f1">&#9670;&nbsp;</a></span>isProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isProto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03147">3147</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03131">LK_Proto</a>, and <a class="el" href="Format_8h_source.html#l03136">LK_TextProto</a>.</p>

</div>
</div>
<a id="a065037978abb87672c3cfa553193d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065037978abb87672c3cfa553193d175">&#9670;&nbsp;</a></span>isTableGen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isTableGen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03150">3150</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03133">LK_TableGen</a>.</p>

<p class="reference">Referenced by <a class="el" href="WhitespaceManager_8cpp_source.html#l00103">clang::format::WhitespaceManager::generateReplacements()</a>, and <a class="el" href="FormatTokenLexer_8cpp_source.html#l00079">clang::format::FormatTokenLexer::lex()</a>.</p>

</div>
</div>
<a id="ab2ad02ccc6b28e8dffe00d83d7341676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ad02ccc6b28e8dffe00d83d7341676">&#9670;&nbsp;</a></span>isVerilog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::isVerilog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03146">3146</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l03140">LK_Verilog</a>.</p>

</div>
</div>
<a id="a8b470c3ac3bd72ea02de155cd2ef32c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b470c3ac3bd72ea02de155cd2ef32c4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04901">4901</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">References <a class="el" href="Format_8h_source.html#l00063">AccessModifierOffset</a>, <a class="el" href="Format_8h_source.html#l00107">AlignAfterOpenBracket</a>, <a class="el" href="Format_8h_source.html#l00143">AlignArrayOfStructures</a>, <a class="el" href="Format_8h_source.html#l00296">AlignConsecutiveAssignments</a>, <a class="el" href="Format_8h_source.html#l00307">AlignConsecutiveBitFields</a>, <a class="el" href="Format_8h_source.html#l00318">AlignConsecutiveDeclarations</a>, <a class="el" href="Format_8h_source.html#l00286">AlignConsecutiveMacros</a>, <a class="el" href="Format_8h_source.html#l00415">AlignConsecutiveShortCaseStatements</a>, <a class="el" href="Format_8h_source.html#l00430">AlignConsecutiveTableGenBreakingDAGArgColons</a>, <a class="el" href="Format_8h_source.html#l00440">AlignConsecutiveTableGenCondOperatorColons</a>, <a class="el" href="Format_8h_source.html#l00450">AlignConsecutiveTableGenDefinitionColons</a>, <a class="el" href="Format_8h_source.html#l00485">AlignEscapedNewlines</a>, <a class="el" href="Format_8h_source.html#l00524">AlignOperands</a>, <a class="el" href="Format_8h_source.html#l00611">AlignTrailingComments</a>, <a class="el" href="Format_8h_source.html#l00628">AllowAllArgumentsOnNextLine</a>, <a class="el" href="Format_8h_source.html#l00651">AllowAllParametersOfDeclarationOnNextLine</a>, <a class="el" href="Format_8h_source.html#l00692">AllowBreakBeforeNoexceptSpecifier</a>, <a class="el" href="Format_8h_source.html#l00725">AllowShortBlocksOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00739">AllowShortCaseLabelsOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00758">AllowShortCompoundRequirementOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00772">AllowShortEnumsOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00825">AllowShortFunctionsOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00896">AllowShortIfStatementsOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00930">AllowShortLambdasOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l00935">AllowShortLoopsOnASingleLine</a>, <a class="el" href="Format_8h_source.html#l01066">AlwaysBreakBeforeMultilineStrings</a>, <a class="el" href="Format_8h_source.html#l01136">AttributeMacros</a>, <a class="el" href="Format_8h_source.html#l01155">BinPackArguments</a>, <a class="el" href="Format_8h_source.html#l01170">BinPackParameters</a>, <a class="el" href="Format_8h_source.html#l01199">BitFieldColonSpacing</a>, <a class="el" href="Format_8h_source.html#l01232">BracedInitializerIndentWidth</a>, <a class="el" href="Format_8h_source.html#l01526">BreakAdjacentStringLiterals</a>, <a class="el" href="Format_8h_source.html#l01613">BreakAfterAttributes</a>, <a class="el" href="Format_8h_source.html#l02248">BreakAfterJavaFieldAnnotations</a>, <a class="el" href="Format_8h_source.html#l01617">BreakAfterReturnType</a>, <a class="el" href="Format_8h_source.html#l01636">BreakArrays</a>, <a class="el" href="Format_8h_source.html#l01691">BreakBeforeBinaryOperators</a>, <a class="el" href="Format_8h_source.html#l02126">BreakBeforeBraces</a>, <a class="el" href="Format_8h_source.html#l02150">BreakBeforeConceptDeclarations</a>, <a class="el" href="Format_8h_source.html#l02179">BreakBeforeInlineASMColon</a>, <a class="el" href="Format_8h_source.html#l02194">BreakBeforeTernaryOperators</a>, <a class="el" href="Format_8h_source.html#l02224">BreakConstructorInitializers</a>, <a class="el" href="Format_8h_source.html#l02238">BreakFunctionDefinitionParameters</a>, <a class="el" href="Format_8h_source.html#l02349">BreakInheritanceList</a>, <a class="el" href="Format_8h_source.html#l02291">BreakStringLiterals</a>, <a class="el" href="Format_8h_source.html#l02353">BreakTemplateDeclarations</a>, <a class="el" href="Format_8h_source.html#l02299">ColumnLimit</a>, <a class="el" href="Format_8h_source.html#l02309">CommentPragmas</a>, <a class="el" href="Format_8h_source.html#l02377">CompactNamespaces</a>, <a class="el" href="Format_8h_source.html#l02387">ConstructorInitializerIndentWidth</a>, <a class="el" href="Format_8h_source.html#l02398">ContinuationIndentWidth</a>, <a class="el" href="Format_8h_source.html#l02421">Cpp11BracedListStyle</a>, <a class="el" href="Format_8h_source.html#l02434">DerivePointerAlignment</a>, <a class="el" href="Format_8h_source.html#l02438">DisableFormat</a>, <a class="el" href="Format_8h_source.html#l02489">EmptyLineAfterAccessModifier</a>, <a class="el" href="Format_8h_source.html#l02552">EmptyLineBeforeAccessModifier</a>, <a class="el" href="Format_8h_source.html#l02567">ExperimentalAutoDetectBinPacking</a>, <a class="el" href="Format_8h_source.html#l02583">FixNamespaceComments</a>, <a class="el" href="Format_8h_source.html#l02601">ForEachMacros</a>, <a class="el" href="IncludeStyle_8h_source.html#l00054">clang::tooling::IncludeStyle::IncludeBlocks</a>, <a class="el" href="IncludeStyle_8h_source.html#l00118">clang::tooling::IncludeStyle::IncludeCategories</a>, <a class="el" href="IncludeStyle_8h_source.html#l00132">clang::tooling::IncludeStyle::IncludeIsMainRegex</a>, <a class="el" href="IncludeStyle_8h_source.html#l00153">clang::tooling::IncludeStyle::IncludeIsMainSourceRegex</a>, <a class="el" href="Format_8h_source.html#l02603">IncludeStyle</a>, <a class="el" href="Format_8h_source.html#l02651">IndentAccessModifiers</a>, <a class="el" href="Format_8h_source.html#l02674">IndentCaseBlocks</a>, <a class="el" href="Format_8h_source.html#l02693">IndentCaseLabels</a>, <a class="el" href="Format_8h_source.html#l02750">IndentExternBlock</a>, <a class="el" href="Format_8h_source.html#l02710">IndentGotoLabels</a>, <a class="el" href="Format_8h_source.html#l02785">IndentPPDirectives</a>, <a class="el" href="Format_8h_source.html#l02807">IndentRequiresClause</a>, <a class="el" href="Format_8h_source.html#l02821">IndentWidth</a>, <a class="el" href="Format_8h_source.html#l02835">IndentWrappedFunctionNames</a>, <a class="el" href="Format_8h_source.html#l02867">InsertBraces</a>, <a class="el" href="Format_8h_source.html#l02871">InsertNewlineAtEOF</a>, <a class="el" href="Format_8h_source.html#l02980">IntegerLiteralSeparator</a>, <a class="el" href="Format_8h_source.html#l03014">JavaImportGroups</a>, <a class="el" href="Format_8h_source.html#l03041">JavaScriptQuotes</a>, <a class="el" href="Format_8h_source.html#l03057">JavaScriptWrapImports</a>, <a class="el" href="Format_8h_source.html#l03062">KeepEmptyLinesAtEOF</a>, <a class="el" href="Format_8h_source.html#l03073">KeepEmptyLinesAtTheStartOfBlocks</a>, <a class="el" href="Format_8h_source.html#l03107">LambdaBodyIndentation</a>, <a class="el" href="Format_8h_source.html#l03154">Language</a>, <a class="el" href="Format_8h_source.html#l03170">LineEnding</a>, <a class="el" href="Format_8h_source.html#l03199">MacroBlockBegin</a>, <a class="el" href="Format_8h_source.html#l03203">MacroBlockEnd</a>, <a class="el" href="Format_8h_source.html#l03243">Macros</a>, <a class="el" href="IncludeStyle_8h_source.html#l00168">clang::tooling::IncludeStyle::MainIncludeChar</a>, <a class="el" href="Format_8h_source.html#l03257">MaxEmptyLinesToKeep</a>, <a class="el" href="Format_8h_source.html#l04544">clang::format::FormatStyle::SpacesInLineComment::Maximum</a>, <a class="el" href="Format_8h_source.html#l04542">clang::format::FormatStyle::SpacesInLineComment::Minimum</a>, <a class="el" href="Format_8h_source.html#l03295">NamespaceIndentation</a>, <a class="el" href="Format_8h_source.html#l03308">NamespaceMacros</a>, <a class="el" href="Format_8h_source.html#l03341">ObjCBinPackProtocolList</a>, <a class="el" href="Format_8h_source.html#l03352">ObjCBlockIndentWidth</a>, <a class="el" href="Format_8h_source.html#l03376">ObjCBreakBeforeNestedBlockParam</a>, <a class="el" href="Format_8h_source.html#l03399">ObjCPropertyAttributeOrder</a>, <a class="el" href="Format_8h_source.html#l03404">ObjCSpaceAfterProperty</a>, <a class="el" href="Format_8h_source.html#l03409">ObjCSpaceBeforeProtocolList</a>, <a class="el" href="Format_8h_source.html#l03471">PackConstructorInitializers</a>, <a class="el" href="Format_8h_source.html#l03475">PenaltyBreakAssignment</a>, <a class="el" href="Format_8h_source.html#l03479">PenaltyBreakBeforeFirstCallParameter</a>, <a class="el" href="Format_8h_source.html#l03483">PenaltyBreakComment</a>, <a class="el" href="Format_8h_source.html#l03487">PenaltyBreakFirstLessLess</a>, <a class="el" href="Format_8h_source.html#l03491">PenaltyBreakOpenParenthesis</a>, <a class="el" href="Format_8h_source.html#l03495">PenaltyBreakScopeResolution</a>, <a class="el" href="Format_8h_source.html#l03499">PenaltyBreakString</a>, <a class="el" href="Format_8h_source.html#l03503">PenaltyBreakTemplateDeclaration</a>, <a class="el" href="Format_8h_source.html#l03507">PenaltyExcessCharacter</a>, <a class="el" href="Format_8h_source.html#l03516">PenaltyReturnTypeOnItsOwnLine</a>, <a class="el" href="Format_8h_source.html#l03539">PointerAlignment</a>, <a class="el" href="Format_8h_source.html#l03600">QualifierAlignment</a>, <a class="el" href="Format_8h_source.html#l03626">QualifierOrder</a>, <a class="el" href="Format_8h_source.html#l03686">RawStringFormats</a>, <a class="el" href="Format_8h_source.html#l03712">ReferenceAlignment</a>, <a class="el" href="Format_8h_source.html#l03785">RemoveBracesLLVM</a>, <a class="el" href="Format_8h_source.html#l03821">RemoveParentheses</a>, <a class="el" href="Format_8h_source.html#l03839">RemoveSemicolon</a>, <a class="el" href="Format_8h_source.html#l03920">RequiresClausePosition</a>, <a class="el" href="Format_8h_source.html#l03946">RequiresExpressionIndentation</a>, <a class="el" href="Format_8h_source.html#l04004">SeparateDefinitionBlocks</a>, <a class="el" href="Format_8h_source.html#l04026">ShortNamespaceLines</a>, <a class="el" href="Format_8h_source.html#l04030">SkipMacroDefinitionBody</a>, <a class="el" href="Format_8h_source.html#l04065">SortIncludes</a>, <a class="el" href="Format_8h_source.html#l04089">SortJavaStaticImport</a>, <a class="el" href="Format_8h_source.html#l04141">SpaceAfterCStyleCast</a>, <a class="el" href="Format_8h_source.html#l04149">SpaceAfterLogicalNot</a>, <a class="el" href="Format_8h_source.html#l04157">SpaceAfterTemplateKeyword</a>, <a class="el" href="Format_8h_source.html#l04190">SpaceAroundPointerQualifiers</a>, <a class="el" href="Format_8h_source.html#l04199">SpaceBeforeAssignmentOperators</a>, <a class="el" href="Format_8h_source.html#l04209">SpaceBeforeCaseColon</a>, <a class="el" href="Format_8h_source.html#l04221">SpaceBeforeCpp11BracedList</a>, <a class="el" href="Format_8h_source.html#l04230">SpaceBeforeCtorInitializerColon</a>, <a class="el" href="Format_8h_source.html#l04238">SpaceBeforeInheritanceColon</a>, <a class="el" href="Format_8h_source.html#l04249">SpaceBeforeJsonColon</a>, <a class="el" href="Format_8h_source.html#l04310">SpaceBeforeParens</a>, <a class="el" href="Format_8h_source.html#l04436">SpaceBeforeParensOptions</a>, <a class="el" href="Format_8h_source.html#l04455">SpaceBeforeRangeBasedForLoopColon</a>, <a class="el" href="Format_8h_source.html#l04446">SpaceBeforeSquareBrackets</a>, <a class="el" href="Format_8h_source.html#l04464">SpaceInEmptyBlock</a>, <a class="el" href="Format_8h_source.html#l04490">SpacesBeforeTrailingComments</a>, <a class="el" href="Format_8h_source.html#l04513">SpacesInAngles</a>, <a class="el" href="Format_8h_source.html#l04531">SpacesInContainerLiterals</a>, <a class="el" href="Format_8h_source.html#l04579">SpacesInLineCommentPrefix</a>, <a class="el" href="Format_8h_source.html#l04608">SpacesInParens</a>, <a class="el" href="Format_8h_source.html#l04684">SpacesInParensOptions</a>, <a class="el" href="Format_8h_source.html#l04695">SpacesInSquareBrackets</a>, <a class="el" href="Format_8h_source.html#l04730">Standard</a>, <a class="el" href="Format_8h_source.html#l04747">StatementAttributeLikeMacros</a>, <a class="el" href="Format_8h_source.html#l04758">StatementMacros</a>, <a class="el" href="Format_8h_source.html#l04784">TableGenBreakingDAGArgOperators</a>, <a class="el" href="Format_8h_source.html#l04812">TableGenBreakInsideDAGArg</a>, <a class="el" href="Format_8h_source.html#l04816">TabWidth</a>, <a class="el" href="Format_8h_source.html#l04843">TypenameMacros</a>, <a class="el" href="Format_8h_source.html#l04826">TypeNames</a>, <a class="el" href="Format_8h_source.html#l04868">UseTab</a>, <a class="el" href="Format_8h_source.html#l04882">VerilogBreakBetweenInstancePorts</a>, and <a class="el" href="Format_8h_source.html#l04899">WhitespaceSensitiveMacros</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a65b31df3483b1e1830e682fe75ba9b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b31df3483b1e1830e682fe75ba9b50">&#9670;&nbsp;</a></span>parseConfiguration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code parseConfiguration </td>
          <td>(</td>
          <td class="paramtype">llvm::MemoryBufferRef&#160;</td>
          <td class="paramname"><em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structclang_1_1format_1_1FormatStyle.html">FormatStyle</a> *&#160;</td>
          <td class="paramname"><em>Style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>AllowUnknownOptions</em> = <code><a class="el" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr::DiagHandlerTy&#160;</td>
          <td class="paramname"><em>DiagHandler</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>DiagHandlerCtxt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse configuration from YAML-formatted text. </p>
<p>Style-&gt;Language is used to get the base style, if the <code>BasedOnStyle</code> option is present.</p>
<p>The <a class="el" href="structclang_1_1format_1_1FormatStyle_1_1FormatStyleSet.html">FormatStyleSet</a> of Style is reset.</p>
<p>When <code>BasedOnStyle</code> is not present, options not present in the YAML document, are retained in <code>Style</code>.</p>
<p>If AllowUnknownOptions is true, no errors are emitted if unknown format options are occurred.</p>
<p>If set all diagnostics are emitted through the DiagHandler. </p>

<p class="definition">Definition at line <a class="el" href="Format_8cpp_source.html#l01993">1993</a> of file <a class="el" href="Format_8cpp_source.html">Format.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a534fd6ed422571ccff12fc5864b49bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534fd6ed422571ccff12fc5864b49bc3">&#9670;&nbsp;</a></span>AccessModifierOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::format::FormatStyle::AccessModifierOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The extra indent or outdent of access modifiers, e.g. </p>
<p><code>public:</code>. </p><dl class="section version"><dt>Version</dt><dd>3.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00063">63</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aa920e43c7189e9b90300239d276de797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa920e43c7189e9b90300239d276de797">&#9670;&nbsp;</a></span>AlignAfterOpenBracket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a442fa38afc320ec9b6d9e1f569c81060">BracketAlignmentStyle</a> clang::format::FormatStyle::AlignAfterOpenBracket</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, horizontally aligns arguments after an open bracket. </p>
<p>This applies to round brackets (parentheses), angle brackets and square brackets. </p><dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00107">107</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, and <a class="el" href="FormatToken_8cpp_source.html#l00202">clang::format::CommaSeparatedList::precomputeFormattingInfos()</a>.</p>

</div>
</div>
<a id="ae1dbc256848c7bed31bd6173014e8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dbc256848c7bed31bd6173014e8ab2">&#9670;&nbsp;</a></span>AlignArrayOfStructures</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac1754a0481292dcc9959bf6fbebcd6b1">ArrayInitializerAlignmentStyle</a> clang::format::FormatStyle::AlignArrayOfStructures</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if not <code>None</code>, when using initialization for an array of structs aligns the fields into columns. </p>
<dl class="section note"><dt>Note</dt><dd>As of clang-format 15 this option only applied to arrays with equal number of columns per row. \endnote</dd></dl>
<dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00143">143</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="acfa62bac28235d2d852aa6b1c74e2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa62bac28235d2d852aa6b1c74e2d80">&#9670;&nbsp;</a></span>AlignConsecutiveAssignments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveAssignments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive assignments. </p>
<p><code>Consecutive</code> will result in formattings like: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a            = 1;</div>
<div class="line"><span class="keywordtype">int</span> somelongname = 2;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>         = 3;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00296">296</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a8df4cf092a1d50fc6096465195aebba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df4cf092a1d50fc6096465195aebba3">&#9670;&nbsp;</a></span>AlignConsecutiveBitFields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveBitFields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive bit fields. </p>
<p><code>Consecutive</code> will align the bitfield separators of consecutive lines. This will result in formattings like: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> aaaa : 1;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>    : 12;</div>
<div class="line"><span class="keywordtype">int</span> ccc  : 8;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00307">307</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a8e9927d5d1e4da6fb9c65a7d1a25a791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9927d5d1e4da6fb9c65a7d1a25a791">&#9670;&nbsp;</a></span>AlignConsecutiveDeclarations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveDeclarations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive declarations. </p>
<p><code>Consecutive</code> will align the declaration names of consecutive lines. This will result in formattings like: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>         aaaa = 12;</div>
<div class="line"><span class="keywordtype">float</span>       <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 23;</div>
<div class="line">std::string ccc;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00318">318</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac9b5f84cb5fc804f5596cefc6937e0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b5f84cb5fc804f5596cefc6937e0d5">&#9670;&nbsp;</a></span>AlignConsecutiveMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive macro definitions. </p>
<p><code>Consecutive</code> will result in formattings like: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SHORT_NAME       42</span></div>
<div class="line"><span class="preprocessor">#define LONGER_NAME      0x007f</span></div>
<div class="line"><span class="preprocessor">#define EVEN_LONGER_NAME (2)</span></div>
<div class="line"><span class="preprocessor">#define foo(x)           (x * x)</span></div>
<div class="line"><span class="preprocessor">#define bar(y, z)        (y + z)</span></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00286">286</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab2cc26b335162d910bfbad3f9569dd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cc26b335162d910bfbad3f9569dd27">&#9670;&nbsp;</a></span>AlignConsecutiveShortCaseStatements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1ShortCaseStatementsAlignmentStyle.html">ShortCaseStatementsAlignmentStyle</a> clang::format::FormatStyle::AlignConsecutiveShortCaseStatements</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive short case labels. </p>
<p>Only applies if <code>AllowShortCaseLabelsOnASingleLine</code> is <code>true</code>.</p>
<div class="fragment"><div class="line"># Example of usage:</div>
<div class="line">AlignConsecutiveShortCaseStatements:</div>
<div class="line">  Enabled: true</div>
<div class="line">  AcrossEmptyLines: true</div>
<div class="line">  AcrossComments: true</div>
<div class="line">  AlignCaseColons: false</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00415">415</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3889e3d68b1eec733bb6c0cc60d832cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3889e3d68b1eec733bb6c0cc60d832cc">&#9670;&nbsp;</a></span>AlignConsecutiveTableGenBreakingDAGArgColons</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveTableGenBreakingDAGArgColons</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive TableGen DAGArg operator colons. </p>
<p>If enabled, align the colon inside DAGArg which have line break inside. This works only when TableGenBreakInsideDAGArg is BreakElements or BreakAll and the DAGArg is not excepted by TableGenBreakingDAGArgOperators's effect. </p><div class="fragment"><div class="line">let dagarg = (ins</div>
<div class="line">    a  :$src1,</div>
<div class="line">    aa :$src2,</div>
<div class="line">    aaa:$src3</div>
<div class="line">)</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00430">430</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aa9f3dde678b43bf25c4f4abb816c7ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f3dde678b43bf25c4f4abb816c7ee0">&#9670;&nbsp;</a></span>AlignConsecutiveTableGenCondOperatorColons</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveTableGenCondOperatorColons</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive TableGen cond operator colons. </p>
<p>Align the colons of cases inside !cond operators. </p><div class="fragment"><div class="line">!cond(!eq(size, 1) : 1,</div>
<div class="line">      !eq(size, 16): 1,</div>
<div class="line">      <span class="keyword">true</span>         : 0)</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00440">440</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a69974864c61d994bcb5992a7391d4f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69974864c61d994bcb5992a7391d4f42">&#9670;&nbsp;</a></span>AlignConsecutiveTableGenDefinitionColons</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1AlignConsecutiveStyle.html">AlignConsecutiveStyle</a> clang::format::FormatStyle::AlignConsecutiveTableGenDefinitionColons</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Style of aligning consecutive TableGen definition colons. </p>
<p>This aligns the inheritance colons of consecutive definitions. </p><div class="fragment"><div class="line">def Def       : <a class="code" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a> {}</div>
<div class="line">def DefDef    : <a class="code" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a> {}</div>
<div class="line">def DefDefDef : <a class="code" href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a> {}</div>
<div class="ttc" id="aASTDiff_8cpp_html_a787d77e399ffabdb66b1361d08789691"><div class="ttname"><a href="ASTDiff_8cpp.html#a787d77e399ffabdb66b1361d08789691">Parent</a></div><div class="ttdeci">NodeId Parent</div><div class="ttdef"><b>Definition:</b> <a href="ASTDiff_8cpp_source.html#l00191">ASTDiff.cpp:191</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00450">450</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab3934e5d2eaf82b086b87ed2f623934e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3934e5d2eaf82b086b87ed2f623934e">&#9670;&nbsp;</a></span>AlignEscapedNewlines</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ac8cfc28e8e1e440535df98dbf25b10c3">EscapedNewlineAlignmentStyle</a> clang::format::FormatStyle::AlignEscapedNewlines</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for aligning backslashes in escaped newlines. </p>
<dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00485">485</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a610668e19a4d6e7813157686803587a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610668e19a4d6e7813157686803587a9">&#9670;&nbsp;</a></span>AlignOperands</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af3421b3510c1cf937d2ed651942e3db6">OperandAlignmentStyle</a> clang::format::FormatStyle::AlignOperands</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, horizontally align operands of binary and ternary expressions. </p>
<dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00524">524</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac0e80d6e4a1c2b00d438abeaa8dd13bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e80d6e4a1c2b00d438abeaa8dd13bc">&#9670;&nbsp;</a></span>AlignTrailingComments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1TrailingCommentsAlignmentStyle.html">TrailingCommentsAlignmentStyle</a> clang::format::FormatStyle::AlignTrailingComments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control of trailing comments. </p>
<p>The alignment stops at closing braces after a line break, and only followed by other closing braces, a (<code>do-</code>) <code>while</code>, a lambda call, or a semicolon.</p>
<dl class="section note"><dt>Note</dt><dd>As of clang-format 16 this option is not a bool but can be set to the options. Conventional bool options still can be parsed as before. \endnote</dd></dl>
<div class="fragment"><div class="line"># Example of usage:</div>
<div class="line">AlignTrailingComments:</div>
<div class="line">  Kind: Always</div>
<div class="line">  OverEmptyLines: 2</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00611">611</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae4b5b18225adbe632496fd2b927d4296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b5b18225adbe632496fd2b927d4296">&#9670;&nbsp;</a></span>AllowAllArgumentsOnNextLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowAllArgumentsOnNextLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a function call or braced initializer list doesn't fit on a line, allow putting all arguments onto the next line, even if <code>BinPackArguments</code> is <code>false</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line">callFunction(</div>
<div class="line">    a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>, d);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line">callFunction(a,</div>
<div class="line">             <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>,</div>
<div class="line">             <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>,</div>
<div class="line">             d);</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00628">628</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aa6eeb36c958dfb1e4f15876c82cef2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eeb36c958dfb1e4f15876c82cef2ce">&#9670;&nbsp;</a></span>AllowAllParametersOfDeclarationOnNextLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowAllParametersOfDeclarationOnNextLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is <b>deprecated</b>. </p>
<p>See <code>NextLine</code> of <code>PackConstructorInitializers</code>. </p><dl class="section version"><dt>Version</dt><dd>9 If the function declaration doesn't fit on a line, allow putting all parameters of a function declaration onto the next line even if <code>BinPackParameters</code> is <code>false</code>. <div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">void</span> myFunction(</div>
<div class="line">    <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>, <span class="keywordtype">int</span> d, <span class="keywordtype">int</span> e);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">void</span> myFunction(<span class="keywordtype">int</span> a,</div>
<div class="line">                <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>,</div>
<div class="line">                <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>,</div>
<div class="line">                <span class="keywordtype">int</span> d,</div>
<div class="line">                <span class="keywordtype">int</span> e);</div>
</div><!-- fragment --> </dd>
<dd>
3.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00651">651</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad8da36904d4175e98433ea03b8756848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da36904d4175e98433ea03b8756848">&#9670;&nbsp;</a></span>AllowBreakBeforeNoexceptSpecifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a87cc60ebba19ff17e09ed2dd63d22cba">BreakBeforeNoexceptSpecifierStyle</a> clang::format::FormatStyle::AllowBreakBeforeNoexceptSpecifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls if there could be a line break before a <code>noexcept</code> specifier. </p>
<dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00692">692</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae35813d4f6867282560971273b02a966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35813d4f6867282560971273b02a966">&#9670;&nbsp;</a></span>AllowShortBlocksOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a594a2f875200530674b48f806d31a227">ShortBlockStyle</a> clang::format::FormatStyle::AllowShortBlocksOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dependent on the value, <code>while (true) { continue; }</code> can be put on a single line. </p>
<dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00725">725</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a4e35e1a6d4a13246530cd1760e78cf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e35e1a6d4a13246530cd1760e78cf84">&#9670;&nbsp;</a></span>AllowShortCaseLabelsOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowShortCaseLabelsOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, short case labels will be contracted to a single line. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                   <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordflow">switch</span> (a) {                    vs.     <span class="keywordflow">switch</span> (a) {</div>
<div class="line"><span class="keywordflow">case</span> 1: x = 1; <span class="keywordflow">break</span>;                   <span class="keywordflow">case</span> 1:</div>
<div class="line"><span class="keywordflow">case</span> 2: <span class="keywordflow">return</span>;                           x = 1;</div>
<div class="line">}                                         <span class="keywordflow">break</span>;</div>
<div class="line">                                        <span class="keywordflow">case</span> 2:</div>
<div class="line">                                          <span class="keywordflow">return</span>;</div>
<div class="line">                                        }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00739">739</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a64d44a5e918725c77a166607a2086ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d44a5e918725c77a166607a2086ecf">&#9670;&nbsp;</a></span>AllowShortCompoundRequirementOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowShortCompoundRequirementOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow short compound requirement on a single line. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">concept <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = requires(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> x) {</div>
<div class="line">  { x + 1 } -&gt; std::same_as&lt;int&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">concept <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = requires(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> x) {</div>
<div class="line">  {</div>
<div class="line">    x + 1</div>
<div class="line">  } -&gt; std::same_as&lt;int&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00758">758</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a53f83d1e629eaf3312db75a57e42782d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f83d1e629eaf3312db75a57e42782d">&#9670;&nbsp;</a></span>AllowShortEnumsOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowShortEnumsOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow short enums on a single line. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">enum</span> { A, B } myEnum;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">enum</span> {</div>
<div class="line">  A,</div>
<div class="line">  B</div>
<div class="line">} myEnum;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00772">772</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae3c557926bf65d7d94806f5e4001239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c557926bf65d7d94806f5e4001239d">&#9670;&nbsp;</a></span>AllowShortFunctionsOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9e649ad0d631fb02b66f55f1cb291c7b">ShortFunctionStyle</a> clang::format::FormatStyle::AllowShortFunctionsOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dependent on the value, <code>int f() { return 0; }</code> can be put on a single line. </p>
<dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00825">825</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad268e2b06c2521b80b2b36bf0ce99fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad268e2b06c2521b80b2b36bf0ce99fd8">&#9670;&nbsp;</a></span>AllowShortIfStatementsOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a5b1cf3879fa6bc4459d4737e440b6ec5">ShortIfStyle</a> clang::format::FormatStyle::AllowShortIfStatementsOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dependent on the value, <code>if (a) return;</code> can be put on a single line. </p>
<dl class="section version"><dt>Version</dt><dd>3.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00896">896</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a94289f5cf7855d4856ecd6861f1f0a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94289f5cf7855d4856ecd6861f1f0a66">&#9670;&nbsp;</a></span>AllowShortLambdasOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1443da0f05d0355c0073b16343fd3065">ShortLambdaStyle</a> clang::format::FormatStyle::AllowShortLambdasOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dependent on the value, <code>auto lambda []() { return 0; }</code> can be put on a single line. </p>
<dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00930">930</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a52ca039b50313d5b5de5207a8c9b2dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca039b50313d5b5de5207a8c9b2dfa">&#9670;&nbsp;</a></span>AllowShortLoopsOnASingleLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AllowShortLoopsOnASingleLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, <code>while (true) continue;</code> can be put on a single line. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00935">935</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a90b34f83ffd78f27d2a7dd21fa4fe223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b34f83ffd78f27d2a7dd21fa4fe223">&#9670;&nbsp;</a></span>AlwaysBreakAfterDefinitionReturnType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abdc06eef4565a8cdcd858356750a4181">DefinitionReturnTypeBreakingStyle</a> clang::format::FormatStyle::AlwaysBreakAfterDefinitionReturnType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function definition return type breaking style to use. </p>
<p>This option is <b>deprecated</b> and is retained for backwards compatibility. </p><dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01046">1046</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>.</p>

</div>
</div>
<a id="a03a80b6fa3e1785c7c59becbc621212d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a80b6fa3e1785c7c59becbc621212d">&#9670;&nbsp;</a></span>AlwaysBreakBeforeMultilineStrings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::AlwaysBreakBeforeMultilineStrings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is renamed to <code>BreakAfterReturnType</code>. </p>
<dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>
<p>If <code>true</code>, always break before multiline string literals.</p>
<p>This flag is mean to make cases where there are multiple multiline strings in a file look more consistent. Thus, it will only take effect if wrapping the string at that point leads to it being indented <code>ContinuationIndentWidth</code> spaces from the start of the line. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">aaaa =                         vs.     aaaa = <span class="stringliteral">&quot;bbbb&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;bbbb&quot;</span>                                    <span class="stringliteral">&quot;cccc&quot;</span>;</div>
<div class="line">    <span class="stringliteral">&quot;cccc&quot;</span>;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01066">1066</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a1344658016b418e7d3a8d915c3304fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1344658016b418e7d3a8d915c3304fa7">&#9670;&nbsp;</a></span>AttributeMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::AttributeMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is renamed to <code>BreakTemplateDeclarations</code>. </p>
<dl class="section version"><dt>Version</dt><dd>3.4 </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>
<p>A vector of strings that should be interpreted as attributes/qualifiers instead of identifiers. This can be useful for language extensions or static analyzer annotations.</p>
<p>For example: </p><div class="fragment"><div class="line">x = (<span class="keywordtype">char</span> *__capability)&amp;y;</div>
<div class="line"><span class="keywordtype">int</span> <span class="keyword">function</span>(void) __unused;</div>
<div class="line"><span class="keywordtype">void</span> only_writes_to_buffer(<span class="keywordtype">char</span> *__output buffer);</div>
</div><!-- fragment --><p>In the .clang-format configuration file, this can be configured like: </p><div class="fragment"><div class="line">AttributeMacros: [&#39;__capability&#39;, &#39;__output&#39;, &#39;__unused&#39;]</div>
</div><!-- fragment --><dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01136">1136</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a94112c67cd7e8e4f69ff6edb9b17fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94112c67cd7e8e4f69ff6edb9b17fd59">&#9670;&nbsp;</a></span>BinPackArguments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BinPackArguments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, a function call's arguments will either be all on the same line or will have one line each. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  f(aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">    aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01155">1155</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, and <a class="el" href="FormatToken_8cpp_source.html#l00202">clang::format::CommaSeparatedList::precomputeFormattingInfos()</a>.</p>

</div>
</div>
<a id="a861528acbc8f4088e276034ce4dbbe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861528acbc8f4088e276034ce4dbbe1b">&#9670;&nbsp;</a></span>BinPackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BinPackParameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, a function declaration's or function definition's parameters will either all be on the same line or will have one line each. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaa, <span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">       <span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">       <span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">       <span class="keywordtype">int</span> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01170">1170</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a29c6fbb51998b53d831f284c982e74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c6fbb51998b53d831f284c982e74b0">&#9670;&nbsp;</a></span>BitFieldColonSpacing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a97aab3da546bc93a6c14047372d920b4">BitFieldColonSpacingStyle</a> clang::format::FormatStyle::BitFieldColonSpacing</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The BitFieldColonSpacingStyle to use for bitfields. </p>
<dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01199">1199</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5bceb5ed304b784c4b65b9a68212c1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bceb5ed304b784c4b65b9a68212c1c1">&#9670;&nbsp;</a></span>BracedInitializerIndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classunsigned.html">unsigned</a>&gt; clang::format::FormatStyle::BracedInitializerIndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of columns to use to indent the contents of braced init lists. </p>
<p>If unset, <code>ContinuationIndentWidth</code> is used. </p><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#aa920e43c7189e9b90300239d276de797">AlignAfterOpenBracket</a>: AlwaysBreak</div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a5bceb5ed304b784c4b65b9a68212c1c1">BracedInitializerIndentWidth</a>: 2</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  SomeClass <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>{</div>
<div class="line">    <span class="stringliteral">&quot;foo&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;bar&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;baz&quot;</span>,</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">auto</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a> = SomeStruct{</div>
<div class="line">    .foo = <span class="stringliteral">&quot;foo&quot;</span>,</div>
<div class="line">    .bar = <span class="stringliteral">&quot;bar&quot;</span>,</div>
<div class="line">    .baz = <span class="stringliteral">&quot;baz&quot;</span>,</div>
<div class="line">  };</div>
<div class="line">  SomeArrayT a[3] = {</div>
<div class="line">    {</div>
<div class="line">      foo,</div>
<div class="line">      bar,</div>
<div class="line">    },</div>
<div class="line">    {</div>
<div class="line">      foo,</div>
<div class="line">      bar,</div>
<div class="line">    },</div>
<div class="line">    SomeArrayT{},</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa9513b8e157e945e0f9eb68bf6e7e7d7"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa9513b8e157e945e0f9eb68bf6e7e7d7">s</a></div><div class="ttdeci">__device__ __2f16 float __ockl_bool s</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00304">__clang_hip_libdevice_declares.h:304</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a5bceb5ed304b784c4b65b9a68212c1c1"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a5bceb5ed304b784c4b65b9a68212c1c1">clang::format::FormatStyle::BracedInitializerIndentWidth</a></div><div class="ttdeci">std::optional&lt; unsigned &gt; BracedInitializerIndentWidth</div><div class="ttdoc">The number of columns to use to indent the contents of braced init lists.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l01232">Format.h:1232</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_aa920e43c7189e9b90300239d276de797"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#aa920e43c7189e9b90300239d276de797">clang::format::FormatStyle::AlignAfterOpenBracket</a></div><div class="ttdeci">BracketAlignmentStyle AlignAfterOpenBracket</div><div class="ttdoc">If true, horizontally aligns arguments after an open bracket.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l00107">Format.h:107</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01232">1232</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac88441d1706049a6098e892dd6e730df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88441d1706049a6098e892dd6e730df">&#9670;&nbsp;</a></span>BraceWrapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1BraceWrappingFlags.html">BraceWrappingFlags</a> clang::format::FormatStyle::BraceWrapping</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control of individual brace wrapping cases. </p>
<p>If <code>BreakBeforeBraces</code> is set to <code>BS_Custom</code>, use this to specify how each individual brace case should be handled. Otherwise, this is ignored. </p><div class="fragment"><div class="line"># Example of usage:</div>
<div class="line">BreakBeforeBraces: Custom</div>
<div class="line">BraceWrapping:</div>
<div class="line">  AfterEnum: true</div>
<div class="line">  AfterStruct: false</div>
<div class="line">  SplitEmptyFunction: false</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01513">1513</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01267">clang::format::expandPresetsBraceWrapping()</a>, and <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="a047bd610318dd6e2f02497151ca7ec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047bd610318dd6e2f02497151ca7ec90">&#9670;&nbsp;</a></span>BreakAdjacentStringLiterals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakAdjacentStringLiterals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break between adjacent string literals. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordflow">return</span> <span class="stringliteral">&quot;Code&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;\0\52\26\55\55\0&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;x013&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;\02\xBA&quot;</span>;</div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordflow">return</span> <span class="stringliteral">&quot;Code&quot;</span> <span class="stringliteral">&quot;\0\52\26\55\55\0&quot;</span> <span class="stringliteral">&quot;x013&quot;</span> <span class="stringliteral">&quot;\02\xBA&quot;</span>;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01526">1526</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac09d889793e2461ec809003aabdfb5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09d889793e2461ec809003aabdfb5bb">&#9670;&nbsp;</a></span>BreakAfterAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a937ce324270bf866adf43576f0eec42a">AttributeBreakingStyle</a> clang::format::FormatStyle::BreakAfterAttributes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break after a group of C++11 attributes before variable or function (including constructor/destructor) declaration/definition names or before control statements, i.e. </p>
<p><code>if</code>, <code>switch</code> (including <code>case</code> and <code>default</code> labels), <code>for</code>, and <code>while</code> statements. </p><dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01613">1613</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5ad505c244da9a1dc2827726dd409f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad505c244da9a1dc2827726dd409f94">&#9670;&nbsp;</a></span>BreakAfterJavaFieldAnnotations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakAfterJavaFieldAnnotations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break after each annotation on a field in Java files. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">@Partial                       vs.     @Partial @Mock DataLoad loader;</div>
<div class="line">@Mock</div>
<div class="line">DataLoad loader;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02248">2248</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a04eed919d54a8731c24e720f8f700d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eed919d54a8731c24e720f8f700d40">&#9670;&nbsp;</a></span>BreakAfterReturnType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae8ce7f7cb26f4a6d278dd9b37a5b5d93">ReturnTypeBreakingStyle</a> clang::format::FormatStyle::BreakAfterReturnType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function declaration return type breaking style to use. </p>
<dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01617">1617</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5a9a1ef6079c3420b70bdcd547a3b5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a1ef6079c3420b70bdcd547a3b5bd">&#9670;&nbsp;</a></span>BreakArrays</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakArrays</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, clang-format will always break after a Json array <code>[</code> otherwise it will scan until the closing <code>]</code> to determine if it should add newlines between elements (prettier compatible). </p>
<dl class="section note"><dt>Note</dt><dd>This is currently only for formatting JSON. \endnote <div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">[                          vs.      [1, 2, 3, 4]</div>
<div class="line">  1,</div>
<div class="line">  2,</div>
<div class="line">  3,</div>
<div class="line">  4</div>
<div class="line">]</div>
</div><!-- fragment --> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01636">1636</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a26e7cc5dc54042fe2cd21fabfd1b4225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e7cc5dc54042fe2cd21fabfd1b4225">&#9670;&nbsp;</a></span>BreakBeforeBinaryOperators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a34f7b0cd30443b4c10869175b520e934">BinaryOperatorStyle</a> clang::format::FormatStyle::BreakBeforeBinaryOperators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way to wrap binary operators. </p>
<dl class="section version"><dt>Version</dt><dd>3.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l01691">1691</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a7bb74cb37f57d469d6760ec09e466647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb74cb37f57d469d6760ec09e466647">&#9670;&nbsp;</a></span>BreakBeforeBraces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a931e5c3eb76618e18dfdcff4677d98d7">BraceBreakingStyle</a> clang::format::FormatStyle::BreakBeforeBraces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The brace breaking style to use. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02126">2126</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01267">clang::format::expandPresetsBraceWrapping()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a30d55b546a66d24cee65141755f71048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d55b546a66d24cee65141755f71048">&#9670;&nbsp;</a></span>BreakBeforeConceptDeclarations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#aa3afcf7e5f9283420a641641e1d449d7">BreakBeforeConceptDeclarationsStyle</a> clang::format::FormatStyle::BreakBeforeConceptDeclarations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The concept declaration style to use. </p>
<dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02150">2150</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a929e52ec1ebefbfa0a47d014689a6599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e52ec1ebefbfa0a47d014689a6599">&#9670;&nbsp;</a></span>BreakBeforeInlineASMColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a47a1ef53a5e87b6bfecc81141f250d98">BreakBeforeInlineASMColonStyle</a> clang::format::FormatStyle::BreakBeforeInlineASMColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inline ASM colon style to use. </p>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02179">2179</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="af83c3653a76e6e749391f7d3663a8ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83c3653a76e6e749391f7d3663a8ce5">&#9670;&nbsp;</a></span>BreakBeforeTernaryOperators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakBeforeTernaryOperators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, ternary operators will be placed after line breaks. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line">veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription</div>
<div class="line">    ? firstValue</div>
<div class="line">    : SecondValueVeryVeryVeryVeryLong;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line">veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?</div>
<div class="line">    firstValue :</div>
<div class="line">    SecondValueVeryVeryVeryVeryLong;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02194">2194</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6d1d6ad0e075233214fff5e298f432e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1d6ad0e075233214fff5e298f432e8">&#9670;&nbsp;</a></span>BreakConstructorInitializers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2d560a46760acc52913885971cd50790">BreakConstructorInitializersStyle</a> clang::format::FormatStyle::BreakConstructorInitializers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The break constructor initializers style to use. </p>
<dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02224">2224</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a9f42df3954dc827999fed609f452f9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f42df3954dc827999fed609f452f9fb">&#9670;&nbsp;</a></span>BreakFunctionDefinitionParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakFunctionDefinitionParameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, clang-format will always break before function definition parameters. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">void</span> functionDefinition(</div>
<div class="line">         <span class="keywordtype">int</span> A, <span class="keywordtype">int</span> B) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">void</span> functionDefinition(<span class="keywordtype">int</span> A, <span class="keywordtype">int</span> B) {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02238">2238</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a09a84fddb46ef4546c5a1e246c266d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a84fddb46ef4546c5a1e246c266d67">&#9670;&nbsp;</a></span>BreakInheritanceList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7bbc9f42236eefecf84f381fedf1fa98">BreakInheritanceListStyle</a> clang::format::FormatStyle::BreakInheritanceList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inheritance list style to use. </p>
<dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02349">2349</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6f3b6f0a6153c976227e11093093bf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3b6f0a6153c976227e11093093bf29">&#9670;&nbsp;</a></span>BreakStringLiterals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::BreakStringLiterals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow breaking string literals when formatting. </p>
<p>In C, C++, and Objective-C: </p><div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* x = <span class="stringliteral">&quot;veryVeryVeryVeryVeryVe&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;ryVeryVeryVeryVeryVery&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;VeryLongString&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* x =</div>
<div class="line">    <span class="stringliteral">&quot;veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString&quot;</span>;</div>
</div><!-- fragment --><p>In C# and Java: </p><div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">string</span> x = <span class="stringliteral">&quot;veryVeryVeryVeryVeryVe&quot;</span> +</div>
<div class="line">           <span class="stringliteral">&quot;ryVeryVeryVeryVeryVery&quot;</span> +</div>
<div class="line">           <span class="stringliteral">&quot;VeryLongString&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">string</span> x =</div>
<div class="line">    <span class="stringliteral">&quot;veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString&quot;</span>;</div>
</div><!-- fragment --><p>C# interpolated strings are not broken.</p>
<p>In Verilog: </p><div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keywordtype">string</span> x = {<span class="stringliteral">&quot;veryVeryVeryVeryVeryVe&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;ryVeryVeryVeryVeryVery&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;VeryLongString&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">string</span> x =</div>
<div class="line">    <span class="stringliteral">&quot;veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString&quot;</span>;</div>
</div><!-- fragment --><dl class="section version"><dt>Version</dt><dd>3.9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02291">2291</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3193ddb985519cf0d38ffb17d4d12221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3193ddb985519cf0d38ffb17d4d12221">&#9670;&nbsp;</a></span>BreakTemplateDeclarations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a633755f5bf183748346c97afa9578a0c">BreakTemplateDeclarationsStyle</a> clang::format::FormatStyle::BreakTemplateDeclarations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The template declaration breaking style to use. </p>
<dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02353">2353</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="afe9550cc9c7c93fbc3506cb0b140593c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9550cc9c7c93fbc3506cb0b140593c">&#9670;&nbsp;</a></span>ColumnLimit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::ColumnLimit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The column limit. </p>
<p>A column limit of <code>0</code> means that there is no column limit. In this case, clang-format will respect the input's line breaking decisions within statements unless they contradict other rules. </p><dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02299">2299</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AtomicChange_8cpp_source.html#l00301">clang::tooling::applyAtomicChanges()</a>, <a class="el" href="FormatToken_8cpp_source.html#l00124">clang::format::CommaSeparatedList::formatAfterToken()</a>, <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="ContinuationIndenter_8cpp_source.html#l02814">clang::format::ContinuationIndenter::getColumnLimit()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, <a class="el" href="FormatToken_8cpp_source.html#l00202">clang::format::CommaSeparatedList::precomputeFormattingInfos()</a>, and <a class="el" href="ContinuationIndenter_8cpp_source.html#l00196">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="ab66e80203947743add360933aa7a2256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66e80203947743add360933aa7a2256">&#9670;&nbsp;</a></span>CommentPragmas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clang::format::FormatStyle::CommentPragmas</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A regular expression that describes comments with special meaning, which should not be split into lines or otherwise changed. </p>
<div class="fragment"><div class="line"><span class="comment">// CommentPragmas: &#39;^ FOOBAR pragma:&#39;</span></div>
<div class="line"><span class="comment">// Will leave the following line unaffected</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span> <span class="comment">// FOOBAR pragma: keep</span></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02309">2309</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a8901d6700758105da858cc31d2ba1862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8901d6700758105da858cc31d2ba1862">&#9670;&nbsp;</a></span>CompactNamespaces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::CompactNamespaces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, consecutive namespace declarations will be on the same line. </p>
<p>If <code>false</code>, each namespace is declared on a new line. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">namespace </span>Foo { <span class="keyword">namespace </span>Bar {</div>
<div class="line">}}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">namespace </span>Foo {</div>
<div class="line"><span class="keyword">namespace </span>Bar {</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><p>If it does not fit on a single line, the overflowing namespaces get wrapped: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>Foo { <span class="keyword">namespace </span>Bar {</div>
<div class="line"><span class="keyword">namespace </span>Extra {</div>
<div class="line">}}}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02377">2377</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a87a31c95b98c7ba6c606237473f61981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a31c95b98c7ba6c606237473f61981">&#9670;&nbsp;</a></span>ConstructorInitializerIndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::ConstructorInitializerIndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is <b>deprecated</b>. </p>
<p>See <code>CurrentLine</code> of <code>PackConstructorInitializers</code>. </p><dl class="section version"><dt>Version</dt><dd>3.7 The number of characters to use for indentation of constructor initializer lists as well as inheritance lists. </dd>
<dd>
3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02387">2387</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a0384417b961b70560004a52de799d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0384417b961b70560004a52de799d7cc">&#9670;&nbsp;</a></span>ContinuationIndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::ContinuationIndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent width for line continuations. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a0384417b961b70560004a52de799d7cc">ContinuationIndentWidth</a>: 2</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> i =         <span class="comment">//  VeryVeryVeryVeryVeryLongComment</span></div>
<div class="line">  longFunction( <span class="comment">// Again a long comment</span></div>
<div class="line">    <a class="code" href="namespacestd.html#abc7307bd3d6368059069bfe77bee0439">arg</a>);</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a0384417b961b70560004a52de799d7cc"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a0384417b961b70560004a52de799d7cc">clang::format::FormatStyle::ContinuationIndentWidth</a></div><div class="ttdeci">unsigned ContinuationIndentWidth</div><div class="ttdoc">Indent width for line continuations.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l02398">Format.h:2398</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02398">2398</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00696">clang::format::BreakableBlockComment::getContentIndent()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a082f72ed255395cea133365999de70a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082f72ed255395cea133365999de70a1">&#9670;&nbsp;</a></span>Cpp11BracedListStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::Cpp11BracedListStyle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, format braced lists as best suited for C++11 braced lists. </p>
<p>Important differences:</p><ul>
<li>No spaces inside the braced list.</li>
<li>No line break before the closing brace.</li>
<li>Indentation with the continuation indent, not with the block indent.</li>
</ul>
<p>Fundamentally, C++11 braced lists are formatted exactly like function calls would be formatted in their place. If the braced list follows a name (e.g. a type or variable name), clang-format formats as if the <code>{}</code> were the parentheses of a function call with that name. If there is no name, a zero-length name is assumed. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">vector&lt;int&gt; x{1, 2, 3, 4};     vs.     vector&lt;int&gt; x{ 1, 2, 3, 4 };</div>
<div class="line">vector&lt;T&gt; x{{}, {}, {}, {}};           vector&lt;T&gt; x{ {}, {}, {}, {} };</div>
<div class="line">f(MyMap[{composite, key}]);            f(MyMap[{ composite, key }]);</div>
<div class="line"><span class="keyword">new</span> <span class="keywordtype">int</span>[3]{1, 2, 3};                   <span class="keyword">new</span> <span class="keywordtype">int</span>[3]{ 1, 2, 3 };</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02421">2421</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, and <a class="el" href="FormatToken_8cpp_source.html#l00202">clang::format::CommaSeparatedList::precomputeFormattingInfos()</a>.</p>

</div>
</div>
<a id="a329af409f225a629965c88cfb686feec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329af409f225a629965c88cfb686feec">&#9670;&nbsp;</a></span>DerivePointerAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::DerivePointerAlignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This option is <b>deprecated</b>. </p>
<p>See <code>DeriveLF</code> and <code>DeriveCRLF</code> of <code>LineEnding</code>. </p><dl class="section version"><dt>Version</dt><dd>10 If <code>true</code>, analyze the formatted file for the most common alignment of <code>&amp;</code> and <code>*</code>. Pointer and reference alignment styles are going to be updated according to the preferences found in the file. <code>PointerAlignment</code> is then used only as fallback. </dd>
<dd>
3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02434">2434</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="abc9a7cd35c99de4dac239136a3060108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9a7cd35c99de4dac239136a3060108">&#9670;&nbsp;</a></span>DisableFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::DisableFormat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables formatting completely. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02438">2438</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01924">clang::format::getNoStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae97ed6f0bb2c3809daf8e9a5f06f381d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97ed6f0bb2c3809daf8e9a5f06f381d">&#9670;&nbsp;</a></span>EmptyLineAfterAccessModifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abd49000e263fa5f5ebcd7a490a108422">EmptyLineAfterAccessModifierStyle</a> clang::format::FormatStyle::EmptyLineAfterAccessModifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines when to put an empty line after access modifiers. </p>
<p><code>EmptyLineBeforeAccessModifier</code> configuration handles the number of empty lines between two access modifiers. </p><dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02489">2489</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad7872685696a4070aea7032539266e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7872685696a4070aea7032539266e62">&#9670;&nbsp;</a></span>EmptyLineBeforeAccessModifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2c08778fc0e59e3f1f2888da08f854d5">EmptyLineBeforeAccessModifierStyle</a> clang::format::FormatStyle::EmptyLineBeforeAccessModifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines in which cases to put empty line before access modifiers. </p>
<dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02552">2552</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5ecc064cf590382856b68c4568c0ce24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecc064cf590382856b68c4568c0ce24">&#9670;&nbsp;</a></span>ExperimentalAutoDetectBinPacking</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::ExperimentalAutoDetectBinPacking</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, clang-format detects whether function calls and definitions are formatted with one parameter per line. </p>
<p>Each call can be bin-packed, one-per-line or inconclusive. If it is inconclusive, e.g. completely on one line, but a decision needs to be made, clang-format analyzes whether there are other bin-packed cases in the input file and act accordingly.</p>
<dl class="section note"><dt>Note</dt><dd>This is an experimental flag, that might go away or be renamed. Do not use this in config files, etc. Use at your own risk. \endnote </dd></dl>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02567">2567</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3ad1fe5d6b71f7b8f57a46cb81358f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad1fe5d6b71f7b8f57a46cb81358f3e">&#9670;&nbsp;</a></span>FixNamespaceComments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::FixNamespaceComments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, clang-format adds missing namespace end comments for namespaces and fixes invalid existing ones. </p>
<p>This doesn't affect short namespaces, which are controlled by <code>ShortNamespaceLines</code>. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">namespace </span>longNamespace {      vs.     <span class="keyword">namespace </span>longNamespace {</div>
<div class="line"><span class="keywordtype">void</span> foo();                            <span class="keywordtype">void</span> foo();</div>
<div class="line"><span class="keywordtype">void</span> bar();                            <span class="keywordtype">void</span> bar();</div>
<div class="line">} <span class="comment">// namespace a                       }</span></div>
<div class="line"><span class="keyword">namespace </span>shortNamespace {             <span class="keyword">namespace </span>shortNamespace {</div>
<div class="line"><span class="keywordtype">void</span> baz();                            <span class="keywordtype">void</span> baz();</div>
<div class="line">}                                      }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02583">2583</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6796db39ca57a3bb76d09051e3aeefb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6796db39ca57a3bb76d09051e3aeefb8">&#9670;&nbsp;</a></span>ForEachMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::ForEachMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros that should be interpreted as foreach loops instead of as function calls. </p>
<p>These are expected to be macros of the form: </p><div class="fragment"><div class="line">FOREACH(&lt;variable-declaration&gt;, ...)</div>
<div class="line">  &lt;loop-body&gt;</div>
</div><!-- fragment --><p>In the .clang-format configuration file, this can be configured like: </p><div class="fragment"><div class="line">ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;]</div>
</div><!-- fragment --><p>For example: BOOST_FOREACH. </p><dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02601">2601</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a59c3c0a900da46f6533abac8446e43ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c3c0a900da46f6533abac8446e43ae">&#9670;&nbsp;</a></span>IfMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::IfMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros that should be interpreted as conditionals instead of as function calls. </p>
<p>These are expected to be macros of the form: </p><div class="fragment"><div class="line">IF(...)</div>
<div class="line">  &lt;conditional-body&gt;</div>
<div class="line"><span class="keywordflow">else</span> IF(...)</div>
<div class="line">  &lt;conditional-body&gt;</div>
</div><!-- fragment --><p>In the .clang-format configuration file, this can be configured like: </p><div class="fragment"><div class="line">IfMacros: [&#39;IF&#39;]</div>
</div><!-- fragment --><p>For example: <code>KJ_IF_MAYBE &lt;<a href="https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md">https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md</a>#maybes&gt;</code>_ </p><dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02624">2624</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="afe5c317444cf95ed94d84580c96f7b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5c317444cf95ed94d84580c96f7b36">&#9670;&nbsp;</a></span>IncludeStyle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1tooling_1_1IncludeStyle.html">tooling::IncludeStyle</a> clang::format::FormatStyle::IncludeStyle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02603">2603</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aebbb2cb8e04b9114557c59c4b9de0e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbb2cb8e04b9114557c59c4b9de0e51">&#9670;&nbsp;</a></span>IndentAccessModifiers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentAccessModifiers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify whether access modifiers should have their own indentation level. </p>
<p>When <code>false</code>, access modifiers are indented (or outdented) relative to the record members, respecting the <code>AccessModifierOffset</code>. Record members are indented one level below the record. When <code>true</code>, access modifiers get their own indentation level. As a consequence, record members are always indented 2 levels below the record, regardless of the access modifier presence. <a class="el" href="classclang_1_1Value.html">Value</a> of the <code>AccessModifierOffset</code> is ignored. </p><div class="fragment"><div class="line"><span class="keyword">false</span>:                                 <span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {                      vs.     <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keyword">class </span>D {                                <span class="keyword">class </span>D {</div>
<div class="line">    <span class="keywordtype">void</span> bar();                                <span class="keywordtype">void</span> bar();</div>
<div class="line">  <span class="keyword">protected</span>:                                 <span class="keyword">protected</span>:</div>
<div class="line">    D();                                       D();</div>
<div class="line">  };                                       };</div>
<div class="line"><span class="keyword">public</span>:                                  <span class="keyword">public</span>:</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();                                     <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line">};                                     };</div>
<div class="line"><span class="keywordtype">void</span> foo() {                           <span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keywordflow">return</span> 1;                              <span class="keywordflow">return</span> 1;</div>
<div class="line">}                                      }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02651">2651</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a2e2c8c3ab1814b00243c816deb29b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2c8c3ab1814b00243c816deb29b538">&#9670;&nbsp;</a></span>IndentCaseBlocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentCaseBlocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent case label blocks one level from the case label. </p>
<p>When <code>false</code>, the block following the case label uses the same indentation level as for the case label, treating the case label the same as an if-statement. When <code>true</code>, the block gets indented as a scope block. </p><div class="fragment"><div class="line"><span class="keyword">false</span>:                                 <span class="keyword">true</span>:</div>
<div class="line"><span class="keywordflow">switch</span> (fool) {                vs.     <span class="keywordflow">switch</span> (fool) {</div>
<div class="line"><span class="keywordflow">case</span> 1: {                              <span class="keywordflow">case</span> 1:</div>
<div class="line">  bar();                                 {</div>
<div class="line">} <span class="keywordflow">break</span>;                                   bar();</div>
<div class="line"><span class="keywordflow">default</span>: {                               }</div>
<div class="line">  plop();                                <span class="keywordflow">break</span>;</div>
<div class="line">}                                      <span class="keywordflow">default</span>:</div>
<div class="line">}                                        {</div>
<div class="line">                                           plop();</div>
<div class="line">                                         }</div>
<div class="line">                                       }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02674">2674</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a178999cdea92868a4f3dc332b36cc285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178999cdea92868a4f3dc332b36cc285">&#9670;&nbsp;</a></span>IndentCaseLabels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentCaseLabels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent case labels one level from the switch statement. </p>
<p>When <code>false</code>, use the same indentation level as for the switch statement. Switch statement body is always indented one level more than case labels (except the first block following the case label, which itself indents the code - unless IndentCaseBlocks is enabled). </p><div class="fragment"><div class="line"><span class="keyword">false</span>:                                 <span class="keyword">true</span>:</div>
<div class="line"><span class="keywordflow">switch</span> (fool) {                vs.     <span class="keywordflow">switch</span> (fool) {</div>
<div class="line"><span class="keywordflow">case</span> 1:                                  <span class="keywordflow">case</span> 1:</div>
<div class="line">  bar();                                   bar();</div>
<div class="line">  <span class="keywordflow">break</span>;                                   <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">default</span>:                                 <span class="keywordflow">default</span>:</div>
<div class="line">  plop();                                  plop();</div>
<div class="line">}                                      }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.3 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02693">2693</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="afd0c1858076c92847069daa7b3f5cb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0c1858076c92847069daa7b3f5cb1f">&#9670;&nbsp;</a></span>IndentExternBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a2db12bb7ed75faac357b59e0a34a08f6">IndentExternBlockStyle</a> clang::format::FormatStyle::IndentExternBlock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IndentExternBlockStyle is the type of indenting of extern blocks. </p>
<dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02750">2750</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac699b89a78eca1b92eee91f7c8b4be3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac699b89a78eca1b92eee91f7c8b4be3c">&#9670;&nbsp;</a></span>IndentGotoLabels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentGotoLabels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent goto labels. </p>
<p>When <code>false</code>, goto labels are flushed left. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">int</span> f() {                      vs.     <span class="keywordtype">int</span> f() {</div>
<div class="line">  <span class="keywordflow">if</span> (foo()) {                           <span class="keywordflow">if</span> (foo()) {</div>
<div class="line">  label1:                              label1:</div>
<div class="line">    bar();                                 bar();</div>
<div class="line">  }                                      }</div>
<div class="line">label2:                                label2:</div>
<div class="line">  <span class="keywordflow">return</span> 1;                              <span class="keywordflow">return</span> 1;</div>
<div class="line">}                                      }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>10 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02710">2710</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a1bea71409a0008ea6c19026cd942cedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bea71409a0008ea6c19026cd942cedf">&#9670;&nbsp;</a></span>IndentPPDirectives</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a48ffe13e89a74f5faa3b1f13f4dd6393">PPDirectiveIndentStyle</a> clang::format::FormatStyle::IndentPPDirectives</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The preprocessor directive indenting style to use. </p>
<dl class="section version"><dt>Version</dt><dd>6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02785">2785</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ContinuationIndenter_8cpp_source.html#l00246">clang::format::ContinuationIndenter::getInitialState()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a15f6f3a42d514c21624e6f03c6b8cf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f6f3a42d514c21624e6f03c6b8cf40">&#9670;&nbsp;</a></span>IndentRequiresClause</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentRequiresClause</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent the requires clause in a template. </p>
<p>This only applies when <code>RequiresClausePosition</code> is <code>OwnLine</code>, or <code>WithFollowing</code>.</p>
<p>In clang-format 12, 13 and 14 it was named <code>IndentRequires</code>. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</div>
<div class="line">  requires Iterator&lt;It&gt;</div>
<div class="line"><span class="keywordtype">void</span> sort(It begin, It end) {</div>
<div class="line">  <span class="comment">//....</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</div>
<div class="line">requires Iterator&lt;It&gt;</div>
<div class="line"><span class="keywordtype">void</span> sort(It begin, It end) {</div>
<div class="line">  <span class="comment">//....</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>15 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02807">2807</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a0e1f96ea453f4d8fc16ab55bc31baeb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1f96ea453f4d8fc16ab55bc31baeb2">&#9670;&nbsp;</a></span>IndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::IndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of columns to use for indentation. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a0e1f96ea453f4d8fc16ab55bc31baeb2">IndentWidth</a>: 3</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">   someFunction();</div>
<div class="line">   <span class="keywordflow">if</span> (<span class="keyword">true</span>, <span class="keyword">false</span>) {</div>
<div class="line">      f();</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a0e1f96ea453f4d8fc16ab55bc31baeb2"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a0e1f96ea453f4d8fc16ab55bc31baeb2">clang::format::FormatStyle::IndentWidth</a></div><div class="ttdeci">unsigned IndentWidth</div><div class="ttdoc">The number of columns to use for indentation.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l02821">Format.h:2821</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02821">2821</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a376802535e897befd601fc35d5f6f58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376802535e897befd601fc35d5f6f58e">&#9670;&nbsp;</a></span>IndentWrappedFunctionNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::IndentWrappedFunctionNames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indent if a function definition or declaration is wrapped after the type. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line">LoooooooooooooooooooooooooooooooooooooooongReturnType</div>
<div class="line">    LoooooooooooooooooooooooooooooooongFunctionDeclaration();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line">LoooooooooooooooooooooooooooooooooooooooongReturnType</div>
<div class="line">LoooooooooooooooooooooooooooooooongFunctionDeclaration();</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02835">2835</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae6e2a44d24d6b6651fb6750531daab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e2a44d24d6b6651fb6750531daab0a">&#9670;&nbsp;</a></span>InheritsParentConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::InheritsParentConfig</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l00059">59</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="a2e2e134cb4fa5c2d73a7cd8d16359655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2e134cb4fa5c2d73a7cd8d16359655">&#9670;&nbsp;</a></span>InsertBraces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::InsertBraces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert braces after control statements (<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, and <code>while</code>) in C++ unless the control statements are inside macro definitions or the braces would enclose preprocessor directives. </p>
<dl class="section warning"><dt>Warning</dt><dd>Setting this option to <code>true</code> could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option. \endwarning <div class="fragment"><div class="line"><span class="keyword">false</span>:                                    <span class="keyword">true</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D))        vs.      <span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D)) {</div>
<div class="line">  handleFunctionDecl(D);                    handleFunctionDecl(D);</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D))                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D)) {</div>
<div class="line">  handleVarDecl(D);                         handleVarDecl(D);</div>
<div class="line"><span class="keywordflow">else</span>                                      } <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="keywordflow">return</span>;                                   <span class="keywordflow">return</span>;</div>
<div class="line">                                          }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (i--)                      vs.      <span class="keywordflow">while</span> (i--) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs())                 <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs()) {</div>
<div class="line">    handleAttr(A);                            handleAttr(A);</div>
<div class="line">                                            }</div>
<div class="line">                                          }</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">do</span>                               vs.      <span class="keywordflow">do</span> {</div>
<div class="line">  --i;                                      --i;</div>
<div class="line"><span class="keywordflow">while</span> (i);                                } <span class="keywordflow">while</span> (i);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>15 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02867">2867</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aec4e7d40aeebee0fe9d5f62da1d72122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4e7d40aeebee0fe9d5f62da1d72122">&#9670;&nbsp;</a></span>InsertNewlineAtEOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::InsertNewlineAtEOF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a newline at end of file if missing. </p>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02871">2871</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6a604df2cc8e1935448f065ef42a5e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a604df2cc8e1935448f065ef42a5e51">&#9670;&nbsp;</a></span>InsertTrailingCommas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a20c259c49568c00e32091c1e1ff2c0f9">TrailingCommaStyle</a> clang::format::FormatStyle::InsertTrailingCommas</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set to <code>TCS_Wrapped</code> will insert trailing commas in container literals (arrays and objects) that wrap across multiple lines. </p>
<p>It is currently only available for JavaScript and disabled by default <code>TCS_None</code>. <code>InsertTrailingCommas</code> cannot be used together with <code>BinPackArguments</code> as inserting the comma disables bin-packing. </p><div class="fragment"><div class="line">TSC_Wrapped:</div>
<div class="line"><span class="keyword">const</span> someArray = [</div>
<div class="line">aaaaaaaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">aaaaaaaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line">aaaaaaaaaaaaaaaaaaaaaaaaaa,</div>
<div class="line"><span class="comment">//                        ^ inserted</span></div>
<div class="line">]</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02901">2901</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="a8f118ef9ae093a08781c49c190f1fe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f118ef9ae093a08781c49c190f1fe91">&#9670;&nbsp;</a></span>IntegerLiteralSeparator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1IntegerLiteralSeparatorStyle.html">IntegerLiteralSeparatorStyle</a> clang::format::FormatStyle::IntegerLiteralSeparator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format integer literal separators (<code>'</code> for C++ and <code>_</code> for C#, Java, and JavaScript). </p>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l02980">2980</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a4a710cbb8d487c2d555ab410dd8351d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a710cbb8d487c2d555ab410dd8351d0">&#9670;&nbsp;</a></span>JavaImportGroups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::JavaImportGroups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of prefixes ordered by the desired groups for Java imports. </p>
<p>One group's prefix can be a subset of another - the longest prefix is always matched. Within a group, the imports are ordered lexicographically. Static imports are grouped separately and follow the same group rules. By default, static imports are placed before non-static imports, but this behavior is changed by another option, <code>SortJavaStaticImport</code>.</p>
<p>In the .clang-format configuration file, this can be configured like in the following yaml example. This will result in imports being formatted as in the Java example below. </p><div class="fragment"><div class="line">JavaImportGroups: [&#39;com.example&#39;, &#39;com&#39;, &#39;org&#39;]</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.example.function1;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.test.function2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.function3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> com.example.ClassA;</div>
<div class="line"><span class="keyword">import</span> com.example.Test;</div>
<div class="line"><span class="keyword">import</span> com.example.a.ClassB;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> com.test.ClassC;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> org.example.ClassD;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03014">3014</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab727d146cfab5867722ff9f017ec7d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab727d146cfab5867722ff9f017ec7d43">&#9670;&nbsp;</a></span>JavaScriptQuotes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8daad6d27cb88ae2796e2603faef4131">JavaScriptQuoteStyle</a> clang::format::FormatStyle::JavaScriptQuotes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The JavaScriptQuoteStyle to use for JavaScript strings. </p>
<dl class="section version"><dt>Version</dt><dd>3.9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03041">3041</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad8ee69af675ea748e8f5782eb779f606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ee69af675ea748e8f5782eb779f606">&#9670;&nbsp;</a></span>JavaScriptWrapImports</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::JavaScriptWrapImports</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to wrap JavaScript import/export statements. </p>
<div class="fragment"><div class="line">true:</div>
<div class="line">import {</div>
<div class="line">    VeryLongImportsAreAnnoying,</div>
<div class="line">    VeryLongImportsAreAnnoying,</div>
<div class="line">    VeryLongImportsAreAnnoying,</div>
<div class="line">} from &#39;some/module.js&#39;</div>
<div class="line"> </div>
<div class="line">false:</div>
<div class="line">import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from &quot;some/module.js&quot;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03057">3057</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae3197474d55d0fd650e0f7ace1263659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3197474d55d0fd650e0f7ace1263659">&#9670;&nbsp;</a></span>KeepEmptyLinesAtEOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::KeepEmptyLinesAtEOF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep empty lines (up to <code>MaxEmptyLinesToKeep</code>) at end of file. </p>
<dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03062">3062</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae5dbf64fe3deb97c962fed5ae2c85fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dbf64fe3deb97c962fed5ae2c85fff">&#9670;&nbsp;</a></span>KeepEmptyLinesAtTheStartOfBlocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::KeepEmptyLinesAtTheStartOfBlocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, the empty line at the start of blocks is kept. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordflow">if</span> (foo) {                     vs.     <span class="keywordflow">if</span> (foo) {</div>
<div class="line">                                         bar();</div>
<div class="line">  bar();                               }</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03073">3073</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac21906e890daa15742d40bdfe6566613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21906e890daa15742d40bdfe6566613">&#9670;&nbsp;</a></span>LambdaBodyIndentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a49fa34a2ee0f9c4f37aa0823ee37a1ff">LambdaBodyIndentationKind</a> clang::format::FormatStyle::LambdaBodyIndentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indentation style of lambda bodies. </p>
<p><code>Signature</code> (the default) causes the lambda body to be indented one additional level relative to the indentation level of the signature. <code>OuterScope</code> forces the lambda body to be indented one additional level relative to the parent scope containing the lambda signature. </p><dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03107">3107</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3e83ab348f7a48c1eefbc866a134cfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e83ab348f7a48c1eefbc866a134cfe9">&#9670;&nbsp;</a></span>Language</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a06e3e163ea545132563cad08dc8598e6">LanguageKind</a> clang::format::FormatStyle::Language</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Language, this format style is targeted at. </p>
<dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03154">3154</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="BreakableToken_8cpp_source.html#l00696">clang::format::BreakableBlockComment::getContentIndent()</a>, <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="ContinuationIndenter_8cpp_source.html#l00246">clang::format::ContinuationIndenter::getInitialState()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="FormatTokenLexer_8cpp_source.html#l00079">clang::format::FormatTokenLexer::lex()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, and <a class="el" href="ContinuationIndenter_8cpp_source.html#l00196">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="af6269937f6158ee331ff67af7519ecc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6269937f6158ee331ff67af7519ecc1">&#9670;&nbsp;</a></span>LineEnding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a35260df344afa7ec64c80750d37b3a5d">LineEndingStyle</a> clang::format::FormatStyle::LineEnding</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line ending style (<code>\n</code> or <code>\r\n</code>) to use. </p>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03170">3170</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3d09aa93387fc5d95def63c59d0692a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d09aa93387fc5d95def63c59d0692a3">&#9670;&nbsp;</a></span>MacroBlockBegin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clang::format::FormatStyle::MacroBlockBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A regular expression matching macros that start a block. </p>
<div class="fragment"><div class="line"><span class="preprocessor"># With:</span></div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a3d09aa93387fc5d95def63c59d0692a3">MacroBlockBegin</a>: <span class="stringliteral">&quot;^NS_MAP_BEGIN|\</span></div>
<div class="line"><span class="stringliteral">NS_TABLE_HEAD$&quot;</span></div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#ae35d37ff2d74806696a34f969de7dddc">MacroBlockEnd</a>: <span class="stringliteral">&quot;^\</span></div>
<div class="line"><span class="stringliteral">NS_MAP_END|\</span></div>
<div class="line"><span class="stringliteral">NS_TABLE_.*_END$&quot;</span></div>
<div class="line"> </div>
<div class="line">NS_MAP_BEGIN</div>
<div class="line">  foo();</div>
<div class="line">NS_MAP_END</div>
<div class="line"> </div>
<div class="line">NS_TABLE_HEAD</div>
<div class="line">  bar();</div>
<div class="line">NS_TABLE_FOO_END</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Without:</span></div>
<div class="line">NS_MAP_BEGIN</div>
<div class="line">foo();</div>
<div class="line">NS_MAP_END</div>
<div class="line"> </div>
<div class="line">NS_TABLE_HEAD</div>
<div class="line">bar();</div>
<div class="line">NS_TABLE_FOO_END</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a3d09aa93387fc5d95def63c59d0692a3"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a3d09aa93387fc5d95def63c59d0692a3">clang::format::FormatStyle::MacroBlockBegin</a></div><div class="ttdeci">std::string MacroBlockBegin</div><div class="ttdoc">A regular expression matching macros that start a block.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l03199">Format.h:3199</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_ae35d37ff2d74806696a34f969de7dddc"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#ae35d37ff2d74806696a34f969de7dddc">clang::format::FormatStyle::MacroBlockEnd</a></div><div class="ttdeci">std::string MacroBlockEnd</div><div class="ttdoc">A regular expression matching macros that end a block.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l03203">Format.h:3203</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03199">3199</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae35d37ff2d74806696a34f969de7dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35d37ff2d74806696a34f969de7dddc">&#9670;&nbsp;</a></span>MacroBlockEnd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string clang::format::FormatStyle::MacroBlockEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A regular expression matching macros that end a block. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03203">3203</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a1d3b4d144014285bf9f1255ef3c6b6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3b4d144014285bf9f1255ef3c6b6a1">&#9670;&nbsp;</a></span>Macros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::Macros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of macros of the form <code></code> &lt;definition&gt;=&lt;expansion&gt; . </p>
<p>Code will be parsed with macros expanded, in order to determine how to interpret and format the macro arguments.</p>
<p>For example, the code: </p><div class="fragment"><div class="line">A(a*<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
</div><!-- fragment --><p>will usually be interpreted as a call to a function A, and the multiplication expression will be formatted as <code>a * b</code>.</p>
<p>If we specify the macro definition: </p><div class="fragment"><div class="line">Macros:</div>
<div class="line">- A(x)=x</div>
</div><!-- fragment --><p>the code will now be parsed as a declaration of the variable b of type a*, and formatted as <code>a* b</code> (depending on pointer-binding rules).</p>
<p>Features and restrictions:</p><ul>
<li>Both function-like macros and object-like macros are supported.</li>
<li>Macro arguments must be used exactly once in the expansion.</li>
<li>No recursive expansion; macros referencing other macros will be ignored.</li>
<li>Overloading by arity is supported: for example, given the macro definitions A=x, A()=y, A(a)=a</li>
</ul>
<div class="fragment"><div class="line">A; -&gt; x;</div>
<div class="line">A(); -&gt; y;</div>
<div class="line">A(z); -&gt; z;</div>
<div class="line">A(a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>); <span class="comment">// will not be expanded.</span></div>
</div><!-- fragment --><dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03243">3243</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aafca7a61d6d72ab0adf276ace30155d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca7a61d6d72ab0adf276ace30155d5">&#9670;&nbsp;</a></span>MaxEmptyLinesToKeep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::MaxEmptyLinesToKeep</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of consecutive empty lines to keep. </p>
<div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#aafca7a61d6d72ab0adf276ace30155d5">MaxEmptyLinesToKeep</a>: 1         vs.     <a class="code" href="structclang_1_1format_1_1FormatStyle.html#aafca7a61d6d72ab0adf276ace30155d5">MaxEmptyLinesToKeep</a>: 0</div>
<div class="line"><span class="keywordtype">int</span> f() {                              <span class="keywordtype">int</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> = 1;                                 <span class="keywordtype">int</span> i = 1;</div>
<div class="line">                                           i = foo();</div>
<div class="line">  i = foo();                               <span class="keywordflow">return</span> i;</div>
<div class="line">                                       }</div>
<div class="line">  <span class="keywordflow">return</span> i;</div>
<div class="line">}</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_aafca7a61d6d72ab0adf276ace30155d5"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#aafca7a61d6d72ab0adf276ace30155d5">clang::format::FormatStyle::MaxEmptyLinesToKeep</a></div><div class="ttdeci">unsigned MaxEmptyLinesToKeep</div><div class="ttdoc">The maximum number of consecutive empty lines to keep.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l03257">Format.h:3257</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03257">3257</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5a74c72d0ca5b345b9d5cf6d40da0adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a74c72d0ca5b345b9d5cf6d40da0adf">&#9670;&nbsp;</a></span>NamespaceIndentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae26cac0d904a16d43ac52c049d9db622">NamespaceIndentationKind</a> clang::format::FormatStyle::NamespaceIndentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indentation used for namespaces. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03295">3295</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ac0724e85bdea3e79ccff8812339536d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0724e85bdea3e79ccff8812339536d5">&#9670;&nbsp;</a></span>NamespaceMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::NamespaceMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros which are used to open namespace blocks. </p>
<p>These are expected to be macros of the form: </p><div class="fragment"><div class="line">NAMESPACE(&lt;<span class="keyword">namespace</span>-<a class="code" href="namespaceclang_1_1transformer.html#afb9ae3f6ff9907205cd12c218f76df7e">name</a>&gt;, ...) {</div>
<div class="line">  &lt;<span class="keyword">namespace</span>-content&gt;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceclang_1_1transformer_html_afb9ae3f6ff9907205cd12c218f76df7e"><div class="ttname"><a href="namespaceclang_1_1transformer.html#afb9ae3f6ff9907205cd12c218f76df7e">clang::transformer::name</a></div><div class="ttdeci">RangeSelector name(std::string ID)</div><div class="ttdoc">Given a node with a &quot;name&quot;, (like NamedDecl, DeclRefExpr, CxxCtorInitializer, and TypeLoc) selects th...</div><div class="ttdef"><b>Definition:</b> <a href="RangeSelector_8cpp_source.html#l00200">RangeSelector.cpp:200</a></div></div>
</div><!-- fragment --><p>For example: TESTSUITE </p><dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03308">3308</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab1db225068abf27cba93aec1a485d863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1db225068abf27cba93aec1a485d863">&#9670;&nbsp;</a></span>ObjCBinPackProtocolList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a299636b6bf3abfe22e688270dd44c3b2">BinPackStyle</a> clang::format::FormatStyle::ObjCBinPackProtocolList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls bin-packing Objective-C protocol conformance list items into as few lines as possible when they go over <code>ColumnLimit</code>. </p>
<p>If <code>Auto</code> (the default), delegates to the value in <code>BinPackParameters</code>. If that is <code>true</code>, bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over <code>ColumnLimit</code>.</p>
<p>If <code>Always</code>, always bin-packs Objective-C protocol conformance list items into as few lines as possible whenever they go over <code>ColumnLimit</code>.</p>
<p>If <code>Never</code>, lays out Objective-C protocol conformance list items onto individual lines whenever they go over <code>ColumnLimit</code>.</p>
<div class="fragment"><div class="line">Always (or Auto, if BinPackParameters=true):</div>
<div class="line">@interface ccccccccccccc () &lt;</div>
<div class="line">    ccccccccccccc, ccccccccccccc,</div>
<div class="line">    ccccccccccccc, ccccccccccccc&gt; {</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Never (or Auto, if BinPackParameters=false):</div>
<div class="line">@interface ddddddddddddd () &lt;</div>
<div class="line">    ddddddddddddd,</div>
<div class="line">    ddddddddddddd,</div>
<div class="line">    ddddddddddddd,</div>
<div class="line">    ddddddddddddd&gt; {</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03341">3341</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5112a40bafcc47664ab0d751bd84b44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5112a40bafcc47664ab0d751bd84b44b">&#9670;&nbsp;</a></span>ObjCBlockIndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::ObjCBlockIndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of characters to use for indentation of ObjC blocks. </p>
<div class="fragment"><div class="line">ObjCBlockIndentWidth: 4</div>
<div class="line"> </div>
<div class="line">[operation setCompletionBlock:^{</div>
<div class="line">    [self onOperationDone];</div>
<div class="line">}];</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03352">3352</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5f68fffff5cf94f20ed706d1980c02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f68fffff5cf94f20ed706d1980c02db">&#9670;&nbsp;</a></span>ObjCBreakBeforeNestedBlockParam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::ObjCBreakBeforeNestedBlockParam</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break parameters list into lines when there is nested block parameters in a function call. </p>
<div class="fragment"><div class="line"><span class="keyword">false</span>:</div>
<div class="line"> - (void)_aMethod</div>
<div class="line"> {</div>
<div class="line">     [<span class="keyword">self</span>.test1 t:<span class="keyword">self</span> w:<span class="keyword">self</span> callback:^(typeof(<span class="keyword">self</span>) self, NSNumber</div>
<div class="line">     *u, NSNumber *<a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>) {</div>
<div class="line">         u = <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">     }]</div>
<div class="line"> }</div>
<div class="line"> <span class="keyword">true</span>:</div>
<div class="line"> - (void)_aMethod</div>
<div class="line"> {</div>
<div class="line">    [<span class="keyword">self</span>.test1 t:<span class="keyword">self</span></div>
<div class="line">                 w:<span class="keyword">self</span></div>
<div class="line">        callback:^(typeof(<span class="keyword">self</span>) self, NSNumber *u, NSNumber *<a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>) {</div>
<div class="line">             u = <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">         }]</div>
<div class="line"> }</div>
<div class="ttc" id="aarm__acle_8h_html_a8603782009ff58be0587ea58013b3e52"><div class="ttname"><a href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a></div><div class="ttdeci">do v</div><div class="ttdef"><b>Definition:</b> <a href="arm__acle_8h_source.html#l00083">arm_acle.h:83</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03376">3376</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a5cbff44c01f8a9231fdde63a20da497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbff44c01f8a9231fdde63a20da497c">&#9670;&nbsp;</a></span>ObjCPropertyAttributeOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::ObjCPropertyAttributeOrder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The order in which ObjC property attributes should appear. </p>
<p>Attributes in code will be sorted in the order specified. Any attributes encountered that are not mentioned in this array will be sorted last, in stable order. Comments between attributes will leave the attributes untouched. </p><dl class="section warning"><dt>Warning</dt><dd>Using this option could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option. \endwarning <div class="fragment"><div class="line">ObjCPropertyAttributeOrder: [</div>
<div class="line">    class, direct,</div>
<div class="line">    atomic, nonatomic,</div>
<div class="line">    assign, retain, strong, copy, weak, unsafe_unretained,</div>
<div class="line">    readonly, readwrite, getter, setter,</div>
<div class="line">    nullable, nonnull, null_resettable, null_unspecified</div>
<div class="line">]</div>
</div><!-- fragment --> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03399">3399</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a7725ac1f55bfd9fff0e3555974cfb1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7725ac1f55bfd9fff0e3555974cfb1c4">&#9670;&nbsp;</a></span>ObjCSpaceAfterProperty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::ObjCSpaceAfterProperty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a space after <code>@property</code> in Objective-C, i.e. </p>
<p>use <code>@property (readonly)</code> instead of <code>@property(readonly)</code>. </p><dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03404">3404</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3b0c9f0c4bb6b9b4e07704865a4acde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c9f0c4bb6b9b4e07704865a4acde6">&#9670;&nbsp;</a></span>ObjCSpaceBeforeProtocolList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::ObjCSpaceBeforeProtocolList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a space in front of an Objective-C protocol list, i.e. </p>
<p>use <code>Foo &lt;Protocol&gt;</code> instead of <code>Foo&lt;Protocol&gt;</code>. </p><dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03409">3409</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aa06db12bb3595e1a043c2d0487d1272b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06db12bb3595e1a043c2d0487d1272b">&#9670;&nbsp;</a></span>PackConstructorInitializers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a73a9eec5aa0372a3e5094d1011675d23">PackConstructorInitializersStyle</a> clang::format::FormatStyle::PackConstructorInitializers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pack constructor initializers style to use. </p>
<dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03471">3471</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="adb712c347a057da49196cbcfbdcfa72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb712c347a057da49196cbcfbdcfa72f">&#9670;&nbsp;</a></span>PenaltyBreakAssignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakAssignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking around an assignment operator. </p>
<dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03475">3475</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a2256bfa6b34a5916077066fb05ad92d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2256bfa6b34a5916077066fb05ad92d2">&#9670;&nbsp;</a></span>PenaltyBreakBeforeFirstCallParameter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakBeforeFirstCallParameter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking a function call after <code>call(</code>. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03479">3479</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae6b9c9cefa83f57a7075e9115bceac5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b9c9cefa83f57a7075e9115bceac5c">&#9670;&nbsp;</a></span>PenaltyBreakComment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakComment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for each line break introduced inside a comment. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03483">3483</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a4e7375a939438afdd39c267da5bda3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7375a939438afdd39c267da5bda3ec">&#9670;&nbsp;</a></span>PenaltyBreakFirstLessLess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakFirstLessLess</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking before the first <code>&lt;&lt;</code>. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03487">3487</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a616f9ce31a1db0c94835d21f2d693448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616f9ce31a1db0c94835d21f2d693448">&#9670;&nbsp;</a></span>PenaltyBreakOpenParenthesis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakOpenParenthesis</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking after <code>(</code>. </p>
<dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03491">3491</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a9689730aea8b71f3417a23057fe84388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9689730aea8b71f3417a23057fe84388">&#9670;&nbsp;</a></span>PenaltyBreakScopeResolution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakScopeResolution</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking after <code>::</code>. </p>
<dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03495">3495</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ade360c8aa3ede11110a1e13d31a7516f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade360c8aa3ede11110a1e13d31a7516f">&#9670;&nbsp;</a></span>PenaltyBreakString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakString</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for each line break introduced inside a string literal. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03499">3499</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6b73633f0cb705c699188b780b6905bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b73633f0cb705c699188b780b6905bc">&#9670;&nbsp;</a></span>PenaltyBreakTemplateDeclaration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyBreakTemplateDeclaration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for breaking after template declaration. </p>
<dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03503">3503</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a7f2b485ba27597314723b0b11e47f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2b485ba27597314723b0b11e47f099">&#9670;&nbsp;</a></span>PenaltyExcessCharacter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyExcessCharacter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The penalty for each character outside of the column limit. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03507">3507</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae1750316d05566314cc864c01e8af62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1750316d05566314cc864c01e8af62f">&#9670;&nbsp;</a></span>PenaltyIndentedWhitespace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyIndentedWhitespace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Penalty for each character of whitespace indentation (counted relative to leading non-whitespace column). </p>
<dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03512">3512</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="a96be8e4382866d0ce27a63786d5f8057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96be8e4382866d0ce27a63786d5f8057">&#9670;&nbsp;</a></span>PenaltyReturnTypeOnItsOwnLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::PenaltyReturnTypeOnItsOwnLine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Penalty for putting the return type of a function onto its own line. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03516">3516</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a97e120bc3116361bd6d92f9191a6c3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e120bc3116361bd6d92f9191a6c3c3">&#9670;&nbsp;</a></span>PointerAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#add72d7e5bd931e683d671940ee98a172">PointerAlignmentStyle</a> clang::format::FormatStyle::PointerAlignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer and reference alignment style. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03539">3539</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a8e6733256cfc8ae8a47c288c86743b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6733256cfc8ae8a47c288c86743b11">&#9670;&nbsp;</a></span>PPIndentWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> clang::format::FormatStyle::PPIndentWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of columns to use for indentation of preprocessor statements. </p>
<p>When set to -1 (default) <code>IndentWidth</code> is used also for preprocessor statements. </p><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a8e6733256cfc8ae8a47c288c86743b11">PPIndentWidth</a>: 1</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef __linux__</span></div>
<div class="line"><span class="preprocessor"># define FOO</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"># define BAR</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a8e6733256cfc8ae8a47c288c86743b11"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a8e6733256cfc8ae8a47c288c86743b11">clang::format::FormatStyle::PPIndentWidth</a></div><div class="ttdeci">int PPIndentWidth</div><div class="ttdoc">The number of columns to use for indentation of preprocessor statements.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l03554">Format.h:3554</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03554">3554</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="ac26b33f834e61a32e53ecc466ac0ec12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26b33f834e61a32e53ecc466ac0ec12">&#9670;&nbsp;</a></span>QualifierAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#af1153efd05d9632bcc0f364abfcb22ef">QualifierAlignmentStyle</a> clang::format::FormatStyle::QualifierAlignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different ways to arrange specifiers and qualifiers (e.g. </p>
<p>const/volatile). </p><dl class="section warning"><dt>Warning</dt><dd>Setting <code>QualifierAlignment</code> to something other than <code>Leave</code>, COULD lead to incorrect code formatting due to incorrect decisions made due to clang-formats lack of complete semantic information. As such extra care should be taken to review code changes made by the use of this option. \endwarning </dd></dl>
<dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03600">3600</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a53777b5478ec7f9751c93ce8d23e71fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53777b5478ec7f9751c93ce8d23e71fe">&#9670;&nbsp;</a></span>QualifierOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::QualifierOrder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The order in which the qualifiers appear. </p>
<p>Order is an array that can contain any of the following:</p>
<ul>
<li>const</li>
<li>inline</li>
<li>static</li>
<li>friend</li>
<li>constexpr</li>
<li>volatile</li>
<li>restrict</li>
<li>type</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>it MUST contain 'type'. \endnote</dd></dl>
<p>Items to the left of 'type' will be placed to the left of the type and aligned in the order supplied. Items to the right of 'type' will be placed to the right of the type and aligned in the order supplied.</p>
<div class="fragment"><div class="line">QualifierOrder: [&#39;inline&#39;, &#39;static&#39;, &#39;type&#39;, &#39;const&#39;, &#39;volatile&#39; ]</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03626">3626</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a18daec6fe8444a5efaae0832e124ef62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18daec6fe8444a5efaae0832e124ef62">&#9670;&nbsp;</a></span>RawStringFormats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structclang_1_1format_1_1FormatStyle_1_1RawStringFormat.html">RawStringFormat</a>&gt; clang::format::FormatStyle::RawStringFormats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines hints for detecting supported languages code blocks in raw strings. </p>
<p>A raw string with a matching delimiter or a matching enclosing function name will be reformatted assuming the specified language based on the style for that language defined in the .clang-format file. If no style has been defined in the .clang-format file for the specific language, a predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not found, the formatting is based on llvm style. A matching delimiter takes precedence over a matching enclosing function name for determining the language of the raw string contents.</p>
<p>If a canonical delimiter is specified, occurrences of other delimiters for the same language will be updated to the canonical if possible.</p>
<p>There should be at most one specification per language and each delimiter and enclosing function should not occur in multiple specifications.</p>
<p>To configure this in the .clang-format file, use: </p><div class="fragment"><div class="line">RawStringFormats:</div>
<div class="line">  - Language: TextProto</div>
<div class="line">      Delimiters:</div>
<div class="line">        - &#39;pb&#39;</div>
<div class="line">        - &#39;proto&#39;</div>
<div class="line">      EnclosingFunctions:</div>
<div class="line">        - &#39;PARSE_TEXT_PROTO&#39;</div>
<div class="line">      BasedOnStyle: google</div>
<div class="line">  - Language: Cpp</div>
<div class="line">      Delimiters:</div>
<div class="line">        - &#39;cc&#39;</div>
<div class="line">        - &#39;cpp&#39;</div>
<div class="line">      BasedOnStyle: llvm</div>
<div class="line">      CanonicalDelimiter: &#39;cc&#39;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03686">3686</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8h_source.html#l04901">operator==()</a>, and <a class="el" href="ContinuationIndenter_8cpp_source.html#l00196">clang::format::RawStringFormatStyleManager::RawStringFormatStyleManager()</a>.</p>

</div>
</div>
<a id="a679827432d81baa1e09fab263e31622d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679827432d81baa1e09fab263e31622d">&#9670;&nbsp;</a></span>ReferenceAlignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ae910a8281f74d90f22d702e35f3c0ef6">ReferenceAlignmentStyle</a> clang::format::FormatStyle::ReferenceAlignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference alignment style (overrides <code>PointerAlignment</code> for references). </p>
<dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03712">3712</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aae9878977b6ca4e6918b4c1bbe6bce8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9878977b6ca4e6918b4c1bbe6bce8c">&#9670;&nbsp;</a></span>ReflowComments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::ReflowComments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, clang-format will attempt to re-flow comments. </p>
<p>That is it will touch a comment and <em>reflow</em> long comments into new lines, trying to obey the <code>ColumnLimit</code>. </p><div class="fragment"><div class="line"><span class="keyword">false</span>:</div>
<div class="line"><span class="comment">// veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information</span></div>
<div class="line"><span class="comment">/* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">true</span>:</div>
<div class="line"><span class="comment">// veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of</span></div>
<div class="line"><span class="comment">// information</span></div>
<div class="line"><span class="comment">/* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of</span></div>
<div class="line"><span class="comment"> * information */</span></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03730">3730</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>.</p>

</div>
</div>
<a id="a4258513bdccfd48e8b59ff583d486359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4258513bdccfd48e8b59ff583d486359">&#9670;&nbsp;</a></span>RemoveBracesLLVM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::RemoveBracesLLVM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove optional braces of control statements (<code>if</code>, <code>else</code>, <code>for</code>, and <code>while</code>) in C++ according to the LLVM coding style. </p>
<dl class="section warning"><dt>Warning</dt><dd>This option will be renamed and expanded to support other styles. \endwarning </dd>
<dd>
Setting this option to <code>true</code> could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option. \endwarning <div class="fragment"><div class="line"><span class="keyword">false</span>:                                     <span class="keyword">true</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D)) {        vs.     <span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D))</div>
<div class="line">  handleFunctionDecl(D);                     handleFunctionDecl(D);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D)) {              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D))</div>
<div class="line">  handleVarDecl(D);                          handleVarDecl(D);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D)) {             vs.     <span class="keywordflow">if</span> (isa&lt;VarDecl&gt;(D)) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs()) {                <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs())</div>
<div class="line">    <span class="keywordflow">if</span> (shouldProcessAttr(A)) {                <span class="keywordflow">if</span> (shouldProcessAttr(A))</div>
<div class="line">      handleAttr(A);                             handleAttr(A);</div>
<div class="line">    }                                      }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D)) {        vs.     <span class="keywordflow">if</span> (isa&lt;FunctionDecl&gt;(D))</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs()) {                <span class="keywordflow">for</span> (<span class="keyword">auto</span> *A : D.attrs())</div>
<div class="line">    handleAttr(A);                             handleAttr(A);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<span class="keyword">auto</span> *D = (<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>)(D)) {            vs.     <span class="keywordflow">if</span> (<span class="keyword">auto</span> *D = (<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a>)(D)) {</div>
<div class="line">  <span class="keywordflow">if</span> (shouldProcess(D)) {                    <span class="keywordflow">if</span> (shouldProcess(D))</div>
<div class="line">    handleVarDecl(D);                          handleVarDecl(D);</div>
<div class="line">  } <span class="keywordflow">else</span> {                                   <span class="keywordflow">else</span></div>
<div class="line">    markAsIgnored(D);                          markAsIgnored(D);</div>
<div class="line">  }                                        }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (a) {                           vs.     <span class="keywordflow">if</span> (a)</div>
<div class="line">  <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>();                                       <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>();</div>
<div class="line">} <span class="keywordflow">else</span> {                                   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>)</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) {                                   d();</div>
<div class="line">    d();                                   <span class="keywordflow">else</span></div>
<div class="line">  } <span class="keywordflow">else</span> {                                   e();</div>
<div class="line">    e();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03785">3785</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3cc3e6e221104d26745b1852df21c6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc3e6e221104d26745b1852df21c6b1">&#9670;&nbsp;</a></span>RemoveParentheses</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#ad2fc6504442bd361923176076e427425">RemoveParenthesesStyle</a> clang::format::FormatStyle::RemoveParentheses</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove redundant parentheses. </p>
<dl class="section warning"><dt>Warning</dt><dd>Setting this option to any value other than <code>Leave</code> could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option. \endwarning </dd></dl>
<dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03821">3821</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a1cf975c5e663bb661b3bf5267f78eca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf975c5e663bb661b3bf5267f78eca1">&#9670;&nbsp;</a></span>RemoveSemicolon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::RemoveSemicolon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove semicolons after the closing braces of functions and constructors/destructors. </p>
<dl class="section warning"><dt>Warning</dt><dd>Setting this option to <code>true</code> could lead to incorrect code formatting due to clang-format's lack of complete semantic information. As such, extra care should be taken to review code changes made by this option. \endwarning <div class="fragment"><div class="line"><span class="keyword">false</span>:                                     <span class="keyword">true</span>:</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">max</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {                    <span class="keywordtype">int</span> <a class="code" href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">max</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">  <span class="keywordflow">return</span> a &gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> ? a : <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;                      <span class="keywordflow">return</span> a &gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> ? a : <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};                                         }</div>
<div class="ttc" id="a____clang__cuda__math_8h_html_ae6bb573e13e3bd5738c8faa552b6a129"><div class="ttname"><a href="____clang__cuda__math_8h.html#ae6bb573e13e3bd5738c8faa552b6a129">max</a></div><div class="ttdeci">__DEVICE__ int max(int __a, int __b)</div><div class="ttdef"><b>Definition:</b> <a href="____clang__cuda__math_8h_source.html#l00196">__clang_cuda_math.h:196</a></div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03839">3839</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a8d77e1af5beec5bbb82a2f84d5e693a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d77e1af5beec5bbb82a2f84d5e693a1">&#9670;&nbsp;</a></span>RequiresClausePosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8a28e9d93da683fcceb043d62fc76f34">RequiresClausePositionStyle</a> clang::format::FormatStyle::RequiresClausePosition</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The position of the <code>requires</code> clause. </p>
<dl class="section version"><dt>Version</dt><dd>15 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03920">3920</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="adf2b68b5bc6c3b1bc1a706eef46dcb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2b68b5bc6c3b1bc1a706eef46dcb34">&#9670;&nbsp;</a></span>RequiresExpressionIndentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a9fe26352e2222d3d490fde5a0effead7">RequiresExpressionIndentationKind</a> clang::format::FormatStyle::RequiresExpressionIndentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indentation used for requires expression bodies. </p>
<dl class="section version"><dt>Version</dt><dd>16 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l03946">3946</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="afe2bf70cb519b1de1ee80675aa0266dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2bf70cb519b1de1ee80675aa0266dc">&#9670;&nbsp;</a></span>SeparateDefinitionBlocks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a152054fb26dfc5f9345e538a61f98f65">SeparateDefinitionStyle</a> clang::format::FormatStyle::SeparateDefinitionBlocks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the use of empty lines to separate definition blocks, including classes, structs, enums, and functions. </p>
<div class="fragment"><div class="line"><a class="code" href="namespaceclang.html#a8ac23e04a365fdf821ce4aa1389d0c74a6e7b34fa59e1bd229b207892956dc41c">Never</a>                  <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>.s.     Always</div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span>              #include &lt;cstring&gt;</div>
<div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;                  <span class="keyword">struct </span>Foo {</div>
<div class="line">};                                <span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keyword">namespace </span>Ns {                  };</div>
<div class="line"><span class="keyword">class </span>Bar {</div>
<div class="line"><span class="keyword">public</span>:                         <span class="keyword">namespace </span>Ns {</div>
<div class="line">  <span class="keyword">struct </span>Foobar {               <span class="keyword">class </span>Bar {</div>
<div class="line">    <span class="keywordtype">int</span> a;                      <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;                        <span class="keyword">struct </span>Foobar {</div>
<div class="line">  };                                <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">private</span>:                            <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  <span class="keywordtype">int</span> t;                          };</div>
<div class="line">  <span class="keywordtype">int</span> method1() {</div>
<div class="line">    <span class="comment">// ...                      private:</span></div>
<div class="line">  }                               <span class="keywordtype">int</span> t;</div>
<div class="line">  <span class="keyword">enum</span> List {</div>
<div class="line">    ITEM1,                        <span class="keywordtype">int</span> method1() {</div>
<div class="line">    ITEM2                           <span class="comment">// ...</span></div>
<div class="line">  };                              }</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">int</span> method2(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> x) {              <span class="keyword">enum</span> List {</div>
<div class="line">    <span class="comment">// ...                          ITEM1,</span></div>
<div class="line">  }                                 ITEM2</div>
<div class="line">  <span class="keywordtype">int</span> i, j, k;                    };</div>
<div class="line">  <span class="keywordtype">int</span> method3(<span class="keywordtype">int</span> par) {</div>
<div class="line">    <span class="comment">// ...                        template&lt;typename T&gt;</span></div>
<div class="line">  }                               <span class="keywordtype">int</span> method2(<a class="code" href="namespaceclang.html#acb831cdeb9db42e534558aeff11c9b8b">T</a> x) {</div>
<div class="line">};                                  <span class="comment">// ...</span></div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};                       }</div>
<div class="line">}</div>
<div class="line">                                  <span class="keywordtype">int</span> i, j, k;</div>
<div class="line"> </div>
<div class="line">                                  <span class="keywordtype">int</span> method3(<span class="keywordtype">int</span> par) {</div>
<div class="line">                                    <span class="comment">// ...</span></div>
<div class="line">                                  }</div>
<div class="line">                                };</div>
<div class="line"> </div>
<div class="line">                                <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">                                }</div>
<div class="ttc" id="anamespaceclang_html_a8ac23e04a365fdf821ce4aa1389d0c74a6e7b34fa59e1bd229b207892956dc41c"><div class="ttname"><a href="namespaceclang.html#a8ac23e04a365fdf821ce4aa1389d0c74a6e7b34fa59e1bd229b207892956dc41c">clang::MSVtorDispMode::Never</a></div><div class="ttdeci">@ Never</div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04004">4004</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="af9d9721a18038a30fdba3f272728f188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d9721a18038a30fdba3f272728f188">&#9670;&nbsp;</a></span>ShortNamespaceLines</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::ShortNamespaceLines</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximal number of unwrapped lines that a short namespace spans. </p>
<p>Defaults to 1.</p>
<p>This determines the maximum length of short namespaces by counting unwrapped lines (i.e. containing neither opening nor closing namespace brace) and makes "FixNamespaceComments" omit adding end comments for those. </p><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">ShortNamespaceLines</a>: 1     vs.     <a class="code" href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">ShortNamespaceLines</a>: 0</div>
<div class="line"><span class="keyword">namespace </span>a {                      <span class="keyword">namespace </span>a {</div>
<div class="line">  <span class="keywordtype">int</span> foo;                           <span class="keywordtype">int</span> foo;</div>
<div class="line">}                                  } <span class="comment">// namespace a</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">ShortNamespaceLines</a>: 1     vs.     <a class="code" href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">ShortNamespaceLines</a>: 0</div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> {                      <span class="keyword">namespace </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> {</div>
<div class="line">  <span class="keywordtype">int</span> foo;                           <span class="keywordtype">int</span> foo;</div>
<div class="line">  <span class="keywordtype">int</span> bar;                           <span class="keywordtype">int</span> bar;</div>
<div class="line">} <span class="comment">// namespace b                   } // namespace b</span></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_af9d9721a18038a30fdba3f272728f188"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#af9d9721a18038a30fdba3f272728f188">clang::format::FormatStyle::ShortNamespaceLines</a></div><div class="ttdeci">unsigned ShortNamespaceLines</div><div class="ttdoc">The maximal number of unwrapped lines that a short namespace spans.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l04026">Format.h:4026</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04026">4026</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="adb6cab7c8d5500cc4e111bb95a8d2952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6cab7c8d5500cc4e111bb95a8d2952">&#9670;&nbsp;</a></span>SkipMacroDefinitionBody</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SkipMacroDefinitionBody</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not format macro definition body. </p>
<dl class="section version"><dt>Version</dt><dd>18 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04030">4030</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a08ba2a005f71a10648ca736b3bec198e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ba2a005f71a10648ca736b3bec198e">&#9670;&nbsp;</a></span>SortIncludes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a272ef822f048b5121b17f9b64c0127de">SortIncludesOptions</a> clang::format::FormatStyle::SortIncludes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls if and how clang-format will sort <code>#includes</code>. </p>
<dl class="section version"><dt>Version</dt><dd>3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04065">4065</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01757">clang::format::getChromiumStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01924">clang::format::getNoStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab9357c565fe3f6af3dc05c04d7466402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9357c565fe3f6af3dc05c04d7466402">&#9670;&nbsp;</a></span>SortJavaStaticImport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a1ac22b24b73abd5283a29a49e5129c4e">SortJavaStaticImportOptions</a> clang::format::FormatStyle::SortJavaStaticImport</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When sorting Java imports, by default static imports are placed before non-static imports. </p>
<p>If <code>JavaStaticImportAfterImport</code> is <code>After</code>, static imports are placed after non-static imports. </p><dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04089">4089</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="afba5ba7b53c084932261abc3d3e056ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba5ba7b53c084932261abc3d3e056ca">&#9670;&nbsp;</a></span>SortUsingDeclarations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acecae06d9d6888f0feb23d55f169fbfe">SortUsingDeclarationsOptions</a> clang::format::FormatStyle::SortUsingDeclarations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls if and how clang-format will sort using declarations. </p>
<dl class="section version"><dt>Version</dt><dd>5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04133">4133</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8cpp_source.html#l01924">clang::format::getNoStyle()</a>.</p>

</div>
</div>
<a id="a8dde150dbe50489f513fa23cee1d6184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dde150dbe50489f513fa23cee1d6184">&#9670;&nbsp;</a></span>SpaceAfterCStyleCast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceAfterCStyleCast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, a space is inserted after C style casts. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) i;                       vs.     (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)i;</div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa7b8984e16daeff79f73e22b4e040334"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></div><div class="ttdeci">__device__ int</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00067">__clang_hip_libdevice_declares.h:67</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04141">4141</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a7027e26ae8145780c54337207a02f1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7027e26ae8145780c54337207a02f1e9">&#9670;&nbsp;</a></span>SpaceAfterLogicalNot</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceAfterLogicalNot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, a space is inserted after the logical not operator (<code>!</code>). </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">! someExpression();            vs.     !someExpression();</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04149">4149</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ae11bcd0560111449a29b0843cf1dfcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11bcd0560111449a29b0843cf1dfcdc">&#9670;&nbsp;</a></span>SpaceAfterTemplateKeyword</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceAfterTemplateKeyword</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, a space will be inserted after the 'template' keyword. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span>&gt; <span class="keywordtype">void</span> foo();     vs.     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span>&gt; <span class="keywordtype">void</span> foo();</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04157">4157</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01817">clang::format::getMozillaStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a903713a1801f5cf5d4ede442400389e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903713a1801f5cf5d4ede442400389e1">&#9670;&nbsp;</a></span>SpaceAroundPointerQualifiers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#abae0b9d459d2a3e76e7595a0d50ad3b9">SpaceAroundPointerQualifiersStyle</a> clang::format::FormatStyle::SpaceAroundPointerQualifiers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines in which cases to put a space before or after pointer qualifiers. </p>
<dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04190">4190</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a915fe4216df56e63f64b37568b82a3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915fe4216df56e63f64b37568b82a3c3">&#9670;&nbsp;</a></span>SpaceBeforeAssignmentOperators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeAssignmentOperators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, spaces will be removed before assignment operators. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">int</span> a = 5;                     vs.     <span class="keywordtype">int</span> a= 5;</div>
<div class="line">a += 42;                               a+= 42;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04199">4199</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad8afba0cad571a6091b457a896bfe6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8afba0cad571a6091b457a896bfe6d3">&#9670;&nbsp;</a></span>SpaceBeforeCaseColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeCaseColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, spaces will be removed before case colon. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                   <span class="keyword">false</span></div>
<div class="line"><span class="keywordflow">switch</span> (x) {                    vs.     <span class="keywordflow">switch</span> (x) {</div>
<div class="line">  <span class="keywordflow">case</span> 1 : <span class="keywordflow">break</span>;                         <span class="keywordflow">case</span> 1: <span class="keywordflow">break</span>;</div>
<div class="line">}                                       }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04209">4209</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aee44e1eba8c06428af3df132b88cfab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44e1eba8c06428af3df132b88cfab7">&#9670;&nbsp;</a></span>SpaceBeforeCpp11BracedList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeCpp11BracedList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, a space will be inserted before a C++11 braced list used to initialize an object (after the preceding identifier or type). </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">Foo foo { bar };               vs.     Foo foo{ bar };</div>
<div class="line">Foo {};                                Foo{};</div>
<div class="line">vector&lt;int&gt; { 1, 2, 3 };               vector&lt;int&gt;{ 1, 2, 3 };</div>
<div class="line"><span class="keyword">new</span> <span class="keywordtype">int</span>[3] { 1, 2, 3 };                <span class="keyword">new</span> <span class="keywordtype">int</span>[3]{ 1, 2, 3 };</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04221">4221</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a243596081d48af8d962a2526faa0ab9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243596081d48af8d962a2526faa0ab9b">&#9670;&nbsp;</a></span>SpaceBeforeCtorInitializerColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeCtorInitializerColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, spaces will be removed before constructor initializer colon. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">Foo::Foo() : a(a) {}                   Foo::Foo(): a(a) {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04230">4230</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a02e26231f68ff129b287fa28cd958b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e26231f68ff129b287fa28cd958b86">&#9670;&nbsp;</a></span>SpaceBeforeInheritanceColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeInheritanceColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, spaces will be removed before inheritance colon. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keyword">class </span>Foo : Bar {}             vs.     <span class="keyword">class </span>Foo: Bar {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04238">4238</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a1eccedeecce047a2673fbf220fd46257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eccedeecce047a2673fbf220fd46257">&#9670;&nbsp;</a></span>SpaceBeforeJsonColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeJsonColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, a space will be added before a JSON colon. </p>
<p>For other languages, e.g. JavaScript, use <code>SpacesInContainerLiterals</code> instead. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line">{                                      {</div>
<div class="line">  <span class="stringliteral">&quot;key&quot;</span> : <span class="stringliteral">&quot;value&quot;</span>              vs.       <span class="stringliteral">&quot;key&quot;</span>: <span class="stringliteral">&quot;value&quot;</span></div>
<div class="line">}                                      }</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04249">4249</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="aed53a0a0f38d3cf168bc155ba65c0262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed53a0a0f38d3cf168bc155ba65c0262">&#9670;&nbsp;</a></span>SpaceBeforeParens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a7112fd8006c061310b6a28e404b73fd9">SpaceBeforeParensStyle</a> clang::format::FormatStyle::SpaceBeforeParens</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines in which cases to put a space before opening parentheses. </p>
<dl class="section version"><dt>Version</dt><dd>3.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04310">4310</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01367">clang::format::expandPresetsSpaceBeforeParens()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6d1bffa3ec200d641f9d7eb40fb1d588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1bffa3ec200d641f9d7eb40fb1d588">&#9670;&nbsp;</a></span>SpaceBeforeParensOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpaceBeforeParensCustom.html">SpaceBeforeParensCustom</a> clang::format::FormatStyle::SpaceBeforeParensOptions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control of individual space before parentheses. </p>
<p>If <code>SpaceBeforeParens</code> is set to <code>Custom</code>, use this to specify how each individual space before parentheses case should be handled. Otherwise, this is ignored. </p><div class="fragment"><div class="line"># Example of usage:</div>
<div class="line">SpaceBeforeParens: Custom</div>
<div class="line">SpaceBeforeParensOptions:</div>
<div class="line">  AfterControlStatements: true</div>
<div class="line">  AfterFunctionDefinitionName: true</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>14 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04436">4436</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01367">clang::format::expandPresetsSpaceBeforeParens()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="abc50a8b81b8abfd535d64a5a95053001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc50a8b81b8abfd535d64a5a95053001">&#9670;&nbsp;</a></span>SpaceBeforeRangeBasedForLoopColon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeRangeBasedForLoopColon</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>false</code>, spaces will be removed before range-based for loop colon. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a> : values) {}       vs.     <span class="keywordflow">for</span>(<span class="keyword">auto</span> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>: values) {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04455">4455</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab1a45e899ec8efc6d2a86ffaebed9257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a45e899ec8efc6d2a86ffaebed9257">&#9670;&nbsp;</a></span>SpaceBeforeSquareBrackets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceBeforeSquareBrackets</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces will be before <code>[</code>. </p>
<p>Lambdas will not be affected. Only the first <code>[</code> will get a space added. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">int</span> a [5];                    vs.      <span class="keywordtype">int</span> a[5];</div>
<div class="line"><span class="keywordtype">int</span> a [5][5];                 vs.      <span class="keywordtype">int</span> a[5][5];</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>10 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04446">4446</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3e5643e0f29b9348d93c1bc3197996ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5643e0f29b9348d93c1bc3197996ba">&#9670;&nbsp;</a></span>SpaceInEmptyBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpaceInEmptyBlock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces will be inserted into <code>{}</code>. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:                                <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">void</span> f() { }                   vs.   <span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { }                     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {}</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>10 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04464">4464</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a2c45bd6563a2837d105771d0c3ea7882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c45bd6563a2837d105771d0c3ea7882">&#9670;&nbsp;</a></span>SpacesBeforeTrailingComments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::SpacesBeforeTrailingComments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces may be inserted into <code>()</code>. </p>
<p>This option is <b>deprecated</b>. See <code>InEmptyParentheses</code> of <code>SpacesInParensOptions</code>. </p><dl class="section version"><dt>Version</dt><dd>3.7 The number of spaces before trailing line comments (<code>//</code> - comments).</dd></dl>
<p>This does not affect trailing block comments (<code>/*</code> - comments) as those commonly have different usage patterns and a number of special cases. In the case of Verilog, it doesn't affect a comment right after the opening parenthesis in the port or parameter list in a module header, because it is probably for the port on the following line instead of the parenthesis it follows. </p><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a2c45bd6563a2837d105771d0c3ea7882">SpacesBeforeTrailingComments</a>: 3</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">true</span>) {   <span class="comment">// foo1</span></div>
<div class="line">    f();        <span class="comment">// bar</span></div>
<div class="line">  }             <span class="comment">// foo</span></div>
<div class="line">}</div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a2c45bd6563a2837d105771d0c3ea7882"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a2c45bd6563a2837d105771d0c3ea7882">clang::format::FormatStyle::SpacesBeforeTrailingComments</a></div><div class="ttdeci">unsigned SpacesBeforeTrailingComments</div><div class="ttdoc">If true, spaces may be inserted into ().</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l04490">Format.h:4490</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04490">4490</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a169cfd68a1f826466cb0aa5602c6328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169cfd68a1f826466cb0aa5602c6328b">&#9670;&nbsp;</a></span>SpacesInAngles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#acaf8ff95ca21cdc0868d2b226b6d8917">SpacesInAnglesStyle</a> clang::format::FormatStyle::SpacesInAngles</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SpacesInAnglesStyle to use for template argument lists. </p>
<dl class="section version"><dt>Version</dt><dd>3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04513">4513</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab910a6a480c2a63971f6b83ec2bdee4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab910a6a480c2a63971f6b83ec2bdee4f">&#9670;&nbsp;</a></span>SpacesInContainerLiterals</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpacesInContainerLiterals</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces will be inserted around if/for/switch/while conditions. </p>
<p>This option is <b>deprecated</b>. See <code>InConditionalStatements</code> of <code>SpacesInParensOptions</code>. </p><dl class="section version"><dt>Version</dt><dd>10 If <code>true</code>, spaces are inserted inside container literals (e.g. ObjC and Javascript array and dict literals). For JSON, use <code>SpaceBeforeJsonColon</code> instead. <div class="fragment"><div class="line">true:                                  false:</div>
<div class="line">var arr = [ 1, 2, 3 ];         vs.     var arr = [1, 2, 3];</div>
<div class="line">f({a : 1, b : 2, c : 3});              f({a: 1, b: 2, c: 3});</div>
</div><!-- fragment --> </dd>
<dd>
3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04531">4531</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab5a3cb6f9679a1b42038c733559af48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a3cb6f9679a1b42038c733559af48f">&#9670;&nbsp;</a></span>SpacesInLineCommentPrefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInLineComment.html">SpacesInLineComment</a> clang::format::FormatStyle::SpacesInLineCommentPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many spaces are allowed at the start of a line comment. </p>
<p>To disable the maximum set it to <code>-1</code>, apart from that the maximum takes precedence over the minimum. </p><div class="fragment"><div class="line">Minimum = 1</div>
<div class="line">Maximum = -1</div>
<div class="line"><span class="comment">// One space is forced</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//  but more spaces are possible</span></div>
<div class="line"> </div>
<div class="line">Minimum = 0</div>
<div class="line">Maximum = 0</div>
<div class="line"><span class="comment">//Forces to start every comment directly after the slashes</span></div>
</div><!-- fragment --><p>Note that in line comment sections the relative indent of the subsequent lines is kept, that means the following: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1transformer.html#aa12c1bf19d03d4000c8cf7e28b6b2e5a">before</a>:                                   <a class="code" href="namespaceclang_1_1transformer.html#a8555e84ab210d67f1e0d1eebd6f29202">after</a>:</div>
<div class="line">Minimum: 1</div>
<div class="line"><span class="comment">//if (b) {                                // if (b) {</span></div>
<div class="line"><span class="comment">//  return true;                          //   return true;</span></div>
<div class="line"><span class="comment">//}                                       // }</span></div>
<div class="line"> </div>
<div class="line">Maximum: 0<span class="comment"></span></div>
<div class="line"><span class="comment">/// List:                                 ///List:</span></div>
<div class="line"><span class="comment">///  - Foo                                /// - Foo</span></div>
<div class="line"><span class="comment"></span><span class="comment">///    - Bar                              ///   - Bar</span></div>
<div class="ttc" id="anamespaceclang_1_1transformer_html_a8555e84ab210d67f1e0d1eebd6f29202"><div class="ttname"><a href="namespaceclang_1_1transformer.html#a8555e84ab210d67f1e0d1eebd6f29202">clang::transformer::after</a></div><div class="ttdeci">RangeSelector after(RangeSelector Selector)</div><div class="ttdoc">Selects the point immediately following Selector.</div><div class="ttdef"><b>Definition:</b> <a href="RangeSelector_8cpp_source.html#l00115">RangeSelector.cpp:115</a></div></div>
<div class="ttc" id="anamespaceclang_1_1transformer_html_aa12c1bf19d03d4000c8cf7e28b6b2e5a"><div class="ttname"><a href="namespaceclang_1_1transformer.html#aa12c1bf19d03d4000c8cf7e28b6b2e5a">clang::transformer::before</a></div><div class="ttdeci">RangeSelector before(RangeSelector Selector)</div><div class="ttdoc">Selects the (empty) range [B,B) when Selector selects the range [B,E).</div><div class="ttdef"><b>Definition:</b> <a href="RangeSelector_8cpp_source.html#l00106">RangeSelector.cpp:106</a></div></div>
</div><!-- fragment --><p>This option has only effect if <code>ReflowComments</code> is set to <code>true</code>. </p><dl class="section version"><dt>Version</dt><dd>13 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04579">4579</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a6648491ea9a25deb2d5f2eeb06088857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6648491ea9a25deb2d5f2eeb06088857">&#9670;&nbsp;</a></span>SpacesInParens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a404a2fb2e5d055e7858aca7bd99c0fe4">SpacesInParensStyle</a> clang::format::FormatStyle::SpacesInParens</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces will be inserted after <code>(</code> and before <code>)</code>. </p>
<p>This option is <b>deprecated</b>. The previous behavior is preserved by using <code>SpacesInParens</code> with <code>Custom</code> and by setting all <code>SpacesInParensOptions</code> to <code>true</code> except for <code>InCStyleCasts</code> and <code>InEmptyParentheses</code>. </p><dl class="section version"><dt>Version</dt><dd>3.7 Defines in which cases spaces will be inserted after <code>(</code> and before <code>)</code>. </dd>
<dd>
17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04608">4608</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01391">clang::format::expandPresetsSpacesInParens()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a675cfe4217900a9fac74b48e774c8563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675cfe4217900a9fac74b48e774c8563">&#9670;&nbsp;</a></span>SpacesInParensOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle_1_1SpacesInParensCustom.html">SpacesInParensCustom</a> clang::format::FormatStyle::SpacesInParensOptions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control of individual spaces in parentheses. </p>
<p>If <code>SpacesInParens</code> is set to <code>Custom</code>, use this to specify how each individual space in parentheses case should be handled. Otherwise, this is ignored. </p><div class="fragment"><div class="line"># Example of usage:</div>
<div class="line">SpacesInParens: Custom</div>
<div class="line">SpacesInParensOptions:</div>
<div class="line">  InConditionalStatements: true</div>
<div class="line">  InEmptyParentheses: true</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04684">4684</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01391">clang::format::expandPresetsSpacesInParens()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a3644fa886992352c66a8de6de4ac8147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3644fa886992352c66a8de6de4ac8147">&#9670;&nbsp;</a></span>SpacesInSquareBrackets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::SpacesInSquareBrackets</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>true</code>, spaces will be inserted after <code>[</code> and before <code>]</code>. </p>
<p>Lambdas without arguments or unspecified size array declarations will not be affected. </p><div class="fragment"><div class="line"><span class="keyword">true</span>:                                  <span class="keyword">false</span>:</div>
<div class="line"><span class="keywordtype">int</span> a[ 5 ];                    vs.     <span class="keywordtype">int</span> a[5];</div>
<div class="line">std::unique_ptr&lt;int[]&gt; foo() {} <span class="comment">// Won&#39;t be affected</span></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04695">4695</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a044e29dde38856beac53b1a307e444da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e29dde38856beac53b1a307e444da">&#9670;&nbsp;</a></span>Standard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8d27b8311dfb0b882b264771cbb33cb8">LanguageStandard</a> clang::format::FormatStyle::Standard</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and format C++ constructs compatible with this standard. </p>
<div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>++03:                                 latest:</div>
<div class="line">vector&lt;set&lt;int&gt; &gt; x;           vs.     vector&lt;set&lt;int&gt;&gt; x;</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04730">4730</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01615">clang::format::getGoogleStyle()</a>, <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a50ece88e4de318c7b0e4b6c487b216bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ece88e4de318c7b0e4b6c487b216bf">&#9670;&nbsp;</a></span>StatementAttributeLikeMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::StatementAttributeLikeMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macros which are ignored in front of a statement, as if they were an attribute. </p>
<p>So that they are not parsed as identifier, for example for Qts emit. </p><div class="fragment"><div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a8e9927d5d1e4da6fb9c65a7d1a25a791">AlignConsecutiveDeclarations</a>: <span class="keyword">true</span></div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a50ece88e4de318c7b0e4b6c487b216bf">StatementAttributeLikeMacros</a>: []</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data = <span class="charliteral">&#39;x&#39;</span>;</div>
<div class="line"><a class="code" href="ByteCodeEmitter_8cpp.html#a7e1bb5570f0bf642d4a11393d2a25dbe">emit</a>          signal(data); <span class="comment">// This is parsed as variable declaration.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a8e9927d5d1e4da6fb9c65a7d1a25a791">AlignConsecutiveDeclarations</a>: <span class="keyword">true</span></div>
<div class="line"><a class="code" href="structclang_1_1format_1_1FormatStyle.html#a50ece88e4de318c7b0e4b6c487b216bf">StatementAttributeLikeMacros</a>: [<a class="code" href="ByteCodeEmitter_8cpp.html#a7e1bb5570f0bf642d4a11393d2a25dbe">emit</a>]</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> data = <span class="charliteral">&#39;x&#39;</span>;</div>
<div class="line"><a class="code" href="ByteCodeEmitter_8cpp.html#a7e1bb5570f0bf642d4a11393d2a25dbe">emit</a> signal(data); <span class="comment">// Now it&#39;s fine again.</span></div>
<div class="ttc" id="aByteCodeEmitter_8cpp_html_a7e1bb5570f0bf642d4a11393d2a25dbe"><div class="ttname"><a href="ByteCodeEmitter_8cpp.html#a7e1bb5570f0bf642d4a11393d2a25dbe">emit</a></div><div class="ttdeci">static void emit(Program &amp;P, std::vector&lt; std::byte &gt; &amp;Code, const T &amp;Val, bool &amp;Success)</div><div class="ttdoc">Helper to write bytecode and bail out if 32-bit offsets become invalid.</div><div class="ttdef"><b>Definition:</b> <a href="ByteCodeEmitter_8cpp_source.html#l00227">ByteCodeEmitter.cpp:227</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a50ece88e4de318c7b0e4b6c487b216bf"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a50ece88e4de318c7b0e4b6c487b216bf">clang::format::FormatStyle::StatementAttributeLikeMacros</a></div><div class="ttdeci">std::vector&lt; std::string &gt; StatementAttributeLikeMacros</div><div class="ttdoc">Macros which are ignored in front of a statement, as if they were an attribute.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l04747">Format.h:4747</a></div></div>
<div class="ttc" id="astructclang_1_1format_1_1FormatStyle_html_a8e9927d5d1e4da6fb9c65a7d1a25a791"><div class="ttname"><a href="structclang_1_1format_1_1FormatStyle.html#a8e9927d5d1e4da6fb9c65a7d1a25a791">clang::format::FormatStyle::AlignConsecutiveDeclarations</a></div><div class="ttdeci">AlignConsecutiveStyle AlignConsecutiveDeclarations</div><div class="ttdoc">Style of aligning consecutive declarations.</div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l00318">Format.h:318</a></div></div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>12 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04747">4747</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="acaf853d01318db5e3c97dfc0f3bc3481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf853d01318db5e3c97dfc0f3bc3481">&#9670;&nbsp;</a></span>StatementMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::StatementMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros that should be interpreted as complete statements. </p>
<p>Typical macros are expressions, and require a semi-colon to be added; sometimes this is not the case, and this allows to make clang-format aware of such cases.</p>
<p>For example: Q_UNUSED </p><dl class="section version"><dt>Version</dt><dd>8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04758">4758</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ad45374984e04b0dfd3394edb1f00fec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45374984e04b0dfd3394edb1f00fec5">&#9670;&nbsp;</a></span>TableGenBreakingDAGArgOperators</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::TableGenBreakingDAGArgOperators</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Works only when TableGenBreakInsideDAGArg is not DontBreak. </p>
<p>The string list needs to consist of identifiers in TableGen. If any identifier is specified, this limits the line breaks by TableGenBreakInsideDAGArg option only on DAGArg values beginning with the specified identifiers.</p>
<p>For example the configuration, </p><div class="fragment"><div class="line">TableGenBreakInsideDAGArg: BreakAll</div>
<div class="line">TableGenBreakingDAGArgOperators: [&#39;ins&#39;, &#39;outs&#39;]</div>
</div><!-- fragment --><p>makes the line break only occurs inside DAGArgs beginning with the specified identifiers 'ins' and 'outs'.</p>
<div class="fragment"><div class="line">let DAGArgIns = (ins</div>
<div class="line">    i32:$src1,</div>
<div class="line">    i32:$src2</div>
<div class="line">);</div>
<div class="line">let DAGArgOtherID = (other i32:$other1, i32:$other2);</div>
<div class="line">let DAGArgBang = (!cast&lt;SomeType&gt;(<span class="stringliteral">&quot;Some&quot;</span>) i32:$src1, i32:$src2)</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04784">4784</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="ab6c70fbc15680b3d4b95a3e85d0b40c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c70fbc15680b3d4b95a3e85d0b40c9">&#9670;&nbsp;</a></span>TableGenBreakInsideDAGArg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a8738b2eed1291b5c9984003dd5a306f6">DAGArgStyle</a> clang::format::FormatStyle::TableGenBreakInsideDAGArg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The styles of the line break inside the DAGArg in TableGen. </p>
<dl class="section version"><dt>Version</dt><dd>19 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04812">4812</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a488265e26e22037ba7fed6489a21028e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488265e26e22037ba7fed6489a21028e">&#9670;&nbsp;</a></span>TabWidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> clang::format::FormatStyle::TabWidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of columns used for tab stops. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04816">4816</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00655">clang::format::BreakableBlockComment::getRangeLength()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l01012">clang::format::BreakableLineCommentSection::getRangeLength()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00255">clang::format::BreakableStringLiteral::getRemainingLength()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00357">clang::format::BreakableStringLiteralUsingOperators::getRemainingLength()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00279">clang::format::BreakableStringLiteral::getSplit()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00419">clang::format::BreakableComment::getSplit()</a>, <a class="el" href="BreakableToken_8cpp_source.html#l00607">clang::format::BreakableBlockComment::getSplit()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="af2b710117042d24d98e0645e56566b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b710117042d24d98e0645e56566b63">&#9670;&nbsp;</a></span>TypenameMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::TypenameMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros that should be interpreted as type declarations instead of as function calls. </p>
<p>These are expected to be macros of the form: </p><div class="fragment"><div class="line">STACK_OF(...)</div>
</div><!-- fragment --><p>In the .clang-format configuration file, this can be configured like: </p><div class="fragment"><div class="line">TypenameMacros: [&#39;STACK_OF&#39;, &#39;LIST&#39;]</div>
</div><!-- fragment --><p>For example: OpenSSL STACK_OF, BSD LIST_ENTRY. </p><dl class="section version"><dt>Version</dt><dd>9 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04843">4843</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a763e816a0e37a1ad440ff2b68db915e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763e816a0e37a1ad440ff2b68db915e2">&#9670;&nbsp;</a></span>TypeNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::TypeNames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of non-keyword identifiers that should be interpreted as type names. </p>
<p>A <code>*</code>, <code>&amp;</code>, or <code>&amp;&amp;</code> between a type name and another non-keyword identifier is annotated as a pointer or reference token instead of a binary operator.</p>
<dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04826">4826</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="af0d526918c493f4e47259fa33beddf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d526918c493f4e47259fa33beddf81">&#9670;&nbsp;</a></span>UseTab</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structclang_1_1format_1_1FormatStyle.html#a020cb5a1ecf0fa97b2496c35ab59619c">UseTabStyle</a> clang::format::FormatStyle::UseTab</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way to use tab characters in the resulting file. </p>
<dl class="section version"><dt>Version</dt><dd>3.7 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04868">4868</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a47c3a88f58b630814a1b38f64ca1195d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c3a88f58b630814a1b38f64ca1195d">&#9670;&nbsp;</a></span>VerilogBreakBetweenInstancePorts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> clang::format::FormatStyle::VerilogBreakBetweenInstancePorts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For Verilog, put each port on its own line in module instantiations. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span>:</div>
<div class="line">ffnand ff1(.q(),</div>
<div class="line">           .qbar(out1),</div>
<div class="line">           .clear(in1),</div>
<div class="line">           .preset(in2));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">false</span>:</div>
<div class="line">ffnand ff1(.q(), .qbar(out1), .clear(in1), .preset(in2));</div>
</div><!-- fragment --> <dl class="section version"><dt>Version</dt><dd>17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04882">4882</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<a id="a7f69dade79f2f4a16b6dae5f7382b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f69dade79f2f4a16b6dae5f7382b60d">&#9670;&nbsp;</a></span>WhitespaceSensitiveMacros</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; clang::format::FormatStyle::WhitespaceSensitiveMacros</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of macros which are whitespace-sensitive and should not be touched. </p>
<p>These are expected to be macros of the form: </p><div class="fragment"><div class="line">STRINGIZE(...)</div>
</div><!-- fragment --><p>In the .clang-format configuration file, this can be configured like: </p><div class="fragment"><div class="line">WhitespaceSensitiveMacros: [&#39;STRINGIZE&#39;, &#39;PP_STRINGIZE&#39;]</div>
</div><!-- fragment --><p>For example: BOOST_PP_STRINGIZE </p><dl class="section version"><dt>Version</dt><dd>11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="Format_8h_source.html#l04899">4899</a> of file <a class="el" href="Format_8h_source.html">Format.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Format_8cpp_source.html#l01399">clang::format::getLLVMStyle()</a>, and <a class="el" href="Format_8h_source.html#l04901">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/clang/Format/<a class="el" href="Format_8h_source.html">Format.h</a></li>
<li>lib/Format/<a class="el" href="Format_8cpp_source.html">Format.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 3 2024 01:35:40 for clang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
