<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>clang: clang::ast_matchers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">clang
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceclang.html">clang</a></li><li class="navelem"><a class="el" href="namespaceclang_1_1ast__matchers.html">ast_matchers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">clang::ast_matchers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceclang_1_1ast__matchers_1_1dynamic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1dynamic.html">dynamic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceclang_1_1ast__matchers_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps string IDs to AST nodes matched by parts of a matcher.  <a href="classclang_1_1ast__matchers_1_1BoundNodes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclang_1_1ast__matchers_1_1MatchFinder.html">MatchFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to allow finding matches over the Clang AST.  <a href="classclang_1_1ast__matchers_1_1MatchFinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8ae01b358e8e1f82b6e2fcd501dc62c3"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:a8ae01b358e8e1f82b6e2fcd501dc62c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a> = internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a>, NodeType &gt;</td></tr>
<tr class="separator:a8ae01b358e8e1f82b6e2fcd501dc62c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1c8d79365d495125b8c32aa08e15ae9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> { <br />
&#160;&#160;<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3">GtestCmp::Eq</a>, 
<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498">GtestCmp::Ne</a>, 
<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483">GtestCmp::Ge</a>, 
<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f">GtestCmp::Gt</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c">GtestCmp::Le</a>, 
<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922">GtestCmp::Lt</a>
<br />
 }</td></tr>
<tr class="memdesc:a1c8d79365d495125b8c32aa08e15ae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gtest's comparison operations.  <a href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">More...</a><br /></td></tr>
<tr class="separator:a1c8d79365d495125b8c32aa08e15ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b507ef98509576ab7fa90acdc3920d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> { <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920da6adf97f83acf6453d4a6a4b1070f3754">MockArgs::None</a>, 
<a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920da695c6ae413c00446733d926ccadefd8b">MockArgs::Some</a>
 }</td></tr>
<tr class="memdesc:a10b507ef98509576ab7fa90acdc3920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum indicates whether the mock method in the matched ON_CALL or EXPECT_CALL macro has arguments.  <a href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">More...</a><br /></td></tr>
<tr class="separator:a10b507ef98509576ab7fa90acdc3920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a652afe55bf376c9c0789d550409d90fe"><td class="memItemLeft" align="right" valign="top">internal::TrueMatcher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a652afe55bf376c9c0789d550409d90fe">anything</a> ()</td></tr>
<tr class="memdesc:a652afe55bf376c9c0789d550409d90fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any node.  <a href="namespaceclang_1_1ast__matchers.html#a652afe55bf376c9c0789d550409d90fe">More...</a><br /></td></tr>
<tr class="separator:a652afe55bf376c9c0789d550409d90fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968ac67c58589231ded255cfa8b7d70e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a968ac67c58589231ded255cfa8b7d70e">AST_POLYMORPHIC_MATCHER</a> (isExpansionInMainFile, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>))</td></tr>
<tr class="memdesc:a968ac67c58589231ded255cfa8b7d70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within the main-file.  <a href="namespaceclang_1_1ast__matchers.html#a968ac67c58589231ded255cfa8b7d70e">More...</a><br /></td></tr>
<tr class="separator:a968ac67c58589231ded255cfa8b7d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac38e17b4f443550d465158fa148ec4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5ac38e17b4f443550d465158fa148ec4">AST_POLYMORPHIC_MATCHER</a> (isExpansionInSystemHeader, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>))</td></tr>
<tr class="memdesc:a5ac38e17b4f443550d465158fa148ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within system-header-files.  <a href="namespaceclang_1_1ast__matchers.html#a5ac38e17b4f443550d465158fa148ec4">More...</a><br /></td></tr>
<tr class="separator:a5ac38e17b4f443550d465158fa148ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb873849aa797b4e9b6691b4d9fed736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#acb873849aa797b4e9b6691b4d9fed736">AST_POLYMORPHIC_MATCHER_REGEX</a> (isExpansionInFileMatching, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>), RegExp)</td></tr>
<tr class="memdesc:acb873849aa797b4e9b6691b4d9fed736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that were expanded within files whose name is partially matching a given regex.  <a href="namespaceclang_1_1ast__matchers.html#acb873849aa797b4e9b6691b4d9fed736">More...</a><br /></td></tr>
<tr class="separator:acb873849aa797b4e9b6691b4d9fed736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35486e436ae0dbb176252fc6b3cf62fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a35486e436ae0dbb176252fc6b3cf62fd">AST_POLYMORPHIC_MATCHER_P</a> (isExpandedFromMacro, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, MacroName)</td></tr>
<tr class="memdesc:a35486e436ae0dbb176252fc6b3cf62fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statements that are (transitively) expanded from the named macro.  <a href="namespaceclang_1_1ast__matchers.html#a35486e436ae0dbb176252fc6b3cf62fd">More...</a><br /></td></tr>
<tr class="separator:a35486e436ae0dbb176252fc6b3cf62fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26030464371cdda3687f2a9e71a6518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae26030464371cdda3687f2a9e71a6518">AST_POLYMORPHIC_MATCHER</a> (isPublic, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:ae26030464371cdda3687f2a9e71a6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches public C++ declarations and C++ base specifers that specify public inheritance.  <a href="namespaceclang_1_1ast__matchers.html#ae26030464371cdda3687f2a9e71a6518">More...</a><br /></td></tr>
<tr class="separator:ae26030464371cdda3687f2a9e71a6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70d182f0dc6e578582e680c791f0425"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa70d182f0dc6e578582e680c791f0425">AST_POLYMORPHIC_MATCHER</a> (isProtected, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:aa70d182f0dc6e578582e680c791f0425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches protected C++ declarations and C++ base specifers that specify protected inheritance.  <a href="namespaceclang_1_1ast__matchers.html#aa70d182f0dc6e578582e680c791f0425">More...</a><br /></td></tr>
<tr class="separator:aa70d182f0dc6e578582e680c791f0425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2128e92dde14b184065a2c1aae5e23b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad2128e92dde14b184065a2c1aae5e23b">AST_POLYMORPHIC_MATCHER</a> (isPrivate, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:ad2128e92dde14b184065a2c1aae5e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches private C++ declarations and C++ base specifers that specify private inheritance.  <a href="namespaceclang_1_1ast__matchers.html#ad2128e92dde14b184065a2c1aae5e23b">More...</a><br /></td></tr>
<tr class="separator:ad2128e92dde14b184065a2c1aae5e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b7c8db135d0ff9fb14a612faa14f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac15b7c8db135d0ff9fb14a612faa14f3">AST_MATCHER</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, isBitField)</td></tr>
<tr class="memdesc:ac15b7c8db135d0ff9fb14a612faa14f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that are bit-fields.  <a href="namespaceclang_1_1ast__matchers.html#ac15b7c8db135d0ff9fb14a612faa14f3">More...</a><br /></td></tr>
<tr class="separator:ac15b7c8db135d0ff9fb14a612faa14f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2e74bf00f236ab96f16fc7d3495f78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3e2e74bf00f236ab96f16fc7d3495f78">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, hasBitWidth, <a class="el" href="classunsigned.html">unsigned</a>, Width)</td></tr>
<tr class="memdesc:a3e2e74bf00f236ab96f16fc7d3495f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that are bit-fields of the specified bit width.  <a href="namespaceclang_1_1ast__matchers.html#a3e2e74bf00f236ab96f16fc7d3495f78">More...</a><br /></td></tr>
<tr class="separator:a3e2e74bf00f236ab96f16fc7d3495f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041bd134ecb46dcb809880b2588a1c19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a041bd134ecb46dcb809880b2588a1c19">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>, hasInClassInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a041bd134ecb46dcb809880b2588a1c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-static data members that have an in-class initializer.  <a href="namespaceclang_1_1ast__matchers.html#a041bd134ecb46dcb809880b2588a1c19">More...</a><br /></td></tr>
<tr class="separator:a041bd134ecb46dcb809880b2588a1c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae5cebfe9c6da04c2d9cfb13a038f0dde">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isMain)</td></tr>
<tr class="memdesc:ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the function is "main", which is the entry point into an executable program.  <a href="namespaceclang_1_1ast__matchers.html#ae5cebfe9c6da04c2d9cfb13a038f0dde">More...</a><br /></td></tr>
<tr class="separator:ae5cebfe9c6da04c2d9cfb13a038f0dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b30a702681d01ead785188e04457f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7b30a702681d01ead785188e04457f92">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, hasSpecializedTemplate, internal::Matcher&lt; <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a7b30a702681d01ead785188e04457f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the specialized template of a specialization declaration.  <a href="namespaceclang_1_1ast__matchers.html#a7b30a702681d01ead785188e04457f92">More...</a><br /></td></tr>
<tr class="separator:a7b30a702681d01ead785188e04457f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be371ebd5c73a20026d875d3f3afffe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6be371ebd5c73a20026d875d3f3afffe">AST_POLYMORPHIC_MATCHER</a> (isImplicit, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a>, <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>))</td></tr>
<tr class="memdesc:a6be371ebd5c73a20026d875d3f3afffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches an entity that has been implicitly added by the compiler (e.g.  <a href="namespaceclang_1_1ast__matchers.html#a6be371ebd5c73a20026d875d3f3afffe">More...</a><br /></td></tr>
<tr class="separator:a6be371ebd5c73a20026d875d3f3afffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b5c72b69ebf86c242f591b3a607cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2a6b5c72b69ebf86c242f591b3a607cf">AST_POLYMORPHIC_MATCHER_P</a> (hasAnyTemplateArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2a6b5c72b69ebf86c242f591b3a607cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches classTemplateSpecializations, templateSpecializationType and functionDecl that have at least one <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matching the given InnerMatcher.  <a href="namespaceclang_1_1ast__matchers.html#a2a6b5c72b69ebf86c242f591b3a607cf">More...</a><br /></td></tr>
<tr class="separator:a2a6b5c72b69ebf86c242f591b3a607cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d18a272b82cd99f0dba56e9ab0c21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab70d18a272b82cd99f0dba56e9ab0c21"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab70d18a272b82cd99f0dba56e9ab0c21">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::Matcher&lt; T &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:ab70d18a272b82cd99f0dba56e9ab0c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes all nested matchers to be matched with the specified traversal kind.  <a href="namespaceclang_1_1ast__matchers.html#ab70d18a272b82cd99f0dba56e9ab0c21">More...</a><br /></td></tr>
<tr class="separator:ab70d18a272b82cd99f0dba56e9ab0c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae07894db27f5bb11e0a76abf77f0eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ae07894db27f5bb11e0a76abf77f0eb"><td class="memTemplItemLeft" align="right" valign="top">internal::BindableMatcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9ae07894db27f5bb11e0a76abf77f0eb">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::BindableMatcher&lt; T &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a9ae07894db27f5bb11e0a76abf77f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047209d5bc6685d7cabbd31d53122834"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a047209d5bc6685d7cabbd31d53122834"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::VariadicOperatorMatcher&lt; T... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a047209d5bc6685d7cabbd31d53122834">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::VariadicOperatorMatcher&lt; T... &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a047209d5bc6685d7cabbd31d53122834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ce086dbc50a9894e16405bbe8d405"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename T , typename ToTypes &gt; </td></tr>
<tr class="memitem:a548ce086dbc50a9894e16405bbe8d405"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a548ce086dbc50a9894e16405bbe8d405">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a548ce086dbc50a9894e16405bbe8d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a97c0d3af71effcec1e3aaf14f4f36c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T, typename... P &gt; class MatcherT, typename... P, typename ReturnTypesF &gt; </td></tr>
<tr class="memitem:a6a97c0d3af71effcec1e3aaf14f4f36c"><td class="memTemplItemLeft" align="right" valign="top">internal::TraversalWrapper&lt; internal::PolymorphicMatcher&lt; MatcherT, ReturnTypesF, P... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6a97c0d3af71effcec1e3aaf14f4f36c">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::PolymorphicMatcher&lt; MatcherT, ReturnTypesF, P... &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a6a97c0d3af71effcec1e3aaf14f4f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba5b3eadb9679a24ed60cb13a30dac"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a52ba5b3eadb9679a24ed60cb13a30dac"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; typename internal::GetClade&lt; T... &gt;::<a class="el" href="classclang_1_1Type.html">Type</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a52ba5b3eadb9679a24ed60cb13a30dac">traverse</a> (<a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a> TK, const internal::MapAnyOfHelper&lt; T... &gt; &amp;InnerMatcher)</td></tr>
<tr class="separator:a52ba5b3eadb9679a24ed60cb13a30dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a92fc5ba0e3c7670df1211d78a0e8cd3b">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringImplicit, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after any implicit AST nodes are stripped off.  <a href="namespaceclang_1_1ast__matchers.html#a92fc5ba0e3c7670df1211d78a0e8cd3b">More...</a><br /></td></tr>
<tr class="separator:a92fc5ba0e3c7670df1211d78a0e8cd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1d68be4dc7543bd7e54dfe60c7e77b30">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringImpCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after any implicit casts are stripped off.  <a href="namespaceclang_1_1ast__matchers.html#a1d68be4dc7543bd7e54dfe60c7e77b30">More...</a><br /></td></tr>
<tr class="separator:a1d68be4dc7543bd7e54dfe60c7e77b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975436793549e3bf233afa633b959539"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a975436793549e3bf233afa633b959539">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParenCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a975436793549e3bf233afa633b959539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after parentheses and casts are stripped off.  <a href="namespaceclang_1_1ast__matchers.html#a975436793549e3bf233afa633b959539">More...</a><br /></td></tr>
<tr class="separator:a975436793549e3bf233afa633b959539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c810b620cfe58f641cb695035984063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5c810b620cfe58f641cb695035984063">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParenImpCasts, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5c810b620cfe58f641cb695035984063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher after implicit casts and parentheses are stripped off.  <a href="namespaceclang_1_1ast__matchers.html#a5c810b620cfe58f641cb695035984063">More...</a><br /></td></tr>
<tr class="separator:a5c810b620cfe58f641cb695035984063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4045123f0a783a289d12aaa2f5dc8e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af4045123f0a783a289d12aaa2f5dc8e7">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, ignoringParens, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:af4045123f0a783a289d12aaa2f5dc8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types that match InnerMatcher after any parens are stripped.  <a href="namespaceclang_1_1ast__matchers.html#af4045123f0a783a289d12aaa2f5dc8e7">More...</a><br /></td></tr>
<tr class="separator:af4045123f0a783a289d12aaa2f5dc8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fc7328f73d9bb7d7d88855195afb34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a07fc7328f73d9bb7d7d88855195afb34">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringParens, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a07fc7328f73d9bb7d7d88855195afb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload <code>ignoringParens</code> for <code><a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a07fc7328f73d9bb7d7d88855195afb34">More...</a><br /></td></tr>
<tr class="separator:a07fc7328f73d9bb7d7d88855195afb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a833e412dcf7c56f98cd2f63b7ef6dc93">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isInstantiationDependent)</td></tr>
<tr class="memdesc:a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that are instantiation-dependent even if it is neither type- nor value-dependent.  <a href="namespaceclang_1_1ast__matchers.html#a833e412dcf7c56f98cd2f63b7ef6dc93">More...</a><br /></td></tr>
<tr class="separator:a833e412dcf7c56f98cd2f63b7ef6dc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f22eb8aa38e1f695312a09764c34ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a00f22eb8aa38e1f695312a09764c34ef">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isTypeDependent)</td></tr>
<tr class="memdesc:a00f22eb8aa38e1f695312a09764c34ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that are type-dependent because the template type is not yet instantiated.  <a href="namespaceclang_1_1ast__matchers.html#a00f22eb8aa38e1f695312a09764c34ef">More...</a><br /></td></tr>
<tr class="separator:a00f22eb8aa38e1f695312a09764c34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a02d8919c5ecf8f9a9ab153ca646d3a6a">AST_MATCHER</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, isValueDependent)</td></tr>
<tr class="memdesc:a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expression that are value-dependent because they contain a non-type template parameter.  <a href="namespaceclang_1_1ast__matchers.html#a02d8919c5ecf8f9a9ab153ca646d3a6a">More...</a><br /></td></tr>
<tr class="separator:a02d8919c5ecf8f9a9ab153ca646d3a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae808f2b4db9e59ead6b1695186d91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac2ae808f2b4db9e59ead6b1695186d91">AST_POLYMORPHIC_MATCHER_P2</a> (hasTemplateArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), <a class="el" href="classunsigned.html">unsigned</a>, N, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac2ae808f2b4db9e59ead6b1695186d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches classTemplateSpecializations, templateSpecializationType and functionDecl where the n'th <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matches the given InnerMatcher.  <a href="namespaceclang_1_1ast__matchers.html#ac2ae808f2b4db9e59ead6b1695186d91">More...</a><br /></td></tr>
<tr class="separator:ac2ae808f2b4db9e59ead6b1695186d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bfa4d4498d0db062ebae29807b397"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8d5bfa4d4498d0db062ebae29807b397">AST_POLYMORPHIC_MATCHER_P</a> (templateArgumentCountIs, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>), <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a8d5bfa4d4498d0db062ebae29807b397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the number of template arguments equals <code>N</code>.  <a href="namespaceclang_1_1ast__matchers.html#a8d5bfa4d4498d0db062ebae29807b397">More...</a><br /></td></tr>
<tr class="separator:a8d5bfa4d4498d0db062ebae29807b397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af189946951ce7f935861b3943634e6d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af189946951ce7f935861b3943634e6d4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af189946951ce7f935861b3943634e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain type.  <a href="namespaceclang_1_1ast__matchers.html#af189946951ce7f935861b3943634e6d4">More...</a><br /></td></tr>
<tr class="separator:af189946951ce7f935861b3943634e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78151d2a32277bb385119910e537d58a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a78151d2a32277bb385119910e537d58a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToTemplate, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a78151d2a32277bb385119910e537d58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain template.  <a href="namespaceclang_1_1ast__matchers.html#a78151d2a32277bb385119910e537d58a">More...</a><br /></td></tr>
<tr class="separator:a78151d2a32277bb385119910e537d58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d66a056fa6763e89a41550a4468db2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0d66a056fa6763e89a41550a4468db2f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToDeclaration, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0d66a056fa6763e89a41550a4468db2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a canonical <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain declaration.  <a href="namespaceclang_1_1ast__matchers.html#a0d66a056fa6763e89a41550a4468db2f">More...</a><br /></td></tr>
<tr class="separator:a0d66a056fa6763e89a41550a4468db2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0f8b99a0a4e189acdcdaf259c2290f3d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, isExpr, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a sugar <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain expression.  <a href="namespaceclang_1_1ast__matchers.html#a0f8b99a0a4e189acdcdaf259c2290f3d">More...</a><br /></td></tr>
<tr class="separator:a0f8b99a0a4e189acdcdaf259c2290f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372ddae878809019381acb68314cb048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a372ddae878809019381acb68314cb048">AST_MATCHER</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, isIntegral)</td></tr>
<tr class="memdesc:a372ddae878809019381acb68314cb048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that is an integral value.  <a href="namespaceclang_1_1ast__matchers.html#a372ddae878809019381acb68314cb048">More...</a><br /></td></tr>
<tr class="separator:a372ddae878809019381acb68314cb048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911620ba71c61c54fcf02cd42d828e56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a911620ba71c61c54fcf02cd42d828e56">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, refersToIntegralType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a911620ba71c61c54fcf02cd42d828e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to an integral type.  <a href="namespaceclang_1_1ast__matchers.html#a911620ba71c61c54fcf02cd42d828e56">More...</a><br /></td></tr>
<tr class="separator:a911620ba71c61c54fcf02cd42d828e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50116e967de8dce02523cc01150f4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7a50116e967de8dce02523cc01150f4d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>, equalsIntegralValue, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)</td></tr>
<tr class="memdesc:a7a50116e967de8dce02523cc01150f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> of integral type with a given value.  <a href="namespaceclang_1_1ast__matchers.html#a7a50116e967de8dce02523cc01150f4d">More...</a><br /></td></tr>
<tr class="separator:a7a50116e967de8dce02523cc01150f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edfa6373df58e343d19f5d2679991d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0edfa6373df58e343d19f5d2679991d1">AST_MATCHER</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, usesADL)</td></tr>
<tr class="memdesc:a0edfa6373df58e343d19f5d2679991d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches call expressions which were resolved using ADL.  <a href="namespaceclang_1_1ast__matchers.html#a0edfa6373df58e343d19f5d2679991d1">More...</a><br /></td></tr>
<tr class="separator:a0edfa6373df58e343d19f5d2679991d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246e4f4313edb67d25bdd6fb935746b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a246e4f4313edb67d25bdd6fb935746b4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>, hasSyntacticForm, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a246e4f4313edb67d25bdd6fb935746b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the syntactic form of init list expressions (if expression have it).  <a href="namespaceclang_1_1ast__matchers.html#a246e4f4313edb67d25bdd6fb935746b4">More...</a><br /></td></tr>
<tr class="separator:a246e4f4313edb67d25bdd6fb935746b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290e141c4140d565458b4eebab9fe706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a290e141c4140d565458b4eebab9fe706">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, hasIncrement, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a290e141c4140d565458b4eebab9fe706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the increment statement of a for loop.  <a href="namespaceclang_1_1ast__matchers.html#a290e141c4140d565458b4eebab9fe706">More...</a><br /></td></tr>
<tr class="separator:a290e141c4140d565458b4eebab9fe706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f93cc605e37bd0bb85673eb580a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac25f93cc605e37bd0bb85673eb580a1e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, hasLoopInit, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac25f93cc605e37bd0bb85673eb580a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initialization statement of a for loop.  <a href="namespaceclang_1_1ast__matchers.html#ac25f93cc605e37bd0bb85673eb580a1e">More...</a><br /></td></tr>
<tr class="separator:ac25f93cc605e37bd0bb85673eb580a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a13417ea6d85e2bff1cadbf9f0969ae1d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, hasLoopVariable, internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initialization statement of a for loop.  <a href="namespaceclang_1_1ast__matchers.html#a13417ea6d85e2bff1cadbf9f0969ae1d">More...</a><br /></td></tr>
<tr class="separator:a13417ea6d85e2bff1cadbf9f0969ae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6716c3f117a63a7d60827379b4cc2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad6716c3f117a63a7d60827379b4cc2a4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, hasRangeInit, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ad6716c3f117a63a7d60827379b4cc2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the range initialization statement of a for loop.  <a href="namespaceclang_1_1ast__matchers.html#ad6716c3f117a63a7d60827379b4cc2a4">More...</a><br /></td></tr>
<tr class="separator:ad6716c3f117a63a7d60827379b4cc2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1b90fe605ed44735e799e76d0b4786"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0f1b90fe605ed44735e799e76d0b4786">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a>, designatorCountIs, <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a0f1b90fe605ed44735e799e76d0b4786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches designated initializer expressions that contain a specific number of designators.  <a href="namespaceclang_1_1ast__matchers.html#a0f1b90fe605ed44735e799e76d0b4786">More...</a><br /></td></tr>
<tr class="separator:a0f1b90fe605ed44735e799e76d0b4786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d2caaa3c207f5b5f91216fe06f1158"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... U&gt; </td></tr>
<tr class="memitem:a90d2caaa3c207f5b5f91216fe06f1158"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a90d2caaa3c207f5b5f91216fe06f1158">mapAnyOf</a> (internal::VariadicDynCastAllOfMatcher&lt; T, <a class="el" href="classU.html">U</a> &gt; const &amp;...)</td></tr>
<tr class="memdesc:a90d2caaa3c207f5b5f91216fe06f1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any of the <code>NodeMatchers</code> with InnerMatchers nested within.  <a href="namespaceclang_1_1ast__matchers.html#a90d2caaa3c207f5b5f91216fe06f1158">More...</a><br /></td></tr>
<tr class="separator:a90d2caaa3c207f5b5f91216fe06f1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda923705023b2e6030c83ffe359a5b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afda923705023b2e6030c83ffe359a5b1">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>, hasArgumentOfType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:afda923705023b2e6030c83ffe359a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary expressions that have a specific type of argument.  <a href="namespaceclang_1_1ast__matchers.html#afda923705023b2e6030c83ffe359a5b1">More...</a><br /></td></tr>
<tr class="separator:afda923705023b2e6030c83ffe359a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364b968cdd1a5dd039ef4002d426e62c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a364b968cdd1a5dd039ef4002d426e62c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>, ofKind, <a class="el" href="namespaceclang.html#a5d73f06594a5ccb763a726bed94a541f">UnaryExprOrTypeTrait</a>, Kind)</td></tr>
<tr class="memdesc:a364b968cdd1a5dd039ef4002d426e62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary expressions of a certain kind.  <a href="namespaceclang_1_1ast__matchers.html#a364b968cdd1a5dd039ef4002d426e62c">More...</a><br /></td></tr>
<tr class="separator:a364b968cdd1a5dd039ef4002d426e62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10baaee079ba40b644bd702d1af7a6ce"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10baaee079ba40b644bd702d1af7a6ce">alignOfExpr</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:a10baaee079ba40b644bd702d1af7a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unaryExprOrTypeTraitExpr, but only matching alignof.  <a href="namespaceclang_1_1ast__matchers.html#a10baaee079ba40b644bd702d1af7a6ce">More...</a><br /></td></tr>
<tr class="separator:a10baaee079ba40b644bd702d1af7a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c21055a9e5d4af474b90f49b8fc79d4"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c21055a9e5d4af474b90f49b8fc79d4">sizeOfExpr</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:a1c21055a9e5d4af474b90f49b8fc79d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as unaryExprOrTypeTraitExpr, but only matching sizeof.  <a href="namespaceclang_1_1ast__matchers.html#a1c21055a9e5d4af474b90f49b8fc79d4">More...</a><br /></td></tr>
<tr class="separator:a1c21055a9e5d4af474b90f49b8fc79d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d768f291504a2ab44e97d4732e25810"><td class="memItemLeft" align="right" valign="top">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a> (StringRef Name)</td></tr>
<tr class="memdesc:a8d768f291504a2ab44e97d4732e25810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have the specified name.  <a href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">More...</a><br /></td></tr>
<tr class="separator:a8d768f291504a2ab44e97d4732e25810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cb7556571e959aa00a7d5c8cdd9394"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa8cb7556571e959aa00a7d5c8cdd9394">AST_MATCHER_REGEX</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>, matchesName, RegExp)</td></tr>
<tr class="memdesc:aa8cb7556571e959aa00a7d5c8cdd9394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes whose fully qualified names contain a substring matched by the given RegExp.  <a href="namespaceclang_1_1ast__matchers.html#aa8cb7556571e959aa00a7d5c8cdd9394">More...</a><br /></td></tr>
<tr class="separator:aa8cb7556571e959aa00a7d5c8cdd9394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79daca24a6baeebb272b2b822bc5f3d3"><td class="memItemLeft" align="right" valign="top">internal::PolymorphicMatcher&lt; internal::HasOverloadedOperatorNameMatcher, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), std::vector&lt; <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a79daca24a6baeebb272b2b822bc5f3d3">hasOverloadedOperatorName</a> (StringRef Name)</td></tr>
<tr class="memdesc:a79daca24a6baeebb272b2b822bc5f3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator names.  <a href="namespaceclang_1_1ast__matchers.html#a79daca24a6baeebb272b2b822bc5f3d3">More...</a><br /></td></tr>
<tr class="separator:a79daca24a6baeebb272b2b822bc5f3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4754fedaf69686660d1d67816e610cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad4754fedaf69686660d1d67816e610cd">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>, hasMemberName, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, N)</td></tr>
<tr class="memdesc:ad4754fedaf69686660d1d67816e610cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template-dependent, but known, member names.  <a href="namespaceclang_1_1ast__matchers.html#ad4754fedaf69686660d1d67816e610cd">More...</a><br /></td></tr>
<tr class="separator:ad4754fedaf69686660d1d67816e610cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1671534b91901a477c76a181b97e4111"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1671534b91901a477c76a181b97e4111">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>, memberHasSameNameAsBoundNode, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BindingID)</td></tr>
<tr class="memdesc:a1671534b91901a477c76a181b97e4111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template-dependent, but known, member names against an already-bound node.  <a href="namespaceclang_1_1ast__matchers.html#a1671534b91901a477c76a181b97e4111">More...</a><br /></td></tr>
<tr class="separator:a1671534b91901a477c76a181b97e4111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeb83f2ec21f29e79ce86e902ed8540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7aeb83f2ec21f29e79ce86e902ed8540">AST_POLYMORPHIC_MATCHER_P</a> (isDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>)</td></tr>
<tr class="memdesc:a7aeb83f2ec21f29e79ce86e902ed8540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that are directly or indirectly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>, or Objective-C classes that directly or indirectly subclass a class matching <code><a class="el" href="classBase.html">Base</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a7aeb83f2ec21f29e79ce86e902ed8540">More...</a><br /></td></tr>
<tr class="separator:a7aeb83f2ec21f29e79ce86e902ed8540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d53d9c92b933394ca4e31fd3610db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a931d53d9c92b933394ca4e31fd3610db">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BaseName, 1)</td></tr>
<tr class="memdesc:a931d53d9c92b933394ca4e31fd3610db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isDerivedFrom(hasName(...))</code>.  <a href="namespaceclang_1_1ast__matchers.html#a931d53d9c92b933394ca4e31fd3610db">More...</a><br /></td></tr>
<tr class="separator:a931d53d9c92b933394ca4e31fd3610db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d5ca0ebfe096ded3ced92d183b60a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af8d5ca0ebfe096ded3ced92d183b60a2">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasAnyBase, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;, BaseSpecMatcher)</td></tr>
<tr class="memdesc:af8d5ca0ebfe096ded3ced92d183b60a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that have a direct or indirect base matching <code>BaseSpecMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#af8d5ca0ebfe096ded3ced92d183b60a2">More...</a><br /></td></tr>
<tr class="separator:af8d5ca0ebfe096ded3ced92d183b60a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a38d1fd2744bb4fa7264ce75e905ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a18a38d1fd2744bb4fa7264ce75e905ce">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasDirectBase, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;, BaseSpecMatcher)</td></tr>
<tr class="memdesc:a18a38d1fd2744bb4fa7264ce75e905ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ classes that have a direct base matching <code>BaseSpecMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a18a38d1fd2744bb4fa7264ce75e905ce">More...</a><br /></td></tr>
<tr class="separator:a18a38d1fd2744bb4fa7264ce75e905ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2fbefa428d3a7d1641d6ac07a021cdcf">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isSameOrDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>, 0)</td></tr>
<tr class="memdesc:a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>isDerivedFrom()</code>, but also matches classes that directly match <code><a class="el" href="classBase.html">Base</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a2fbefa428d3a7d1641d6ac07a021cdcf">More...</a><br /></td></tr>
<tr class="separator:a2fbefa428d3a7d1641d6ac07a021cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9b17e996eb7d40a1b04ce7701a07db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afb9b17e996eb7d40a1b04ce7701a07db">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isSameOrDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BaseName, 1)</td></tr>
<tr class="memdesc:afb9b17e996eb7d40a1b04ce7701a07db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isSameOrDerivedFrom(hasName(...))</code>.  <a href="namespaceclang_1_1ast__matchers.html#afb9b17e996eb7d40a1b04ce7701a07db">More...</a><br /></td></tr>
<tr class="separator:afb9b17e996eb7d40a1b04ce7701a07db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5e3046ab1a3310f7867a4c1e47c9bfff">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDirectlyDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, <a class="el" href="classBase.html">Base</a>, 0)</td></tr>
<tr class="memdesc:a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ or Objective-C classes that are directly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a5e3046ab1a3310f7867a4c1e47c9bfff">More...</a><br /></td></tr>
<tr class="separator:a5e3046ab1a3310f7867a4c1e47c9bfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898b5ddf30c2409c36bdb3cc0abb789f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a898b5ddf30c2409c36bdb3cc0abb789f">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (isDirectlyDerivedFrom, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BaseName, 1)</td></tr>
<tr class="memdesc:a898b5ddf30c2409c36bdb3cc0abb789f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded method as shortcut for <code>isDirectlyDerivedFrom(hasName(...))</code>.  <a href="namespaceclang_1_1ast__matchers.html#a898b5ddf30c2409c36bdb3cc0abb789f">More...</a><br /></td></tr>
<tr class="separator:a898b5ddf30c2409c36bdb3cc0abb789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58c11d6864fd939f7c9e2bad80dde51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae58c11d6864fd939f7c9e2bad80dde51">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, hasMethod, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae58c11d6864fd939f7c9e2bad80dde51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the first method of a class or struct that satisfies <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#ae58c11d6864fd939f7c9e2bad80dde51">More...</a><br /></td></tr>
<tr class="separator:ae58c11d6864fd939f7c9e2bad80dde51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae1b1b3c472ca3262e95b5a2eefa63b7e">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, isLambda)</td></tr>
<tr class="memdesc:ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the generated class of lambda expressions.  <a href="namespaceclang_1_1ast__matchers.html#ae1b1b3c472ca3262e95b5a2eefa63b7e">More...</a><br /></td></tr>
<tr class="separator:ae1b1b3c472ca3262e95b5a2eefa63b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adc91bda011c0b3ffcc4c315131cfb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2adc91bda011c0b3ffcc4c315131cfb4"><td class="memTemplItemLeft" align="right" valign="top">internal::Matcher&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2adc91bda011c0b3ffcc4c315131cfb4">findAll</a> (const internal::Matcher&lt; T &gt; &amp;Matcher)</td></tr>
<tr class="memdesc:a2adc91bda011c0b3ffcc4c315131cfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the node or any descendant matches.  <a href="namespaceclang_1_1ast__matchers.html#a2adc91bda011c0b3ffcc4c315131cfb4">More...</a><br /></td></tr>
<tr class="separator:a2adc91bda011c0b3ffcc4c315131cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76835a0f3b2093794608ce6c16da9bc"><td class="memItemLeft" align="right" valign="top">internal::PolymorphicMatcher&lt; internal::HasDeclarationMatcher, void(internal::HasDeclarationSupportedTypes), internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa76835a0f3b2093794608ce6c16da9bc">hasDeclaration</a> (const internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; &amp;InnerMatcher)</td></tr>
<tr class="memdesc:aa76835a0f3b2093794608ce6c16da9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a node if the declaration associated with that node matches the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#aa76835a0f3b2093794608ce6c16da9bc">More...</a><br /></td></tr>
<tr class="separator:aa76835a0f3b2093794608ce6c16da9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af541323ee4a7cfcaa6032acb78ac3a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af541323ee4a7cfcaa6032acb78ac3a86">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>, hasUnderlyingDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af541323ee4a7cfcaa6032acb78ac3a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a></code> whose underlying declaration matches the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#af541323ee4a7cfcaa6032acb78ac3a86">More...</a><br /></td></tr>
<tr class="separator:af541323ee4a7cfcaa6032acb78ac3a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fc9646b82282913629cad30181a3a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a99fc9646b82282913629cad30181a3a0">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, on, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a99fc9646b82282913629cad30181a3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the implicit object argument of a member call expression, after stripping off any parentheses or implicit casts.  <a href="namespaceclang_1_1ast__matchers.html#a99fc9646b82282913629cad30181a3a0">More...</a><br /></td></tr>
<tr class="separator:a99fc9646b82282913629cad30181a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eadcbb53864d57ff194cfb633fc783e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2eadcbb53864d57ff194cfb633fc783e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasReceiverType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2eadcbb53864d57ff194cfb633fc783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the receiver of an ObjectiveC Message expression.  <a href="namespaceclang_1_1ast__matchers.html#a2eadcbb53864d57ff194cfb633fc783e">More...</a><br /></td></tr>
<tr class="separator:a2eadcbb53864d57ff194cfb633fc783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed7081a3099b4c413dd177c4c00559c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abed7081a3099b4c413dd177c4c00559c">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, isClassMethod)</td></tr>
<tr class="memdesc:abed7081a3099b4c413dd177c4c00559c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C method declaration is a class method.  <a href="namespaceclang_1_1ast__matchers.html#abed7081a3099b4c413dd177c4c00559c">More...</a><br /></td></tr>
<tr class="separator:abed7081a3099b4c413dd177c4c00559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae407a60668f5aeb7fb497b64762b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adae407a60668f5aeb7fb497b64762b8d">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="SemaDeclAttr_8cpp.html#ad35282e02924165aae3b360b22ab028e">isInstanceMethod</a>)</td></tr>
<tr class="memdesc:adae407a60668f5aeb7fb497b64762b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C method declaration is an instance method.  <a href="namespaceclang_1_1ast__matchers.html#adae407a60668f5aeb7fb497b64762b8d">More...</a><br /></td></tr>
<tr class="separator:adae407a60668f5aeb7fb497b64762b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ccba02e6d782bd0ffda74eef632efc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a50ccba02e6d782bd0ffda74eef632efc">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, isClassMessage)</td></tr>
<tr class="memdesc:a50ccba02e6d782bd0ffda74eef632efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C message is sent to a class.  <a href="namespaceclang_1_1ast__matchers.html#a50ccba02e6d782bd0ffda74eef632efc">More...</a><br /></td></tr>
<tr class="separator:a50ccba02e6d782bd0ffda74eef632efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4ac3bec31f7eb8625530f52cf6f5a87f">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, isInstanceMessage)</td></tr>
<tr class="memdesc:a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when the Objective-C message is sent to an instance.  <a href="namespaceclang_1_1ast__matchers.html#a4ac3bec31f7eb8625530f52cf6f5a87f">More...</a><br /></td></tr>
<tr class="separator:a4ac3bec31f7eb8625530f52cf6f5a87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81978c4da301b92d8b05c2f29c73d86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa81978c4da301b92d8b05c2f29c73d86">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasReceiver, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa81978c4da301b92d8b05c2f29c73d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the Objective-C message is sent to an instance, and the inner matcher matches on that instance.  <a href="namespaceclang_1_1ast__matchers.html#aa81978c4da301b92d8b05c2f29c73d86">More...</a><br /></td></tr>
<tr class="separator:aa81978c4da301b92d8b05c2f29c73d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c4492e391c4ebab66249547cbda68c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae7c4492e391c4ebab66249547cbda68c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasSelector, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BaseName)</td></tr>
<tr class="memdesc:ae7c4492e391c4ebab66249547cbda68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when BaseName == <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a>  <a href="namespaceclang_1_1ast__matchers.html#ae7c4492e391c4ebab66249547cbda68c">More...</a><br /></td></tr>
<tr class="separator:ae7c4492e391c4ebab66249547cbda68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1a26f57707ca1cc9c7c2f915bdef1dec">AST_MATCHER_REGEX</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, matchesSelector, RegExp)</td></tr>
<tr class="memdesc:a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ObjC selectors whose name contains a substring matched by the given RegExp.  <a href="namespaceclang_1_1ast__matchers.html#a1a26f57707ca1cc9c7c2f915bdef1dec">More...</a><br /></td></tr>
<tr class="separator:a1a26f57707ca1cc9c7c2f915bdef1dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f55858b223a0e11066738f16c77a25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a38f55858b223a0e11066738f16c77a25">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasNullSelector)</td></tr>
<tr class="memdesc:a38f55858b223a0e11066738f16c77a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is the empty selector.  <a href="namespaceclang_1_1ast__matchers.html#a38f55858b223a0e11066738f16c77a25">More...</a><br /></td></tr>
<tr class="separator:a38f55858b223a0e11066738f16c77a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe17436c3837899bc7a1f07dd6c23f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#affe17436c3837899bc7a1f07dd6c23f8">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasUnarySelector)</td></tr>
<tr class="memdesc:affe17436c3837899bc7a1f07dd6c23f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is a Unary <a class="el" href="classclang_1_1Selector.html" title="Smart pointer class that efficiently represents Objective-C method names.">Selector</a>.  <a href="namespaceclang_1_1ast__matchers.html#affe17436c3837899bc7a1f07dd6c23f8">More...</a><br /></td></tr>
<tr class="separator:affe17436c3837899bc7a1f07dd6c23f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a210ce15787ad4e0ef9f5f8bdd0b1b7b3">AST_MATCHER</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasKeywordSelector)</td></tr>
<tr class="memdesc:a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector is a keyword selector.  <a href="namespaceclang_1_1ast__matchers.html#a210ce15787ad4e0ef9f5f8bdd0b1b7b3">More...</a><br /></td></tr>
<tr class="separator:a210ce15787ad4e0ef9f5f8bdd0b1b7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b6b13e9f4c74054e742f1222a70a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a73b6b13e9f4c74054e742f1222a70a8c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, numSelectorArgs, <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a73b6b13e9f4c74054e742f1222a70a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when the selector has the specified number of arguments.  <a href="namespaceclang_1_1ast__matchers.html#a73b6b13e9f4c74054e742f1222a70a8c">More...</a><br /></td></tr>
<tr class="separator:a73b6b13e9f4c74054e742f1222a70a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c658c5f5005a9159e4a74960fa3e0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a09c658c5f5005a9159e4a74960fa3e0f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, callee, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a09c658c5f5005a9159e4a74960fa3e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the call expression's callee expression matches.  <a href="namespaceclang_1_1ast__matchers.html#a09c658c5f5005a9159e4a74960fa3e0f">More...</a><br /></td></tr>
<tr class="separator:a09c658c5f5005a9159e4a74960fa3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20927991ed40f5b7fc29095fa96e9c36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a20927991ed40f5b7fc29095fa96e9c36">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, callee, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a20927991ed40f5b7fc29095fa96e9c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the call expression's callee's declaration matches the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#a20927991ed40f5b7fc29095fa96e9c36">More...</a><br /></td></tr>
<tr class="separator:a20927991ed40f5b7fc29095fa96e9c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32edc701e40baa415fe15868791c4b9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a32edc701e40baa415fe15868791c4b9a">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (hasType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:a32edc701e40baa415fe15868791c4b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the expression's or declaration's type matches a type matcher.  <a href="namespaceclang_1_1ast__matchers.html#a32edc701e40baa415fe15868791c4b9a">More...</a><br /></td></tr>
<tr class="separator:a32edc701e40baa415fe15868791c4b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a094ff7ddc1b0328cb262bffc465b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ace3a094ff7ddc1b0328cb262bffc465b">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (hasType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:ace3a094ff7ddc1b0328cb262bffc465b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the declaration of the expression's or value declaration's type.  <a href="namespaceclang_1_1ast__matchers.html#ace3a094ff7ddc1b0328cb262bffc465b">More...</a><br /></td></tr>
<tr class="separator:ace3a094ff7ddc1b0328cb262bffc465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d441fb8797a726cc8f58469ea017523"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8d441fb8797a726cc8f58469ea017523">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, asString, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, Name)</td></tr>
<tr class="memdesc:a8d441fb8797a726cc8f58469ea017523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the type location of a node matches the inner matcher.  <a href="namespaceclang_1_1ast__matchers.html#a8d441fb8797a726cc8f58469ea017523">More...</a><br /></td></tr>
<tr class="separator:a8d441fb8797a726cc8f58469ea017523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34619df672712c3c1b89e9556ea6fb5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a34619df672712c3c1b89e9556ea6fb5e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, pointsTo, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a34619df672712c3c1b89e9556ea6fb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type is a pointer type and the pointee type matches the specified matcher.  <a href="namespaceclang_1_1ast__matchers.html#a34619df672712c3c1b89e9556ea6fb5e">More...</a><br /></td></tr>
<tr class="separator:a34619df672712c3c1b89e9556ea6fb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6356d65a88dcac0fda65fd48fa0338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac6356d65a88dcac0fda65fd48fa0338">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, pointsTo, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:aac6356d65a88dcac0fda65fd48fa0338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the pointee type's declaration.  <a href="namespaceclang_1_1ast__matchers.html#aac6356d65a88dcac0fda65fd48fa0338">More...</a><br /></td></tr>
<tr class="separator:aac6356d65a88dcac0fda65fd48fa0338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9ed079b63bde07a29f118be67d998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6ce9ed079b63bde07a29f118be67d998">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Type.html">Type</a>, hasUnqualifiedDesugaredType, internal::Matcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a6ce9ed079b63bde07a29f118be67d998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type matches the unqualified desugared type of the matched node.  <a href="namespaceclang_1_1ast__matchers.html#a6ce9ed079b63bde07a29f118be67d998">More...</a><br /></td></tr>
<tr class="separator:a6ce9ed079b63bde07a29f118be67d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326c00e2c764f18193b0e2ba5050199a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a326c00e2c764f18193b0e2ba5050199a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, references, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a326c00e2c764f18193b0e2ba5050199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the matched type is a reference type and the referenced type matches the specified matcher.  <a href="namespaceclang_1_1ast__matchers.html#a326c00e2c764f18193b0e2ba5050199a">More...</a><br /></td></tr>
<tr class="separator:a326c00e2c764f18193b0e2ba5050199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa0898cce8002e6e0db4a3e13b5e9d7ff">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, hasCanonicalType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches QualTypes whose canonical type matches InnerMatcher.  <a href="namespaceclang_1_1ast__matchers.html#aa0898cce8002e6e0db4a3e13b5e9d7ff">More...</a><br /></td></tr>
<tr class="separator:aa0898cce8002e6e0db4a3e13b5e9d7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee02e539525731a4811d4d33437b5ff7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aee02e539525731a4811d4d33437b5ff7">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, references, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:aee02e539525731a4811d4d33437b5ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the referenced type's declaration.  <a href="namespaceclang_1_1ast__matchers.html#aee02e539525731a4811d4d33437b5ff7">More...</a><br /></td></tr>
<tr class="separator:aee02e539525731a4811d4d33437b5ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9312d37843a929bb3d5e3fc89f6582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4d9312d37843a929bb3d5e3fc89f6582">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, onImplicitObjectArgument, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4d9312d37843a929bb3d5e3fc89f6582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the implicit object argument of a member call expression.  <a href="namespaceclang_1_1ast__matchers.html#a4d9312d37843a929bb3d5e3fc89f6582">More...</a><br /></td></tr>
<tr class="separator:a4d9312d37843a929bb3d5e3fc89f6582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a86ef01849f0ca8c3b8b5222a4b8e0522">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, thisPointerType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the type of the expression's implicit object argument either matches the InnerMatcher, or is a pointer to a type that matches the InnerMatcher.  <a href="namespaceclang_1_1ast__matchers.html#a86ef01849f0ca8c3b8b5222a4b8e0522">More...</a><br /></td></tr>
<tr class="separator:a86ef01849f0ca8c3b8b5222a4b8e0522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932ce498cc406f28f22149d1936c4b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8932ce498cc406f28f22149d1936c4b1">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>, thisPointerType, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a8932ce498cc406f28f22149d1936c4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded to match the type's declaration.  <a href="namespaceclang_1_1ast__matchers.html#a8932ce498cc406f28f22149d1936c4b1">More...</a><br /></td></tr>
<tr class="separator:a8932ce498cc406f28f22149d1936c4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2ae2d3c41e0c472fa618cfa95c73f17e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>, to, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a> that refers to a declaration that matches the specified matcher.  <a href="namespaceclang_1_1ast__matchers.html#a2ae2d3c41e0c472fa618cfa95c73f17e">More...</a><br /></td></tr>
<tr class="separator:a2ae2d3c41e0c472fa618cfa95c73f17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a19ee00dadd390e9911cdc64d2f0f0aa0">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OverloadExpr.html">OverloadExpr</a>, hasAnyDeclaration, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if a node refers to a declaration through a specific using shadow declaration.  <a href="namespaceclang_1_1ast__matchers.html#a19ee00dadd390e9911cdc64d2f0f0aa0">More...</a><br /></td></tr>
<tr class="separator:a19ee00dadd390e9911cdc64d2f0f0aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3490831f470cc4fa91a8e69e2b49cb92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3490831f470cc4fa91a8e69e2b49cb92">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, hasSingleDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a3490831f470cc4fa91a8e69e2b49cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> of a <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a> which has a single declaration.  <a href="namespaceclang_1_1ast__matchers.html#a3490831f470cc4fa91a8e69e2b49cb92">More...</a><br /></td></tr>
<tr class="separator:a3490831f470cc4fa91a8e69e2b49cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17df7f136021603cccaee853f067429"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af17df7f136021603cccaee853f067429">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af17df7f136021603cccaee853f067429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has an initializer expression that matches the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#af17df7f136021603cccaee853f067429">More...</a><br /></td></tr>
<tr class="separator:af17df7f136021603cccaee853f067429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef750e09ba850dbea8cc64f23454af0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aef750e09ba850dbea8cc64f23454af0f">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isInitCapture)</td></tr>
<tr class="memdesc:aef750e09ba850dbea8cc64f23454af0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable serving as the implicit variable for a lambda init- capture.  <a href="namespaceclang_1_1ast__matchers.html#aef750e09ba850dbea8cc64f23454af0f">More...</a><br /></td></tr>
<tr class="separator:aef750e09ba850dbea8cc64f23454af0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8847b49fa5e19735067eb7a690da5d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8847b49fa5e19735067eb7a690da5d5e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>, forEachLambdaCapture, internal::Matcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a8847b49fa5e19735067eb7a690da5d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches each lambda capture in a lambda expression.  <a href="namespaceclang_1_1ast__matchers.html#a8847b49fa5e19735067eb7a690da5d5e">More...</a><br /></td></tr>
<tr class="separator:a8847b49fa5e19735067eb7a690da5d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b5af78266c07a51fc05b0340faa5f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a40b5af78266c07a51fc05b0340faa5f0">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isStaticLocal)</td></tr>
<tr class="memdesc:a40b5af78266c07a51fc05b0340faa5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a static variable with local scope.  <a href="namespaceclang_1_1ast__matchers.html#a40b5af78266c07a51fc05b0340faa5f0">More...</a><br /></td></tr>
<tr class="separator:a40b5af78266c07a51fc05b0340faa5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20615f964d0cc210125ba1a7030e1d99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a20615f964d0cc210125ba1a7030e1d99">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasLocalStorage)</td></tr>
<tr class="memdesc:a20615f964d0cc210125ba1a7030e1d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has function scope and is a non-static local variable.  <a href="namespaceclang_1_1ast__matchers.html#a20615f964d0cc210125ba1a7030e1d99">More...</a><br /></td></tr>
<tr class="separator:a20615f964d0cc210125ba1a7030e1d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9fb8c35f77273ca8c9d74d3ccd8115ee">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasGlobalStorage)</td></tr>
<tr class="memdesc:a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that does not have local storage.  <a href="namespaceclang_1_1ast__matchers.html#a9fb8c35f77273ca8c9d74d3ccd8115ee">More...</a><br /></td></tr>
<tr class="separator:a9fb8c35f77273ca8c9d74d3ccd8115ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1491a3107fcb1a9823b82f0e0d2c8f8b">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasAutomaticStorageDuration)</td></tr>
<tr class="memdesc:a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has automatic storage duration.  <a href="namespaceclang_1_1ast__matchers.html#a1491a3107fcb1a9823b82f0e0d2c8f8b">More...</a><br /></td></tr>
<tr class="separator:a1491a3107fcb1a9823b82f0e0d2c8f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c982b6814464ccb0e81ad49e5deb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abe1c982b6814464ccb0e81ad49e5deb8">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasStaticStorageDuration)</td></tr>
<tr class="memdesc:abe1c982b6814464ccb0e81ad49e5deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has static storage duration.  <a href="namespaceclang_1_1ast__matchers.html#abe1c982b6814464ccb0e81ad49e5deb8">More...</a><br /></td></tr>
<tr class="separator:abe1c982b6814464ccb0e81ad49e5deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea11fc4361920f652b8655a7fc1ce7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abea11fc4361920f652b8655a7fc1ce7a">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, hasThreadStorageDuration)</td></tr>
<tr class="memdesc:abea11fc4361920f652b8655a7fc1ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that has thread storage duration.  <a href="namespaceclang_1_1ast__matchers.html#abea11fc4361920f652b8655a7fc1ce7a">More...</a><br /></td></tr>
<tr class="separator:abea11fc4361920f652b8655a7fc1ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5663ab187f13ea8c1a0d3884a5837369"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5663ab187f13ea8c1a0d3884a5837369">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isExceptionVariable)</td></tr>
<tr class="memdesc:a5663ab187f13ea8c1a0d3884a5837369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a variable declaration that is an exception variable from a C++ catch block, or an Objective-C @catch statement.  <a href="namespaceclang_1_1ast__matchers.html#a5663ab187f13ea8c1a0d3884a5837369">More...</a><br /></td></tr>
<tr class="separator:a5663ab187f13ea8c1a0d3884a5837369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a46a4ccd4bcea5a4e03c1a502b4febba3">AST_POLYMORPHIC_MATCHER_P</a> (argumentCountIs, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a call expression or a constructor call expression has a specific number of arguments (including absent default arguments).  <a href="namespaceclang_1_1ast__matchers.html#a46a4ccd4bcea5a4e03c1a502b4febba3">More...</a><br /></td></tr>
<tr class="separator:a46a4ccd4bcea5a4e03c1a502b4febba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47efa625b357d8576ddd7845b4d8a2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad47efa625b357d8576ddd7845b4d8a2e">AST_POLYMORPHIC_MATCHER_P2</a> (hasArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), <a class="el" href="classunsigned.html">unsigned</a>, N, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ad47efa625b357d8576ddd7845b4d8a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th argument of a call expression or a constructor call expression.  <a href="namespaceclang_1_1ast__matchers.html#ad47efa625b357d8576ddd7845b4d8a2e">More...</a><br /></td></tr>
<tr class="separator:ad47efa625b357d8576ddd7845b4d8a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0a44f1320d0ad1ade3dc82fc4730f17f">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>, hasInit, <a class="el" href="classunsigned.html">unsigned</a>, N, ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th item of an initializer list expression.  <a href="namespaceclang_1_1ast__matchers.html#a0a44f1320d0ad1ade3dc82fc4730f17f">More...</a><br /></td></tr>
<tr class="separator:a0a44f1320d0ad1ade3dc82fc4730f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e9465ba62aea874dab861b34a2484"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aad3e9465ba62aea874dab861b34a2484">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, declCountIs, <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:aad3e9465ba62aea874dab861b34a2484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration statements that contain a specific number of declarations.  <a href="namespaceclang_1_1ast__matchers.html#aad3e9465ba62aea874dab861b34a2484">More...</a><br /></td></tr>
<tr class="separator:aad3e9465ba62aea874dab861b34a2484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436242d922937081d26821317552407e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a436242d922937081d26821317552407e">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>, containsDeclaration, <a class="el" href="classunsigned.html">unsigned</a>, N, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a436242d922937081d26821317552407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th declaration of a declaration statement.  <a href="namespaceclang_1_1ast__matchers.html#a436242d922937081d26821317552407e">More...</a><br /></td></tr>
<tr class="separator:a436242d922937081d26821317552407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75db3620648d58f6be5e799142f86a31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a75db3620648d58f6be5e799142f86a31">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a>, isCatchAll)</td></tr>
<tr class="memdesc:a75db3620648d58f6be5e799142f86a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ catch statement that has a catch-all handler.  <a href="namespaceclang_1_1ast__matchers.html#a75db3620648d58f6be5e799142f86a31">More...</a><br /></td></tr>
<tr class="separator:a75db3620648d58f6be5e799142f86a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706a42c87f0ca22a7ab5875eb6d074b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1706a42c87f0ca22a7ab5875eb6d074b">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, hasAnyConstructorInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a1706a42c87f0ca22a7ab5875eb6d074b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer.  <a href="namespaceclang_1_1ast__matchers.html#a1706a42c87f0ca22a7ab5875eb6d074b">More...</a><br /></td></tr>
<tr class="separator:a1706a42c87f0ca22a7ab5875eb6d074b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdaa82b53209463877c44d74dab03d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9bdaa82b53209463877c44d74dab03d4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, forField, internal::Matcher&lt; <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a9bdaa82b53209463877c44d74dab03d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the field declaration of a constructor initializer.  <a href="namespaceclang_1_1ast__matchers.html#a9bdaa82b53209463877c44d74dab03d4">More...</a><br /></td></tr>
<tr class="separator:a9bdaa82b53209463877c44d74dab03d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc97227bc2ea23c497ac5c88111fcab7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abc97227bc2ea23c497ac5c88111fcab7">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, withInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:abc97227bc2ea23c497ac5c88111fcab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the initializer expression of a constructor initializer.  <a href="namespaceclang_1_1ast__matchers.html#abc97227bc2ea23c497ac5c88111fcab7">More...</a><br /></td></tr>
<tr class="separator:abc97227bc2ea23c497ac5c88111fcab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a03f7a8a989c0ca1eaa26b3045b1ceaab">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isWritten)</td></tr>
<tr class="memdesc:a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is explicitly written in code (as opposed to implicitly added by the compiler).  <a href="namespaceclang_1_1ast__matchers.html#a03f7a8a989c0ca1eaa26b3045b1ceaab">More...</a><br /></td></tr>
<tr class="separator:a03f7a8a989c0ca1eaa26b3045b1ceaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151df67d97404bc1b336c5dfc6d01951"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a151df67d97404bc1b336c5dfc6d01951">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isBaseInitializer)</td></tr>
<tr class="memdesc:a151df67d97404bc1b336c5dfc6d01951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is initializing a base, as opposed to a member.  <a href="namespaceclang_1_1ast__matchers.html#a151df67d97404bc1b336c5dfc6d01951">More...</a><br /></td></tr>
<tr class="separator:a151df67d97404bc1b336c5dfc6d01951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b640dfb1653cfed5729b59331761"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4740b640dfb1653cfed5729b59331761">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>, isMemberInitializer)</td></tr>
<tr class="memdesc:a4740b640dfb1653cfed5729b59331761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor initializer if it is initializing a member, as opposed to a base.  <a href="namespaceclang_1_1ast__matchers.html#a4740b640dfb1653cfed5729b59331761">More...</a><br /></td></tr>
<tr class="separator:a4740b640dfb1653cfed5729b59331761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33beb8112c5d3457aa00768aaafc89f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a33beb8112c5d3457aa00768aaafc89f2">AST_POLYMORPHIC_MATCHER_P</a> (hasAnyArgument, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a33beb8112c5d3457aa00768aaafc89f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any argument of a call expression or a constructor call expression, or an ObjC-message-send expression.  <a href="namespaceclang_1_1ast__matchers.html#a33beb8112c5d3457aa00768aaafc89f2">More...</a><br /></td></tr>
<tr class="separator:a33beb8112c5d3457aa00768aaafc89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb3eae1c288af703b6bac40de050e41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1eb3eae1c288af703b6bac40de050e41">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>, hasAnyCapture, internal::Matcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a1eb3eae1c288af703b6bac40de050e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any capture in a lambda expression.  <a href="namespaceclang_1_1ast__matchers.html#a1eb3eae1c288af703b6bac40de050e41">More...</a><br /></td></tr>
<tr class="separator:a1eb3eae1c288af703b6bac40de050e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b0de5095cbd59d3e99338aadeedd6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a36b0de5095cbd59d3e99338aadeedd6f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>, capturesVar, internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a36b0de5095cbd59d3e99338aadeedd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classclang_1_1LambdaCapture.html" title="Describes the capture of a variable or of this, or of a C++1y init-capture.">LambdaCapture</a></code> that refers to the specified <code><a class="el" href="classclang_1_1VarDecl.html" title="Represents a variable declaration or definition.">VarDecl</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a36b0de5095cbd59d3e99338aadeedd6f">More...</a><br /></td></tr>
<tr class="separator:a36b0de5095cbd59d3e99338aadeedd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c4cdd5e71df74ae03654ec95477167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a39c4cdd5e71df74ae03654ec95477167">AST_MATCHER</a> (<a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>, capturesThis)</td></tr>
<tr class="memdesc:a39c4cdd5e71df74ae03654ec95477167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a <code><a class="el" href="classclang_1_1LambdaCapture.html" title="Describes the capture of a variable or of this, or of a C++1y init-capture.">LambdaCapture</a></code> that refers to 'this'.  <a href="namespaceclang_1_1ast__matchers.html#a39c4cdd5e71df74ae03654ec95477167">More...</a><br /></td></tr>
<tr class="separator:a39c4cdd5e71df74ae03654ec95477167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113d0616cb8189881b650642e748512"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8113d0616cb8189881b650642e748512">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, isListInitialization)</td></tr>
<tr class="memdesc:a8113d0616cb8189881b650642e748512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor call expression which uses list initialization.  <a href="namespaceclang_1_1ast__matchers.html#a8113d0616cb8189881b650642e748512">More...</a><br /></td></tr>
<tr class="separator:a8113d0616cb8189881b650642e748512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5125c811ce3f78efc6ab3c5a1bf68362"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5125c811ce3f78efc6ab3c5a1bf68362">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, requiresZeroInitialization)</td></tr>
<tr class="memdesc:a5125c811ce3f78efc6ab3c5a1bf68362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constructor call expression which requires zero initialization.  <a href="namespaceclang_1_1ast__matchers.html#a5125c811ce3f78efc6ab3c5a1bf68362">More...</a><br /></td></tr>
<tr class="separator:a5125c811ce3f78efc6ab3c5a1bf68362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ebb293017dba39bb149d8faea59176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a79ebb293017dba39bb149d8faea59176">AST_POLYMORPHIC_MATCHER_P2</a> (hasParameter, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>), <a class="el" href="classunsigned.html">unsigned</a>, N, internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a79ebb293017dba39bb149d8faea59176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the n'th parameter of a function or an ObjC method declaration or a block.  <a href="namespaceclang_1_1ast__matchers.html#a79ebb293017dba39bb149d8faea59176">More...</a><br /></td></tr>
<tr class="separator:a79ebb293017dba39bb149d8faea59176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af575f4746ac9a3a887ba95055a0b98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2af575f4746ac9a3a887ba95055a0b98">AST_POLYMORPHIC_MATCHER_P2</a> (forEachArgumentWithParam, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, ArgMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;, ParamMatcher)</td></tr>
<tr class="memdesc:a2af575f4746ac9a3a887ba95055a0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all arguments and their respective <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a>.  <a href="namespaceclang_1_1ast__matchers.html#a2af575f4746ac9a3a887ba95055a0b98">More...</a><br /></td></tr>
<tr class="separator:a2af575f4746ac9a3a887ba95055a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7884898943337e06f5ab539e5b508b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af7884898943337e06f5ab539e5b508b0">AST_POLYMORPHIC_MATCHER_P2</a> (forEachArgumentWithParamType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, ArgMatcher, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, ParamMatcher)</td></tr>
<tr class="memdesc:af7884898943337e06f5ab539e5b508b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all arguments and their respective types for a <code><a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a></code> or <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#af7884898943337e06f5ab539e5b508b0">More...</a><br /></td></tr>
<tr class="separator:af7884898943337e06f5ab539e5b508b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1f3a0f652c9f6a1b9664e62f8806a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a20b1f3a0f652c9f6a1b9664e62f8806a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a>, isAtPosition, <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a20b1f3a0f652c9f6a1b9664e62f8806a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a> nodes that are at the N'th position in the parameter list.  <a href="namespaceclang_1_1ast__matchers.html#a20b1f3a0f652c9f6a1b9664e62f8806a">More...</a><br /></td></tr>
<tr class="separator:a20b1f3a0f652c9f6a1b9664e62f8806a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8247f72147eb15518da3fefa6d89de38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8247f72147eb15518da3fefa6d89de38">AST_POLYMORPHIC_MATCHER_P</a> (hasAnyParameter, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a8247f72147eb15518da3fefa6d89de38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any parameter of a function or an ObjC method declaration or a block.  <a href="namespaceclang_1_1ast__matchers.html#a8247f72147eb15518da3fefa6d89de38">More...</a><br /></td></tr>
<tr class="separator:a8247f72147eb15518da3fefa6d89de38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c864eda133965e8b52b66d3f05a1e28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5c864eda133965e8b52b66d3f05a1e28">AST_POLYMORPHIC_MATCHER_P</a> (parameterCountIs, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>), <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a5c864eda133965e8b52b66d3f05a1e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>FunctionDecls</code> and <code>FunctionProtoTypes</code> that have a specific parameter count.  <a href="namespaceclang_1_1ast__matchers.html#a5c864eda133965e8b52b66d3f05a1e28">More...</a><br /></td></tr>
<tr class="separator:a5c864eda133965e8b52b66d3f05a1e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482f6a19376344d86cd5ec9aac7d39fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a482f6a19376344d86cd5ec9aac7d39fc">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isNoReturn)</td></tr>
<tr class="memdesc:a482f6a19376344d86cd5ec9aac7d39fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>FunctionDecls</code> that have a noreturn attribute.  <a href="namespaceclang_1_1ast__matchers.html#a482f6a19376344d86cd5ec9aac7d39fc">More...</a><br /></td></tr>
<tr class="separator:a482f6a19376344d86cd5ec9aac7d39fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8788b28117869cda162e847833df3e1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8788b28117869cda162e847833df3e1c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, returns, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a8788b28117869cda162e847833df3e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the return type of a function declaration.  <a href="namespaceclang_1_1ast__matchers.html#a8788b28117869cda162e847833df3e1c">More...</a><br /></td></tr>
<tr class="separator:a8788b28117869cda162e847833df3e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d371182732d8e3f7bf723c389bcf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac23d371182732d8e3f7bf723c389bcf0">AST_POLYMORPHIC_MATCHER</a> (<a class="el" href="SemaDecl_8cpp.html#aec982ed92ad089218775cb39b43df9fc">isExternC</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>))</td></tr>
<tr class="memdesc:ac23d371182732d8e3f7bf723c389bcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches extern "C" function or variable declarations.  <a href="namespaceclang_1_1ast__matchers.html#ac23d371182732d8e3f7bf723c389bcf0">More...</a><br /></td></tr>
<tr class="separator:ac23d371182732d8e3f7bf723c389bcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff96786938aea59fcf81f4f787dddbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9ff96786938aea59fcf81f4f787dddbd">AST_POLYMORPHIC_MATCHER</a> (isStaticStorageClass, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>))</td></tr>
<tr class="memdesc:a9ff96786938aea59fcf81f4f787dddbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches variable/function declarations that have "static" storage class specifier ("static" keyword) written in the source.  <a href="namespaceclang_1_1ast__matchers.html#a9ff96786938aea59fcf81f4f787dddbd">More...</a><br /></td></tr>
<tr class="separator:a9ff96786938aea59fcf81f4f787dddbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb9eddf358dcb8c8f85861bd308178d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aeeb9eddf358dcb8c8f85861bd308178d">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isDeleted)</td></tr>
<tr class="memdesc:aeeb9eddf358dcb8c8f85861bd308178d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches deleted function declarations.  <a href="namespaceclang_1_1ast__matchers.html#aeeb9eddf358dcb8c8f85861bd308178d">More...</a><br /></td></tr>
<tr class="separator:aeeb9eddf358dcb8c8f85861bd308178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a6edb23b007372acf1505df0a76019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a04a6edb23b007372acf1505df0a76019">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isDefaulted)</td></tr>
<tr class="memdesc:a04a6edb23b007372acf1505df0a76019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches defaulted function declarations.  <a href="namespaceclang_1_1ast__matchers.html#a04a6edb23b007372acf1505df0a76019">More...</a><br /></td></tr>
<tr class="separator:a04a6edb23b007372acf1505df0a76019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d84f589f05d59fa13d516934b15077"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a94d84f589f05d59fa13d516934b15077">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isWeak)</td></tr>
<tr class="memdesc:a94d84f589f05d59fa13d516934b15077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches weak function declarations.  <a href="namespaceclang_1_1ast__matchers.html#a94d84f589f05d59fa13d516934b15077">More...</a><br /></td></tr>
<tr class="separator:a94d84f589f05d59fa13d516934b15077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa682f6d7ba1fc7a0a4473ef0a9a60cf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa682f6d7ba1fc7a0a4473ef0a9a60cf2">AST_POLYMORPHIC_MATCHER</a> (hasDynamicExceptionSpec, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>))</td></tr>
<tr class="memdesc:aa682f6d7ba1fc7a0a4473ef0a9a60cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functions that have a dynamic exception specification.  <a href="namespaceclang_1_1ast__matchers.html#aa682f6d7ba1fc7a0a4473ef0a9a60cf2">More...</a><br /></td></tr>
<tr class="separator:aa682f6d7ba1fc7a0a4473ef0a9a60cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8994aabec60a6969bd1db250086972e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8994aabec60a6969bd1db250086972e6">AST_POLYMORPHIC_MATCHER</a> (isNoThrow, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>))</td></tr>
<tr class="memdesc:a8994aabec60a6969bd1db250086972e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functions that have a non-throwing exception specification.  <a href="namespaceclang_1_1ast__matchers.html#a8994aabec60a6969bd1db250086972e6">More...</a><br /></td></tr>
<tr class="separator:a8994aabec60a6969bd1db250086972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c636295b8e279c5b5878462d002f0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a34c636295b8e279c5b5878462d002f0b">AST_POLYMORPHIC_MATCHER</a> (isConsteval, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>))</td></tr>
<tr class="memdesc:a34c636295b8e279c5b5878462d002f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches consteval function declarations and if consteval/if ! consteval statements.  <a href="namespaceclang_1_1ast__matchers.html#a34c636295b8e279c5b5878462d002f0b">More...</a><br /></td></tr>
<tr class="separator:a34c636295b8e279c5b5878462d002f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47b3fd0af4c1fd58128fd23c52af8dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad47b3fd0af4c1fd58128fd23c52af8dd">AST_POLYMORPHIC_MATCHER</a> (isConstexpr, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>))</td></tr>
<tr class="memdesc:ad47b3fd0af4c1fd58128fd23c52af8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constexpr variable and function declarations, and if constexpr.  <a href="namespaceclang_1_1ast__matchers.html#ad47b3fd0af4c1fd58128fd23c52af8dd">More...</a><br /></td></tr>
<tr class="separator:ad47b3fd0af4c1fd58128fd23c52af8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee32557ec036b3e0838b05d42b4b831"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6ee32557ec036b3e0838b05d42b4b831">AST_MATCHER</a> (<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, isConstinit)</td></tr>
<tr class="memdesc:a6ee32557ec036b3e0838b05d42b4b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constinit variable declarations.  <a href="namespaceclang_1_1ast__matchers.html#a6ee32557ec036b3e0838b05d42b4b831">More...</a><br /></td></tr>
<tr class="separator:a6ee32557ec036b3e0838b05d42b4b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51232687c8252d0341b5a094b0feb33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac51232687c8252d0341b5a094b0feb33">AST_POLYMORPHIC_MATCHER_P</a> (hasInitStatement, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac51232687c8252d0341b5a094b0feb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches selection statements with initializer.  <a href="namespaceclang_1_1ast__matchers.html#ac51232687c8252d0341b5a094b0feb33">More...</a><br /></td></tr>
<tr class="separator:ac51232687c8252d0341b5a094b0feb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29d543b314240f67d977c1e1211c8bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae29d543b314240f67d977c1e1211c8bb">AST_POLYMORPHIC_MATCHER_P</a> (hasCondition, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>, <a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae29d543b314240f67d977c1e1211c8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the condition expression of an if statement, for loop, switch statement or conditional operator.  <a href="namespaceclang_1_1ast__matchers.html#ae29d543b314240f67d977c1e1211c8bb">More...</a><br /></td></tr>
<tr class="separator:ae29d543b314240f67d977c1e1211c8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24292ba3bd8669c92e59fcaaebcf672c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a24292ba3bd8669c92e59fcaaebcf672c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, hasThen, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a24292ba3bd8669c92e59fcaaebcf672c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the then-statement of an if statement.  <a href="namespaceclang_1_1ast__matchers.html#a24292ba3bd8669c92e59fcaaebcf672c">More...</a><br /></td></tr>
<tr class="separator:a24292ba3bd8669c92e59fcaaebcf672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b626d54664c5e174cfb8e4733c97e89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5b626d54664c5e174cfb8e4733c97e89">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, hasElse, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5b626d54664c5e174cfb8e4733c97e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the else-statement of an if statement.  <a href="namespaceclang_1_1ast__matchers.html#a5b626d54664c5e174cfb8e4733c97e89">More...</a><br /></td></tr>
<tr class="separator:a5b626d54664c5e174cfb8e4733c97e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e24bcf30db85f9701f1edd3f74b70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a311e24bcf30db85f9701f1edd3f74b70">AST_POLYMORPHIC_MATCHER_P</a> (equalsBoundNode, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Type.html">Type</a>, <a class="el" href="classclang_1_1QualType.html">QualType</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, ID)</td></tr>
<tr class="memdesc:a311e24bcf30db85f9701f1edd3f74b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if a node equals a previously bound node.  <a href="namespaceclang_1_1ast__matchers.html#a311e24bcf30db85f9701f1edd3f74b70">More...</a><br /></td></tr>
<tr class="separator:a311e24bcf30db85f9701f1edd3f74b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938c34e60bf2f27d1e66f9091b17f58b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a938c34e60bf2f27d1e66f9091b17f58b">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, hasConditionVariableStatement, internal::Matcher&lt; <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a938c34e60bf2f27d1e66f9091b17f58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the condition variable statement in an if statement.  <a href="namespaceclang_1_1ast__matchers.html#a938c34e60bf2f27d1e66f9091b17f58b">More...</a><br /></td></tr>
<tr class="separator:a938c34e60bf2f27d1e66f9091b17f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf010352b49cd17b4e902f7bef7ba82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6bf010352b49cd17b4e902f7bef7ba82">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>, hasIndex, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a6bf010352b49cd17b4e902f7bef7ba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the index expression of an array subscript expression.  <a href="namespaceclang_1_1ast__matchers.html#a6bf010352b49cd17b4e902f7bef7ba82">More...</a><br /></td></tr>
<tr class="separator:a6bf010352b49cd17b4e902f7bef7ba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2e70bf9f26381c3b9b55582d894db7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2b2e70bf9f26381c3b9b55582d894db7">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>, hasBase, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a2b2e70bf9f26381c3b9b55582d894db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the base expression of an array subscript expression.  <a href="namespaceclang_1_1ast__matchers.html#a2b2e70bf9f26381c3b9b55582d894db7">More...</a><br /></td></tr>
<tr class="separator:a2b2e70bf9f26381c3b9b55582d894db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108c5647ad1e01c2f4a2bfdb4b917965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a108c5647ad1e01c2f4a2bfdb4b917965">AST_POLYMORPHIC_MATCHER_P</a> (hasBody, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DoStmt.html">DoStmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a108c5647ad1e01c2f4a2bfdb4b917965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a 'for', 'while', 'do while' statement or a function definition that has a given body.  <a href="namespaceclang_1_1ast__matchers.html#a108c5647ad1e01c2f4a2bfdb4b917965">More...</a><br /></td></tr>
<tr class="separator:a108c5647ad1e01c2f4a2bfdb4b917965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bd01b778096c483b22f6d19a730a46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a88bd01b778096c483b22f6d19a730a46">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, hasAnyBody, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a88bd01b778096c483b22f6d19a730a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a function declaration that has a given body present in the AST.  <a href="namespaceclang_1_1ast__matchers.html#a88bd01b778096c483b22f6d19a730a46">More...</a><br /></td></tr>
<tr class="separator:a88bd01b778096c483b22f6d19a730a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff742094cc27e60ffda9e493ccf0773"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4ff742094cc27e60ffda9e493ccf0773">AST_POLYMORPHIC_MATCHER_P</a> (hasAnySubstatement, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4ff742094cc27e60ffda9e493ccf0773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches compound statements where at least one substatement matches a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#a4ff742094cc27e60ffda9e493ccf0773">More...</a><br /></td></tr>
<tr class="separator:a4ff742094cc27e60ffda9e493ccf0773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e8f220890d4edd52d83be0784f917e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a51e8f220890d4edd52d83be0784f917e">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a>, statementCountIs, <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a51e8f220890d4edd52d83be0784f917e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a compound statement contains a specific number of child statements.  <a href="namespaceclang_1_1ast__matchers.html#a51e8f220890d4edd52d83be0784f917e">More...</a><br /></td></tr>
<tr class="separator:a51e8f220890d4edd52d83be0784f917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144e36e553f364291ec8746c14cd05c"><td class="memTemplParams" colspan="2">template&lt;typename ValueT &gt; </td></tr>
<tr class="memitem:aa144e36e553f364291ec8746c14cd05c"><td class="memTemplItemLeft" align="right" valign="top">internal::PolymorphicMatcher&lt; internal::ValueEqualsMatcher, void(internal::AllNodeBaseTypes), ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a> (const ValueT &amp;<a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>)</td></tr>
<tr class="memdesc:aa144e36e553f364291ec8746c14cd05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches literals that are equal to the given value of type ValueT.  <a href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">More...</a><br /></td></tr>
<tr class="separator:aa144e36e553f364291ec8746c14cd05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3fb0f523a50436b680799583adf5b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aaa3fb0f523a50436b680799583adf5b2">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>), <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>, 0)</td></tr>
<tr class="separator:aaa3fb0f523a50436b680799583adf5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b7ca6be7f065051e54b82cde76f81d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a93b7ca6be7f065051e54b82cde76f81d">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>), <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>, 1)</td></tr>
<tr class="separator:a93b7ca6be7f065051e54b82cde76f81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8896d437173e705cd26d3a57a6949840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8896d437173e705cd26d3a57a6949840">AST_POLYMORPHIC_MATCHER_P_OVERLOAD</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>), <a class="el" href="____clang__hip__libdevice__declares_8h.html#a81cb22c87f277e41a39a91e48766e549">double</a>, <a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>, 2)</td></tr>
<tr class="separator:a8896d437173e705cd26d3a57a6949840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7347eb115ff1dd512cb2f720ca35f812"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7347eb115ff1dd512cb2f720ca35f812">AST_POLYMORPHIC_MATCHER_P</a> (hasOperatorName, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a>), <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, Name)</td></tr>
<tr class="memdesc:a7347eb115ff1dd512cb2f720ca35f812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the operator Name of operator expressions (binary or unary).  <a href="namespaceclang_1_1ast__matchers.html#a7347eb115ff1dd512cb2f720ca35f812">More...</a><br /></td></tr>
<tr class="separator:a7347eb115ff1dd512cb2f720ca35f812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2906b75257d9178e6513f1cb5834b79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad2906b75257d9178e6513f1cb5834b79">AST_POLYMORPHIC_MATCHER</a> (isAssignmentOperator, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>))</td></tr>
<tr class="memdesc:ad2906b75257d9178e6513f1cb5834b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all kinds of assignment operators.  <a href="namespaceclang_1_1ast__matchers.html#ad2906b75257d9178e6513f1cb5834b79">More...</a><br /></td></tr>
<tr class="separator:ad2906b75257d9178e6513f1cb5834b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921dd0c92df1afb657e587157c605ab0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a921dd0c92df1afb657e587157c605ab0">AST_POLYMORPHIC_MATCHER</a> (isComparisonOperator, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>))</td></tr>
<tr class="memdesc:a921dd0c92df1afb657e587157c605ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches comparison operators.  <a href="namespaceclang_1_1ast__matchers.html#a921dd0c92df1afb657e587157c605ab0">More...</a><br /></td></tr>
<tr class="separator:a921dd0c92df1afb657e587157c605ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e231cf3ad9b2d725fe41521ae01416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a58e231cf3ad9b2d725fe41521ae01416">AST_POLYMORPHIC_MATCHER_P</a> (hasLHS, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a58e231cf3ad9b2d725fe41521ae01416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the left hand side of binary operator expressions.  <a href="namespaceclang_1_1ast__matchers.html#a58e231cf3ad9b2d725fe41521ae01416">More...</a><br /></td></tr>
<tr class="separator:a58e231cf3ad9b2d725fe41521ae01416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa103fa34c8174316318f579a15234a33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa103fa34c8174316318f579a15234a33">AST_POLYMORPHIC_MATCHER_P</a> (hasRHS, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa103fa34c8174316318f579a15234a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the right hand side of binary operator expressions.  <a href="namespaceclang_1_1ast__matchers.html#aa103fa34c8174316318f579a15234a33">More...</a><br /></td></tr>
<tr class="separator:aa103fa34c8174316318f579a15234a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5713c227c2899711e0994de49ce918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3e5713c227c2899711e0994de49ce918">AST_POLYMORPHIC_MATCHER_P</a> (hasEitherOperand, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a3e5713c227c2899711e0994de49ce918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if either the left hand side or the right hand side of a binary operator matches.  <a href="namespaceclang_1_1ast__matchers.html#a3e5713c227c2899711e0994de49ce918">More...</a><br /></td></tr>
<tr class="separator:a3e5713c227c2899711e0994de49ce918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a96b1f5a45478d7712a6ff08c5a12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9f4a96b1f5a45478d7712a6ff08c5a12">AST_POLYMORPHIC_MATCHER_P2</a> (hasOperands, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, Matcher1, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, Matcher2)</td></tr>
<tr class="memdesc:a9f4a96b1f5a45478d7712a6ff08c5a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if both matchers match with opposite sides of the binary operator.  <a href="namespaceclang_1_1ast__matchers.html#a9f4a96b1f5a45478d7712a6ff08c5a12">More...</a><br /></td></tr>
<tr class="separator:a9f4a96b1f5a45478d7712a6ff08c5a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b418923f78e631d2435afa5e2e19652"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3b418923f78e631d2435afa5e2e19652">AST_POLYMORPHIC_MATCHER_P</a> (hasUnaryOperand, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a3b418923f78e631d2435afa5e2e19652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the operand of a unary operator matches.  <a href="namespaceclang_1_1ast__matchers.html#a3b418923f78e631d2435afa5e2e19652">More...</a><br /></td></tr>
<tr class="separator:a3b418923f78e631d2435afa5e2e19652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3cd96cdc8e727cc6d2b1a997d00ee4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5f3cd96cdc8e727cc6d2b1a997d00ee4">AST_POLYMORPHIC_MATCHER_P</a> (hasSourceExpression, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CastExpr.html">CastExpr</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5f3cd96cdc8e727cc6d2b1a997d00ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the cast's source expression or opaque value's source expression matches the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#a5f3cd96cdc8e727cc6d2b1a997d00ee4">More...</a><br /></td></tr>
<tr class="separator:a5f3cd96cdc8e727cc6d2b1a997d00ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa1d3e00476bc176f02041341776ab1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#acaa1d3e00476bc176f02041341776ab1">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CastExpr.html">CastExpr</a>, hasCastKind, <a class="el" href="namespaceclang.html#aa8bdb68daa57cbb2096f354001e2df8c">CastKind</a>, Kind)</td></tr>
<tr class="memdesc:acaa1d3e00476bc176f02041341776ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches casts that has a given cast kind.  <a href="namespaceclang_1_1ast__matchers.html#acaa1d3e00476bc176f02041341776ab1">More...</a><br /></td></tr>
<tr class="separator:acaa1d3e00476bc176f02041341776ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae483f80b9fb6ac6dd16b9ca2150beaa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae483f80b9fb6ac6dd16b9ca2150beaa4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>, hasDestinationType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae483f80b9fb6ac6dd16b9ca2150beaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches casts whose destination type matches a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#ae483f80b9fb6ac6dd16b9ca2150beaa4">More...</a><br /></td></tr>
<tr class="separator:ae483f80b9fb6ac6dd16b9ca2150beaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa618c0bf6f0873d081052cb92a35d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5fa618c0bf6f0873d081052cb92a35d2">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a>, hasImplicitDestinationType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5fa618c0bf6f0873d081052cb92a35d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches implicit casts whose destination type matches a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#a5fa618c0bf6f0873d081052cb92a35d2">More...</a><br /></td></tr>
<tr class="separator:a5fa618c0bf6f0873d081052cb92a35d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f139141766e6fd227fce08a3782f2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a12f139141766e6fd227fce08a3782f2d">AST_MATCHER</a> (<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, isStruct)</td></tr>
<tr class="memdesc:a12f139141766e6fd227fce08a3782f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "struct.".  <a href="namespaceclang_1_1ast__matchers.html#a12f139141766e6fd227fce08a3782f2d">More...</a><br /></td></tr>
<tr class="separator:a12f139141766e6fd227fce08a3782f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a33ea23e6d76e2dc1b49c24ad6280eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0a33ea23e6d76e2dc1b49c24ad6280eb">AST_MATCHER</a> (<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, isUnion)</td></tr>
<tr class="memdesc:a0a33ea23e6d76e2dc1b49c24ad6280eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "union.".  <a href="namespaceclang_1_1ast__matchers.html#a0a33ea23e6d76e2dc1b49c24ad6280eb">More...</a><br /></td></tr>
<tr class="separator:a0a33ea23e6d76e2dc1b49c24ad6280eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d392366262bf6fc023e6b94ecbccde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a84d392366262bf6fc023e6b94ecbccde">AST_MATCHER</a> (<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, isClass)</td></tr>
<tr class="memdesc:a84d392366262bf6fc023e6b94ecbccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "class.".  <a href="namespaceclang_1_1ast__matchers.html#a84d392366262bf6fc023e6b94ecbccde">More...</a><br /></td></tr>
<tr class="separator:a84d392366262bf6fc023e6b94ecbccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad334219b265c85cede50cbc80b8c86b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad334219b265c85cede50cbc80b8c86b7">AST_MATCHER</a> (<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, isEnum)</td></tr>
<tr class="memdesc:ad334219b265c85cede50cbc80b8c86b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "enum.".  <a href="namespaceclang_1_1ast__matchers.html#ad334219b265c85cede50cbc80b8c86b7">More...</a><br /></td></tr>
<tr class="separator:ad334219b265c85cede50cbc80b8c86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6019ff261c2b642ff8dc931abd80b67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad6019ff261c2b642ff8dc931abd80b67">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>, hasTrueExpression, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ad6019ff261c2b642ff8dc931abd80b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the true branch expression of a conditional operator.  <a href="namespaceclang_1_1ast__matchers.html#ad6019ff261c2b642ff8dc931abd80b67">More...</a><br /></td></tr>
<tr class="separator:ad6019ff261c2b642ff8dc931abd80b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5b8784e1ef435e2c12993d80053c97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9f5b8784e1ef435e2c12993d80053c97">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>, hasFalseExpression, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a9f5b8784e1ef435e2c12993d80053c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the false branch expression of a conditional operator (binary or ternary).  <a href="namespaceclang_1_1ast__matchers.html#a9f5b8784e1ef435e2c12993d80053c97">More...</a><br /></td></tr>
<tr class="separator:a9f5b8784e1ef435e2c12993d80053c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f8830105eda64428bbebf2e06104cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae8f8830105eda64428bbebf2e06104cd">AST_POLYMORPHIC_MATCHER</a> (isDefinition, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>))</td></tr>
<tr class="memdesc:ae8f8830105eda64428bbebf2e06104cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if a declaration has a body attached.  <a href="namespaceclang_1_1ast__matchers.html#ae8f8830105eda64428bbebf2e06104cd">More...</a><br /></td></tr>
<tr class="separator:ae8f8830105eda64428bbebf2e06104cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1792b21c372bbe39f6a1d998e9e1ac84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1792b21c372bbe39f6a1d998e9e1ac84">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, isVariadic)</td></tr>
<tr class="memdesc:a1792b21c372bbe39f6a1d998e9e1ac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if a function declaration is variadic.  <a href="namespaceclang_1_1ast__matchers.html#a1792b21c372bbe39f6a1d998e9e1ac84">More...</a><br /></td></tr>
<tr class="separator:a1792b21c372bbe39f6a1d998e9e1ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e5adb14a8a36db06b0705c002014c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a219e5adb14a8a36db06b0705c002014c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, ofClass, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a219e5adb14a8a36db06b0705c002014c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the class declaration that the given method declaration belongs to.  <a href="namespaceclang_1_1ast__matchers.html#a219e5adb14a8a36db06b0705c002014c">More...</a><br /></td></tr>
<tr class="separator:a219e5adb14a8a36db06b0705c002014c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee42ec34375c06335058c4af2da024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abaee42ec34375c06335058c4af2da024">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, forEachOverridden, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:abaee42ec34375c06335058c4af2da024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches each method overridden by the given method.  <a href="namespaceclang_1_1ast__matchers.html#abaee42ec34375c06335058c4af2da024">More...</a><br /></td></tr>
<tr class="separator:abaee42ec34375c06335058c4af2da024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0448005fc240cb31fe89537aa08fdac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab0448005fc240cb31fe89537aa08fdac">AST_POLYMORPHIC_MATCHER</a> (isVirtual, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>))</td></tr>
<tr class="memdesc:ab0448005fc240cb31fe89537aa08fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations of virtual methods and C++ base specifers that specify virtual inheritance.  <a href="namespaceclang_1_1ast__matchers.html#ab0448005fc240cb31fe89537aa08fdac">More...</a><br /></td></tr>
<tr class="separator:ab0448005fc240cb31fe89537aa08fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9aeed83b57735c38c8d8e9f22f2192"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2f9aeed83b57735c38c8d8e9f22f2192">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isVirtualAsWritten)</td></tr>
<tr class="memdesc:a2f9aeed83b57735c38c8d8e9f22f2192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration has an explicit "virtual".  <a href="namespaceclang_1_1ast__matchers.html#a2f9aeed83b57735c38c8d8e9f22f2192">More...</a><br /></td></tr>
<tr class="separator:a2f9aeed83b57735c38c8d8e9f22f2192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e5003965a3d46728b1fd843fb29cf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a00e5003965a3d46728b1fd843fb29cf3">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, isInheritingConstructor)</td></tr>
<tr class="separator:a00e5003965a3d46728b1fd843fb29cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9751536735d265204f305b51cefd1ab6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9751536735d265204f305b51cefd1ab6">AST_POLYMORPHIC_MATCHER</a> (isFinal, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>))</td></tr>
<tr class="memdesc:a9751536735d265204f305b51cefd1ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method or class declaration is final.  <a href="namespaceclang_1_1ast__matchers.html#a9751536735d265204f305b51cefd1ab6">More...</a><br /></td></tr>
<tr class="separator:a9751536735d265204f305b51cefd1ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da68121f6bf340c733d85b7a7239850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3da68121f6bf340c733d85b7a7239850">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isPure)</td></tr>
<tr class="memdesc:a3da68121f6bf340c733d85b7a7239850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration is pure.  <a href="namespaceclang_1_1ast__matchers.html#a3da68121f6bf340c733d85b7a7239850">More...</a><br /></td></tr>
<tr class="separator:a3da68121f6bf340c733d85b7a7239850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8435f1b9638bfcb614dd2f94f6a777ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8435f1b9638bfcb614dd2f94f6a777ae">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isConst)</td></tr>
<tr class="memdesc:a8435f1b9638bfcb614dd2f94f6a777ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration is const.  <a href="namespaceclang_1_1ast__matchers.html#a8435f1b9638bfcb614dd2f94f6a777ae">More...</a><br /></td></tr>
<tr class="separator:a8435f1b9638bfcb614dd2f94f6a777ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70216ae4b468a7691f86871be8d47a44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a70216ae4b468a7691f86871be8d47a44">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isCopyAssignmentOperator)</td></tr>
<tr class="memdesc:a70216ae4b468a7691f86871be8d47a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration declares a copy assignment operator.  <a href="namespaceclang_1_1ast__matchers.html#a70216ae4b468a7691f86871be8d47a44">More...</a><br /></td></tr>
<tr class="separator:a70216ae4b468a7691f86871be8d47a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acef6bdde0954f5381dd824d2a8ee2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a51acef6bdde0954f5381dd824d2a8ee2">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isMoveAssignmentOperator)</td></tr>
<tr class="memdesc:a51acef6bdde0954f5381dd824d2a8ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration declares a move assignment operator.  <a href="namespaceclang_1_1ast__matchers.html#a51acef6bdde0954f5381dd824d2a8ee2">More...</a><br /></td></tr>
<tr class="separator:a51acef6bdde0954f5381dd824d2a8ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1af9627f2b938ceade2b02b4cf1442"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8d1af9627f2b938ceade2b02b4cf1442">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isOverride)</td></tr>
<tr class="memdesc:a8d1af9627f2b938ceade2b02b4cf1442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the given method declaration overrides another method.  <a href="namespaceclang_1_1ast__matchers.html#a8d1af9627f2b938ceade2b02b4cf1442">More...</a><br /></td></tr>
<tr class="separator:a8d1af9627f2b938ceade2b02b4cf1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7424217be877dfb6d2ae56e28009ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4d7424217be877dfb6d2ae56e28009ad">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, isUserProvided)</td></tr>
<tr class="memdesc:a4d7424217be877dfb6d2ae56e28009ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches method declarations that are user-provided.  <a href="namespaceclang_1_1ast__matchers.html#a4d7424217be877dfb6d2ae56e28009ad">More...</a><br /></td></tr>
<tr class="separator:a4d7424217be877dfb6d2ae56e28009ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fdc35c5063926e195a8e9f0814b058"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac1fdc35c5063926e195a8e9f0814b058">AST_POLYMORPHIC_MATCHER</a> (isArrow, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>))</td></tr>
<tr class="memdesc:ac1fdc35c5063926e195a8e9f0814b058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member expressions that are called with '-&gt;' as opposed to '.  <a href="namespaceclang_1_1ast__matchers.html#ac1fdc35c5063926e195a8e9f0814b058">More...</a><br /></td></tr>
<tr class="separator:ac1fdc35c5063926e195a8e9f0814b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a73bbb88280b57b26efebd78dbf1d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab4a73bbb88280b57b26efebd78dbf1d0">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isInteger)</td></tr>
<tr class="memdesc:ab4a73bbb88280b57b26efebd78dbf1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of integer type.  <a href="namespaceclang_1_1ast__matchers.html#ab4a73bbb88280b57b26efebd78dbf1d0">More...</a><br /></td></tr>
<tr class="separator:ab4a73bbb88280b57b26efebd78dbf1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd461383edbc3b0fb25d468361da60c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afd461383edbc3b0fb25d468361da60c8">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isUnsignedInteger)</td></tr>
<tr class="memdesc:afd461383edbc3b0fb25d468361da60c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of unsigned integer type.  <a href="namespaceclang_1_1ast__matchers.html#afd461383edbc3b0fb25d468361da60c8">More...</a><br /></td></tr>
<tr class="separator:afd461383edbc3b0fb25d468361da60c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdadfba0b95c13792be8ee05ac17cb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#accdadfba0b95c13792be8ee05ac17cb8">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isSignedInteger)</td></tr>
<tr class="memdesc:accdadfba0b95c13792be8ee05ac17cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of signed integer type.  <a href="namespaceclang_1_1ast__matchers.html#accdadfba0b95c13792be8ee05ac17cb8">More...</a><br /></td></tr>
<tr class="separator:accdadfba0b95c13792be8ee05ac17cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e710b1308cae72a0cb67631f93bad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4d9e710b1308cae72a0cb67631f93bad">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isAnyCharacter)</td></tr>
<tr class="memdesc:a4d9e710b1308cae72a0cb67631f93bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of character type.  <a href="namespaceclang_1_1ast__matchers.html#a4d9e710b1308cae72a0cb67631f93bad">More...</a><br /></td></tr>
<tr class="separator:a4d9e710b1308cae72a0cb67631f93bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5b77763e9db8d70b6b9ed859feae02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2e5b77763e9db8d70b6b9ed859feae02">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isAnyPointer)</td></tr>
<tr class="memdesc:a2e5b77763e9db8d70b6b9ed859feae02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of any pointer type; this includes the Objective-C object pointer type, which is different despite being syntactically similar.  <a href="namespaceclang_1_1ast__matchers.html#a2e5b77763e9db8d70b6b9ed859feae02">More...</a><br /></td></tr>
<tr class="separator:a2e5b77763e9db8d70b6b9ed859feae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac8c30a5b2e273349949e39762f51f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abac8c30a5b2e273349949e39762f51f3">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isConstQualified)</td></tr>
<tr class="memdesc:abac8c30a5b2e273349949e39762f51f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are const-qualified, i.e., that include "top-level" const.  <a href="namespaceclang_1_1ast__matchers.html#abac8c30a5b2e273349949e39762f51f3">More...</a><br /></td></tr>
<tr class="separator:abac8c30a5b2e273349949e39762f51f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d648df28587f0db52a54783c7ae00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a928d648df28587f0db52a54783c7ae00">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, isVolatileQualified)</td></tr>
<tr class="memdesc:a928d648df28587f0db52a54783c7ae00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are volatile-qualified, i.e., that include "top-level" volatile.  <a href="namespaceclang_1_1ast__matchers.html#a928d648df28587f0db52a54783c7ae00">More...</a><br /></td></tr>
<tr class="separator:a928d648df28587f0db52a54783c7ae00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730656106bd2b8e38948dc278fd83a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a730656106bd2b8e38948dc278fd83a39">AST_MATCHER</a> (<a class="el" href="classclang_1_1QualType.html">QualType</a>, hasLocalQualifiers)</td></tr>
<tr class="memdesc:a730656106bd2b8e38948dc278fd83a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that have local CV-qualifiers attached to the node, not hidden within a typedef.  <a href="namespaceclang_1_1ast__matchers.html#a730656106bd2b8e38948dc278fd83a39">More...</a><br /></td></tr>
<tr class="separator:a730656106bd2b8e38948dc278fd83a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9537471ed664862c0392e7af2a9122d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae9537471ed664862c0392e7af2a9122d">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>, member, internal::Matcher&lt; <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae9537471ed664862c0392e7af2a9122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a member expression where the member is matched by a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#ae9537471ed664862c0392e7af2a9122d">More...</a><br /></td></tr>
<tr class="separator:ae9537471ed664862c0392e7af2a9122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0d19d5ba477202f97ac5a225d246a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adc0d19d5ba477202f97ac5a225d246a3">AST_POLYMORPHIC_MATCHER_P</a> (hasObjectExpression, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>), internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:adc0d19d5ba477202f97ac5a225d246a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a member expression where the object expression is matched by a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#adc0d19d5ba477202f97ac5a225d246a3">More...</a><br /></td></tr>
<tr class="separator:adc0d19d5ba477202f97ac5a225d246a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54676e4f255159b2113847a3cd6fb10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af54676e4f255159b2113847a3cd6fb10">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1BaseUsingDecl.html">BaseUsingDecl</a>, hasAnyUsingShadowDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:af54676e4f255159b2113847a3cd6fb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any using shadow declaration.  <a href="namespaceclang_1_1ast__matchers.html#af54676e4f255159b2113847a3cd6fb10">More...</a><br /></td></tr>
<tr class="separator:af54676e4f255159b2113847a3cd6fb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafed008cf985cdd00f757db410c921c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#acafed008cf985cdd00f757db410c921c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>, hasTargetDecl, internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:acafed008cf985cdd00f757db410c921c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a using shadow declaration where the target declaration is matched by the given matcher.  <a href="namespaceclang_1_1ast__matchers.html#acafed008cf985cdd00f757db410c921c">More...</a><br /></td></tr>
<tr class="separator:acafed008cf985cdd00f757db410c921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ea8656591d99d51f9101406b84bc6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab7ea8656591d99d51f9101406b84bc6e">AST_POLYMORPHIC_MATCHER</a> (<a class="el" href="namespaceclang.html#a0b8388fd083767ec7fc87ac872cb7be3">isTemplateInstantiation</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>))</td></tr>
<tr class="memdesc:ab7ea8656591d99d51f9101406b84bc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template instantiations of function, class, or static member variable template instantiations.  <a href="namespaceclang_1_1ast__matchers.html#ab7ea8656591d99d51f9101406b84bc6e">More...</a><br /></td></tr>
<tr class="separator:ab7ea8656591d99d51f9101406b84bc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2745cd447f2bfd8135133ed47eaf614e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2745cd447f2bfd8135133ed47eaf614e">AST_MATCHER_FUNCTION</a> (internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, isInstantiated)</td></tr>
<tr class="memdesc:a2745cd447f2bfd8135133ed47eaf614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations that are template instantiations or are inside template instantiations.  <a href="namespaceclang_1_1ast__matchers.html#a2745cd447f2bfd8135133ed47eaf614e">More...</a><br /></td></tr>
<tr class="separator:a2745cd447f2bfd8135133ed47eaf614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8d230186d4232b33a6bd1d9062d372"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aab8d230186d4232b33a6bd1d9062d372">AST_MATCHER_FUNCTION</a> (internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, isInTemplateInstantiation)</td></tr>
<tr class="memdesc:aab8d230186d4232b33a6bd1d9062d372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statements inside of a template instantiation.  <a href="namespaceclang_1_1ast__matchers.html#aab8d230186d4232b33a6bd1d9062d372">More...</a><br /></td></tr>
<tr class="separator:aab8d230186d4232b33a6bd1d9062d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ca64c1b2c32d0a675fea55d05231f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a712ca64c1b2c32d0a675fea55d05231f">AST_POLYMORPHIC_MATCHER</a> (isExplicitTemplateSpecialization, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>))</td></tr>
<tr class="memdesc:a712ca64c1b2c32d0a675fea55d05231f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches explicit template specializations of function, class, or static member variable template instantiations.  <a href="namespaceclang_1_1ast__matchers.html#a712ca64c1b2c32d0a675fea55d05231f">More...</a><br /></td></tr>
<tr class="separator:a712ca64c1b2c32d0a675fea55d05231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3481dc12121ff50b48803a6a867887b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab3481dc12121ff50b48803a6a867887b">AST_MATCHER_FUNCTION_P_OVERLOAD</a> (internal::BindableMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, loc, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:ab3481dc12121ff50b48803a6a867887b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>TypeLocs</code> for which the given inner QualType-matcher matches.  <a href="namespaceclang_1_1ast__matchers.html#ab3481dc12121ff50b48803a6a867887b">More...</a><br /></td></tr>
<tr class="separator:ab3481dc12121ff50b48803a6a867887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae337c8496000b5158bd5d078f049681c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae337c8496000b5158bd5d078f049681c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a>, hasUnqualifiedLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae337c8496000b5158bd5d078f049681c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1QualifiedTypeLoc.html" title="Wrapper of type source information for a type with non-trivial direct qualifiers.">QualifiedTypeLoc</a></code>s that have an unqualified <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#ae337c8496000b5158bd5d078f049681c">More...</a><br /></td></tr>
<tr class="separator:ae337c8496000b5158bd5d078f049681c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe24b80b0c7f389698881797248ccba0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abe24b80b0c7f389698881797248ccba0">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, hasReturnTypeLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, ReturnMatcher)</td></tr>
<tr class="memdesc:abe24b80b0c7f389698881797248ccba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a function declared with the specified return <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#abe24b80b0c7f389698881797248ccba0">More...</a><br /></td></tr>
<tr class="separator:abe24b80b0c7f389698881797248ccba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b21a24755b4c4f087b0280223a5d90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a13b21a24755b4c4f087b0280223a5d90">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a>, hasPointeeLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, PointeeMatcher)</td></tr>
<tr class="memdesc:a13b21a24755b4c4f087b0280223a5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches pointer <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a pointee <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>PointeeMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a13b21a24755b4c4f087b0280223a5d90">More...</a><br /></td></tr>
<tr class="separator:a13b21a24755b4c4f087b0280223a5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224b76b39157090fd8b19e496e6c7938"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a224b76b39157090fd8b19e496e6c7938">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a>, hasReferentLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, ReferentMatcher)</td></tr>
<tr class="memdesc:a224b76b39157090fd8b19e496e6c7938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches reference <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a referent <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>ReferentMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a224b76b39157090fd8b19e496e6c7938">More...</a><br /></td></tr>
<tr class="separator:a224b76b39157090fd8b19e496e6c7938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7180d456edbc9ab91e28edc4912b5675"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7180d456edbc9ab91e28edc4912b5675">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>, hasAnyTemplateArgumentLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a7180d456edbc9ab91e28edc4912b5675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have at least one <code><a class="el" href="classclang_1_1TemplateArgumentLoc.html" title="Location wrapper for a TemplateArgument.">TemplateArgumentLoc</a></code> matching the given <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a7180d456edbc9ab91e28edc4912b5675">More...</a><br /></td></tr>
<tr class="separator:a7180d456edbc9ab91e28edc4912b5675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cfe4f5d9f29cc35a12a3abb6443bce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa2cfe4f5d9f29cc35a12a3abb6443bce">AST_POLYMORPHIC_MATCHER_P2</a> (hasTemplateArgumentLoc, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>, <a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>), <a class="el" href="classunsigned.html">unsigned</a>, Index, internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa2cfe4f5d9f29cc35a12a3abb6443bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s where the n'th <code><a class="el" href="classclang_1_1TemplateArgumentLoc.html" title="Location wrapper for a TemplateArgument.">TemplateArgumentLoc</a></code> matches the given <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#aa2cfe4f5d9f29cc35a12a3abb6443bce">More...</a><br /></td></tr>
<tr class="separator:aa2cfe4f5d9f29cc35a12a3abb6443bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d722ea161c9e778a372802649e5c2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a37d722ea161c9e778a372802649e5c2f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a>, hasNamedTypeLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a37d722ea161c9e778a372802649e5c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches elaborated <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a named <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a37d722ea161c9e778a372802649e5c2f">More...</a><br /></td></tr>
<tr class="separator:a37d722ea161c9e778a372802649e5c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff857767d820b98d6f4fa2f237950cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8ff857767d820b98d6f4fa2f237950cf">AST_MATCHER</a> (<a class="el" href="classclang_1_1Type.html">Type</a>, booleanType)</td></tr>
<tr class="memdesc:a8ff857767d820b98d6f4fa2f237950cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type <code>bool</code>.  <a href="namespaceclang_1_1ast__matchers.html#a8ff857767d820b98d6f4fa2f237950cf">More...</a><br /></td></tr>
<tr class="separator:a8ff857767d820b98d6f4fa2f237950cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729714cdf1308ca2a14ee48e79528817"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a729714cdf1308ca2a14ee48e79528817">AST_MATCHER</a> (<a class="el" href="classclang_1_1Type.html">Type</a>, voidType)</td></tr>
<tr class="memdesc:a729714cdf1308ca2a14ee48e79528817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type <code>void</code>.  <a href="namespaceclang_1_1ast__matchers.html#a729714cdf1308ca2a14ee48e79528817">More...</a><br /></td></tr>
<tr class="separator:a729714cdf1308ca2a14ee48e79528817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f20af5398aa43186617f8e9717cb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a088f20af5398aa43186617f8e9717cb5">AST_MATCHER</a> (<a class="el" href="classclang_1_1Type.html">Type</a>, realFloatingPointType)</td></tr>
<tr class="memdesc:a088f20af5398aa43186617f8e9717cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any real floating-point type (float, double, long double).  <a href="namespaceclang_1_1ast__matchers.html#a088f20af5398aa43186617f8e9717cb5">More...</a><br /></td></tr>
<tr class="separator:a088f20af5398aa43186617f8e9717cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558dcdb7f37b0f64f9ebdfa2855b2445"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a558dcdb7f37b0f64f9ebdfa2855b2445">AST_TYPELOC_TRAVERSE_MATCHER_DECL</a> (hasElementType, getElement, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>))</td></tr>
<tr class="memdesc:a558dcdb7f37b0f64f9ebdfa2855b2445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches arrays and C99 complex types that have a specific element type.  <a href="namespaceclang_1_1ast__matchers.html#a558dcdb7f37b0f64f9ebdfa2855b2445">More...</a><br /></td></tr>
<tr class="separator:a558dcdb7f37b0f64f9ebdfa2855b2445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e42518161472ddb640ba49d061a6507"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2e42518161472ddb640ba49d061a6507">AST_POLYMORPHIC_MATCHER_P</a> (hasSize, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a>), <a class="el" href="classunsigned.html">unsigned</a>, N)</td></tr>
<tr class="memdesc:a2e42518161472ddb640ba49d061a6507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes that have the specified size.  <a href="namespaceclang_1_1ast__matchers.html#a2e42518161472ddb640ba49d061a6507">More...</a><br /></td></tr>
<tr class="separator:a2e42518161472ddb640ba49d061a6507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c97f65fbd9a52a76ebc63979c76f44c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8c97f65fbd9a52a76ebc63979c76f44c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a>, hasSizeExpr, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a8c97f65fbd9a52a76ebc63979c76f44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1VariableArrayType.html" title="Represents a C array with a specified size that is not an integer-constant-expression.">VariableArrayType</a></code> nodes that have a specific size expression.  <a href="namespaceclang_1_1ast__matchers.html#a8c97f65fbd9a52a76ebc63979c76f44c">More...</a><br /></td></tr>
<tr class="separator:a8c97f65fbd9a52a76ebc63979c76f44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64bdc785ad1466d7bc3752335e5e1b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad64bdc785ad1466d7bc3752335e5e1b5">AST_TYPELOC_TRAVERSE_MATCHER_DECL</a> (hasValueType, <a class="el" href="ArrayBoundCheckerV2_8cpp.html#a0f5cc163e1c5feb0c0b0af79d4b4869a">getValue</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>))</td></tr>
<tr class="memdesc:ad64bdc785ad1466d7bc3752335e5e1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches atomic types with a specific value type.  <a href="namespaceclang_1_1ast__matchers.html#ad64bdc785ad1466d7bc3752335e5e1b5">More...</a><br /></td></tr>
<tr class="separator:ad64bdc785ad1466d7bc3752335e5e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e736c2b875e6ea57aa811e01da8ef6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2e736c2b875e6ea57aa811e01da8ef6d">AST_TYPE_TRAVERSE_MATCHER</a> (hasDeducedType, getDeducedType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AutoType.html">AutoType</a>))</td></tr>
<tr class="memdesc:a2e736c2b875e6ea57aa811e01da8ef6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1AutoType.html" title="Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained by a type-constraint.">AutoType</a></code> nodes where the deduced type is a specific type.  <a href="namespaceclang_1_1ast__matchers.html#a2e736c2b875e6ea57aa811e01da8ef6d">More...</a><br /></td></tr>
<tr class="separator:a2e736c2b875e6ea57aa811e01da8ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfb240ad1b8144d7d9a59c834a8e5cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0dfb240ad1b8144d7d9a59c834a8e5cb">AST_TYPE_TRAVERSE_MATCHER</a> (hasUnderlyingType, <a class="el" href="RegionStore_8cpp.html#aa40d60a0a659ed599a32ba7f410edd06">getUnderlyingType</a>, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a>, <a class="el" href="classclang_1_1UsingType.html">UsingType</a>))</td></tr>
<tr class="memdesc:a0dfb240ad1b8144d7d9a59c834a8e5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1DecltypeType.html" title="Represents the type decltype(expr) (C++11).">DecltypeType</a></code> or <code><a class="el" href="classclang_1_1UsingType.html">UsingType</a></code> nodes to find the underlying type.  <a href="namespaceclang_1_1ast__matchers.html#a0dfb240ad1b8144d7d9a59c834a8e5cb">More...</a><br /></td></tr>
<tr class="separator:a0dfb240ad1b8144d7d9a59c834a8e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641d86a073599a892f18f64743cf5af1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a641d86a073599a892f18f64743cf5af1">AST_TYPE_TRAVERSE_MATCHER</a> (innerType, getInnerType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ParenType.html">ParenType</a>))</td></tr>
<tr class="memdesc:a641d86a073599a892f18f64743cf5af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1ParenType.html" title="Sugar for parentheses used when specifying types.">ParenType</a></code> nodes where the inner type is a specific type.  <a href="namespaceclang_1_1ast__matchers.html#a641d86a073599a892f18f64743cf5af1">More...</a><br /></td></tr>
<tr class="separator:a641d86a073599a892f18f64743cf5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf51c463d9416f6dff27349995032db1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abf51c463d9416f6dff27349995032db1">AST_TYPELOC_TRAVERSE_MATCHER_DECL</a> (pointee, getPointee, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>))</td></tr>
<tr class="memdesc:abf51c463d9416f6dff27349995032db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrows <a class="el" href="classclang_1_1PointerType.html" title="PointerType - C99 6.7.5.1 - Pointer Declarators.">PointerType</a> (and similar) matchers to those where the <code>pointee</code> matches a given matcher.  <a href="namespaceclang_1_1ast__matchers.html#abf51c463d9416f6dff27349995032db1">More...</a><br /></td></tr>
<tr class="separator:abf51c463d9416f6dff27349995032db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f915dc513a7302266dbc3fc9ade730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac0f915dc513a7302266dbc3fc9ade730">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a>, hasQualifier, internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac0f915dc513a7302266dbc3fc9ade730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ElaboratedTypes whose qualifier, a <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a>, matches <code>InnerMatcher</code> if the qualifier exists.  <a href="namespaceclang_1_1ast__matchers.html#ac0f915dc513a7302266dbc3fc9ade730">More...</a><br /></td></tr>
<tr class="separator:ac0f915dc513a7302266dbc3fc9ade730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bf5b9b8e54f44c8c159e78f532490f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a79bf5b9b8e54f44c8c159e78f532490f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a>, namesType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a79bf5b9b8e54f44c8c159e78f532490f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ElaboratedTypes whose named type matches <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a79bf5b9b8e54f44c8c159e78f532490f">More...</a><br /></td></tr>
<tr class="separator:a79bf5b9b8e54f44c8c159e78f532490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10974b3b97a20357316c2557f54d55fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10974b3b97a20357316c2557f54d55fc">AST_TYPE_TRAVERSE_MATCHER</a> (hasReplacementType, getReplacementType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a>))</td></tr>
<tr class="memdesc:a10974b3b97a20357316c2557f54d55fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template type parameter substitutions that have a replacement type that matches the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#a10974b3b97a20357316c2557f54d55fc">More...</a><br /></td></tr>
<tr class="separator:a10974b3b97a20357316c2557f54d55fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36d1ab4dd342580f69ab63fe3b4120f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac36d1ab4dd342580f69ab63fe3b4120f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DecayedType.html">DecayedType</a>, hasDecayedType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerType)</td></tr>
<tr class="memdesc:ac36d1ab4dd342580f69ab63fe3b4120f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the decayed type, whoes decayed type matches <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#ac36d1ab4dd342580f69ab63fe3b4120f">More...</a><br /></td></tr>
<tr class="separator:ac36d1ab4dd342580f69ab63fe3b4120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616533eb9d1bd2fba65947fc59f237cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a616533eb9d1bd2fba65947fc59f237cd">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Decl.html">Decl</a>, hasDeclContext, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a616533eb9d1bd2fba65947fc59f237cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations whose declaration context, interpreted as a <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a>, matches <code>InnerMatcher</code>.  <a href="namespaceclang_1_1ast__matchers.html#a616533eb9d1bd2fba65947fc59f237cd">More...</a><br /></td></tr>
<tr class="separator:a616533eb9d1bd2fba65947fc59f237cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af208b1b6e204747b1aef07708022aec5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af208b1b6e204747b1aef07708022aec5">AST_MATCHER_FUNCTION_P_OVERLOAD</a> (internal::BindableMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;, loc, internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:af208b1b6e204747b1aef07708022aec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>NestedNameSpecifierLocs</code> for which the given inner NestedNameSpecifier-matcher matches.  <a href="namespaceclang_1_1ast__matchers.html#af208b1b6e204747b1aef07708022aec5">More...</a><br /></td></tr>
<tr class="separator:af208b1b6e204747b1aef07708022aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cf25202b4b45344cc6fcc0cb6da8f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a94cf25202b4b45344cc6fcc0cb6da8f4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>, specifiesType, internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a94cf25202b4b45344cc6fcc0cb6da8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nested name specifiers that specify a type matching the given <code><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a></code> matcher without qualifiers.  <a href="namespaceclang_1_1ast__matchers.html#a94cf25202b4b45344cc6fcc0cb6da8f4">More...</a><br /></td></tr>
<tr class="separator:a94cf25202b4b45344cc6fcc0cb6da8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947552d76a386eff09436d02433c8f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4947552d76a386eff09436d02433c8f5">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, specifiesTypeLoc, internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4947552d76a386eff09436d02433c8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nested name specifier locs that specify a type matching the given <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a4947552d76a386eff09436d02433c8f5">More...</a><br /></td></tr>
<tr class="separator:a4947552d76a386eff09436d02433c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3d9f788a6b28e7dc769bea201f3931"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aca3d9f788a6b28e7dc769bea201f3931">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>, hasPrefix, internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;, InnerMatcher, 0)</td></tr>
<tr class="memdesc:aca3d9f788a6b28e7dc769bea201f3931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the prefix of a <code><a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#aca3d9f788a6b28e7dc769bea201f3931">More...</a><br /></td></tr>
<tr class="separator:aca3d9f788a6b28e7dc769bea201f3931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea7972419fdbae1850a62aa39c99137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6ea7972419fdbae1850a62aa39c99137">AST_MATCHER_P_OVERLOAD</a> (<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, hasPrefix, internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;, InnerMatcher, 1)</td></tr>
<tr class="memdesc:a6ea7972419fdbae1850a62aa39c99137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches on the prefix of a <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html" title="A C++ nested-name-specifier augmented with source location information.">NestedNameSpecifierLoc</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a6ea7972419fdbae1850a62aa39c99137">More...</a><br /></td></tr>
<tr class="separator:a6ea7972419fdbae1850a62aa39c99137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a93eeb115d0957d26d204424fbfb0c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7a93eeb115d0957d26d204424fbfb0c1">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>, specifiesNamespace, internal::Matcher&lt; <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a7a93eeb115d0957d26d204424fbfb0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nested name specifiers that specify a namespace matching the given namespace matcher.  <a href="namespaceclang_1_1ast__matchers.html#a7a93eeb115d0957d26d204424fbfb0c1">More...</a><br /></td></tr>
<tr class="separator:a7a93eeb115d0957d26d204424fbfb0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a92ba420d89f91d64dce561258473bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4a92ba420d89f91d64dce561258473bd">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>, forEachSwitchCase, internal::Matcher&lt; <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4a92ba420d89f91d64dce561258473bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches each case or default statement belonging to the given switch statement.  <a href="namespaceclang_1_1ast__matchers.html#a4a92ba420d89f91d64dce561258473bd">More...</a><br /></td></tr>
<tr class="separator:a4a92ba420d89f91d64dce561258473bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4887132c90f8fc757098cc7ae52d1f80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4887132c90f8fc757098cc7ae52d1f80">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, forEachConstructorInitializer, internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a4887132c90f8fc757098cc7ae52d1f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches each constructor initializer in a constructor definition.  <a href="namespaceclang_1_1ast__matchers.html#a4887132c90f8fc757098cc7ae52d1f80">More...</a><br /></td></tr>
<tr class="separator:a4887132c90f8fc757098cc7ae52d1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d1631ee2a7d6376f6edd8a1aa11335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac6d1631ee2a7d6376f6edd8a1aa11335">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, isCopyConstructor)</td></tr>
<tr class="memdesc:ac6d1631ee2a7d6376f6edd8a1aa11335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor declarations that are copy constructors.  <a href="namespaceclang_1_1ast__matchers.html#ac6d1631ee2a7d6376f6edd8a1aa11335">More...</a><br /></td></tr>
<tr class="separator:ac6d1631ee2a7d6376f6edd8a1aa11335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3964182fd77de56ef99d2a8b637a575"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa3964182fd77de56ef99d2a8b637a575">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, isMoveConstructor)</td></tr>
<tr class="memdesc:aa3964182fd77de56ef99d2a8b637a575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor declarations that are move constructors.  <a href="namespaceclang_1_1ast__matchers.html#aa3964182fd77de56ef99d2a8b637a575">More...</a><br /></td></tr>
<tr class="separator:aa3964182fd77de56ef99d2a8b637a575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad600c3f4a2cd82f23eda8276ab3e61be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad600c3f4a2cd82f23eda8276ab3e61be">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, isDefaultConstructor)</td></tr>
<tr class="memdesc:ad600c3f4a2cd82f23eda8276ab3e61be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor declarations that are default constructors.  <a href="namespaceclang_1_1ast__matchers.html#ad600c3f4a2cd82f23eda8276ab3e61be">More...</a><br /></td></tr>
<tr class="separator:ad600c3f4a2cd82f23eda8276ab3e61be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ccec7a66d7aed8d9a7e852213b596b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab6ccec7a66d7aed8d9a7e852213b596b">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, isDelegatingConstructor)</td></tr>
<tr class="memdesc:ab6ccec7a66d7aed8d9a7e852213b596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructors that delegate to another constructor.  <a href="namespaceclang_1_1ast__matchers.html#ab6ccec7a66d7aed8d9a7e852213b596b">More...</a><br /></td></tr>
<tr class="separator:ab6ccec7a66d7aed8d9a7e852213b596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ace1f0e85191bbb9826bea67ed9825c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3ace1f0e85191bbb9826bea67ed9825c">AST_POLYMORPHIC_MATCHER</a> (isExplicit, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a>))</td></tr>
<tr class="memdesc:a3ace1f0e85191bbb9826bea67ed9825c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor, conversion function, and deduction guide declarations that have an explicit specifier if this explicit specifier is resolved to true.  <a href="namespaceclang_1_1ast__matchers.html#a3ace1f0e85191bbb9826bea67ed9825c">More...</a><br /></td></tr>
<tr class="separator:a3ace1f0e85191bbb9826bea67ed9825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449e8a24f8169202139270647cc24506"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a449e8a24f8169202139270647cc24506">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, hasExplicitSpecifier, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a449e8a24f8169202139270647cc24506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the expression in an explicit specifier if present in the given declaration.  <a href="namespaceclang_1_1ast__matchers.html#a449e8a24f8169202139270647cc24506">More...</a><br /></td></tr>
<tr class="separator:a449e8a24f8169202139270647cc24506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d8baceba2a26515ef9ed5d850f12e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0c2d8baceba2a26515ef9ed5d850f12e">AST_POLYMORPHIC_MATCHER</a> (isInline, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>))</td></tr>
<tr class="memdesc:a0c2d8baceba2a26515ef9ed5d850f12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functions, variables and namespace declarations that are marked with the inline keyword.  <a href="namespaceclang_1_1ast__matchers.html#a0c2d8baceba2a26515ef9ed5d850f12e">More...</a><br /></td></tr>
<tr class="separator:a0c2d8baceba2a26515ef9ed5d850f12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6023a3bfaeeb3044f730c854d1c18d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abb6023a3bfaeeb3044f730c854d1c18d">AST_MATCHER</a> (<a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a>, isAnonymous)</td></tr>
<tr class="memdesc:abb6023a3bfaeeb3044f730c854d1c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches anonymous namespace declarations.  <a href="namespaceclang_1_1ast__matchers.html#abb6023a3bfaeeb3044f730c854d1c18d">More...</a><br /></td></tr>
<tr class="separator:abb6023a3bfaeeb3044f730c854d1c18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9c5b2c07f8f8e332a6248e95e75c55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afb9c5b2c07f8f8e332a6248e95e75c55">AST_MATCHER</a> (<a class="el" href="classclang_1_1Decl.html">Decl</a>, isInStdNamespace)</td></tr>
<tr class="memdesc:afb9c5b2c07f8f8e332a6248e95e75c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations in the namespace <code>std</code>, but not in nested namespaces.  <a href="namespaceclang_1_1ast__matchers.html#afb9c5b2c07f8f8e332a6248e95e75c55">More...</a><br /></td></tr>
<tr class="separator:afb9c5b2c07f8f8e332a6248e95e75c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6283f33749110044dc071dd7daafe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9a6283f33749110044dc071dd7daafe4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a>, hasCaseConstant, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a9a6283f33749110044dc071dd7daafe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given case statement does not use the GNU case range extension, matches the constant given in the statement.  <a href="namespaceclang_1_1ast__matchers.html#a9a6283f33749110044dc071dd7daafe4">More...</a><br /></td></tr>
<tr class="separator:a9a6283f33749110044dc071dd7daafe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2995332340b5792b85e50de5b1db15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac2995332340b5792b85e50de5b1db15">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="SemaCUDA_8cpp.html#a6d28c44d89e5f716fbc724a19a6c9b6b">hasAttr</a>, <a class="el" href="namespaceclang_1_1attr.html#ac160b7b7240633e6932ebb177d0f03ef">attr::Kind</a>, AttrKind)</td></tr>
<tr class="memdesc:aac2995332340b5792b85e50de5b1db15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration that has a given attribute.  <a href="namespaceclang_1_1ast__matchers.html#aac2995332340b5792b85e50de5b1db15">More...</a><br /></td></tr>
<tr class="separator:aac2995332340b5792b85e50de5b1db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ff88ab9d0d424289cd086b65dda0e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac2ff88ab9d0d424289cd086b65dda0e4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a>, hasReturnValue, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ac2ff88ab9d0d424289cd086b65dda0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the return value expression of a return statement.  <a href="namespaceclang_1_1ast__matchers.html#ac2ff88ab9d0d424289cd086b65dda0e4">More...</a><br /></td></tr>
<tr class="separator:ac2ff88ab9d0d424289cd086b65dda0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c8754d7c61ed2147f7579ee3690487"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a76c8754d7c61ed2147f7579ee3690487">AST_MATCHER_FUNCTION</a> (internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, nullPointerConstant)</td></tr>
<tr class="memdesc:a76c8754d7c61ed2147f7579ee3690487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that resolve to a null pointer constant, such as GNU's __null, C++11's nullptr, or C's NULL macro.  <a href="namespaceclang_1_1ast__matchers.html#a76c8754d7c61ed2147f7579ee3690487">More...</a><br /></td></tr>
<tr class="separator:a76c8754d7c61ed2147f7579ee3690487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8cfd5ba82d4ac370c5ff377b728f46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aec8cfd5ba82d4ac370c5ff377b728f46">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a>, forDecomposition, internal::Matcher&lt; <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aec8cfd5ba82d4ac370c5ff377b728f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a> the binding belongs to.  <a href="namespaceclang_1_1ast__matchers.html#aec8cfd5ba82d4ac370c5ff377b728f46">More...</a><br /></td></tr>
<tr class="separator:aec8cfd5ba82d4ac370c5ff377b728f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c5a8881ab6f78c544c0a5e158cb54d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a61c5a8881ab6f78c544c0a5e158cb54d">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a>, hasBinding, <a class="el" href="classunsigned.html">unsigned</a>, N, internal::Matcher&lt; <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a61c5a8881ab6f78c544c0a5e158cb54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the Nth binding of a <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a>.  <a href="namespaceclang_1_1ast__matchers.html#a61c5a8881ab6f78c544c0a5e158cb54d">More...</a><br /></td></tr>
<tr class="separator:a61c5a8881ab6f78c544c0a5e158cb54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e11922930086f116be1c4472256e94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa6e11922930086f116be1c4472256e94">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a>, hasAnyBinding, internal::Matcher&lt; <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aa6e11922930086f116be1c4472256e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any binding of a <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a>.  <a href="namespaceclang_1_1ast__matchers.html#aa6e11922930086f116be1c4472256e94">More...</a><br /></td></tr>
<tr class="separator:aa6e11922930086f116be1c4472256e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84a79607cf2c340fa7b7ab1c9ddc28a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae84a79607cf2c340fa7b7ab1c9ddc28a">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, forFunction, internal::Matcher&lt; <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:ae84a79607cf2c340fa7b7ab1c9ddc28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration of the function the statement belongs to.  <a href="namespaceclang_1_1ast__matchers.html#ae84a79607cf2c340fa7b7ab1c9ddc28a">More...</a><br /></td></tr>
<tr class="separator:ae84a79607cf2c340fa7b7ab1c9ddc28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5393b4cd5dfd74fe486e15f1c0e0cdc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5393b4cd5dfd74fe486e15f1c0e0cdc3">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, forCallable, internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a5393b4cd5dfd74fe486e15f1c0e0cdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration of the function, method, or block the statement belongs to.  <a href="namespaceclang_1_1ast__matchers.html#a5393b4cd5dfd74fe486e15f1c0e0cdc3">More...</a><br /></td></tr>
<tr class="separator:a5393b4cd5dfd74fe486e15f1c0e0cdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aea4baa7212cbc8faac94018f329ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad8aea4baa7212cbc8faac94018f329ba">AST_MATCHER</a> (<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>, hasExternalFormalLinkage)</td></tr>
<tr class="memdesc:ad8aea4baa7212cbc8faac94018f329ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration that has external formal linkage.  <a href="namespaceclang_1_1ast__matchers.html#ad8aea4baa7212cbc8faac94018f329ba">More...</a><br /></td></tr>
<tr class="separator:ad8aea4baa7212cbc8faac94018f329ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47d57c87bec70a8f07a0fbded588fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5f47d57c87bec70a8f07a0fbded588fc">AST_MATCHER</a> (<a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a>, hasDefaultArgument)</td></tr>
<tr class="memdesc:a5f47d57c87bec70a8f07a0fbded588fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration that has default arguments.  <a href="namespaceclang_1_1ast__matchers.html#a5f47d57c87bec70a8f07a0fbded588fc">More...</a><br /></td></tr>
<tr class="separator:a5f47d57c87bec70a8f07a0fbded588fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ef6cf6a860c83a65b4fb1f205690e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8b7ef6cf6a860c83a65b4fb1f205690e">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>, isArray)</td></tr>
<tr class="memdesc:a8b7ef6cf6a860c83a65b4fb1f205690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches array new expressions.  <a href="namespaceclang_1_1ast__matchers.html#a8b7ef6cf6a860c83a65b4fb1f205690e">More...</a><br /></td></tr>
<tr class="separator:a8b7ef6cf6a860c83a65b4fb1f205690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db73fc80716eac3847be470e9d5a8b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6db73fc80716eac3847be470e9d5a8b3">AST_MATCHER_P2</a> (<a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>, hasPlacementArg, <a class="el" href="classunsigned.html">unsigned</a>, Index, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a6db73fc80716eac3847be470e9d5a8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches placement new expression arguments.  <a href="namespaceclang_1_1ast__matchers.html#a6db73fc80716eac3847be470e9d5a8b3">More...</a><br /></td></tr>
<tr class="separator:a6db73fc80716eac3847be470e9d5a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95748550e6a5c26396235386d01ea052"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a95748550e6a5c26396235386d01ea052">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>, hasAnyPlacementArg, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a95748550e6a5c26396235386d01ea052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any placement new expression arguments.  <a href="namespaceclang_1_1ast__matchers.html#a95748550e6a5c26396235386d01ea052">More...</a><br /></td></tr>
<tr class="separator:a95748550e6a5c26396235386d01ea052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6658d09eeb51548739f6cecef2f3c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9a6658d09eeb51548739f6cecef2f3c9">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>, hasArraySize, internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a9a6658d09eeb51548739f6cecef2f3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches array new expressions with a given array size.  <a href="namespaceclang_1_1ast__matchers.html#a9a6658d09eeb51548739f6cecef2f3c9">More...</a><br /></td></tr>
<tr class="separator:a9a6658d09eeb51548739f6cecef2f3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850452e839bfb6e00fe566ed8341c6f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a850452e839bfb6e00fe566ed8341c6f8">AST_MATCHER</a> (<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="DynamicTypeChecker_8cpp.html#a900bedab3071753a7a3b3ee0fd4bcb74">hasDefinition</a>)</td></tr>
<tr class="memdesc:a850452e839bfb6e00fe566ed8341c6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a class declaration that is defined.  <a href="namespaceclang_1_1ast__matchers.html#a850452e839bfb6e00fe566ed8341c6f8">More...</a><br /></td></tr>
<tr class="separator:a850452e839bfb6e00fe566ed8341c6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d428c79f2cc613530525c2b9412ab20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2d428c79f2cc613530525c2b9412ab20">AST_MATCHER</a> (<a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a>, isScoped)</td></tr>
<tr class="memdesc:a2d428c79f2cc613530525c2b9412ab20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++11 scoped enum declaration.  <a href="namespaceclang_1_1ast__matchers.html#a2d428c79f2cc613530525c2b9412ab20">More...</a><br /></td></tr>
<tr class="separator:a2d428c79f2cc613530525c2b9412ab20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09615f50bf93357b7b6125a05aa4177c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a09615f50bf93357b7b6125a05aa4177c">AST_MATCHER</a> (<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, hasTrailingReturn)</td></tr>
<tr class="memdesc:a09615f50bf93357b7b6125a05aa4177c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a function declared with a trailing return type.  <a href="namespaceclang_1_1ast__matchers.html#a09615f50bf93357b7b6125a05aa4177c">More...</a><br /></td></tr>
<tr class="separator:a09615f50bf93357b7b6125a05aa4177c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3da709a45f0cd933497b1f7588f82f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7d3da709a45f0cd933497b1f7588f82f">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1Expr.html">Expr</a>, ignoringElidableConstructorCall, ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a7d3da709a45f0cd933497b1f7588f82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that match InnerMatcher that are possibly wrapped in an elidable constructor and other corresponding bookkeeping nodes.  <a href="namespaceclang_1_1ast__matchers.html#a7d3da709a45f0cd933497b1f7588f82f">More...</a><br /></td></tr>
<tr class="separator:a7d3da709a45f0cd933497b1f7588f82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc2672b07a0daec274bac69ed423c46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abcc2672b07a0daec274bac69ed423c46">AST_MATCHER</a> (<a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>, isStandaloneDirective)</td></tr>
<tr class="memdesc:abcc2672b07a0daec274bac69ed423c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches standalone OpenMP directives, i.e., directives that can't have a structured block.  <a href="namespaceclang_1_1ast__matchers.html#abcc2672b07a0daec274bac69ed423c46">More...</a><br /></td></tr>
<tr class="separator:abcc2672b07a0daec274bac69ed423c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6eac16c91f23300c033128c7d237e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aab6eac16c91f23300c033128c7d237e2">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>, hasStructuredBlock, internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:aab6eac16c91f23300c033128c7d237e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the structured-block of the OpenMP executable directive.  <a href="namespaceclang_1_1ast__matchers.html#aab6eac16c91f23300c033128c7d237e2">More...</a><br /></td></tr>
<tr class="separator:aab6eac16c91f23300c033128c7d237e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620158236235a959021528136fdea9a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a620158236235a959021528136fdea9a4">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>, hasAnyClause, internal::Matcher&lt; <a class="el" href="classclang_1_1OMPClause.html">OMPClause</a> &gt;, InnerMatcher)</td></tr>
<tr class="memdesc:a620158236235a959021528136fdea9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any clause in an OpenMP directive.  <a href="namespaceclang_1_1ast__matchers.html#a620158236235a959021528136fdea9a4">More...</a><br /></td></tr>
<tr class="separator:a620158236235a959021528136fdea9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae472248d0b5c303b822a7d56faf7448e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae472248d0b5c303b822a7d56faf7448e">AST_MATCHER</a> (<a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>, isNoneKind)</td></tr>
<tr class="memdesc:ae472248d0b5c303b822a7d56faf7448e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the OpenMP <code>default</code> clause has <code>none</code> kind specified.  <a href="namespaceclang_1_1ast__matchers.html#ae472248d0b5c303b822a7d56faf7448e">More...</a><br /></td></tr>
<tr class="separator:ae472248d0b5c303b822a7d56faf7448e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b25f8e3090e6647c4a1ed65d96d219"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa8b25f8e3090e6647c4a1ed65d96d219">AST_MATCHER</a> (<a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>, isSharedKind)</td></tr>
<tr class="memdesc:aa8b25f8e3090e6647c4a1ed65d96d219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the OpenMP <code>default</code> clause has <code>shared</code> kind specified.  <a href="namespaceclang_1_1ast__matchers.html#aa8b25f8e3090e6647c4a1ed65d96d219">More...</a><br /></td></tr>
<tr class="separator:aa8b25f8e3090e6647c4a1ed65d96d219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd7e8e64044ad79b73296c2c76605fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aefd7e8e64044ad79b73296c2c76605fb">AST_MATCHER</a> (<a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>, isFirstPrivateKind)</td></tr>
<tr class="memdesc:aefd7e8e64044ad79b73296c2c76605fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the OpenMP <code>default</code> clause has <code>firstprivate</code> kind specified.  <a href="namespaceclang_1_1ast__matchers.html#aefd7e8e64044ad79b73296c2c76605fb">More...</a><br /></td></tr>
<tr class="separator:aefd7e8e64044ad79b73296c2c76605fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5713ebcfebb04bcfd89e6098999e65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aaa5713ebcfebb04bcfd89e6098999e65">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>, isAllowedToContainClauseKind, <a class="el" href="namespaceclang.html#a4e0b3c12565106860a261ba7d4330112">OpenMPClauseKind</a>, CKind)</td></tr>
<tr class="memdesc:aaa5713ebcfebb04bcfd89e6098999e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the OpenMP directive is allowed to contain the specified OpenMP clause kind.  <a href="namespaceclang_1_1ast__matchers.html#aaa5713ebcfebb04bcfd89e6098999e65">More...</a><br /></td></tr>
<tr class="separator:aaa5713ebcfebb04bcfd89e6098999e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memTemplParams" colspan="2">template&lt;typename MatcherT &gt; </td></tr>
<tr class="memitem:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6e076c5e724f5522f9c51ffdc6dddf89">match</a> (MatcherT Matcher, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="memdesc:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of matching <code>Matcher</code> on the translation unit of <code>Context</code> and collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations.  <a href="namespaceclang_1_1ast__matchers.html#a6e076c5e724f5522f9c51ffdc6dddf89">More...</a><br /></td></tr>
<tr class="separator:a6e076c5e724f5522f9c51ffdc6dddf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87727e2eb520afc1b6df1b71b12f1712"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a87727e2eb520afc1b6df1b71b12f1712"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a87727e2eb520afc1b6df1b71b12f1712">selectFirst</a> (StringRef BoundTo, const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a> &gt; &amp;Results)</td></tr>
<tr class="memdesc:a87727e2eb520afc1b6df1b71b12f1712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first result of type <code>NodeT</code> bound to <code>BoundTo</code>.  <a href="namespaceclang_1_1ast__matchers.html#a87727e2eb520afc1b6df1b71b12f1712">More...</a><br /></td></tr>
<tr class="separator:a87727e2eb520afc1b6df1b71b12f1712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58768c3354b28da90a699c86524c62c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af58768c3354b28da90a699c86524c62c">matchDynamic</a> (internal::DynTypedMatcher Matcher, const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:af58768c3354b28da90a699c86524c62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263fa8fdf923632b5d87560254b12432"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a263fa8fdf923632b5d87560254b12432"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a263fa8fdf923632b5d87560254b12432">matchDynamic</a> (internal::DynTypedMatcher Matcher, const NodeT &amp;<a class="el" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:a263fa8fdf923632b5d87560254b12432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d62b16e618eb1aff8f3334fa773bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0a3d62b16e618eb1aff8f3334fa773bd">matchDynamic</a> (internal::DynTypedMatcher Matcher, <a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;Context)</td></tr>
<tr class="separator:a0a3d62b16e618eb1aff8f3334fa773bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03719ad642f4411e33d92b1081361f07"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a03719ad642f4411e33d92b1081361f07">gtestAssert</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Left, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Right)</td></tr>
<tr class="memdesc:a03719ad642f4411e33d92b1081361f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's ASSERT comparison macros including ASSERT_EQ, ASSERT_NE, ASSERT_GE, ASSERT_GT, ASSERT_LE and ASSERT_LT.  <a href="namespaceclang_1_1ast__matchers.html#a03719ad642f4411e33d92b1081361f07">More...</a><br /></td></tr>
<tr class="separator:a03719ad642f4411e33d92b1081361f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad460b6b2d5e64993560b4ce2d830181"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aad460b6b2d5e64993560b4ce2d830181">gtestAssertThat</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Actual, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Matcher)</td></tr>
<tr class="memdesc:aad460b6b2d5e64993560b4ce2d830181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's ASSERT_THAT macro.  <a href="namespaceclang_1_1ast__matchers.html#aad460b6b2d5e64993560b4ce2d830181">More...</a><br /></td></tr>
<tr class="separator:aad460b6b2d5e64993560b4ce2d830181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33afaf3f80e491354dc39625e4a6785b"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a33afaf3f80e491354dc39625e4a6785b">gtestExpect</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Left, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Right)</td></tr>
<tr class="memdesc:a33afaf3f80e491354dc39625e4a6785b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's EXPECT comparison macros including EXPECT_EQ, EXPECT_NE, EXPECT_GE, EXPECT_GT, EXPECT_LE and EXPECT_LT.  <a href="namespaceclang_1_1ast__matchers.html#a33afaf3f80e491354dc39625e4a6785b">More...</a><br /></td></tr>
<tr class="separator:a33afaf3f80e491354dc39625e4a6785b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b24c7e7612943db3615925608bb3b4"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a97b24c7e7612943db3615925608bb3b4">gtestExpectThat</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Actual, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Matcher)</td></tr>
<tr class="memdesc:a97b24c7e7612943db3615925608bb3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's EXPECT_THAT macro.  <a href="namespaceclang_1_1ast__matchers.html#a97b24c7e7612943db3615925608bb3b4">More...</a><br /></td></tr>
<tr class="separator:a97b24c7e7612943db3615925608bb3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc094e9ea85b60b5c76234c641737076"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#acc094e9ea85b60b5c76234c641737076">gtestExpectCall</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockObject, llvm::StringRef MockMethodName, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="memdesc:acc094e9ea85b60b5c76234c641737076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's EXPECT_CALL macro.  <a href="namespaceclang_1_1ast__matchers.html#acc094e9ea85b60b5c76234c641737076">More...</a><br /></td></tr>
<tr class="separator:acc094e9ea85b60b5c76234c641737076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6164c2c64e8ff507e212408e9a68e1bc"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6164c2c64e8ff507e212408e9a68e1bc">gtestExpectCall</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockCall, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="memdesc:a6164c2c64e8ff507e212408e9a68e1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matcher for gtest's EXPECT_CALL macro.  <a href="namespaceclang_1_1ast__matchers.html#a6164c2c64e8ff507e212408e9a68e1bc">More...</a><br /></td></tr>
<tr class="separator:a6164c2c64e8ff507e212408e9a68e1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4762f4e0573506f32ba15ead667acd8"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac4762f4e0573506f32ba15ead667acd8">gtestOnCall</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockObject, llvm::StringRef MockMethodName, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="memdesc:ac4762f4e0573506f32ba15ead667acd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the first <code>gtestExpectCall</code> overload but for <code>ON_CALL</code>.  <a href="namespaceclang_1_1ast__matchers.html#ac4762f4e0573506f32ba15ead667acd8">More...</a><br /></td></tr>
<tr class="separator:ac4762f4e0573506f32ba15ead667acd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86627675f3e19c46523c535e450e88"><td class="memItemLeft" align="right" valign="top">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aba86627675f3e19c46523c535e450e88">gtestOnCall</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockCall, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="memdesc:aba86627675f3e19c46523c535e450e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the second <code>gtestExpectCall</code> overload but for <code>ON_CALL</code>.  <a href="namespaceclang_1_1ast__matchers.html#aba86627675f3e19c46523c535e450e88">More...</a><br /></td></tr>
<tr class="separator:aba86627675f3e19c46523c535e450e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ca863c3bc2d2bc5af99d90933d6e9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac1ca863c3bc2d2bc5af99d90933d6e9c">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>, hasAnySelectorMatcher, std::vector&lt; <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &gt;, Matches)</td></tr>
<tr class="separator:ac1ca863c3bc2d2bc5af99d90933d6e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e40f7a7120043b6e36077adcf44c9cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9e40f7a7120043b6e36077adcf44c9cd">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (hasElementType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>))</td></tr>
<tr class="separator:a9e40f7a7120043b6e36077adcf44c9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d25fd07bb81ad8bf5a87a0068f13b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a953d25fd07bb81ad8bf5a87a0068f13b">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (hasValueType, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>))</td></tr>
<tr class="separator:a953d25fd07bb81ad8bf5a87a0068f13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3509e3798b4581a7a8cb59106aa6b73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad3509e3798b4581a7a8cb59106aa6b73">AST_TYPELOC_TRAVERSE_MATCHER_DEF</a> (pointee, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>))</td></tr>
<tr class="separator:ad3509e3798b4581a7a8cb59106aa6b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300e0f48793e28002e73a44d46dc3392"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceclang_1_1ast__matchers.html#a22b3e62e1b83cda2c7a5d9fc0f14f5cf">DeclarationMatcher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a300e0f48793e28002e73a44d46dc3392">getComparisonDecl</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:a300e0f48793e28002e73a44d46dc3392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a953cbdfc1d8d2d93032fa0b0c7124c"><td class="memItemLeft" align="right" valign="top">static llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5a953cbdfc1d8d2d93032fa0b0c7124c">getMacroTypeName</a> (MacroType Macro)</td></tr>
<tr class="separator:a5a953cbdfc1d8d2d93032fa0b0c7124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ddfef6d6925f8360634963103be7e2"><td class="memItemLeft" align="right" valign="top">static llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a11ddfef6d6925f8360634963103be7e2">getComparisonTypeName</a> (<a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:a11ddfef6d6925f8360634963103be7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7d2d8f325494b15676b71942e33834"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aca7d2d8f325494b15676b71942e33834">getMacroName</a> (MacroType Macro, <a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp)</td></tr>
<tr class="separator:aca7d2d8f325494b15676b71942e33834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b10fa75961d05f6dfe195cc5a83a4b8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1b10fa75961d05f6dfe195cc5a83a4b8">getMacroName</a> (MacroType Macro, llvm::StringRef Operation)</td></tr>
<tr class="separator:a1b10fa75961d05f6dfe195cc5a83a4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae386bd504bd7c7e82630d30f5b29f73c"><td class="memItemLeft" align="right" valign="top">static llvm::StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae386bd504bd7c7e82630d30f5b29f73c">getSpecSetterName</a> (MacroType Macro)</td></tr>
<tr class="separator:ae386bd504bd7c7e82630d30f5b29f73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f6fa697150613afbee7342dd3b2963"><td class="memItemLeft" align="right" valign="top">static internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a03f6fa697150613afbee7342dd3b2963">gtestComparisonInternal</a> (MacroType Macro, <a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a> Cmp, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Left, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Right)</td></tr>
<tr class="separator:a03f6fa697150613afbee7342dd3b2963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa032516f93fe85701798c899d7e3ea6b"><td class="memItemLeft" align="right" valign="top">static internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa032516f93fe85701798c899d7e3ea6b">gtestThatInternal</a> (MacroType Macro, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Actual, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> Matcher)</td></tr>
<tr class="separator:aa032516f93fe85701798c899d7e3ea6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9a3786e1bd4444c0543aad1e41ddb2"><td class="memItemLeft" align="right" valign="top">static internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aee9a3786e1bd4444c0543aad1e41ddb2">gtestCallInternal</a> (MacroType Macro, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockCall, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="separator:aee9a3786e1bd4444c0543aad1e41ddb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d09072840ada9128cb4cf992168c623"><td class="memItemLeft" align="right" valign="top">static internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6d09072840ada9128cb4cf992168c623">gtestCallInternal</a> (MacroType Macro, <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a> MockObject, llvm::StringRef MockMethodName, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a> Args)</td></tr>
<tr class="separator:a6d09072840ada9128cb4cf992168c623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a998865c12796efc3e50a1799f60e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a48a998865c12796efc3e50a1799f60e2">AST_MATCHER_P</a> (<a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a>, mentionsBoundType, <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>, BindingID)</td></tr>
<tr class="separator:a48a998865c12796efc3e50a1799f60e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaa73ed83faa263bfb5cface81d30ef91"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TranslationUnitDecl.html">TranslationUnitDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aaa73ed83faa263bfb5cface81d30ef91">translationUnitDecl</a></td></tr>
<tr class="memdesc:aaa73ed83faa263bfb5cface81d30ef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the top declaration context.  <a href="namespaceclang_1_1ast__matchers.html#aaa73ed83faa263bfb5cface81d30ef91">More...</a><br /></td></tr>
<tr class="separator:aaa73ed83faa263bfb5cface81d30ef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a234965f6e7ef273e30c9b19fd778"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefDecl.html">TypedefDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3c8a234965f6e7ef273e30c9b19fd778">typedefDecl</a></td></tr>
<tr class="memdesc:a3c8a234965f6e7ef273e30c9b19fd778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches typedef declarations.  <a href="namespaceclang_1_1ast__matchers.html#a3c8a234965f6e7ef273e30c9b19fd778">More...</a><br /></td></tr>
<tr class="separator:a3c8a234965f6e7ef273e30c9b19fd778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e36abe1065caf311d087b0a24ce3b00"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0e36abe1065caf311d087b0a24ce3b00">typedefNameDecl</a></td></tr>
<tr class="memdesc:a0e36abe1065caf311d087b0a24ce3b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches typedef name declarations.  <a href="namespaceclang_1_1ast__matchers.html#a0e36abe1065caf311d087b0a24ce3b00">More...</a><br /></td></tr>
<tr class="separator:a0e36abe1065caf311d087b0a24ce3b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f1d727044894974cd023ecdd58c879"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasDecl.html">TypeAliasDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a13f1d727044894974cd023ecdd58c879">typeAliasDecl</a></td></tr>
<tr class="memdesc:a13f1d727044894974cd023ecdd58c879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type alias declarations.  <a href="namespaceclang_1_1ast__matchers.html#a13f1d727044894974cd023ecdd58c879">More...</a><br /></td></tr>
<tr class="separator:a13f1d727044894974cd023ecdd58c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89576459aa43e2e320832d2221f6d405"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasTemplateDecl.html">TypeAliasTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a89576459aa43e2e320832d2221f6d405">typeAliasTemplateDecl</a></td></tr>
<tr class="memdesc:a89576459aa43e2e320832d2221f6d405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches type alias template declarations.  <a href="namespaceclang_1_1ast__matchers.html#a89576459aa43e2e320832d2221f6d405">More...</a><br /></td></tr>
<tr class="separator:a89576459aa43e2e320832d2221f6d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ccadfbea5e9e43c2153175afca6cac"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac5ccadfbea5e9e43c2153175afca6cac">decl</a></td></tr>
<tr class="memdesc:ac5ccadfbea5e9e43c2153175afca6cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarations.  <a href="namespaceclang_1_1ast__matchers.html#ac5ccadfbea5e9e43c2153175afca6cac">More...</a><br /></td></tr>
<tr class="separator:ac5ccadfbea5e9e43c2153175afca6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c34f70634543e4f54c46ee7df6614f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">decompositionDecl</a></td></tr>
<tr class="memdesc:ab8c34f70634543e4f54c46ee7df6614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches decomposition-declarations.  <a href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">More...</a><br /></td></tr>
<tr class="separator:ab8c34f70634543e4f54c46ee7df6614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661a4b3ebe2e4a9b67ab5be7d1c17e6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">bindingDecl</a></td></tr>
<tr class="memdesc:a3661a4b3ebe2e4a9b67ab5be7d1c17e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches binding declarations Example matches <code>foo</code> and <code>bar</code> (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6" title="Matches binding declarations Example matches foo and bar (matcher = bindingDecl()">bindingDecl()</a>  <a href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">More...</a><br /></td></tr>
<tr class="separator:a3661a4b3ebe2e4a9b67ab5be7d1c17e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf8474301563772fb4c854671e4f33f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LinkageSpecDecl.html">LinkageSpecDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7cf8474301563772fb4c854671e4f33f">linkageSpecDecl</a></td></tr>
<tr class="memdesc:a7cf8474301563772fb4c854671e4f33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a linkage specification.  <a href="namespaceclang_1_1ast__matchers.html#a7cf8474301563772fb4c854671e4f33f">More...</a><br /></td></tr>
<tr class="separator:a7cf8474301563772fb4c854671e4f33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f643ef24ff21b9fcedf8bca5c56a66"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a58f643ef24ff21b9fcedf8bca5c56a66">namedDecl</a></td></tr>
<tr class="memdesc:a58f643ef24ff21b9fcedf8bca5c56a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of anything that could have a name.  <a href="namespaceclang_1_1ast__matchers.html#a58f643ef24ff21b9fcedf8bca5c56a66">More...</a><br /></td></tr>
<tr class="separator:a58f643ef24ff21b9fcedf8bca5c56a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e34720bac0bffb62007c39c84ba58"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LabelDecl.html">LabelDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6f0e34720bac0bffb62007c39c84ba58">labelDecl</a></td></tr>
<tr class="memdesc:a6f0e34720bac0bffb62007c39c84ba58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of label.  <a href="namespaceclang_1_1ast__matchers.html#a6f0e34720bac0bffb62007c39c84ba58">More...</a><br /></td></tr>
<tr class="separator:a6f0e34720bac0bffb62007c39c84ba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad499907435f5547a1f44215dd65c00a2"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad499907435f5547a1f44215dd65c00a2">namespaceDecl</a></td></tr>
<tr class="memdesc:ad499907435f5547a1f44215dd65c00a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a namespace.  <a href="namespaceclang_1_1ast__matchers.html#ad499907435f5547a1f44215dd65c00a2">More...</a><br /></td></tr>
<tr class="separator:ad499907435f5547a1f44215dd65c00a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75d519da08b712a2dbc687eb84bfafd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceAliasDecl.html">NamespaceAliasDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab75d519da08b712a2dbc687eb84bfafd">namespaceAliasDecl</a></td></tr>
<tr class="memdesc:ab75d519da08b712a2dbc687eb84bfafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a declaration of a namespace alias.  <a href="namespaceclang_1_1ast__matchers.html#ab75d519da08b712a2dbc687eb84bfafd">More...</a><br /></td></tr>
<tr class="separator:ab75d519da08b712a2dbc687eb84bfafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97e34c0eac8c61ce7fe928633657c9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1RecordDecl.html">RecordDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ace97e34c0eac8c61ce7fe928633657c9">recordDecl</a></td></tr>
<tr class="memdesc:ace97e34c0eac8c61ce7fe928633657c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches class, struct, and union declarations.  <a href="namespaceclang_1_1ast__matchers.html#ace97e34c0eac8c61ce7fe928633657c9">More...</a><br /></td></tr>
<tr class="separator:ace97e34c0eac8c61ce7fe928633657c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a></td></tr>
<tr class="memdesc:ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class declarations.  <a href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">More...</a><br /></td></tr>
<tr class="separator:ac1ef73826e6b83dd0e8fc4a4b7284c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdb6ae259330bdf0876aba6e07c8710"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afcdb6ae259330bdf0876aba6e07c8710">classTemplateDecl</a></td></tr>
<tr class="memdesc:afcdb6ae259330bdf0876aba6e07c8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template declarations.  <a href="namespaceclang_1_1ast__matchers.html#afcdb6ae259330bdf0876aba6e07c8710">More...</a><br /></td></tr>
<tr class="separator:afcdb6ae259330bdf0876aba6e07c8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81538ee441769591ce912334397e6b7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab81538ee441769591ce912334397e6b7">classTemplateSpecializationDecl</a></td></tr>
<tr class="memdesc:ab81538ee441769591ce912334397e6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template specializations.  <a href="namespaceclang_1_1ast__matchers.html#ab81538ee441769591ce912334397e6b7">More...</a><br /></td></tr>
<tr class="separator:ab81538ee441769591ce912334397e6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a4778ab8392430ee9a0a28b7e9693"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplatePartialSpecializationDecl.html">ClassTemplatePartialSpecializationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a614a4778ab8392430ee9a0a28b7e9693">classTemplatePartialSpecializationDecl</a></td></tr>
<tr class="memdesc:a614a4778ab8392430ee9a0a28b7e9693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ class template partial specializations.  <a href="namespaceclang_1_1ast__matchers.html#a614a4778ab8392430ee9a0a28b7e9693">More...</a><br /></td></tr>
<tr class="separator:a614a4778ab8392430ee9a0a28b7e9693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cafc159defa3d1fdcbb28ec72ae418"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a91cafc159defa3d1fdcbb28ec72ae418">declaratorDecl</a></td></tr>
<tr class="memdesc:a91cafc159defa3d1fdcbb28ec72ae418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declarator declarations (field, variable, function and non-type template parameter declarations).  <a href="namespaceclang_1_1ast__matchers.html#a91cafc159defa3d1fdcbb28ec72ae418">More...</a><br /></td></tr>
<tr class="separator:a91cafc159defa3d1fdcbb28ec72ae418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3b7539a5a5ad3112f453ffb3ab9a67c5">parmVarDecl</a></td></tr>
<tr class="memdesc:a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches parameter variable declarations.  <a href="namespaceclang_1_1ast__matchers.html#a3b7539a5a5ad3112f453ffb3ab9a67c5">More...</a><br /></td></tr>
<tr class="separator:a3b7539a5a5ad3112f453ffb3ab9a67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1AccessSpecDecl.html">AccessSpecDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7acfa3a6a57ccd2484a71e0f1bbe9c09">accessSpecDecl</a></td></tr>
<tr class="memdesc:a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ access specifier declarations.  <a href="namespaceclang_1_1ast__matchers.html#a7acfa3a6a57ccd2484a71e0f1bbe9c09">More...</a><br /></td></tr>
<tr class="separator:a7acfa3a6a57ccd2484a71e0f1bbe9c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5309a87cb7c21babc136012e839f910a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5309a87cb7c21babc136012e839f910a">cxxBaseSpecifier</a></td></tr>
<tr class="memdesc:a5309a87cb7c21babc136012e839f910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches class bases.  <a href="namespaceclang_1_1ast__matchers.html#a5309a87cb7c21babc136012e839f910a">More...</a><br /></td></tr>
<tr class="separator:a5309a87cb7c21babc136012e839f910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0414dac04ff22f5ebd022efd442d4e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2d0414dac04ff22f5ebd022efd442d4e">cxxCtorInitializer</a></td></tr>
<tr class="memdesc:a2d0414dac04ff22f5ebd022efd442d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor initializers.  <a href="namespaceclang_1_1ast__matchers.html#a2d0414dac04ff22f5ebd022efd442d4e">More...</a><br /></td></tr>
<tr class="separator:a2d0414dac04ff22f5ebd022efd442d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c848824461ac59d9a1c7e7aeea9ec3"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a56c848824461ac59d9a1c7e7aeea9ec3">templateArgument</a></td></tr>
<tr class="memdesc:a56c848824461ac59d9a1c7e7aeea9ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template arguments.  <a href="namespaceclang_1_1ast__matchers.html#a56c848824461ac59d9a1c7e7aeea9ec3">More...</a><br /></td></tr>
<tr class="separator:a56c848824461ac59d9a1c7e7aeea9ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2354be35a4ff17fd80deade9753ea97"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac2354be35a4ff17fd80deade9753ea97">templateArgumentLoc</a></td></tr>
<tr class="memdesc:ac2354be35a4ff17fd80deade9753ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template arguments (with location info).  <a href="namespaceclang_1_1ast__matchers.html#ac2354be35a4ff17fd80deade9753ea97">More...</a><br /></td></tr>
<tr class="separator:ac2354be35a4ff17fd80deade9753ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2244dfcab0601fe79666d8a4a9dde4b9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2244dfcab0601fe79666d8a4a9dde4b9">templateName</a></td></tr>
<tr class="memdesc:a2244dfcab0601fe79666d8a4a9dde4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template name.  <a href="namespaceclang_1_1ast__matchers.html#a2244dfcab0601fe79666d8a4a9dde4b9">More...</a><br /></td></tr>
<tr class="separator:a2244dfcab0601fe79666d8a4a9dde4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NonTypeTemplateParmDecl.html">NonTypeTemplateParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4c54a7bb3aa3ae9d1fdca749e1da10c6">nonTypeTemplateParmDecl</a></td></tr>
<tr class="memdesc:a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches non-type template parameter declarations.  <a href="namespaceclang_1_1ast__matchers.html#a4c54a7bb3aa3ae9d1fdca749e1da10c6">More...</a><br /></td></tr>
<tr class="separator:a4c54a7bb3aa3ae9d1fdca749e1da10c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTypeParmDecl.html">TemplateTypeParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a95a6a300dc0c5bbfdcdc2af001c316f6">templateTypeParmDecl</a></td></tr>
<tr class="memdesc:a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template type parameter declarations.  <a href="namespaceclang_1_1ast__matchers.html#a95a6a300dc0c5bbfdcdc2af001c316f6">More...</a><br /></td></tr>
<tr class="separator:a95a6a300dc0c5bbfdcdc2af001c316f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab193711230649b28f6fd61cde737bed5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTemplateParmDecl.html">TemplateTemplateParmDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab193711230649b28f6fd61cde737bed5">templateTemplateParmDecl</a></td></tr>
<tr class="memdesc:ab193711230649b28f6fd61cde737bed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template template parameter declarations.  <a href="namespaceclang_1_1ast__matchers.html#ab193711230649b28f6fd61cde737bed5">More...</a><br /></td></tr>
<tr class="separator:ab193711230649b28f6fd61cde737bed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4d2e026596dc3bea52f83878ebc1a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAutoreleasePoolStmt.html">ObjCAutoreleasePoolStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4b4d2e026596dc3bea52f83878ebc1a7">autoreleasePoolStmt</a></td></tr>
<tr class="memdesc:a4b4d2e026596dc3bea52f83878ebc1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches an Objective-C autorelease pool statement.  <a href="namespaceclang_1_1ast__matchers.html#a4b4d2e026596dc3bea52f83878ebc1a7">More...</a><br /></td></tr>
<tr class="separator:a4b4d2e026596dc3bea52f83878ebc1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27f54246f26b3989e97274e01a4c30"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aaa27f54246f26b3989e97274e01a4c30">valueDecl</a></td></tr>
<tr class="memdesc:aaa27f54246f26b3989e97274e01a4c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any value declaration.  <a href="namespaceclang_1_1ast__matchers.html#aaa27f54246f26b3989e97274e01a4c30">More...</a><br /></td></tr>
<tr class="separator:aaa27f54246f26b3989e97274e01a4c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832104640e9b865d3d10cb779f59dbee"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a832104640e9b865d3d10cb779f59dbee">cxxConstructorDecl</a></td></tr>
<tr class="memdesc:a832104640e9b865d3d10cb779f59dbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ constructor declarations.  <a href="namespaceclang_1_1ast__matchers.html#a832104640e9b865d3d10cb779f59dbee">More...</a><br /></td></tr>
<tr class="separator:a832104640e9b865d3d10cb779f59dbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDestructorDecl.html">CXXDestructorDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac797cd3d7e0d85d5bd07773f1c9e2f7e">cxxDestructorDecl</a></td></tr>
<tr class="memdesc:ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches explicit C++ destructor declarations.  <a href="namespaceclang_1_1ast__matchers.html#ac797cd3d7e0d85d5bd07773f1c9e2f7e">More...</a><br /></td></tr>
<tr class="separator:ac797cd3d7e0d85d5bd07773f1c9e2f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e48dc9e0067b916df8f57d3d3bb72a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a31e48dc9e0067b916df8f57d3d3bb72a">enumDecl</a></td></tr>
<tr class="memdesc:a31e48dc9e0067b916df8f57d3d3bb72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches enum declarations.  <a href="namespaceclang_1_1ast__matchers.html#a31e48dc9e0067b916df8f57d3d3bb72a">More...</a><br /></td></tr>
<tr class="separator:a31e48dc9e0067b916df8f57d3d3bb72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcb1ffb5fb859e719d305b311baaeba"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumConstantDecl.html">EnumConstantDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8dcb1ffb5fb859e719d305b311baaeba">enumConstantDecl</a></td></tr>
<tr class="memdesc:a8dcb1ffb5fb859e719d305b311baaeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches enum constants.  <a href="namespaceclang_1_1ast__matchers.html#a8dcb1ffb5fb859e719d305b311baaeba">More...</a><br /></td></tr>
<tr class="separator:a8dcb1ffb5fb859e719d305b311baaeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036eda5d1a6e83d02a2479799aa1e0ad"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TagDecl.html">TagDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a036eda5d1a6e83d02a2479799aa1e0ad">tagDecl</a></td></tr>
<tr class="memdesc:a036eda5d1a6e83d02a2479799aa1e0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches tag declarations.  <a href="namespaceclang_1_1ast__matchers.html#a036eda5d1a6e83d02a2479799aa1e0ad">More...</a><br /></td></tr>
<tr class="separator:a036eda5d1a6e83d02a2479799aa1e0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe825b22b86295d319b09c996fe78fd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd">cxxMethodDecl</a></td></tr>
<tr class="memdesc:aebe825b22b86295d319b09c996fe78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches method declarations.  <a href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd">More...</a><br /></td></tr>
<tr class="separator:aebe825b22b86295d319b09c996fe78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d2f76b0d40efafcb16d997b1928f5b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a67d2f76b0d40efafcb16d997b1928f5b">cxxConversionDecl</a></td></tr>
<tr class="memdesc:a67d2f76b0d40efafcb16d997b1928f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches conversion operator declarations.  <a href="namespaceclang_1_1ast__matchers.html#a67d2f76b0d40efafcb16d997b1928f5b">More...</a><br /></td></tr>
<tr class="separator:a67d2f76b0d40efafcb16d997b1928f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a400a7d8c9a439cb1c43dfa8ed4f6d5d7">cxxDeductionGuideDecl</a></td></tr>
<tr class="memdesc:a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches user-defined and implicitly generated deduction guide.  <a href="namespaceclang_1_1ast__matchers.html#a400a7d8c9a439cb1c43dfa8ed4f6d5d7">More...</a><br /></td></tr>
<tr class="separator:a400a7d8c9a439cb1c43dfa8ed4f6d5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e81429237736b6458df18bb538c82"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a></td></tr>
<tr class="memdesc:a056e81429237736b6458df18bb538c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches variable declarations.  <a href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">More...</a><br /></td></tr>
<tr class="separator:a056e81429237736b6458df18bb538c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26f3ff62d6be975196efa86f3b15d82"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a></td></tr>
<tr class="memdesc:ab26f3ff62d6be975196efa86f3b15d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches field declarations.  <a href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">More...</a><br /></td></tr>
<tr class="separator:ab26f3ff62d6be975196efa86f3b15d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1IndirectFieldDecl.html">IndirectFieldDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aeb255b80ce8ca025df9e3d52ddbcfe9e">indirectFieldDecl</a></td></tr>
<tr class="memdesc:aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches indirect field declarations.  <a href="namespaceclang_1_1ast__matchers.html#aeb255b80ce8ca025df9e3d52ddbcfe9e">More...</a><br /></td></tr>
<tr class="separator:aeb255b80ce8ca025df9e3d52ddbcfe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95624c30888b0c7688e3a6171ed49cc"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab95624c30888b0c7688e3a6171ed49cc">functionDecl</a></td></tr>
<tr class="memdesc:ab95624c30888b0c7688e3a6171ed49cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches function declarations.  <a href="namespaceclang_1_1ast__matchers.html#ab95624c30888b0c7688e3a6171ed49cc">More...</a><br /></td></tr>
<tr class="separator:ab95624c30888b0c7688e3a6171ed49cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973fc1ea542ea4bb3543d905e2ee1e11"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionTemplateDecl.html">FunctionTemplateDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a973fc1ea542ea4bb3543d905e2ee1e11">functionTemplateDecl</a></td></tr>
<tr class="memdesc:a973fc1ea542ea4bb3543d905e2ee1e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ function template declarations.  <a href="namespaceclang_1_1ast__matchers.html#a973fc1ea542ea4bb3543d905e2ee1e11">More...</a><br /></td></tr>
<tr class="separator:a973fc1ea542ea4bb3543d905e2ee1e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded924f4ec88be994f9c255803e6075c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aded924f4ec88be994f9c255803e6075c">friendDecl</a></td></tr>
<tr class="memdesc:aded924f4ec88be994f9c255803e6075c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches friend declarations.  <a href="namespaceclang_1_1ast__matchers.html#aded924f4ec88be994f9c255803e6075c">More...</a><br /></td></tr>
<tr class="separator:aded924f4ec88be994f9c255803e6075c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2304887c9dd0e9fad2e0ff35320739"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ade2304887c9dd0e9fad2e0ff35320739">stmt</a></td></tr>
<tr class="memdesc:ade2304887c9dd0e9fad2e0ff35320739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statements.  <a href="namespaceclang_1_1ast__matchers.html#ade2304887c9dd0e9fad2e0ff35320739">More...</a><br /></td></tr>
<tr class="separator:ade2304887c9dd0e9fad2e0ff35320739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d4ad0df1926038d75178efe06dcd8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adc3d4ad0df1926038d75178efe06dcd8">declStmt</a></td></tr>
<tr class="memdesc:adc3d4ad0df1926038d75178efe06dcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches declaration statements.  <a href="namespaceclang_1_1ast__matchers.html#adc3d4ad0df1926038d75178efe06dcd8">More...</a><br /></td></tr>
<tr class="separator:adc3d4ad0df1926038d75178efe06dcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11400493de87945dbc3c568ac8e4b08"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac11400493de87945dbc3c568ac8e4b08">memberExpr</a></td></tr>
<tr class="memdesc:ac11400493de87945dbc3c568ac8e4b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member expressions.  <a href="namespaceclang_1_1ast__matchers.html#ac11400493de87945dbc3c568ac8e4b08">More...</a><br /></td></tr>
<tr class="separator:ac11400493de87945dbc3c568ac8e4b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2cfd327a640154b61dc04b4dbe173"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab9f2cfd327a640154b61dc04b4dbe173">unresolvedMemberExpr</a></td></tr>
<tr class="memdesc:ab9f2cfd327a640154b61dc04b4dbe173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved member expressions.  <a href="namespaceclang_1_1ast__matchers.html#ab9f2cfd327a640154b61dc04b4dbe173">More...</a><br /></td></tr>
<tr class="separator:ab9f2cfd327a640154b61dc04b4dbe173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3285794ef7314a9b8ca5c18ed2744c13"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3285794ef7314a9b8ca5c18ed2744c13">cxxDependentScopeMemberExpr</a></td></tr>
<tr class="memdesc:a3285794ef7314a9b8ca5c18ed2744c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member expressions where the actual member referenced could not be resolved because the base expression or the member name was dependent.  <a href="namespaceclang_1_1ast__matchers.html#a3285794ef7314a9b8ca5c18ed2744c13">More...</a><br /></td></tr>
<tr class="separator:a3285794ef7314a9b8ca5c18ed2744c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460801cda670b9a3ccc3d42f51f3bd5c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a460801cda670b9a3ccc3d42f51f3bd5c">callExpr</a></td></tr>
<tr class="memdesc:a460801cda670b9a3ccc3d42f51f3bd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches call expressions.  <a href="namespaceclang_1_1ast__matchers.html#a460801cda670b9a3ccc3d42f51f3bd5c">More...</a><br /></td></tr>
<tr class="separator:a460801cda670b9a3ccc3d42f51f3bd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479809a0ad129df8390412a37ba54462"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a479809a0ad129df8390412a37ba54462">lambdaExpr</a></td></tr>
<tr class="memdesc:a479809a0ad129df8390412a37ba54462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches lambda expressions.  <a href="namespaceclang_1_1ast__matchers.html#a479809a0ad129df8390412a37ba54462">More...</a><br /></td></tr>
<tr class="separator:a479809a0ad129df8390412a37ba54462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e164251478f3b38b3685d4d330cff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a831e164251478f3b38b3685d4d330cff">cxxMemberCallExpr</a></td></tr>
<tr class="memdesc:a831e164251478f3b38b3685d4d330cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member call expressions.  <a href="namespaceclang_1_1ast__matchers.html#a831e164251478f3b38b3685d4d330cff">More...</a><br /></td></tr>
<tr class="separator:a831e164251478f3b38b3685d4d330cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e430a6b71305865cc46c57a9465c84"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a76e430a6b71305865cc46c57a9465c84">objcMessageExpr</a></td></tr>
<tr class="memdesc:a76e430a6b71305865cc46c57a9465c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches ObjectiveC Message invocation expressions.  <a href="namespaceclang_1_1ast__matchers.html#a76e430a6b71305865cc46c57a9465c84">More...</a><br /></td></tr>
<tr class="separator:a76e430a6b71305865cc46c57a9465c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10a69694c50b6e017fbe02072e7115e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab10a69694c50b6e017fbe02072e7115e">objcInterfaceDecl</a></td></tr>
<tr class="memdesc:ab10a69694c50b6e017fbe02072e7115e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C interface declarations.  <a href="namespaceclang_1_1ast__matchers.html#ab10a69694c50b6e017fbe02072e7115e">More...</a><br /></td></tr>
<tr class="separator:ab10a69694c50b6e017fbe02072e7115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd07286ab423090b73a60717e8ccf5a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCImplementationDecl.html">ObjCImplementationDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#acd07286ab423090b73a60717e8ccf5a7">objcImplementationDecl</a></td></tr>
<tr class="memdesc:acd07286ab423090b73a60717e8ccf5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C implementation declarations.  <a href="namespaceclang_1_1ast__matchers.html#acd07286ab423090b73a60717e8ccf5a7">More...</a><br /></td></tr>
<tr class="separator:acd07286ab423090b73a60717e8ccf5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b140b9aeec980b173418f5b4490c8e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCProtocolDecl.html">ObjCProtocolDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a27b140b9aeec980b173418f5b4490c8e">objcProtocolDecl</a></td></tr>
<tr class="memdesc:a27b140b9aeec980b173418f5b4490c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C protocol declarations.  <a href="namespaceclang_1_1ast__matchers.html#a27b140b9aeec980b173418f5b4490c8e">More...</a><br /></td></tr>
<tr class="separator:a27b140b9aeec980b173418f5b4490c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d992911b288aaba2ba96ecc5e1e33c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryDecl.html">ObjCCategoryDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a64d992911b288aaba2ba96ecc5e1e33c">objcCategoryDecl</a></td></tr>
<tr class="memdesc:a64d992911b288aaba2ba96ecc5e1e33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C category declarations.  <a href="namespaceclang_1_1ast__matchers.html#a64d992911b288aaba2ba96ecc5e1e33c">More...</a><br /></td></tr>
<tr class="separator:a64d992911b288aaba2ba96ecc5e1e33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryImplDecl.html">ObjCCategoryImplDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9a8d9b5d54b3ed41d0b2d03e776af90e">objcCategoryImplDecl</a></td></tr>
<tr class="memdesc:a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C category definitions.  <a href="namespaceclang_1_1ast__matchers.html#a9a8d9b5d54b3ed41d0b2d03e776af90e">More...</a><br /></td></tr>
<tr class="separator:a9a8d9b5d54b3ed41d0b2d03e776af90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3a90eb6eeec44cfb79ef98129ad90ec1">objcMethodDecl</a></td></tr>
<tr class="memdesc:a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C method declarations.  <a href="namespaceclang_1_1ast__matchers.html#a3a90eb6eeec44cfb79ef98129ad90ec1">More...</a><br /></td></tr>
<tr class="separator:a3a90eb6eeec44cfb79ef98129ad90ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba4cdc11e5f93571b6b2107d4a9030e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aeba4cdc11e5f93571b6b2107d4a9030e">blockDecl</a></td></tr>
<tr class="memdesc:aeba4cdc11e5f93571b6b2107d4a9030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches block declarations.  <a href="namespaceclang_1_1ast__matchers.html#aeba4cdc11e5f93571b6b2107d4a9030e">More...</a><br /></td></tr>
<tr class="separator:aeba4cdc11e5f93571b6b2107d4a9030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b9991e6e90b4ca132af940b11b4339"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCIvarDecl.html">ObjCIvarDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b9991e6e90b4ca132af940b11b4339">objcIvarDecl</a></td></tr>
<tr class="memdesc:a10b9991e6e90b4ca132af940b11b4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C instance variable declarations.  <a href="namespaceclang_1_1ast__matchers.html#a10b9991e6e90b4ca132af940b11b4339">More...</a><br /></td></tr>
<tr class="separator:a10b9991e6e90b4ca132af940b11b4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfb6ad7b935550af24feaa79d757eca"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2bfb6ad7b935550af24feaa79d757eca">objcPropertyDecl</a></td></tr>
<tr class="memdesc:a2bfb6ad7b935550af24feaa79d757eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C property declarations.  <a href="namespaceclang_1_1ast__matchers.html#a2bfb6ad7b935550af24feaa79d757eca">More...</a><br /></td></tr>
<tr class="separator:a2bfb6ad7b935550af24feaa79d757eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb294df9fab76f0f4677ccc500d94f26"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtThrowStmt.html">ObjCAtThrowStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abb294df9fab76f0f4677ccc500d94f26">objcThrowStmt</a></td></tr>
<tr class="memdesc:abb294df9fab76f0f4677ccc500d94f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @throw statements.  <a href="namespaceclang_1_1ast__matchers.html#abb294df9fab76f0f4677ccc500d94f26">More...</a><br /></td></tr>
<tr class="separator:abb294df9fab76f0f4677ccc500d94f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c79304345729b9a3b5f1abf9dc5a8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtTryStmt.html">ObjCAtTryStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa54c79304345729b9a3b5f1abf9dc5a8">objcTryStmt</a></td></tr>
<tr class="memdesc:aa54c79304345729b9a3b5f1abf9dc5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @try statements.  <a href="namespaceclang_1_1ast__matchers.html#aa54c79304345729b9a3b5f1abf9dc5a8">More...</a><br /></td></tr>
<tr class="separator:aa54c79304345729b9a3b5f1abf9dc5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d07f25f82fdf52ca6b480e0aca4d5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtCatchStmt.html">ObjCAtCatchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a928d07f25f82fdf52ca6b480e0aca4d5">objcCatchStmt</a></td></tr>
<tr class="memdesc:a928d07f25f82fdf52ca6b480e0aca4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @catch statements.  <a href="namespaceclang_1_1ast__matchers.html#a928d07f25f82fdf52ca6b480e0aca4d5">More...</a><br /></td></tr>
<tr class="separator:a928d07f25f82fdf52ca6b480e0aca4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d463a0af3ae121edc9b41d14c0706a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtFinallyStmt.html">ObjCAtFinallyStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2d463a0af3ae121edc9b41d14c0706a7">objcFinallyStmt</a></td></tr>
<tr class="memdesc:a2d463a0af3ae121edc9b41d14c0706a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches Objective-C @finally statements.  <a href="namespaceclang_1_1ast__matchers.html#a2d463a0af3ae121edc9b41d14c0706a7">More...</a><br /></td></tr>
<tr class="separator:a2d463a0af3ae121edc9b41d14c0706a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d31bd81eb28a0b2db583b181cfc01"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExprWithCleanups.html">ExprWithCleanups</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a071d31bd81eb28a0b2db583b181cfc01">exprWithCleanups</a></td></tr>
<tr class="memdesc:a071d31bd81eb28a0b2db583b181cfc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that introduce cleanups to be run at the end of the sub-expression's evaluation.  <a href="namespaceclang_1_1ast__matchers.html#a071d31bd81eb28a0b2db583b181cfc01">More...</a><br /></td></tr>
<tr class="separator:a071d31bd81eb28a0b2db583b181cfc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514475a0724042d82b5323d5a7710f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8514475a0724042d82b5323d5a7710f6">initListExpr</a></td></tr>
<tr class="memdesc:a8514475a0724042d82b5323d5a7710f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches init list expressions.  <a href="namespaceclang_1_1ast__matchers.html#a8514475a0724042d82b5323d5a7710f6">More...</a><br /></td></tr>
<tr class="separator:a8514475a0724042d82b5323d5a7710f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf0cd73005c114b30400dc613baa59"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStdInitializerListExpr.html">CXXStdInitializerListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae4cf0cd73005c114b30400dc613baa59">cxxStdInitializerListExpr</a></td></tr>
<tr class="memdesc:ae4cf0cd73005c114b30400dc613baa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ initializer list expressions.  <a href="namespaceclang_1_1ast__matchers.html#ae4cf0cd73005c114b30400dc613baa59">More...</a><br /></td></tr>
<tr class="separator:ae4cf0cd73005c114b30400dc613baa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3014baa2a35a9fa076ae72bcedd48ad"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitValueInitExpr.html">ImplicitValueInitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad3014baa2a35a9fa076ae72bcedd48ad">implicitValueInitExpr</a></td></tr>
<tr class="memdesc:ad3014baa2a35a9fa076ae72bcedd48ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches implicit initializers of init list expressions.  <a href="namespaceclang_1_1ast__matchers.html#ad3014baa2a35a9fa076ae72bcedd48ad">More...</a><br /></td></tr>
<tr class="separator:ad3014baa2a35a9fa076ae72bcedd48ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6137ba1734e9c2499cefdac0ad7474de"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6137ba1734e9c2499cefdac0ad7474de">parenListExpr</a></td></tr>
<tr class="memdesc:a6137ba1734e9c2499cefdac0ad7474de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches paren list expressions.  <a href="namespaceclang_1_1ast__matchers.html#a6137ba1734e9c2499cefdac0ad7474de">More...</a><br /></td></tr>
<tr class="separator:a6137ba1734e9c2499cefdac0ad7474de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06b6e50f8eb6094020ec5bf89a746a4"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SubstNonTypeTemplateParmExpr.html">SubstNonTypeTemplateParmExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af06b6e50f8eb6094020ec5bf89a746a4">substNonTypeTemplateParmExpr</a></td></tr>
<tr class="memdesc:af06b6e50f8eb6094020ec5bf89a746a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches substitutions of non-type template parameters.  <a href="namespaceclang_1_1ast__matchers.html#af06b6e50f8eb6094020ec5bf89a746a4">More...</a><br /></td></tr>
<tr class="separator:af06b6e50f8eb6094020ec5bf89a746a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9d64e967b6707c36254647d2bc4155"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDecl.html">UsingDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2a9d64e967b6707c36254647d2bc4155">usingDecl</a></td></tr>
<tr class="memdesc:a2a9d64e967b6707c36254647d2bc4155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches using declarations.  <a href="namespaceclang_1_1ast__matchers.html#a2a9d64e967b6707c36254647d2bc4155">More...</a><br /></td></tr>
<tr class="separator:a2a9d64e967b6707c36254647d2bc4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1470af2f7c9754818e2946266066461e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingEnumDecl.html">UsingEnumDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1470af2f7c9754818e2946266066461e">usingEnumDecl</a></td></tr>
<tr class="memdesc:a1470af2f7c9754818e2946266066461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches using-enum declarations.  <a href="namespaceclang_1_1ast__matchers.html#a1470af2f7c9754818e2946266066461e">More...</a><br /></td></tr>
<tr class="separator:a1470af2f7c9754818e2946266066461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b5096b155587486eb932cc3a86c481"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDirectiveDecl.html">UsingDirectiveDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af0b5096b155587486eb932cc3a86c481">usingDirectiveDecl</a></td></tr>
<tr class="memdesc:af0b5096b155587486eb932cc3a86c481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches using namespace declarations.  <a href="namespaceclang_1_1ast__matchers.html#af0b5096b155587486eb932cc3a86c481">More...</a><br /></td></tr>
<tr class="separator:af0b5096b155587486eb932cc3a86c481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3721288207aea6b68f442b2d752e78d0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedLookupExpr.html">UnresolvedLookupExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3721288207aea6b68f442b2d752e78d0">unresolvedLookupExpr</a></td></tr>
<tr class="memdesc:a3721288207aea6b68f442b2d752e78d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches reference to a name that can be looked up during parsing but could not be resolved to a specific declaration.  <a href="namespaceclang_1_1ast__matchers.html#a3721288207aea6b68f442b2d752e78d0">More...</a><br /></td></tr>
<tr class="separator:a3721288207aea6b68f442b2d752e78d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fcb7fd463685d9e37e8f31637ed45f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingValueDecl.html">UnresolvedUsingValueDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af2fcb7fd463685d9e37e8f31637ed45f">unresolvedUsingValueDecl</a></td></tr>
<tr class="memdesc:af2fcb7fd463685d9e37e8f31637ed45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved using value declarations.  <a href="namespaceclang_1_1ast__matchers.html#af2fcb7fd463685d9e37e8f31637ed45f">More...</a><br /></td></tr>
<tr class="separator:af2fcb7fd463685d9e37e8f31637ed45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebfdb4a7578a482a07cefc8e5907c85"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingTypenameDecl.html">UnresolvedUsingTypenameDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5ebfdb4a7578a482a07cefc8e5907c85">unresolvedUsingTypenameDecl</a></td></tr>
<tr class="memdesc:a5ebfdb4a7578a482a07cefc8e5907c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved using value declarations that involve the typename.  <a href="namespaceclang_1_1ast__matchers.html#a5ebfdb4a7578a482a07cefc8e5907c85">More...</a><br /></td></tr>
<tr class="separator:a5ebfdb4a7578a482a07cefc8e5907c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1636090af19685070c1f5183bce08909"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConstantExpr.html">ConstantExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1636090af19685070c1f5183bce08909">constantExpr</a></td></tr>
<tr class="memdesc:a1636090af19685070c1f5183bce08909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant expression wrapper.  <a href="namespaceclang_1_1ast__matchers.html#a1636090af19685070c1f5183bce08909">More...</a><br /></td></tr>
<tr class="separator:a1636090af19685070c1f5183bce08909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ef12437e36922d96bea2cb8f762b9a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenExpr.html">ParenExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a97ef12437e36922d96bea2cb8f762b9a">parenExpr</a></td></tr>
<tr class="memdesc:a97ef12437e36922d96bea2cb8f762b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches parentheses used in expressions.  <a href="namespaceclang_1_1ast__matchers.html#a97ef12437e36922d96bea2cb8f762b9a">More...</a><br /></td></tr>
<tr class="separator:a97ef12437e36922d96bea2cb8f762b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da198b76c77bfd4737a339d5a78e33"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a></td></tr>
<tr class="memdesc:ab0da198b76c77bfd4737a339d5a78e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches constructor call expressions (including implicit ones).  <a href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33">More...</a><br /></td></tr>
<tr class="separator:ab0da198b76c77bfd4737a339d5a78e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe2da9177520906d97d82833577922"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#accfe2da9177520906d97d82833577922">cxxUnresolvedConstructExpr</a></td></tr>
<tr class="memdesc:accfe2da9177520906d97d82833577922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unresolved constructor call expressions.  <a href="namespaceclang_1_1ast__matchers.html#accfe2da9177520906d97d82833577922">More...</a><br /></td></tr>
<tr class="separator:accfe2da9177520906d97d82833577922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af636f476cad8054e282b42e8ea613987"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af636f476cad8054e282b42e8ea613987">cxxThisExpr</a></td></tr>
<tr class="memdesc:af636f476cad8054e282b42e8ea613987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches implicit and explicit this expressions.  <a href="namespaceclang_1_1ast__matchers.html#af636f476cad8054e282b42e8ea613987">More...</a><br /></td></tr>
<tr class="separator:af636f476cad8054e282b42e8ea613987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBindTemporaryExpr.html">CXXBindTemporaryExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab78d0ccf6cfdd2460d9c4d5f7847605d">cxxBindTemporaryExpr</a></td></tr>
<tr class="memdesc:ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes where temporaries are created.  <a href="namespaceclang_1_1ast__matchers.html#ab78d0ccf6cfdd2460d9c4d5f7847605d">More...</a><br /></td></tr>
<tr class="separator:ab78d0ccf6cfdd2460d9c4d5f7847605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa051954c84b4df94040c842186dc7af7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MaterializeTemporaryExpr.html">MaterializeTemporaryExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa051954c84b4df94040c842186dc7af7">materializeTemporaryExpr</a></td></tr>
<tr class="memdesc:aa051954c84b4df94040c842186dc7af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes where temporaries are materialized.  <a href="namespaceclang_1_1ast__matchers.html#aa051954c84b4df94040c842186dc7af7">More...</a><br /></td></tr>
<tr class="separator:aa051954c84b4df94040c842186dc7af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90fa40e809e57f174ef162b26bb7d9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8c90fa40e809e57f174ef162b26bb7d9">cxxNewExpr</a></td></tr>
<tr class="memdesc:a8c90fa40e809e57f174ef162b26bb7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches new expressions.  <a href="namespaceclang_1_1ast__matchers.html#a8c90fa40e809e57f174ef162b26bb7d9">More...</a><br /></td></tr>
<tr class="separator:a8c90fa40e809e57f174ef162b26bb7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c9455ba631c516e4e7818a0f7f8eff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDeleteExpr.html">CXXDeleteExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a21c9455ba631c516e4e7818a0f7f8eff">cxxDeleteExpr</a></td></tr>
<tr class="memdesc:a21c9455ba631c516e4e7818a0f7f8eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches delete expressions.  <a href="namespaceclang_1_1ast__matchers.html#a21c9455ba631c516e4e7818a0f7f8eff">More...</a><br /></td></tr>
<tr class="separator:a21c9455ba631c516e4e7818a0f7f8eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896f97c027b999f18752148a0921a19c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNoexceptExpr.html">CXXNoexceptExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a896f97c027b999f18752148a0921a19c">cxxNoexceptExpr</a></td></tr>
<tr class="memdesc:a896f97c027b999f18752148a0921a19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches noexcept expressions.  <a href="namespaceclang_1_1ast__matchers.html#a896f97c027b999f18752148a0921a19c">More...</a><br /></td></tr>
<tr class="separator:a896f97c027b999f18752148a0921a19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770b1eeabaf13b5ab1547634f8fef742"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a770b1eeabaf13b5ab1547634f8fef742">arraySubscriptExpr</a></td></tr>
<tr class="memdesc:a770b1eeabaf13b5ab1547634f8fef742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches array subscript expressions.  <a href="namespaceclang_1_1ast__matchers.html#a770b1eeabaf13b5ab1547634f8fef742">More...</a><br /></td></tr>
<tr class="separator:a770b1eeabaf13b5ab1547634f8fef742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5505ee16ebcb2b7ee272e91d709849ee"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDefaultArgExpr.html">CXXDefaultArgExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5505ee16ebcb2b7ee272e91d709849ee">cxxDefaultArgExpr</a></td></tr>
<tr class="memdesc:a5505ee16ebcb2b7ee272e91d709849ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the value of a default argument at the call site.  <a href="namespaceclang_1_1ast__matchers.html#a5505ee16ebcb2b7ee272e91d709849ee">More...</a><br /></td></tr>
<tr class="separator:a5505ee16ebcb2b7ee272e91d709849ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422b5e5502151463a9d2d6ad04350e4"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab422b5e5502151463a9d2d6ad04350e4">cxxOperatorCallExpr</a></td></tr>
<tr class="memdesc:ab422b5e5502151463a9d2d6ad04350e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator calls.  <a href="namespaceclang_1_1ast__matchers.html#ab422b5e5502151463a9d2d6ad04350e4">More...</a><br /></td></tr>
<tr class="separator:ab422b5e5502151463a9d2d6ad04350e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e9197127c18de63db7a43256f1aff"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3b9e9197127c18de63db7a43256f1aff">cxxRewrittenBinaryOperator</a></td></tr>
<tr class="memdesc:a3b9e9197127c18de63db7a43256f1aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches rewritten binary operators.  <a href="namespaceclang_1_1ast__matchers.html#a3b9e9197127c18de63db7a43256f1aff">More...</a><br /></td></tr>
<tr class="separator:a3b9e9197127c18de63db7a43256f1aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc0ccd398780d345e2c541cc716cc66"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adfc0ccd398780d345e2c541cc716cc66">expr</a></td></tr>
<tr class="memdesc:adfc0ccd398780d345e2c541cc716cc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions.  <a href="namespaceclang_1_1ast__matchers.html#adfc0ccd398780d345e2c541cc716cc66">More...</a><br /></td></tr>
<tr class="separator:adfc0ccd398780d345e2c541cc716cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0781cbe6d50bd620cb6f8f0627378be6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a></td></tr>
<tr class="memdesc:a0781cbe6d50bd620cb6f8f0627378be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches expressions that refer to declarations.  <a href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">More...</a><br /></td></tr>
<tr class="separator:a0781cbe6d50bd620cb6f8f0627378be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1691aa67fc4125c0978aa73995001aa8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCIvarRefExpr.html">ObjCIvarRefExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1691aa67fc4125c0978aa73995001aa8">objcIvarRefExpr</a></td></tr>
<tr class="memdesc:a1691aa67fc4125c0978aa73995001aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reference to an ObjCIvar.  <a href="namespaceclang_1_1ast__matchers.html#a1691aa67fc4125c0978aa73995001aa8">More...</a><br /></td></tr>
<tr class="separator:a1691aa67fc4125c0978aa73995001aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9731ff0864f46a3fb06e34554ae54cb8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BlockExpr.html">BlockExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9731ff0864f46a3fb06e34554ae54cb8">blockExpr</a></td></tr>
<tr class="memdesc:a9731ff0864f46a3fb06e34554ae54cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reference to a block.  <a href="namespaceclang_1_1ast__matchers.html#a9731ff0864f46a3fb06e34554ae54cb8">More...</a><br /></td></tr>
<tr class="separator:a9731ff0864f46a3fb06e34554ae54cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cd72a6718872ac996d48de9a80bf81"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a></td></tr>
<tr class="memdesc:af5cd72a6718872ac996d48de9a80bf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if statements.  <a href="namespaceclang_1_1ast__matchers.html#af5cd72a6718872ac996d48de9a80bf81">More...</a><br /></td></tr>
<tr class="separator:af5cd72a6718872ac996d48de9a80bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f109ac0734990e8ae974d36e76c7e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a></td></tr>
<tr class="memdesc:a8e6f109ac0734990e8ae974d36e76c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches for statements.  <a href="namespaceclang_1_1ast__matchers.html#a8e6f109ac0734990e8ae974d36e76c7e">More...</a><br /></td></tr>
<tr class="separator:a8e6f109ac0734990e8ae974d36e76c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8270a8d8f21ce50af2f56e4bcdd31eba">cxxForRangeStmt</a></td></tr>
<tr class="memdesc:a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches range-based for statements.  <a href="namespaceclang_1_1ast__matchers.html#a8270a8d8f21ce50af2f56e4bcdd31eba">More...</a><br /></td></tr>
<tr class="separator:a8270a8d8f21ce50af2f56e4bcdd31eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fb772f53dc8076440090557a4bb388"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a63fb772f53dc8076440090557a4bb388">whileStmt</a></td></tr>
<tr class="memdesc:a63fb772f53dc8076440090557a4bb388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches while statements.  <a href="namespaceclang_1_1ast__matchers.html#a63fb772f53dc8076440090557a4bb388">More...</a><br /></td></tr>
<tr class="separator:a63fb772f53dc8076440090557a4bb388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35f9309e910ba3399781cc30baa2439"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad35f9309e910ba3399781cc30baa2439">doStmt</a></td></tr>
<tr class="memdesc:ad35f9309e910ba3399781cc30baa2439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches do statements.  <a href="namespaceclang_1_1ast__matchers.html#ad35f9309e910ba3399781cc30baa2439">More...</a><br /></td></tr>
<tr class="separator:ad35f9309e910ba3399781cc30baa2439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3570a0e97bc3258e6b063729994e791f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BreakStmt.html">BreakStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3570a0e97bc3258e6b063729994e791f">breakStmt</a></td></tr>
<tr class="memdesc:a3570a0e97bc3258e6b063729994e791f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches break statements.  <a href="namespaceclang_1_1ast__matchers.html#a3570a0e97bc3258e6b063729994e791f">More...</a><br /></td></tr>
<tr class="separator:a3570a0e97bc3258e6b063729994e791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af901ad829d7e589a44f983a327351ebf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ContinueStmt.html">ContinueStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af901ad829d7e589a44f983a327351ebf">continueStmt</a></td></tr>
<tr class="memdesc:af901ad829d7e589a44f983a327351ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches continue statements.  <a href="namespaceclang_1_1ast__matchers.html#af901ad829d7e589a44f983a327351ebf">More...</a><br /></td></tr>
<tr class="separator:af901ad829d7e589a44f983a327351ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44762e1acc1d5a4f9921704755f87a9c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoreturnStmt.html">CoreturnStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a44762e1acc1d5a4f9921704755f87a9c">coreturnStmt</a></td></tr>
<tr class="memdesc:a44762e1acc1d5a4f9921704755f87a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches co_return statements.  <a href="namespaceclang_1_1ast__matchers.html#a44762e1acc1d5a4f9921704755f87a9c">More...</a><br /></td></tr>
<tr class="separator:a44762e1acc1d5a4f9921704755f87a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a42e8f0ff0127b0536c53a76dbf5f28a7">returnStmt</a></td></tr>
<tr class="memdesc:a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches return statements.  <a href="namespaceclang_1_1ast__matchers.html#a42e8f0ff0127b0536c53a76dbf5f28a7">More...</a><br /></td></tr>
<tr class="separator:a42e8f0ff0127b0536c53a76dbf5f28a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f07c79fb3acf3af34be21d41010648a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GotoStmt.html">GotoStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8f07c79fb3acf3af34be21d41010648a">gotoStmt</a></td></tr>
<tr class="memdesc:a8f07c79fb3acf3af34be21d41010648a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches goto statements.  <a href="namespaceclang_1_1ast__matchers.html#a8f07c79fb3acf3af34be21d41010648a">More...</a><br /></td></tr>
<tr class="separator:a8f07c79fb3acf3af34be21d41010648a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add73462f8d3fac6fc366163c4665447b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LabelStmt.html">LabelStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#add73462f8d3fac6fc366163c4665447b">labelStmt</a></td></tr>
<tr class="memdesc:add73462f8d3fac6fc366163c4665447b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches label statements.  <a href="namespaceclang_1_1ast__matchers.html#add73462f8d3fac6fc366163c4665447b">More...</a><br /></td></tr>
<tr class="separator:add73462f8d3fac6fc366163c4665447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32844cb1d9bb3605e13b8bed8092cc14"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a32844cb1d9bb3605e13b8bed8092cc14">addrLabelExpr</a></td></tr>
<tr class="memdesc:a32844cb1d9bb3605e13b8bed8092cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches address of label statements (GNU extension).  <a href="namespaceclang_1_1ast__matchers.html#a32844cb1d9bb3605e13b8bed8092cc14">More...</a><br /></td></tr>
<tr class="separator:a32844cb1d9bb3605e13b8bed8092cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf04346715336de0dfc10dac8ed114d9"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abf04346715336de0dfc10dac8ed114d9">switchStmt</a></td></tr>
<tr class="memdesc:abf04346715336de0dfc10dac8ed114d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches switch statements.  <a href="namespaceclang_1_1ast__matchers.html#abf04346715336de0dfc10dac8ed114d9">More...</a><br /></td></tr>
<tr class="separator:abf04346715336de0dfc10dac8ed114d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7abc89804682f83816d2323cdc718cf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab7abc89804682f83816d2323cdc718cf">switchCase</a></td></tr>
<tr class="memdesc:ab7abc89804682f83816d2323cdc718cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches case and default statements inside switch statements.  <a href="namespaceclang_1_1ast__matchers.html#ab7abc89804682f83816d2323cdc718cf">More...</a><br /></td></tr>
<tr class="separator:ab7abc89804682f83816d2323cdc718cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5725bf80823feea320c27f79c712e8f6"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5725bf80823feea320c27f79c712e8f6">caseStmt</a></td></tr>
<tr class="memdesc:a5725bf80823feea320c27f79c712e8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches case statements inside switch statements.  <a href="namespaceclang_1_1ast__matchers.html#a5725bf80823feea320c27f79c712e8f6">More...</a><br /></td></tr>
<tr class="separator:a5725bf80823feea320c27f79c712e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cc259a084492c93e3053e78ea9d088"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DefaultStmt.html">DefaultStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab7cc259a084492c93e3053e78ea9d088">defaultStmt</a></td></tr>
<tr class="memdesc:ab7cc259a084492c93e3053e78ea9d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches default statements inside switch statements.  <a href="namespaceclang_1_1ast__matchers.html#ab7cc259a084492c93e3053e78ea9d088">More...</a><br /></td></tr>
<tr class="separator:ab7cc259a084492c93e3053e78ea9d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496a3f466a3f754041e8a1cfd3aaf749"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749">compoundStmt</a></td></tr>
<tr class="memdesc:a496a3f466a3f754041e8a1cfd3aaf749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches compound statements.  <a href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749">More...</a><br /></td></tr>
<tr class="separator:a496a3f466a3f754041e8a1cfd3aaf749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed73db7e4f5258557e39edc7fc5168d0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aed73db7e4f5258557e39edc7fc5168d0">cxxCatchStmt</a></td></tr>
<tr class="memdesc:aed73db7e4f5258557e39edc7fc5168d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches catch statements.  <a href="namespaceclang_1_1ast__matchers.html#aed73db7e4f5258557e39edc7fc5168d0">More...</a><br /></td></tr>
<tr class="separator:aed73db7e4f5258557e39edc7fc5168d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0002878ac1dc163307befba0daa2b17"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTryStmt.html">CXXTryStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af0002878ac1dc163307befba0daa2b17">cxxTryStmt</a></td></tr>
<tr class="memdesc:af0002878ac1dc163307befba0daa2b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches try statements.  <a href="namespaceclang_1_1ast__matchers.html#af0002878ac1dc163307befba0daa2b17">More...</a><br /></td></tr>
<tr class="separator:af0002878ac1dc163307befba0daa2b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc856098ca748d9cff1734ff8fe3bd56"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThrowExpr.html">CXXThrowExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abc856098ca748d9cff1734ff8fe3bd56">cxxThrowExpr</a></td></tr>
<tr class="memdesc:abc856098ca748d9cff1734ff8fe3bd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches throw expressions.  <a href="namespaceclang_1_1ast__matchers.html#abc856098ca748d9cff1734ff8fe3bd56">More...</a><br /></td></tr>
<tr class="separator:abc856098ca748d9cff1734ff8fe3bd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e85f3028bc3d2d590878c3587d43f5c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1NullStmt.html">NullStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4e85f3028bc3d2d590878c3587d43f5c">nullStmt</a></td></tr>
<tr class="memdesc:a4e85f3028bc3d2d590878c3587d43f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches null statements.  <a href="namespaceclang_1_1ast__matchers.html#a4e85f3028bc3d2d590878c3587d43f5c">More...</a><br /></td></tr>
<tr class="separator:a4e85f3028bc3d2d590878c3587d43f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4329ae4c7c6f153f7529aab870ffec8b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AsmStmt.html">AsmStmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4329ae4c7c6f153f7529aab870ffec8b">asmStmt</a></td></tr>
<tr class="memdesc:a4329ae4c7c6f153f7529aab870ffec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches asm statements.  <a href="namespaceclang_1_1ast__matchers.html#a4329ae4c7c6f153f7529aab870ffec8b">More...</a><br /></td></tr>
<tr class="separator:a4329ae4c7c6f153f7529aab870ffec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409ccd26dc35075d52eef632d86bbf33"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a409ccd26dc35075d52eef632d86bbf33">cxxBoolLiteral</a></td></tr>
<tr class="memdesc:a409ccd26dc35075d52eef632d86bbf33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches bool literals.  <a href="namespaceclang_1_1ast__matchers.html#a409ccd26dc35075d52eef632d86bbf33">More...</a><br /></td></tr>
<tr class="separator:a409ccd26dc35075d52eef632d86bbf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2c9fffe33e90bbb4b8f099caf377d7b1">stringLiteral</a></td></tr>
<tr class="memdesc:a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches string literals (also matches wide string literals).  <a href="namespaceclang_1_1ast__matchers.html#a2c9fffe33e90bbb4b8f099caf377d7b1">More...</a><br /></td></tr>
<tr class="separator:a2c9fffe33e90bbb4b8f099caf377d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2752fd9ce2d1e53440035178d4a0feb"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae2752fd9ce2d1e53440035178d4a0feb">characterLiteral</a></td></tr>
<tr class="memdesc:ae2752fd9ce2d1e53440035178d4a0feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches character literals (also matches wchar_t).  <a href="namespaceclang_1_1ast__matchers.html#ae2752fd9ce2d1e53440035178d4a0feb">More...</a><br /></td></tr>
<tr class="separator:ae2752fd9ce2d1e53440035178d4a0feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2109e16a4a151dc8f6416a66a750eac"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a></td></tr>
<tr class="memdesc:ad2109e16a4a151dc8f6416a66a750eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches integer literals of all sizes / encodings, e.g.  <a href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">More...</a><br /></td></tr>
<tr class="separator:ad2109e16a4a151dc8f6416a66a750eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e38c6224c16252040dc697a6af832"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4a4e38c6224c16252040dc697a6af832">floatLiteral</a></td></tr>
<tr class="memdesc:a4a4e38c6224c16252040dc697a6af832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches float literals of all sizes / encodings, e.g.  <a href="namespaceclang_1_1ast__matchers.html#a4a4e38c6224c16252040dc697a6af832">More...</a><br /></td></tr>
<tr class="separator:a4a4e38c6224c16252040dc697a6af832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b21c26d322030721227bd877344452"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImaginaryLiteral.html">ImaginaryLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af7b21c26d322030721227bd877344452">imaginaryLiteral</a></td></tr>
<tr class="memdesc:af7b21c26d322030721227bd877344452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches imaginary literals, which are based on integer and floating point literals e.g.  <a href="namespaceclang_1_1ast__matchers.html#af7b21c26d322030721227bd877344452">More...</a><br /></td></tr>
<tr class="separator:af7b21c26d322030721227bd877344452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0045003e9bc57bbe8c8f5e32a64c9533"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FixedPointLiteral.html">FixedPointLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0045003e9bc57bbe8c8f5e32a64c9533">fixedPointLiteral</a></td></tr>
<tr class="memdesc:a0045003e9bc57bbe8c8f5e32a64c9533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches fixed point literals.  <a href="namespaceclang_1_1ast__matchers.html#a0045003e9bc57bbe8c8f5e32a64c9533">More...</a><br /></td></tr>
<tr class="separator:a0045003e9bc57bbe8c8f5e32a64c9533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f2a941709daf18c1eb096bdde38868"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UserDefinedLiteral.html">UserDefinedLiteral</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab2f2a941709daf18c1eb096bdde38868">userDefinedLiteral</a></td></tr>
<tr class="memdesc:ab2f2a941709daf18c1eb096bdde38868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches user defined literal operator call.  <a href="namespaceclang_1_1ast__matchers.html#ab2f2a941709daf18c1eb096bdde38868">More...</a><br /></td></tr>
<tr class="separator:ab2f2a941709daf18c1eb096bdde38868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adcac5ffe32ca0150ad183cbdc3d0f6c1">compoundLiteralExpr</a></td></tr>
<tr class="memdesc:adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches compound (i.e.  <a href="namespaceclang_1_1ast__matchers.html#adcac5ffe32ca0150ad183cbdc3d0f6c1">More...</a><br /></td></tr>
<tr class="separator:adcac5ffe32ca0150ad183cbdc3d0f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316dfc14ff4a5e127c5942d1bd97340c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoawaitExpr.html">CoawaitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a316dfc14ff4a5e127c5942d1bd97340c">coawaitExpr</a></td></tr>
<tr class="memdesc:a316dfc14ff4a5e127c5942d1bd97340c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches co_await expressions.  <a href="namespaceclang_1_1ast__matchers.html#a316dfc14ff4a5e127c5942d1bd97340c">More...</a><br /></td></tr>
<tr class="separator:a316dfc14ff4a5e127c5942d1bd97340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bfb525257906764abbd2c71bd8e8e0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DependentCoawaitExpr.html">DependentCoawaitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a34bfb525257906764abbd2c71bd8e8e0">dependentCoawaitExpr</a></td></tr>
<tr class="memdesc:a34bfb525257906764abbd2c71bd8e8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches co_await expressions where the type of the promise is dependent.  <a href="namespaceclang_1_1ast__matchers.html#a34bfb525257906764abbd2c71bd8e8e0">More...</a><br /></td></tr>
<tr class="separator:a34bfb525257906764abbd2c71bd8e8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19508bdafd0681dc1c08480af65bf65e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoyieldExpr.html">CoyieldExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a19508bdafd0681dc1c08480af65bf65e">coyieldExpr</a></td></tr>
<tr class="memdesc:a19508bdafd0681dc1c08480af65bf65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches co_yield expressions.  <a href="namespaceclang_1_1ast__matchers.html#a19508bdafd0681dc1c08480af65bf65e">More...</a><br /></td></tr>
<tr class="separator:a19508bdafd0681dc1c08480af65bf65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74cde61d132689b56daab21db683425"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNullPtrLiteralExpr.html">CXXNullPtrLiteralExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ad74cde61d132689b56daab21db683425">cxxNullPtrLiteralExpr</a></td></tr>
<tr class="memdesc:ad74cde61d132689b56daab21db683425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nullptr literal.  <a href="namespaceclang_1_1ast__matchers.html#ad74cde61d132689b56daab21db683425">More...</a><br /></td></tr>
<tr class="separator:ad74cde61d132689b56daab21db683425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d6075693f8e67b1a952da3fe26acaf"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ChooseExpr.html">ChooseExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab3d6075693f8e67b1a952da3fe26acaf">chooseExpr</a></td></tr>
<tr class="memdesc:ab3d6075693f8e67b1a952da3fe26acaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches GNU __builtin_choose_expr.  <a href="namespaceclang_1_1ast__matchers.html#ab3d6075693f8e67b1a952da3fe26acaf">More...</a><br /></td></tr>
<tr class="separator:ab3d6075693f8e67b1a952da3fe26acaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80570a2d56d8d2d1788318a946a68a05"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GNUNullExpr.html">GNUNullExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a80570a2d56d8d2d1788318a946a68a05">gnuNullExpr</a></td></tr>
<tr class="memdesc:a80570a2d56d8d2d1788318a946a68a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches GNU __null expression.  <a href="namespaceclang_1_1ast__matchers.html#a80570a2d56d8d2d1788318a946a68a05">More...</a><br /></td></tr>
<tr class="separator:a80570a2d56d8d2d1788318a946a68a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GenericSelectionExpr.html">GenericSelectionExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a3f42e20a3d2500bbee1741d7f8bc04f3">genericSelectionExpr</a></td></tr>
<tr class="memdesc:a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C11 _Generic expression.  <a href="namespaceclang_1_1ast__matchers.html#a3f42e20a3d2500bbee1741d7f8bc04f3">More...</a><br /></td></tr>
<tr class="separator:a3f42e20a3d2500bbee1741d7f8bc04f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc5672f38513ca660c5c383e958cec0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AtomicExpr.html">AtomicExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2fc5672f38513ca660c5c383e958cec0">atomicExpr</a></td></tr>
<tr class="memdesc:a2fc5672f38513ca660c5c383e958cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches atomic builtins.  <a href="namespaceclang_1_1ast__matchers.html#a2fc5672f38513ca660c5c383e958cec0">More...</a><br /></td></tr>
<tr class="separator:a2fc5672f38513ca660c5c383e958cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07128394c216b2d373a8ee39956e7689"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a07128394c216b2d373a8ee39956e7689">stmtExpr</a></td></tr>
<tr class="memdesc:a07128394c216b2d373a8ee39956e7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches statement expression (GNU extension).  <a href="namespaceclang_1_1ast__matchers.html#a07128394c216b2d373a8ee39956e7689">More...</a><br /></td></tr>
<tr class="separator:a07128394c216b2d373a8ee39956e7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d236ec1064f604664b1e9123249e01"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a92d236ec1064f604664b1e9123249e01">binaryOperator</a></td></tr>
<tr class="memdesc:a92d236ec1064f604664b1e9123249e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches binary operator expressions.  <a href="namespaceclang_1_1ast__matchers.html#a92d236ec1064f604664b1e9123249e01">More...</a><br /></td></tr>
<tr class="separator:a92d236ec1064f604664b1e9123249e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ac1ea4304cca5a3d773782c45e3a9d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a71ac1ea4304cca5a3d773782c45e3a9d">unaryOperator</a></td></tr>
<tr class="memdesc:a71ac1ea4304cca5a3d773782c45e3a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches unary operator expressions.  <a href="namespaceclang_1_1ast__matchers.html#a71ac1ea4304cca5a3d773782c45e3a9d">More...</a><br /></td></tr>
<tr class="separator:a71ac1ea4304cca5a3d773782c45e3a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae471648f1de66bdde248ef4b1edae5e5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConditionalOperator.html">ConditionalOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae471648f1de66bdde248ef4b1edae5e5">conditionalOperator</a></td></tr>
<tr class="memdesc:ae471648f1de66bdde248ef4b1edae5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches conditional operator expressions.  <a href="namespaceclang_1_1ast__matchers.html#ae471648f1de66bdde248ef4b1edae5e5">More...</a><br /></td></tr>
<tr class="separator:ae471648f1de66bdde248ef4b1edae5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa466a1e59dbf5a8785b2561a308ae4fb"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryConditionalOperator.html">BinaryConditionalOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa466a1e59dbf5a8785b2561a308ae4fb">binaryConditionalOperator</a></td></tr>
<tr class="memdesc:aa466a1e59dbf5a8785b2561a308ae4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches binary conditional operator expressions (GNU extension).  <a href="namespaceclang_1_1ast__matchers.html#aa466a1e59dbf5a8785b2561a308ae4fb">More...</a><br /></td></tr>
<tr class="separator:aa466a1e59dbf5a8785b2561a308ae4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7160bb2f02400b2152dc7e0b10d763a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae7160bb2f02400b2152dc7e0b10d763a">opaqueValueExpr</a></td></tr>
<tr class="memdesc:ae7160bb2f02400b2152dc7e0b10d763a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches opaque value expressions.  <a href="namespaceclang_1_1ast__matchers.html#ae7160bb2f02400b2152dc7e0b10d763a">More...</a><br /></td></tr>
<tr class="separator:ae7160bb2f02400b2152dc7e0b10d763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab1f66ff6c5a790900ae8f625e9a09"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1StaticAssertDecl.html">StaticAssertDecl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a99ab1f66ff6c5a790900ae8f625e9a09">staticAssertDecl</a></td></tr>
<tr class="memdesc:a99ab1f66ff6c5a790900ae8f625e9a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ static_assert declaration.  <a href="namespaceclang_1_1ast__matchers.html#a99ab1f66ff6c5a790900ae8f625e9a09">More...</a><br /></td></tr>
<tr class="separator:a99ab1f66ff6c5a790900ae8f625e9a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXReinterpretCastExpr.html">CXXReinterpretCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a04dc23e7233bd6aa6c8cd1240dfc71de">cxxReinterpretCastExpr</a></td></tr>
<tr class="memdesc:a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a reinterpret_cast expression.  <a href="namespaceclang_1_1ast__matchers.html#a04dc23e7233bd6aa6c8cd1240dfc71de">More...</a><br /></td></tr>
<tr class="separator:a04dc23e7233bd6aa6c8cd1240dfc71de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83203112fbb0fc35646465509fce105"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStaticCastExpr.html">CXXStaticCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa83203112fbb0fc35646465509fce105">cxxStaticCastExpr</a></td></tr>
<tr class="memdesc:aa83203112fbb0fc35646465509fce105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C++ static_cast expression.  <a href="namespaceclang_1_1ast__matchers.html#aa83203112fbb0fc35646465509fce105">More...</a><br /></td></tr>
<tr class="separator:aa83203112fbb0fc35646465509fce105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ee71422a19b825dd23d6dde2c0551"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDynamicCastExpr.html">CXXDynamicCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a446ee71422a19b825dd23d6dde2c0551">cxxDynamicCastExpr</a></td></tr>
<tr class="memdesc:a446ee71422a19b825dd23d6dde2c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a dynamic_cast expression.  <a href="namespaceclang_1_1ast__matchers.html#a446ee71422a19b825dd23d6dde2c0551">More...</a><br /></td></tr>
<tr class="separator:a446ee71422a19b825dd23d6dde2c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704390715c62f500730acc8eb8133ee0"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstCastExpr.html">CXXConstCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a704390715c62f500730acc8eb8133ee0">cxxConstCastExpr</a></td></tr>
<tr class="memdesc:a704390715c62f500730acc8eb8133ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a const_cast expression.  <a href="namespaceclang_1_1ast__matchers.html#a704390715c62f500730acc8eb8133ee0">More...</a><br /></td></tr>
<tr class="separator:a704390715c62f500730acc8eb8133ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0262eb3971f2f7649d0354cbddaaec73"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CStyleCastExpr.html">CStyleCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a0262eb3971f2f7649d0354cbddaaec73">cStyleCastExpr</a></td></tr>
<tr class="memdesc:a0262eb3971f2f7649d0354cbddaaec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a C-style cast expression.  <a href="namespaceclang_1_1ast__matchers.html#a0262eb3971f2f7649d0354cbddaaec73">More...</a><br /></td></tr>
<tr class="separator:a0262eb3971f2f7649d0354cbddaaec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64f0fe0351af4d0e37f7838e6385d3c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa64f0fe0351af4d0e37f7838e6385d3c">explicitCastExpr</a></td></tr>
<tr class="memdesc:aa64f0fe0351af4d0e37f7838e6385d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches explicit cast expressions.  <a href="namespaceclang_1_1ast__matchers.html#aa64f0fe0351af4d0e37f7838e6385d3c">More...</a><br /></td></tr>
<tr class="separator:aa64f0fe0351af4d0e37f7838e6385d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1bdd70cca95686345d5a96d97071a"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a28b1bdd70cca95686345d5a96d97071a">implicitCastExpr</a></td></tr>
<tr class="memdesc:a28b1bdd70cca95686345d5a96d97071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the implicit cast nodes of Clang's AST.  <a href="namespaceclang_1_1ast__matchers.html#a28b1bdd70cca95686345d5a96d97071a">More...</a><br /></td></tr>
<tr class="separator:a28b1bdd70cca95686345d5a96d97071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0910ccb567ed2465a935d7bd6831ed"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CastExpr.html">CastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aee0910ccb567ed2465a935d7bd6831ed">castExpr</a></td></tr>
<tr class="memdesc:aee0910ccb567ed2465a935d7bd6831ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any cast nodes of Clang's AST.  <a href="namespaceclang_1_1ast__matchers.html#aee0910ccb567ed2465a935d7bd6831ed">More...</a><br /></td></tr>
<tr class="separator:aee0910ccb567ed2465a935d7bd6831ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701d2c84173a8709dcb4a221ad478e1e"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a701d2c84173a8709dcb4a221ad478e1e">cxxFunctionalCastExpr</a></td></tr>
<tr class="memdesc:a701d2c84173a8709dcb4a221ad478e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functional cast expressions.  <a href="namespaceclang_1_1ast__matchers.html#a701d2c84173a8709dcb4a221ad478e1e">More...</a><br /></td></tr>
<tr class="separator:a701d2c84173a8709dcb4a221ad478e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e8b0c7519edb6b05d1663a4266b6d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a704e8b0c7519edb6b05d1663a4266b6d">cxxTemporaryObjectExpr</a></td></tr>
<tr class="memdesc:a704e8b0c7519edb6b05d1663a4266b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches functional cast expressions having N != 1 arguments.  <a href="namespaceclang_1_1ast__matchers.html#a704e8b0c7519edb6b05d1663a4266b6d">More...</a><br /></td></tr>
<tr class="separator:a704e8b0c7519edb6b05d1663a4266b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b52666b405fc2bf1a28120d488488c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1PredefinedExpr.html">PredefinedExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a33b52666b405fc2bf1a28120d488488c">predefinedExpr</a></td></tr>
<tr class="memdesc:a33b52666b405fc2bf1a28120d488488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches predefined identifier expressions [C99 6.4.2.2].  <a href="namespaceclang_1_1ast__matchers.html#a33b52666b405fc2bf1a28120d488488c">More...</a><br /></td></tr>
<tr class="separator:a33b52666b405fc2bf1a28120d488488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5af767c2d681ddb0122fec2e3ab43a5"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac5af767c2d681ddb0122fec2e3ab43a5">designatedInitExpr</a></td></tr>
<tr class="memdesc:ac5af767c2d681ddb0122fec2e3ab43a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C99 designated initializer expressions [C99 6.7.8].  <a href="namespaceclang_1_1ast__matchers.html#ac5af767c2d681ddb0122fec2e3ab43a5">More...</a><br /></td></tr>
<tr class="separator:ac5af767c2d681ddb0122fec2e3ab43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc28b8bf75f10413691d11b9c371116"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aefc28b8bf75f10413691d11b9c371116">qualType</a></td></tr>
<tr class="memdesc:aefc28b8bf75f10413691d11b9c371116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>QualTypes</code> in the clang AST.  <a href="namespaceclang_1_1ast__matchers.html#aefc28b8bf75f10413691d11b9c371116">More...</a><br /></td></tr>
<tr class="separator:aefc28b8bf75f10413691d11b9c371116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600679c157b5bd05c4bfb940fb2511dd"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a600679c157b5bd05c4bfb940fb2511dd">type</a></td></tr>
<tr class="memdesc:a600679c157b5bd05c4bfb940fb2511dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>Types</code> in the clang AST.  <a href="namespaceclang_1_1ast__matchers.html#a600679c157b5bd05c4bfb940fb2511dd">More...</a><br /></td></tr>
<tr class="separator:a600679c157b5bd05c4bfb940fb2511dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605961d8a647c2ec766b2417552393a2"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a605961d8a647c2ec766b2417552393a2">typeLoc</a></td></tr>
<tr class="memdesc:a605961d8a647c2ec766b2417552393a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code>TypeLocs</code> in the clang AST.  <a href="namespaceclang_1_1ast__matchers.html#a605961d8a647c2ec766b2417552393a2">More...</a><br /></td></tr>
<tr class="separator:a605961d8a647c2ec766b2417552393a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3c535f34a336b4e966342d44a631d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab0c3c535f34a336b4e966342d44a631d">eachOf</a> = {internal::DynTypedMatcher::VO_EachOf}</td></tr>
<tr class="memdesc:ab0c3c535f34a336b4e966342d44a631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if any of the given matchers matches.  <a href="namespaceclang_1_1ast__matchers.html#ab0c3c535f34a336b4e966342d44a631d">More...</a><br /></td></tr>
<tr class="separator:ab0c3c535f34a336b4e966342d44a631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a1974283c9a2cb2410008e32fe3f1"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a> = {internal::DynTypedMatcher::VO_AnyOf}</td></tr>
<tr class="memdesc:ae56a1974283c9a2cb2410008e32fe3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if any of the given matchers matches.  <a href="namespaceclang_1_1ast__matchers.html#ae56a1974283c9a2cb2410008e32fe3f1">More...</a><br /></td></tr>
<tr class="separator:ae56a1974283c9a2cb2410008e32fe3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7f0b785ca07327256931286ebc99f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab7f7f0b785ca07327256931286ebc99f">allOf</a> = {internal::DynTypedMatcher::VO_AllOf}</td></tr>
<tr class="memdesc:ab7f7f0b785ca07327256931286ebc99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if all given matchers match.  <a href="namespaceclang_1_1ast__matchers.html#ab7f7f0b785ca07327256931286ebc99f">More...</a><br /></td></tr>
<tr class="separator:ab7f7f0b785ca07327256931286ebc99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a07934509f8d264c16974bbe0c15ac7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2a07934509f8d264c16974bbe0c15ac7">optionally</a></td></tr>
<tr class="memdesc:a2a07934509f8d264c16974bbe0c15ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any node regardless of the submatcher.  <a href="namespaceclang_1_1ast__matchers.html#a2a07934509f8d264c16974bbe0c15ac7">More...</a><br /></td></tr>
<tr class="separator:a2a07934509f8d264c16974bbe0c15ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4e6f1fbd69a5f3bd0b1f7c81f30ba547">unaryExprOrTypeTraitExpr</a></td></tr>
<tr class="memdesc:a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)  <a href="namespaceclang_1_1ast__matchers.html#a4e6f1fbd69a5f3bd0b1f7c81f30ba547">More...</a><br /></td></tr>
<tr class="separator:a4e6f1fbd69a5f3bd0b1f7c81f30ba547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76efced611335bad85d3da6fe6ae790e"><td class="memItemLeft" align="right" valign="top">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e">binaryOperation</a></td></tr>
<tr class="memdesc:a76efced611335bad85d3da6fe6ae790e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nodes which can be used with binary operators.  <a href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e">More...</a><br /></td></tr>
<tr class="separator:a76efced611335bad85d3da6fe6ae790e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb82889579b3228e5741598746e94b31"><td class="memItemLeft" align="right" valign="top">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abb82889579b3228e5741598746e94b31">invocation</a></td></tr>
<tr class="memdesc:abb82889579b3228e5741598746e94b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches function calls and constructor calls.  <a href="namespaceclang_1_1ast__matchers.html#abb82889579b3228e5741598746e94b31">More...</a><br /></td></tr>
<tr class="separator:abb82889579b3228e5741598746e94b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75176e564329aea08a65d667d019d9f8"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#afaf7bb46aec8e879467a959bcb38fefe">internal::hasAnyNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a75176e564329aea08a65d667d019d9f8">hasAnyName</a> = {}</td></tr>
<tr class="memdesc:a75176e564329aea08a65d667d019d9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have any of the specified names.  <a href="namespaceclang_1_1ast__matchers.html#a75176e564329aea08a65d667d019d9f8">More...</a><br /></td></tr>
<tr class="separator:a75176e564329aea08a65d667d019d9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa5862611b82aa132a5ab534b63e9b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::PolymorphicMatcher&lt; internal::HasOverloadedOperatorNameMatcher, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), std::vector&lt; <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &gt; &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a1e5b2642d58cd1ce19c81f4c4335fc80">internal::hasAnyOverloadedOperatorNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4baa5862611b82aa132a5ab534b63e9b">hasAnyOverloadedOperatorName</a> = {}</td></tr>
<tr class="memdesc:a4baa5862611b82aa132a5ab534b63e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches overloaded operator names.  <a href="namespaceclang_1_1ast__matchers.html#a4baa5862611b82aa132a5ab534b63e9b">More...</a><br /></td></tr>
<tr class="separator:a4baa5862611b82aa132a5ab534b63e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a14e1788aad32c318543405b5ec5962"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a> = {}</td></tr>
<tr class="memdesc:a9a14e1788aad32c318543405b5ec5962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have child AST nodes that match the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">More...</a><br /></td></tr>
<tr class="separator:a9a14e1788aad32c318543405b5ec5962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b133847db656cf51934b25cde311b8e"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasDescendantMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2b133847db656cf51934b25cde311b8e">hasDescendant</a> = {}</td></tr>
<tr class="memdesc:a2b133847db656cf51934b25cde311b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have descendant AST nodes that match the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#a2b133847db656cf51934b25cde311b8e">More...</a><br /></td></tr>
<tr class="separator:a2b133847db656cf51934b25cde311b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e1d83c63172816c6678224f6d73fb8"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a56e1d83c63172816c6678224f6d73fb8">forEach</a></td></tr>
<tr class="memdesc:a56e1d83c63172816c6678224f6d73fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have child AST nodes that match the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#a56e1d83c63172816c6678224f6d73fb8">More...</a><br /></td></tr>
<tr class="separator:a56e1d83c63172816c6678224f6d73fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114cdbe34bca53c82f6304894904740"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachDescendantMatcher &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a5114cdbe34bca53c82f6304894904740">forEachDescendant</a> = {}</td></tr>
<tr class="memdesc:a5114cdbe34bca53c82f6304894904740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have descendant AST nodes that match the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#a5114cdbe34bca53c82f6304894904740">More...</a><br /></td></tr>
<tr class="separator:a5114cdbe34bca53c82f6304894904740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ae5090f4e722ad6ee2a8ae45d59223"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasParentMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af5ae5090f4e722ad6ee2a8ae45d59223">hasParent</a> = {}</td></tr>
<tr class="memdesc:af5ae5090f4e722ad6ee2a8ae45d59223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have a parent that matches the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#af5ae5090f4e722ad6ee2a8ae45d59223">More...</a><br /></td></tr>
<tr class="separator:af5ae5090f4e722ad6ee2a8ae45d59223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c2ce2d42eb22f44382ea0f139a45b4"><td class="memItemLeft" align="right" valign="top">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasAncestorMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af3c2ce2d42eb22f44382ea0f139a45b4">hasAncestor</a> = {}</td></tr>
<tr class="memdesc:af3c2ce2d42eb22f44382ea0f139a45b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches AST nodes that have an ancestor that matches the provided matcher.  <a href="namespaceclang_1_1ast__matchers.html#af3c2ce2d42eb22f44382ea0f139a45b4">More...</a><br /></td></tr>
<tr class="separator:af3c2ce2d42eb22f44382ea0f139a45b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183ba07d4205e38e5d960a99062722dc"><td class="memItemLeft" align="right" valign="top">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a183ba07d4205e38e5d960a99062722dc">unless</a></td></tr>
<tr class="memdesc:a183ba07d4205e38e5d960a99062722dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches if the provided matcher does not match.  <a href="namespaceclang_1_1ast__matchers.html#a183ba07d4205e38e5d960a99062722dc">More...</a><br /></td></tr>
<tr class="separator:a183ba07d4205e38e5d960a99062722dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568b14e2ddad80f141bc0f81958f12b"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#ab36710df5527233f1d4ea5ac9e78a7b9">internal::hasAnySelectorFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6568b14e2ddad80f141bc0f81958f12b">hasAnySelector</a> = {}</td></tr>
<tr class="memdesc:a6568b14e2ddad80f141bc0f81958f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches when at least one of the supplied string equals to the <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a>  <a href="namespaceclang_1_1ast__matchers.html#a6568b14e2ddad80f141bc0f81958f12b">More...</a><br /></td></tr>
<tr class="separator:a6568b14e2ddad80f141bc0f81958f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01242d6cc88506d489ed38978597292"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab01242d6cc88506d489ed38978597292">lambdaCapture</a></td></tr>
<tr class="memdesc:ab01242d6cc88506d489ed38978597292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches lambda captures.  <a href="namespaceclang_1_1ast__matchers.html#ab01242d6cc88506d489ed38978597292">More...</a><br /></td></tr>
<tr class="separator:ab01242d6cc88506d489ed38978597292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7072ab53ba2443d644a2a478f1d5280"><td class="memItemLeft" align="right" valign="top">const internal::VariadicFunction&lt; internal::PolymorphicMatcher&lt; internal::HasAnyOperatorNameMatcher, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a>), std::vector&lt; <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &gt; &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#aa6c82af4b9087769a26b4e80ff53d5e0">internal::hasAnyOperatorNameFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae7072ab53ba2443d644a2a478f1d5280">hasAnyOperatorName</a> = {}</td></tr>
<tr class="memdesc:ae7072ab53ba2443d644a2a478f1d5280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches operator expressions (binary or unary) that have any of the specified names.  <a href="namespaceclang_1_1ast__matchers.html#ae7072ab53ba2443d644a2a478f1d5280">More...</a><br /></td></tr>
<tr class="separator:ae7072ab53ba2443d644a2a478f1d5280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e5eef17f07cfff020966a57173654c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a93e5eef17f07cfff020966a57173654c">qualifiedTypeLoc</a></td></tr>
<tr class="memdesc:a93e5eef17f07cfff020966a57173654c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1QualifiedTypeLoc.html" title="Wrapper of type source information for a type with non-trivial direct qualifiers.">QualifiedTypeLoc</a></code>s in the clang AST.  <a href="namespaceclang_1_1ast__matchers.html#a93e5eef17f07cfff020966a57173654c">More...</a><br /></td></tr>
<tr class="separator:a93e5eef17f07cfff020966a57173654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82053583c94237b11f14c38d58262e69"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a82053583c94237b11f14c38d58262e69">pointerTypeLoc</a></td></tr>
<tr class="memdesc:a82053583c94237b11f14c38d58262e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches pointer <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s.  <a href="namespaceclang_1_1ast__matchers.html#a82053583c94237b11f14c38d58262e69">More...</a><br /></td></tr>
<tr class="separator:a82053583c94237b11f14c38d58262e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739478b8ffe02ebfd1a48be839ae440d"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a739478b8ffe02ebfd1a48be839ae440d">referenceTypeLoc</a></td></tr>
<tr class="memdesc:a739478b8ffe02ebfd1a48be839ae440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches reference <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s.  <a href="namespaceclang_1_1ast__matchers.html#a739478b8ffe02ebfd1a48be839ae440d">More...</a><br /></td></tr>
<tr class="separator:a739478b8ffe02ebfd1a48be839ae440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c3729d0b5b87dee87ab24e7e8d3671"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a50c3729d0b5b87dee87ab24e7e8d3671">templateSpecializationTypeLoc</a></td></tr>
<tr class="memdesc:a50c3729d0b5b87dee87ab24e7e8d3671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s.  <a href="namespaceclang_1_1ast__matchers.html#a50c3729d0b5b87dee87ab24e7e8d3671">More...</a><br /></td></tr>
<tr class="separator:a50c3729d0b5b87dee87ab24e7e8d3671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065704e9c5222dd93296aaeb3383cdf7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a065704e9c5222dd93296aaeb3383cdf7">elaboratedTypeLoc</a></td></tr>
<tr class="memdesc:a065704e9c5222dd93296aaeb3383cdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C or C++ elaborated <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s.  <a href="namespaceclang_1_1ast__matchers.html#a065704e9c5222dd93296aaeb3383cdf7">More...</a><br /></td></tr>
<tr class="separator:a065704e9c5222dd93296aaeb3383cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ab8ee766c693dcbe7b511984675e75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1BuiltinType.html">BuiltinType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a16ab8ee766c693dcbe7b511984675e75">builtinType</a></td></tr>
<tr class="memdesc:a16ab8ee766c693dcbe7b511984675e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches builtin Types.  <a href="namespaceclang_1_1ast__matchers.html#a16ab8ee766c693dcbe7b511984675e75">More...</a><br /></td></tr>
<tr class="separator:a16ab8ee766c693dcbe7b511984675e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6733c0e2dab3236688140fb7e73db035"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ArrayType.html">ArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6733c0e2dab3236688140fb7e73db035">arrayType</a></td></tr>
<tr class="memdesc:a6733c0e2dab3236688140fb7e73db035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches all kinds of arrays.  <a href="namespaceclang_1_1ast__matchers.html#a6733c0e2dab3236688140fb7e73db035">More...</a><br /></td></tr>
<tr class="separator:a6733c0e2dab3236688140fb7e73db035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84886494cbc41d78353574764bf4566"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae84886494cbc41d78353574764bf4566">complexType</a></td></tr>
<tr class="memdesc:ae84886494cbc41d78353574764bf4566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C99 complex types.  <a href="namespaceclang_1_1ast__matchers.html#ae84886494cbc41d78353574764bf4566">More...</a><br /></td></tr>
<tr class="separator:ae84886494cbc41d78353574764bf4566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac021576281120c3d3621e0bf2bcf591"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac021576281120c3d3621e0bf2bcf591">constantArrayType</a></td></tr>
<tr class="memdesc:aac021576281120c3d3621e0bf2bcf591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C arrays with a specified constant size.  <a href="namespaceclang_1_1ast__matchers.html#aac021576281120c3d3621e0bf2bcf591">More...</a><br /></td></tr>
<tr class="separator:aac021576281120c3d3621e0bf2bcf591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34f28aac1f47aac489477a599a0efd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DependentSizedArrayType.html">DependentSizedArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2e34f28aac1f47aac489477a599a0efd">dependentSizedArrayType</a></td></tr>
<tr class="memdesc:a2e34f28aac1f47aac489477a599a0efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++ arrays whose size is a value-dependent expression.  <a href="namespaceclang_1_1ast__matchers.html#a2e34f28aac1f47aac489477a599a0efd">More...</a><br /></td></tr>
<tr class="separator:a2e34f28aac1f47aac489477a599a0efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce6e0c98327394eeecc992d9d1715e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1IncompleteArrayType.html">IncompleteArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae0ce6e0c98327394eeecc992d9d1715e">incompleteArrayType</a></td></tr>
<tr class="memdesc:ae0ce6e0c98327394eeecc992d9d1715e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C arrays with unspecified size.  <a href="namespaceclang_1_1ast__matchers.html#ae0ce6e0c98327394eeecc992d9d1715e">More...</a><br /></td></tr>
<tr class="separator:ae0ce6e0c98327394eeecc992d9d1715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d12a4d6b3a44f08f4bb0e37a3b1f9c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a4d12a4d6b3a44f08f4bb0e37a3b1f9c5">variableArrayType</a></td></tr>
<tr class="memdesc:a4d12a4d6b3a44f08f4bb0e37a3b1f9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C arrays with a specified size that is not an integer-constant-expression.  <a href="namespaceclang_1_1ast__matchers.html#a4d12a4d6b3a44f08f4bb0e37a3b1f9c5">More...</a><br /></td></tr>
<tr class="separator:a4d12a4d6b3a44f08f4bb0e37a3b1f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f187323c83df32908d285ed132bd18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1AtomicType.html">AtomicType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a88f187323c83df32908d285ed132bd18">atomicType</a></td></tr>
<tr class="memdesc:a88f187323c83df32908d285ed132bd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches atomic types.  <a href="namespaceclang_1_1ast__matchers.html#a88f187323c83df32908d285ed132bd18">More...</a><br /></td></tr>
<tr class="separator:a88f187323c83df32908d285ed132bd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6616dde4596353abb9635c1f322fca1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1AutoType.html">AutoType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a6616dde4596353abb9635c1f322fca1e">autoType</a></td></tr>
<tr class="memdesc:a6616dde4596353abb9635c1f322fca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types nodes representing C++11 auto types.  <a href="namespaceclang_1_1ast__matchers.html#a6616dde4596353abb9635c1f322fca1e">More...</a><br /></td></tr>
<tr class="separator:a6616dde4596353abb9635c1f322fca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60595a1ea21c91357ce6a094ae9d24a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a60595a1ea21c91357ce6a094ae9d24a7">decltypeType</a></td></tr>
<tr class="memdesc:a60595a1ea21c91357ce6a094ae9d24a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types nodes representing C++11 decltype(&lt;expr&gt;) types.  <a href="namespaceclang_1_1ast__matchers.html#a60595a1ea21c91357ce6a094ae9d24a7">More...</a><br /></td></tr>
<tr class="separator:a60595a1ea21c91357ce6a094ae9d24a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb793c9ea9a7c9a4584f8d9a84963981"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1FunctionType.html">FunctionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aeb793c9ea9a7c9a4584f8d9a84963981">functionType</a></td></tr>
<tr class="memdesc:aeb793c9ea9a7c9a4584f8d9a84963981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1FunctionType.html" title="FunctionType - C99 6.7.5.3 - Function Declarators.">FunctionType</a></code> nodes.  <a href="namespaceclang_1_1ast__matchers.html#aeb793c9ea9a7c9a4584f8d9a84963981">More...</a><br /></td></tr>
<tr class="separator:aeb793c9ea9a7c9a4584f8d9a84963981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129a0097a2bce4041eef9fbb315a35a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a129a0097a2bce4041eef9fbb315a35a7">functionProtoType</a></td></tr>
<tr class="memdesc:a129a0097a2bce4041eef9fbb315a35a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1FunctionProtoType.html" title="Represents a prototype with parameter type info, e.g.">FunctionProtoType</a></code> nodes.  <a href="namespaceclang_1_1ast__matchers.html#a129a0097a2bce4041eef9fbb315a35a7">More...</a><br /></td></tr>
<tr class="separator:a129a0097a2bce4041eef9fbb315a35a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ff863eb011e066031ce6b86a11da65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ParenType.html">ParenType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a68ff863eb011e066031ce6b86a11da65">parenType</a></td></tr>
<tr class="memdesc:a68ff863eb011e066031ce6b86a11da65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches <code><a class="el" href="classclang_1_1ParenType.html" title="Sugar for parentheses used when specifying types.">ParenType</a></code> nodes.  <a href="namespaceclang_1_1ast__matchers.html#a68ff863eb011e066031ce6b86a11da65">More...</a><br /></td></tr>
<tr class="separator:a68ff863eb011e066031ce6b86a11da65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cb286e46a83694307c53a4c1375852"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a83cb286e46a83694307c53a4c1375852">blockPointerType</a></td></tr>
<tr class="memdesc:a83cb286e46a83694307c53a4c1375852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches block pointer types, i.e.  <a href="namespaceclang_1_1ast__matchers.html#a83cb286e46a83694307c53a4c1375852">More...</a><br /></td></tr>
<tr class="separator:a83cb286e46a83694307c53a4c1375852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0cfc47879f5df22623bd4ca7680c7e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#add0cfc47879f5df22623bd4ca7680c7e">memberPointerType</a></td></tr>
<tr class="memdesc:add0cfc47879f5df22623bd4ca7680c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches member pointer types.  <a href="namespaceclang_1_1ast__matchers.html#add0cfc47879f5df22623bd4ca7680c7e">More...</a><br /></td></tr>
<tr class="separator:add0cfc47879f5df22623bd4ca7680c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b0467fd444a7daa8a8aa79ec045765"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1PointerType.html">PointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765">pointerType</a></td></tr>
<tr class="memdesc:a34b0467fd444a7daa8a8aa79ec045765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches pointer types, but does not match Objective-C object pointer types.  <a href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765">More...</a><br /></td></tr>
<tr class="separator:a34b0467fd444a7daa8a8aa79ec045765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161e81bed81f9401f7ea8e89de381a50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ObjCObjectPointerType.html">ObjCObjectPointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a161e81bed81f9401f7ea8e89de381a50">objcObjectPointerType</a></td></tr>
<tr class="memdesc:a161e81bed81f9401f7ea8e89de381a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches an Objective-C object pointer type, which is different from a pointer type, despite being syntactically similar.  <a href="namespaceclang_1_1ast__matchers.html#a161e81bed81f9401f7ea8e89de381a50">More...</a><br /></td></tr>
<tr class="separator:a161e81bed81f9401f7ea8e89de381a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac599b04c233b9d56cb646d22d9440f68"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ac599b04c233b9d56cb646d22d9440f68">referenceType</a></td></tr>
<tr class="memdesc:ac599b04c233b9d56cb646d22d9440f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches both lvalue and rvalue reference types.  <a href="namespaceclang_1_1ast__matchers.html#ac599b04c233b9d56cb646d22d9440f68">More...</a><br /></td></tr>
<tr class="separator:ac599b04c233b9d56cb646d22d9440f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4571b67b57d8cb1499ddd796819306"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1LValueReferenceType.html">LValueReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#afd4571b67b57d8cb1499ddd796819306">lValueReferenceType</a></td></tr>
<tr class="memdesc:afd4571b67b57d8cb1499ddd796819306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches lvalue reference types.  <a href="namespaceclang_1_1ast__matchers.html#afd4571b67b57d8cb1499ddd796819306">More...</a><br /></td></tr>
<tr class="separator:afd4571b67b57d8cb1499ddd796819306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b6bc736027364037dec0b5f9d574a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1RValueReferenceType.html">RValueReferenceType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#af7b6bc736027364037dec0b5f9d574a3">rValueReferenceType</a></td></tr>
<tr class="memdesc:af7b6bc736027364037dec0b5f9d574a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches rvalue reference types.  <a href="namespaceclang_1_1ast__matchers.html#af7b6bc736027364037dec0b5f9d574a3">More...</a><br /></td></tr>
<tr class="separator:af7b6bc736027364037dec0b5f9d574a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f43dc5af55843306a50ec410c088d6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TypedefType.html">TypedefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a9f43dc5af55843306a50ec410c088d6a">typedefType</a></td></tr>
<tr class="memdesc:a9f43dc5af55843306a50ec410c088d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches typedef types.  <a href="namespaceclang_1_1ast__matchers.html#a9f43dc5af55843306a50ec410c088d6a">More...</a><br /></td></tr>
<tr class="separator:a9f43dc5af55843306a50ec410c088d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1182014746912db21f315121c2ed6098"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1EnumType.html">EnumType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1182014746912db21f315121c2ed6098">enumType</a></td></tr>
<tr class="memdesc:a1182014746912db21f315121c2ed6098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches enum types.  <a href="namespaceclang_1_1ast__matchers.html#a1182014746912db21f315121c2ed6098">More...</a><br /></td></tr>
<tr class="separator:a1182014746912db21f315121c2ed6098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa868bfe1462fc934f1a64bad7d856d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a2fa868bfe1462fc934f1a64bad7d856d">templateSpecializationType</a></td></tr>
<tr class="memdesc:a2fa868bfe1462fc934f1a64bad7d856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template specialization types.  <a href="namespaceclang_1_1ast__matchers.html#a2fa868bfe1462fc934f1a64bad7d856d">More...</a><br /></td></tr>
<tr class="separator:a2fa868bfe1462fc934f1a64bad7d856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f4487f1a9017a589b1eca7c8f277f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DeducedTemplateSpecializationType.html">DeducedTemplateSpecializationType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a30f4487f1a9017a589b1eca7c8f277f9">deducedTemplateSpecializationType</a></td></tr>
<tr class="memdesc:a30f4487f1a9017a589b1eca7c8f277f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches C++17 deduced template specialization types, e.g.  <a href="namespaceclang_1_1ast__matchers.html#a30f4487f1a9017a589b1eca7c8f277f9">More...</a><br /></td></tr>
<tr class="separator:a30f4487f1a9017a589b1eca7c8f277f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992eb4eee25162bb3cf9eb24bdd387f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1UnaryTransformType.html">UnaryTransformType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab992eb4eee25162bb3cf9eb24bdd387f">unaryTransformType</a></td></tr>
<tr class="memdesc:ab992eb4eee25162bb3cf9eb24bdd387f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types nodes representing unary type transformations.  <a href="namespaceclang_1_1ast__matchers.html#ab992eb4eee25162bb3cf9eb24bdd387f">More...</a><br /></td></tr>
<tr class="separator:ab992eb4eee25162bb3cf9eb24bdd387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2f0de9c9e156981b881b8d5d89aec6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1RecordType.html">RecordType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#abf2f0de9c9e156981b881b8d5d89aec6">recordType</a></td></tr>
<tr class="memdesc:abf2f0de9c9e156981b881b8d5d89aec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches record types (e.g.  <a href="namespaceclang_1_1ast__matchers.html#abf2f0de9c9e156981b881b8d5d89aec6">More...</a><br /></td></tr>
<tr class="separator:abf2f0de9c9e156981b881b8d5d89aec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ff15545b1962675f3b54e94e136b72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TagType.html">TagType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa3ff15545b1962675f3b54e94e136b72">tagType</a></td></tr>
<tr class="memdesc:aa3ff15545b1962675f3b54e94e136b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches tag types (record and enum types).  <a href="namespaceclang_1_1ast__matchers.html#aa3ff15545b1962675f3b54e94e136b72">More...</a><br /></td></tr>
<tr class="separator:aa3ff15545b1962675f3b54e94e136b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138456104e5e77cc8dd42e8a2f6fc8bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a138456104e5e77cc8dd42e8a2f6fc8bf">elaboratedType</a></td></tr>
<tr class="memdesc:a138456104e5e77cc8dd42e8a2f6fc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types specified with an elaborated type keyword or with a qualified name.  <a href="namespaceclang_1_1ast__matchers.html#a138456104e5e77cc8dd42e8a2f6fc8bf">More...</a><br /></td></tr>
<tr class="separator:a138456104e5e77cc8dd42e8a2f6fc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c09ef1f494b514efb2056e08b0f55d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1UsingType.html">UsingType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a8c09ef1f494b514efb2056e08b0f55d8">usingType</a></td></tr>
<tr class="memdesc:a8c09ef1f494b514efb2056e08b0f55d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types specified through a using declaration.  <a href="namespaceclang_1_1ast__matchers.html#a8c09ef1f494b514efb2056e08b0f55d8">More...</a><br /></td></tr>
<tr class="separator:a8c09ef1f494b514efb2056e08b0f55d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fe2d09e8930e40adf164af9377fc44"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ab8fe2d09e8930e40adf164af9377fc44">substTemplateTypeParmType</a></td></tr>
<tr class="memdesc:ab8fe2d09e8930e40adf164af9377fc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches types that represent the result of substituting a type for a template type parameter.  <a href="namespaceclang_1_1ast__matchers.html#ab8fe2d09e8930e40adf164af9377fc44">More...</a><br /></td></tr>
<tr class="separator:ab8fe2d09e8930e40adf164af9377fc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad61df8e618f0aad595f8cbdbc3f644"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#aaad61df8e618f0aad595f8cbdbc3f644">templateTypeParmType</a></td></tr>
<tr class="memdesc:aaad61df8e618f0aad595f8cbdbc3f644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches template type parameter types.  <a href="namespaceclang_1_1ast__matchers.html#aaad61df8e618f0aad595f8cbdbc3f644">More...</a><br /></td></tr>
<tr class="separator:aaad61df8e618f0aad595f8cbdbc3f644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed6218432518ee468d2fae74289a1b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7ed6218432518ee468d2fae74289a1b2">injectedClassNameType</a></td></tr>
<tr class="memdesc:a7ed6218432518ee468d2fae74289a1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches injected class name types.  <a href="namespaceclang_1_1ast__matchers.html#a7ed6218432518ee468d2fae74289a1b2">More...</a><br /></td></tr>
<tr class="separator:a7ed6218432518ee468d2fae74289a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb22e211875d1365ddfdf3a721f63e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DecayedType.html">DecayedType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#adbb22e211875d1365ddfdf3a721f63e6">decayedType</a></td></tr>
<tr class="memdesc:adbb22e211875d1365ddfdf3a721f63e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches decayed type Example matches i[] in declaration of f.  <a href="namespaceclang_1_1ast__matchers.html#adbb22e211875d1365ddfdf3a721f63e6">More...</a><br /></td></tr>
<tr class="separator:adbb22e211875d1365ddfdf3a721f63e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d403e158636a01ed2f43b87029f7cc"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a33d403e158636a01ed2f43b87029f7cc">nestedNameSpecifier</a></td></tr>
<tr class="memdesc:a33d403e158636a01ed2f43b87029f7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches nested name specifiers.  <a href="namespaceclang_1_1ast__matchers.html#a33d403e158636a01ed2f43b87029f7cc">More...</a><br /></td></tr>
<tr class="separator:a33d403e158636a01ed2f43b87029f7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58010de6c771b8d3deea3f55c1a208f7"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a58010de6c771b8d3deea3f55c1a208f7">nestedNameSpecifierLoc</a></td></tr>
<tr class="memdesc:a58010de6c771b8d3deea3f55c1a208f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>nestedNameSpecifier</code> but matches <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html" title="A C++ nested-name-specifier augmented with source location information.">NestedNameSpecifierLoc</a></code>.  <a href="namespaceclang_1_1ast__matchers.html#a58010de6c771b8d3deea3f55c1a208f7">More...</a><br /></td></tr>
<tr class="separator:a58010de6c771b8d3deea3f55c1a208f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44173f6c846c27df62f0f56fc741534c"><td class="memItemLeft" align="right" valign="top">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a44173f6c846c27df62f0f56fc741534c">attr</a></td></tr>
<tr class="memdesc:a44173f6c846c27df62f0f56fc741534c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches attributes.  <a href="namespaceclang_1_1ast__matchers.html#a44173f6c846c27df62f0f56fc741534c">More...</a><br /></td></tr>
<tr class="separator:a44173f6c846c27df62f0f56fc741534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99eeac842695b2fd84e506a06f0d2de"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CUDAKernelCallExpr.html">CUDAKernelCallExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#ae99eeac842695b2fd84e506a06f0d2de">cudaKernelCallExpr</a></td></tr>
<tr class="memdesc:ae99eeac842695b2fd84e506a06f0d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches CUDA kernel call expression.  <a href="namespaceclang_1_1ast__matchers.html#ae99eeac842695b2fd84e506a06f0d2de">More...</a><br /></td></tr>
<tr class="separator:ae99eeac842695b2fd84e506a06f0d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a4fde56ab996048a27733bdbe3f80f"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a38a4fde56ab996048a27733bdbe3f80f">ompExecutableDirective</a></td></tr>
<tr class="memdesc:a38a4fde56ab996048a27733bdbe3f80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches any <code>#pragma omp</code> executable directive.  <a href="namespaceclang_1_1ast__matchers.html#a38a4fde56ab996048a27733bdbe3f80f">More...</a><br /></td></tr>
<tr class="separator:a38a4fde56ab996048a27733bdbe3f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7936cb99a469a161f6ad457bda882628"><td class="memItemLeft" align="right" valign="top">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1OMPClause.html">OMPClause</a>, <a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceclang_1_1ast__matchers.html#a7936cb99a469a161f6ad457bda882628">ompDefaultClause</a></td></tr>
<tr class="memdesc:a7936cb99a469a161f6ad457bda882628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches OpenMP <code>default</code> clause.  <a href="namespaceclang_1_1ast__matchers.html#a7936cb99a469a161f6ad457bda882628">More...</a><br /></td></tr>
<tr class="separator:a7936cb99a469a161f6ad457bda882628"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8ae01b358e8e1f82b6e2fcd501dc62c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae01b358e8e1f82b6e2fcd501dc62c3">&#9670;&nbsp;</a></span>AstTypeMatcher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">clang::ast_matchers::AstTypeMatcher</a> = typedef internal::VariadicDynCastAllOfMatcher&lt;<a class="el" href="classclang_1_1Type.html">Type</a>, NodeType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06664">6664</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae630e7cbe46a84b8fc8d82aa73bef513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae630e7cbe46a84b8fc8d82aa73bef513">&#9670;&nbsp;</a></span>AttrMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#ae630e7cbe46a84b8fc8d82aa73bef513">clang::ast_matchers::AttrMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1Attr.html">Attr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00152">152</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8fe75f9908666b35bf60b93a4e7df6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe75f9908666b35bf60b93a4e7df6c5">&#9670;&nbsp;</a></span>CXXBaseSpecifierMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a8fe75f9908666b35bf60b93a4e7df6c5">clang::ast_matchers::CXXBaseSpecifierMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00147">147</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a879280309828cf280ce62817f2701614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879280309828cf280ce62817f2701614">&#9670;&nbsp;</a></span>CXXCtorInitializerMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a879280309828cf280ce62817f2701614">clang::ast_matchers::CXXCtorInitializerMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00148">148</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a22b3e62e1b83cda2c7a5d9fc0f14f5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b3e62e1b83cda2c7a5d9fc0f14f5cf">&#9670;&nbsp;</a></span>DeclarationMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a22b3e62e1b83cda2c7a5d9fc0f14f5cf">clang::ast_matchers::DeclarationMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1Decl.html">Decl</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of matchers for the top-level classes in the AST class hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00141">141</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aecf82c63cac9c4dced3d2faf3912ab17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf82c63cac9c4dced3d2faf3912ab17">&#9670;&nbsp;</a></span>LambdaCaptureMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#aecf82c63cac9c4dced3d2faf3912ab17">clang::ast_matchers::LambdaCaptureMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00151">151</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aeee46b26cfe48a6df2f371bcde88bcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee46b26cfe48a6df2f371bcde88bcfc">&#9670;&nbsp;</a></span>NestedNameSpecifierLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#aeee46b26cfe48a6df2f371bcde88bcfc">clang::ast_matchers::NestedNameSpecifierLocMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00146">146</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2548d559e30a3a461712d0c3a3a70ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2548d559e30a3a461712d0c3a3a70ea3">&#9670;&nbsp;</a></span>NestedNameSpecifierMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a2548d559e30a3a461712d0c3a3a70ea3">clang::ast_matchers::NestedNameSpecifierMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00145">145</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aac1d4a43f06a6eaa2702a396b8a7b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d4a43f06a6eaa2702a396b8a7b88d">&#9670;&nbsp;</a></span>StatementMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">clang::ast_matchers::StatementMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a52">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00142">142</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ab0c3164183070e70d8078bd3f5dff9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3164183070e70d8078bd3f5dff9b9">&#9670;&nbsp;</a></span>TemplateArgumentLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#ab0c3164183070e70d8078bd3f5dff9b9">clang::ast_matchers::TemplateArgumentLocMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00150">150</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="adffdac2f5762fbfb7e2c6d7cef796b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffdac2f5762fbfb7e2c6d7cef796b12">&#9670;&nbsp;</a></span>TemplateArgumentMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#adffdac2f5762fbfb7e2c6d7cef796b12">clang::ast_matchers::TemplateArgumentMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00149">149</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aadd99513755b5e66e17c365f0a59ab03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd99513755b5e66e17c365f0a59ab03">&#9670;&nbsp;</a></span>TypeLocMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#aadd99513755b5e66e17c365f0a59ab03">clang::ast_matchers::TypeLocMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00144">144</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a043260ed0c88f92c8415495872f1de99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043260ed0c88f92c8415495872f1de99">&#9670;&nbsp;</a></span>TypeMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceclang_1_1ast__matchers.html#a043260ed0c88f92c8415495872f1de99">clang::ast_matchers::TypeMatcher</a> = typedef internal::Matcher&lt;<a class="el" href="classclang_1_1QualType.html">QualType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00143">143</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1c8d79365d495125b8c32aa08e15ae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8d79365d495125b8c32aa08e15ae9d">&#9670;&nbsp;</a></span>GtestCmp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">clang::ast_matchers::GtestCmp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gtest's comparison operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da4dec99baa99738721da9c9b0c1a92498"></a>Ne&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9dac6a675552648c0becb8283f05c172483"></a>Ge&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9dabccd5ec3ec8fd3a4471e71e9b407c60c"></a>Le&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c8d79365d495125b8c32aa08e15ae9da50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8h_source.html#l00025">25</a> of file <a class="el" href="GtestMatchers_8h_source.html">GtestMatchers.h</a>.</p>

</div>
</div>
<a id="a10b507ef98509576ab7fa90acdc3920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b507ef98509576ab7fa90acdc3920d">&#9670;&nbsp;</a></span>MockArgs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">clang::ast_matchers::MockArgs</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This enum indicates whether the mock method in the matched ON_CALL or EXPECT_CALL macro has arguments. </p>
<p>For example, <code>None</code> can be used to match <code>ON_CALL(mock, TwoParamMethod)</code> whereas <code>Some</code> can be used to match <code>ON_CALL(mock, TwoParamMethod(m1, m2))</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a10b507ef98509576ab7fa90acdc3920da6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a10b507ef98509576ab7fa90acdc3920da695c6ae413c00446733d926ccadefd8b"></a>Some&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8h_source.html#l00038">38</a> of file <a class="el" href="GtestMatchers_8h_source.html">GtestMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a10baaee079ba40b644bd702d1af7a6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10baaee079ba40b644bd702d1af7a6ce">&#9670;&nbsp;</a></span>alignOfExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::alignOfExpr </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unaryExprOrTypeTraitExpr, but only matching alignof. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02961">2961</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a652afe55bf376c9c0789d550409d90fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652afe55bf376c9c0789d550409d90fe">&#9670;&nbsp;</a></span>anything()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::TrueMatcher clang::ast_matchers::anything </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches any node. </p>
<p>Useful when another matcher requires a child matcher, but there's no additional constraint. This will often be used with an explicit conversion to an <code>internal::Matcher&lt;&gt;</code> type such as <code>TypeMatcher</code>.</p>
<p>Example: <code>DeclarationMatcher(anything())</code> matches all declarations, e.g., </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;int* p&quot;</span> <a class="code" href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> <span class="stringliteral">&quot;void f()&quot;</span> in</div>
<div class="line">  <span class="keywordtype">int</span>* p;</div>
<div class="line">  <span class="keywordtype">void</span> f();</div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00169">169</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a0edfa6373df58e343d19f5d2679991d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edfa6373df58e343d19f5d2679991d1">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[1/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">usesADL&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches call expressions which were resolved using ADL. </p>
<p>Example matches y(x) but not y(42) or NS::y(x). </p><div class="fragment"><div class="line">      <span class="keyword">namespace </span>NS {</div>
<div class="line">        <span class="keyword">struct </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line">        <span class="keywordtype">void</span> y(<a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>);</div>
<div class="line">      }</div>
<div class="line">   </div>
<div class="line">      <span class="keywordtype">void</span> y(...);</div>
<div class="line">   </div>
<div class="line">      <span class="keywordtype">void</span> test() {</div>
<div class="line">        <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">NS::X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">        y(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>); <span class="comment">// Matches</span></div>
<div class="line">        NS::y(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>); <span class="comment">// Doesn&#39;t match</span></div>
<div class="line">        y(42); <span class="comment">// Doesn&#39;t match</span></div>
<div class="line">        <span class="keyword">using</span> NS::y;</div>
<div class="line">        y(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>); <span class="comment">// Found by both unqualified lookup and ADL, doesn&#39;t match</span></div>
<div class="line"><span class="comment">//    }</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01486">1486</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a75db3620648d58f6be5e799142f86a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75db3620648d58f6be5e799142f86a31">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[2/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isCatchAll&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ catch statement that has a catch-all handler. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keywordtype">int</span>) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">} <span class="keywordflow">catch</span> (...) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> cxxCatchStmt(isCatchAll()) matches catch(...) but not catch(int). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04480">4480</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8113d0616cb8189881b650642e748512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8113d0616cb8189881b650642e748512">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[3/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isListInitialization&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor call expression which uses list initialization. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04716">4716</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a5125c811ce3f78efc6ab3c5a1bf68362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5125c811ce3f78efc6ab3c5a1bf68362">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[4/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">requiresZeroInitialization&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor call expression which requires zero initialization. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keyword">struct </span>point { <span class="keywordtype">double</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <span class="keywordtype">double</span> y; };</div>
<div class="line">  point pt[2] = { { 1.0, 2.0 } };</div>
<div class="line">}</div>
</div><!-- fragment --><p> initListExpr(has(cxxConstructExpr(requiresZeroInitialization())) will match the implicit array filler for pt[1]. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04732">4732</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ac6d1631ee2a7d6376f6edd8a1aa11335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d1631ee2a7d6376f6edd8a1aa11335">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[5/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isCopyConstructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor declarations that are copy constructors. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(); <span class="comment">// #1</span></div>
<div class="line">  S(<span class="keyword">const</span> S &amp;); <span class="comment">// #2</span></div>
<div class="line">  S(S &amp;&amp;); <span class="comment">// #3</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(isCopyConstructor()) will match #2, but not #1 or #3. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07565">7565</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad600c3f4a2cd82f23eda8276ab3e61be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad600c3f4a2cd82f23eda8276ab3e61be">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[6/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isDefaultConstructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor declarations that are default constructors. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(); <span class="comment">// #1</span></div>
<div class="line">  S(<span class="keyword">const</span> S &amp;); <span class="comment">// #2</span></div>
<div class="line">  S(S &amp;&amp;); <span class="comment">// #3</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(isDefaultConstructor()) will match #1, but not #2 or #3. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07595">7595</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ab6ccec7a66d7aed8d9a7e852213b596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ccec7a66d7aed8d9a7e852213b596b">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[7/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isDelegatingConstructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructors that delegate to another constructor. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(); <span class="comment">// #1</span></div>
<div class="line">  S(<span class="keywordtype">int</span>) {} <span class="comment">// #2</span></div>
<div class="line">  S(S &amp;&amp;) : S() {} <span class="comment">// #3</span></div>
<div class="line">};</div>
<div class="line">S::S() : S(0) {} <span class="comment">// #4</span></div>
</div><!-- fragment --><p> cxxConstructorDecl(isDelegatingConstructor()) will match #3 and #4, but not #1 or #2. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07612">7612</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a00e5003965a3d46728b1fd843fb29cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e5003965a3d46728b1fd843fb29cf3">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[8/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInheritingConstructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05996">5996</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aa3964182fd77de56ef99d2a8b637a575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3964182fd77de56ef99d2a8b637a575">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[9/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMoveConstructor&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor declarations that are move constructors. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(); <span class="comment">// #1</span></div>
<div class="line">  S(<span class="keyword">const</span> S &amp;); <span class="comment">// #2</span></div>
<div class="line">  S(S &amp;&amp;); <span class="comment">// #3</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(isMoveConstructor()) will match #3, but not #1 or #2. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07580">7580</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a151df67d97404bc1b336c5dfc6d01951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151df67d97404bc1b336c5dfc6d01951">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[10/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isBaseInitializer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is initializing a base, as opposed to a member. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B {};</div>
<div class="line"><span class="keyword">struct </span>D : B {</div>
<div class="line">  <span class="keywordtype">int</span> I;</div>
<div class="line">  D(<span class="keywordtype">int</span> i) : I(i) {}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>E : B {</div>
<div class="line">  E() : B() {}</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isBaseInitializer())) will match E(), but not match D(int). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04579">4579</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a4740b640dfb1653cfed5729b59331761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b640dfb1653cfed5729b59331761">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[11/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMemberInitializer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is initializing a member, as opposed to a base. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B {};</div>
<div class="line"><span class="keyword">struct </span>D : B {</div>
<div class="line">  <span class="keywordtype">int</span> I;</div>
<div class="line">  D(<span class="keywordtype">int</span> i) : I(i) {}</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>E : B {</div>
<div class="line">  E() : B() {}</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isMemberInitializer())) will match D(int), but not match E(). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04599">4599</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a03f7a8a989c0ca1eaa26b3045b1ceaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f7a8a989c0ca1eaa26b3045b1ceaab">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[12/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isWritten&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer if it is explicitly written in code (as opposed to implicitly added by the compiler). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() { }</div>
<div class="line">  Foo(<span class="keywordtype">int</span>) : foo_(<span class="stringliteral">&quot;A&quot;</span>) { }</div>
<div class="line">  <span class="keywordtype">string</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(hasAnyConstructorInitializer(isWritten())) will match Foo(int), but not Foo() </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04559">4559</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8435f1b9638bfcb614dd2f94f6a777ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8435f1b9638bfcb614dd2f94f6a777ae">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[13/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isConst&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration is const. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">  <span class="keywordtype">void</span> foo() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> bar();</div>
<div class="line">};</div>
</div><!-- fragment --><p>cxxMethodDecl(isConst()) matches A::foo() but not A::bar() </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06046">6046</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a70216ae4b468a7691f86871be8d47a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70216ae4b468a7691f86871be8d47a44">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[14/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isCopyAssignmentOperator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration declares a copy assignment operator. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">  A &amp;operator=(<span class="keyword">const</span> A &amp;);</div>
<div class="line">  A &amp;operator=(A &amp;&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p>cxxMethodDecl(isCopyAssignmentOperator()) matches the first method but not the second one. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06063">6063</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a51acef6bdde0954f5381dd824d2a8ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acef6bdde0954f5381dd824d2a8ee2">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[15/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMoveAssignmentOperator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration declares a move assignment operator. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A {</div>
<div class="line">  A &amp;operator=(<span class="keyword">const</span> A &amp;);</div>
<div class="line">  A &amp;operator=(A &amp;&amp;);</div>
<div class="line">};</div>
</div><!-- fragment --><p>cxxMethodDecl(isMoveAssignmentOperator()) matches the second method but not the first one. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06080">6080</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8d1af9627f2b938ceade2b02b4cf1442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1af9627f2b938ceade2b02b4cf1442">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[16/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isOverride&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration overrides another method. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>();</div>
<div class="line">};</div>
</div><!-- fragment --><p> matches B::x </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06098">6098</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a3da68121f6bf340c733d85b7a7239850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da68121f6bf340c733d85b7a7239850">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[17/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isPure&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration is pure. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p> matches A::x </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06031">6031</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a4d7424217be877dfb6d2ae56e28009ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7424217be877dfb6d2ae56e28009ad">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[18/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isUserProvided&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches method declarations that are user-provided. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(); <span class="comment">// #1</span></div>
<div class="line">  S(<span class="keyword">const</span> S &amp;) = <span class="keywordflow">default</span>; <span class="comment">// #2</span></div>
<div class="line">  S(S &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// #3</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxConstructorDecl(isUserProvided()) will match #1, but not #2 or #3. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06113">6113</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2f9aeed83b57735c38c8d8e9f22f2192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9aeed83b57735c38c8d8e9f22f2192">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[19/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isVirtualAsWritten&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method declaration has an explicit "virtual". </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>();</div>
<div class="line">};</div>
</div><!-- fragment --><p> matches A::x but not B::x </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05992">5992</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8b7ef6cf6a860c83a65b4fb1f205690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7ef6cf6a860c83a65b4fb1f205690e">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[20/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isArray&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches array new expressions. </p>
<p>Given: </p><div class="fragment"><div class="line">MyClass *p1 = <span class="keyword">new</span> MyClass[10];</div>
</div><!-- fragment --><p> cxxNewExpr(isArray()) matches the expression 'new MyClass[10]'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08052">8052</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a850452e839bfb6e00fe566ed8341c6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850452e839bfb6e00fe566ed8341c6f8">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[21/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="DynamicTypeChecker_8cpp.html#a900bedab3071753a7a3b3ee0fd4bcb74">hasDefinition</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a class declaration that is defined. </p>
<p>Example matches x (matcher = cxxRecordDecl(hasDefinition())) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> {};</div>
<div class="line"><span class="keyword">class </span>y;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08105">8105</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae1b1b3c472ca3262e95b5a2eefa63b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b1b3c472ca3262e95b5a2eefa63b7e">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[22/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isLambda&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the generated class of lambda expressions. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = []{};</div>
</div><!-- fragment --><p><code>cxxRecordDecl(isLambda())</code> matches the implicit class declaration of <code>decltype(x)</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03369">3369</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="afb9c5b2c07f8f8e332a6248e95e75c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9c5b2c07f8f8e332a6248e95e75c55">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[23/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInStdNamespace&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations in the namespace <code>std</code>, but not in nested namespaces. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>vector {};</div>
<div class="line"><span class="keyword">namespace </span>foo {</div>
<div class="line">  <span class="keyword">class </span>vector {};</div>
<div class="line">  <span class="keyword">namespace </span><a class="code" href="namespacestd.html">std</a> {</div>
<div class="line">    <span class="keyword">class </span>vector {};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacestd.html">std</a> {</div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">namespace </span>__1 {</div>
<div class="line">    <span class="keyword">class </span>vector {}; <span class="comment">// #1</span></div>
<div class="line">    <span class="keyword">namespace </span>experimental {</div>
<div class="line">      <span class="keyword">class </span>vector {};</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> cxxRecordDecl(hasName("vector"), isInStdNamespace()) will match only #1. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07739">7739</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2d428c79f2cc613530525c2b9412ab20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d428c79f2cc613530525c2b9412ab20">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[24/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isScoped&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++11 scoped enum declaration. </p>
<p>Example matches Y (matcher = enumDecl(isScoped())) </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">enum class</span> Y {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08116">8116</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a833e412dcf7c56f98cd2f63b7ef6dc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e412dcf7c56f98cd2f63b7ef6dc93">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[25/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInstantiationDependent&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that are instantiation-dependent even if it is neither type- nor value-dependent. </p>
<p>In the following example, the expression sizeof(sizeof(T() + T())) is instantiation-dependent (since it involves a template parameter T), but is neither type- nor value-dependent, since the type of the inner sizeof is known (std::size_t) and therefore the size of the outer sizeof is known. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(T <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, T y) { <span class="keyword">sizeof</span>(<span class="keyword">sizeof</span>(T() + T()); }</div>
</div><!-- fragment --><p> expr(isInstantiationDependent()) matches sizeof(sizeof(T() + T()) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01019">1019</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a00f22eb8aa38e1f695312a09764c34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f22eb8aa38e1f695312a09764c34ef">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[26/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isTypeDependent&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that are type-dependent because the template type is not yet instantiated. </p>
<p>For example, the expressions "x" and "x + y" are type-dependent in the following code, but "y" is not type-dependent: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> add(T <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, <span class="keywordtype">int</span> y) {</div>
<div class="line">  <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> + y;</div>
<div class="line">}</div>
</div><!-- fragment --><p> expr(isTypeDependent()) matches x + y </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01035">1035</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a02d8919c5ecf8f9a9ab153ca646d3a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d8919c5ecf8f9a9ab153ca646d3a6a">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[27/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isValueDependent&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expression that are value-dependent because they contain a non-type template parameter. </p>
<p>For example, the array bound of "Chars" in the following example is value-dependent. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size&gt; <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> <a class="code" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">Size</a>; }</div>
</div><!-- fragment --><p> expr(isValueDependent()) matches return Size </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01046">1046</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ac15b7c8db135d0ff9fb14a612faa14f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b7c8db135d0ff9fb14a612faa14f3">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[28/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isBitField&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that are bit-fields. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a : 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> fieldDecl(isBitField()) matches 'int a;' but not 'int b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00691">691</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a09615f50bf93357b7b6125a05aa4177c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09615f50bf93357b7b6125a05aa4177c">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[29/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasTrailingReturn&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a function declared with a trailing return type. </p>
<p>Example matches Y (matcher = functionDecl(hasTrailingReturn())) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>() {}</div>
<div class="line"><span class="keyword">auto</span> Y() -&gt; <span class="keywordtype">int</span> {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08127">8127</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a04a6edb23b007372acf1505df0a76019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a6edb23b007372acf1505df0a76019">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[30/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isDefaulted&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches defaulted function declarations. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { ~A(); };</div>
<div class="line"><span class="keyword">class </span>B { ~B() = <span class="keywordflow">default</span>; };</div>
</div><!-- fragment --><p> functionDecl(isDefaulted()) matches the declaration of ~B, but not ~A. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05105">5105</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aeeb9eddf358dcb8c8f85861bd308178d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb9eddf358dcb8c8f85861bd308178d">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[31/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isDeleted&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches deleted function declarations. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Func();</div>
<div class="line"><span class="keywordtype">void</span> DeletedFunc() = <span class="keyword">delete</span>;</div>
</div><!-- fragment --><p> functionDecl(isDeleted()) matches the declaration of DeletedFunc, but not Func. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05092">5092</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae5cebfe9c6da04c2d9cfb13a038f0dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5cebfe9c6da04c2d9cfb13a038f0dde">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[32/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isMain&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the function is "main", which is the entry point into an executable program. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00736">736</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a482f6a19376344d86cd5ec9aac7d39fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482f6a19376344d86cd5ec9aac7d39fc">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[33/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isNoReturn&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>FunctionDecls</code> that have a noreturn attribute. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> nope();</div>
<div class="line">[[<a class="code" href="stdnoreturn_8h.html#a4a453f3a748e55cbdac6fcc79357cfef">noreturn</a>]] <span class="keywordtype">void</span> a();</div>
<div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((<a class="code" href="stdnoreturn_8h.html#a4a453f3a748e55cbdac6fcc79357cfef">noreturn</a>)) <span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>();</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> { [[<a class="code" href="stdnoreturn_8h.html#a4a453f3a748e55cbdac6fcc79357cfef">noreturn</a>]] <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(); };</div>
</div><!-- fragment --><p> functionDecl(isNoReturn()) matches all of those except </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> nope();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05028">5028</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a1792b21c372bbe39f6a1d998e9e1ac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1792b21c372bbe39f6a1d998e9e1ac84">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[34/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isVariadic&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a function declaration is variadic. </p>
<p>Example matches f, but not g or h. The function i will not match, even when compiled in C mode. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(...);</div>
<div class="line"><span class="keywordtype">void</span> g(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt; <span class="keywordtype">void</span> h(Ts...);</div>
<div class="line"><span class="keywordtype">void</span> i();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05881">5881</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a94d84f589f05d59fa13d516934b15077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d84f589f05d59fa13d516934b15077">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[35/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isWeak&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches weak function declarations. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() <a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((__weakref__(&quot;__foo&quot;)));</div>
<div class="line"><span class="keywordtype">void</span> bar();</div>
</div><!-- fragment --><p> functionDecl(isWeak()) matches the weak declaration "foo", but not "bar". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05118">5118</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a39c4cdd5e71df74ae03654ec95477167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c4cdd5e71df74ae03654ec95477167">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[36/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">capturesThis&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classclang_1_1LambdaCapture.html" title="Describes the capture of a variable or of this, or of a C++1y init-capture.">LambdaCapture</a></code> that refers to 'this'. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> cc;</div>
<div class="line">  <span class="keywordtype">int</span> f() {</div>
<div class="line">    <span class="keyword">auto</span> l = [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> cc; };</div>
<div class="line">    <span class="keywordflow">return</span> l();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> lambdaExpr(hasAnyCapture(lambdaCapture(capturesThis()))) matches <code>[this]() { return cc; }</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04713">4713</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad8aea4baa7212cbc8faac94018f329ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8aea4baa7212cbc8faac94018f329ba">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[37/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasExternalFormalLinkage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration that has external formal linkage. </p>
<p>Example matches only z (matcher = varDecl(hasExternalFormalLinkage())) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> z;</div>
</div><!-- fragment --><p>Example matches f() because it has external formal linkage despite being unique to the translation unit as though it has internal likage (matcher = functionDecl(hasExternalFormalLinkage()))</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"><span class="keywordtype">void</span> f() {}</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08015">8015</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="abb6023a3bfaeeb3044f730c854d1c18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6023a3bfaeeb3044f730c854d1c18d">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[38/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAnonymous&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches anonymous namespace declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>n {</div>
<div class="line"><span class="keyword">namespace </span>{} <span class="comment">// #1</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> namespaceDecl(isAnonymous()) will match #1 but not ::n. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07714">7714</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a210ce15787ad4e0ef9f5f8bdd0b1b7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ce15787ad4e0ef9f5f8bdd0b1b7b3">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[39/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasKeywordSelector&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is a keyword selector. </p>
<p>objCMessageExpr(hasKeywordSelector()) matches the generated setFrame message expression in</p>
<div class="fragment"><div class="line">UIWebView *webView = ...;</div>
<div class="line">CGRect bodyFrame = webView.frame;</div>
<div class="line">bodyFrame.size.height = <span class="keyword">self</span>.bodyContentHeight;</div>
<div class="line">webView.frame = bodyFrame;</div>
<div class="line"><span class="comment">//     ^---- matches here</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03790">3790</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a38f55858b223a0e11066738f16c77a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f55858b223a0e11066738f16c77a25">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[40/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasNullSelector&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is the empty selector. </p>
<p>Matches only when the selector of the objCMessageExpr is NULL. This may represent an error condition in the tree! </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03762">3762</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="affe17436c3837899bc7a1f07dd6c23f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe17436c3837899bc7a1f07dd6c23f8">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[41/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnarySelector&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector is a Unary <a class="el" href="classclang_1_1Selector.html" title="Smart pointer class that efficiently represents Objective-C method names.">Selector</a>. </p>
<p>matcher = objCMessageExpr(matchesSelector(hasUnarySelector()); matches self.bodyView in the code below, but NOT the outer message invocation of "loadHTMLString:baseURL:". </p><div class="fragment"><div class="line">[<span class="keyword">self</span>.bodyView loadHTMLString:html baseURL:<a class="code" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03774">3774</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a50ccba02e6d782bd0ffda74eef632efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ccba02e6d782bd0ffda74eef632efc">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[42/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isClassMessage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C message is sent to a class. </p>
<p>Example matcher = objcMessageExpr(isClassMessage()) matches </p><div class="fragment"><div class="line">[NSString stringWithFormat:<span class="stringliteral">@&quot;format&quot;</span>];</div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line">NSString *<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03679">3679</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a4ac3bec31f7eb8625530f52cf6f5a87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3bec31f7eb8625530f52cf6f5a87f">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[43/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInstanceMessage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C message is sent to an instance. </p>
<p>Example matcher = objcMessageExpr(isInstanceMessage()) matches </p><div class="fragment"><div class="line">NSString *<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line">[NSString stringWithFormat:<span class="stringliteral">@&quot;format&quot;</span>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03696">3696</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="abed7081a3099b4c413dd177c4c00559c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed7081a3099b4c413dd177c4c00559c">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[44/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isClassMethod&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C method declaration is a class method. </p>
<p>Example matcher = objcMethodDecl(isClassMethod()) matches </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I + (void)foo; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void)bar; <span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03646">3646</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="adae407a60668f5aeb7fb497b64762b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae407a60668f5aeb7fb497b64762b8d">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[45/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SemaDeclAttr_8cpp.html#ad35282e02924165aae3b360b22ab028e">isInstanceMethod</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when the Objective-C method declaration is an instance method. </p>
<p>Example matcher = objcMethodDecl(isInstanceMethod()) matches </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void)bar; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> but not </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I + (void)foo; <span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03662">3662</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aefd7e8e64044ad79b73296c2c76605fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd7e8e64044ad79b73296c2c76605fb">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[46/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isFirstPrivateKind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the OpenMP <code>default</code> clause has <code>firstprivate</code> kind specified. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(shared)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(firstprivate)</span></div>
</div><!-- fragment --><p><code>ompDefaultClause(isFirstPrivateKind())</code> matches only <code>default(firstprivate)</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08318">8318</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae472248d0b5c303b822a7d56faf7448e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae472248d0b5c303b822a7d56faf7448e">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[47/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isNoneKind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the OpenMP <code>default</code> clause has <code>none</code> kind specified. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(shared)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(firstprivate)</span></div>
</div><!-- fragment --><p><code>ompDefaultClause(isNoneKind())</code> matches only <code>default(none)</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08284">8284</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aa8b25f8e3090e6647c4a1ed65d96d219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b25f8e3090e6647c4a1ed65d96d219">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[48/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isSharedKind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the OpenMP <code>default</code> clause has <code>shared</code> kind specified. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(shared)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(firstprivate)</span></div>
</div><!-- fragment --><p><code>ompDefaultClause(isSharedKind())</code> matches only <code>default(shared)</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08300">8300</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="abcc2672b07a0daec274bac69ed423c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc2672b07a0daec274bac69ed423c46">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[49/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isStandaloneDirective&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches standalone OpenMP directives, i.e., directives that can't have a structured block. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line">{}</div>
<div class="line"><span class="preprocessor">#pragma omp taskyield</span></div>
</div><!-- fragment --><p><code>ompExecutableDirective(isStandaloneDirective()))</code> matches <code>omp taskyield</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08211">8211</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a5f47d57c87bec70a8f07a0fbded588fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47d57c87bec70a8f07a0fbded588fc">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[50/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDefaultArgument&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration that has default arguments. </p>
<p>Example matches y (matcher = parmVarDecl(hasDefaultArgument())) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(<span class="keywordtype">int</span> val) {}</div>
<div class="line"><span class="keywordtype">void</span> y(<span class="keywordtype">int</span> val = 0) {}</div>
</div><!-- fragment --><p>Deprecated. Use hasInitializer() instead to be able to match on the contents of the default argument. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(<span class="keywordtype">int</span> val = 7) {}</div>
<div class="line"><span class="keywordtype">void</span> y(<span class="keywordtype">int</span> val = 42) {}</div>
</div><!-- fragment --><p> parmVarDecl(hasInitializer(integerLiteral(equals(42)))) matches the parameter of y</p>
<p>A matcher such as parmVarDecl(hasInitializer(anything())) is equivalent to parmVarDecl(hasDefaultArgument()). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08040">8040</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a730656106bd2b8e38948dc278fd83a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730656106bd2b8e38948dc278fd83a39">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[51/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLocalQualifiers&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that have local CV-qualifiers attached to the node, not hidden within a typedef. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">int</span> const_int;</div>
<div class="line">const_int i;</div>
<div class="line"><span class="keywordtype">int</span> *<span class="keyword">const</span> j;</div>
<div class="line"><span class="keywordtype">int</span> *<span class="keyword">volatile</span> k;</div>
<div class="line"><span class="keywordtype">int</span> m;</div>
</div><!-- fragment --><p> <code>varDecl</code>(hasType(hasLocalQualifiers())) matches only <code>j</code> and <code>k</code>. <code>i</code> is const-qualified but the qualifier is not local. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06274">6274</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a4d9e710b1308cae72a0cb67631f93bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e710b1308cae72a0cb67631f93bad">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[52/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAnyCharacter&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of character type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">char</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">wchar_t</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keywordtype">double</span>);</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isAnyCharacter()))) matches "a(char)", "b(wchar_t)", but not "c(double)". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06199">6199</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2e5b77763e9db8d70b6b9ed859feae02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5b77763e9db8d70b6b9ed859feae02">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[53/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAnyPointer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of any pointer type; this includes the Objective-C object pointer type, which is different despite being syntactically similar. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *i = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line">Foo *f;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> j;</div>
</div><!-- fragment --><p> varDecl(hasType(isAnyPointer())) matches "int *i" and "Foo *f", but not "int j". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06219">6219</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="abac8c30a5b2e273349949e39762f51f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac8c30a5b2e273349949e39762f51f3">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[54/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isConstQualified&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are const-qualified, i.e., that include "top-level" const. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">int</span> <span class="keyword">const</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> d(<span class="keyword">const</span> <span class="keywordtype">int</span>*);</div>
<div class="line"><span class="keywordtype">void</span> e(<span class="keywordtype">int</span> <span class="keyword">const</span>) {};</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isConstQualified()))) matches "void b(int const)", "void c(const int)" and "void e(int const) {}". It does not match d as there is no top-level const on the parameter type "const int *". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06238">6238</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ab4a73bbb88280b57b26efebd78dbf1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a73bbb88280b57b26efebd78dbf1d0">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[55/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInteger&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of integer type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">long</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keywordtype">double</span>);</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isInteger()))) matches "a(int)", "b(long)", but not "c(double)". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06157">6157</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="accdadfba0b95c13792be8ee05ac17cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdadfba0b95c13792be8ee05ac17cb8">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[56/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isSignedInteger&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of signed integer type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keywordtype">double</span>);</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isSignedInteger()))) matches "a(int)", but not "b(unsigned long)" and "c(double)". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06185">6185</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="afd461383edbc3b0fb25d468361da60c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd461383edbc3b0fb25d468361da60c8">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[57/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isUnsignedInteger&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are of unsigned integer type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keywordtype">double</span>);</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isUnsignedInteger()))) matches "b(unsigned long)", but not "a(int)" and "c(double)". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06171">6171</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a928d648df28587f0db52a54783c7ae00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d648df28587f0db52a54783c7ae00">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[58/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isVolatileQualified&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a> nodes that are volatile-qualified, i.e., that include "top-level" volatile. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> a(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(<span class="keywordtype">int</span> <span class="keyword">volatile</span>);</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(<span class="keyword">volatile</span> <span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> d(<span class="keyword">volatile</span> <span class="keywordtype">int</span>*);</div>
<div class="line"><span class="keywordtype">void</span> e(<span class="keywordtype">int</span> <span class="keyword">volatile</span>) {};</div>
</div><!-- fragment --><p> functionDecl(hasAnyParameter(hasType(isVolatileQualified()))) matches "void b(int volatile)", "void c(volatile int)" and "void e(int volatile) {}". It does not match d as there is no top-level volatile on the parameter type "volatile int *". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06257">6257</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a84d392366262bf6fc023e6b94ecbccde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d392366262bf6fc023e6b94ecbccde">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[59/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isClass&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "class.". </p>
<p>Example matches C, but not S, <a class="el" href="classU.html">U</a> or E. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05794">5794</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad334219b265c85cede50cbc80b8c86b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad334219b265c85cede50cbc80b8c86b7">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[60/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isEnum&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "enum.". </p>
<p>Example matches E, but not C, S or <a class="el" href="classU.html">U</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05807">5807</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a12f139141766e6fd227fce08a3782f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f139141766e6fd227fce08a3782f2d">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[61/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isStruct&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "struct.". </p>
<p>Example matches S, but not C, <a class="el" href="classU.html">U</a> or E. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05768">5768</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a0a33ea23e6d76e2dc1b49c24ad6280eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a33ea23e6d76e2dc1b49c24ad6280eb">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[62/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isUnion&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1TagDecl.html" title="Represents the declaration of a struct/union/class/enum.">TagDecl</a> object that are spelled with "union.". </p>
<p>Example matches <a class="el" href="classU.html">U</a>, but not C, S or E. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05781">5781</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a372ddae878809019381acb68314cb048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372ddae878809019381acb68314cb048">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[63/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isIntegral&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that is an integral value. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;42&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(isIntegral())) matches the implicit instantiation of C in C&lt;42&gt; with isIntegral() matching 42. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01181">1181</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00082">clang::TemplateArgument::Integral</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8ff857767d820b98d6f4fa2f237950cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff857767d820b98d6f4fa2f237950cf">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[64/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">booleanType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type <code>bool</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S { <span class="keywordtype">bool</span> func(); };</div>
</div><!-- fragment --><p> functionDecl(returns(booleanType())) matches "bool func();" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06647">6647</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a088f20af5398aa43186617f8e9717cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088f20af5398aa43186617f8e9717cb5">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[65/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realFloatingPointType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any real floating-point type (float, double, long double). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordtype">float</span> f;</div>
</div><!-- fragment --><p> realFloatingPointType() matches "float f" but not "int i" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06711">6711</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a729714cdf1308ca2a14ee48e79528817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729714cdf1308ca2a14ee48e79528817">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[66/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">voidType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type <code>void</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S { <span class="keywordtype">void</span> func(); };</div>
</div><!-- fragment --><p> functionDecl(returns(voidType())) matches "void func();" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06659">6659</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a1491a3107fcb1a9823b82f0e0d2c8f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491a3107fcb1a9823b82f0e0d2c8f8b">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[67/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAutomaticStorageDuration&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has automatic storage duration. </p>
<p>Example matches x, but not y, z, or a. (matcher = varDecl(hasAutomaticStorageDuration()) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  thread_local <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04310">4310</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00308">clang::SD_Automatic</a>.</p>

</div>
</div>
<a id="a9fb8c35f77273ca8c9d74d3ccd8115ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8c35f77273ca8c9d74d3ccd8115ee">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[68/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasGlobalStorage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that does not have local storage. </p>
<p>Example matches y and z (matcher = varDecl(hasGlobalStorage()) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04294">4294</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a20615f964d0cc210125ba1a7030e1d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20615f964d0cc210125ba1a7030e1d99">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[69/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLocalStorage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has function scope and is a non-static local variable. </p>
<p>Example matches x (matcher = varDecl(hasLocalStorage()) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04280">4280</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="abe1c982b6814464ccb0e81ad49e5deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1c982b6814464ccb0e81ad49e5deb8">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[70/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasStaticStorageDuration&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has static storage duration. </p>
<p>It includes the variable declared at namespace scope and those declared with "static" and "extern" storage class specifiers.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  thread_local <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasStaticStorageDuration())</div>
<div class="line">  <a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> the function declaration y, a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> <a class="code" href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>.</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04330">4330</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00310">clang::SD_Static</a>.</p>

</div>
</div>
<a id="abea11fc4361920f652b8655a7fc1ce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea11fc4361920f652b8655a7fc1ce7a">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[71/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasThreadStorageDuration&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has thread storage duration. </p>
<p>Example matches z, but not x, z, or a. (matcher = varDecl(hasThreadStorageDuration()) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">  thread_local <span class="keywordtype">int</span> z;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04346">4346</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00309">clang::SD_Thread</a>.</p>

</div>
</div>
<a id="a6ee32557ec036b3e0838b05d42b4b831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee32557ec036b3e0838b05d42b4b831">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[72/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isConstinit&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constinit variable declarations. </p>
<p>Given: </p><div class="fragment"><div class="line">constinit <span class="keywordtype">int</span> foo = 42;</div>
<div class="line">constinit <span class="keyword">const</span> <span class="keywordtype">char</span>* bar = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> baz = 42;</div>
<div class="line">[[clang::require_constant_initialization]] <span class="keywordtype">int</span> xyz = 42;</div>
</div><!-- fragment --><p> varDecl(isConstinit()) matches the declaration of <code>foo</code> and <code>bar</code>, but not <code>baz</code> and <code>xyz</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05225">5225</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a5663ab187f13ea8c1a0d3884a5837369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5663ab187f13ea8c1a0d3884a5837369">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[73/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isExceptionVariable&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that is an exception variable from a C++ catch block, or an Objective-C @catch statement. </p>
<p>Example matches x (matcher = varDecl(isExceptionVariable()) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> y) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">  } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) {</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04361">4361</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aef750e09ba850dbea8cc64f23454af0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef750e09ba850dbea8cc64f23454af0f">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[74/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInitCapture&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable serving as the implicit variable for a lambda init- capture. </p>
<p>Example matches x (matcher = varDecl(isInitCapture())) </p><div class="fragment"><div class="line"><span class="keyword">auto</span> f = [<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>=3]() { <span class="keywordflow">return</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04223">4223</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a40b5af78266c07a51fc05b0340faa5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b5af78266c07a51fc05b0340faa5f0">&#9670;&nbsp;</a></span>AST_MATCHER() <span class="overload">[75/75]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isStaticLocal&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a static variable with local scope. </p>
<p>Example matches y (matcher = varDecl(isStaticLocal())) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> y;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> z;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04265">4265</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2745cd447f2bfd8135133ed47eaf614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2745cd447f2bfd8135133ed47eaf614e">&#9670;&nbsp;</a></span>AST_MATCHER_FUNCTION() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInstantiated&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations that are template instantiations or are inside template instantiations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> A(T t) { T i; }</div>
<div class="line">A(0);</div>
<div class="line">A(0<a class="code" href="classU.html">U</a>);</div>
</div><!-- fragment --><p> functionDecl(isInstantiated()) matches 'A(int) {...};' and 'A(unsigned) {...}'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06406">6406</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00745">cxxRecordDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00734">decl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">functionDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01024">hasAncestor</a>, and <a class="el" href="Specifiers_8h_source.html#l00197">clang::isTemplateInstantiation()</a>.</p>

</div>
</div>
<a id="a76c8754d7c61ed2147f7579ee3690487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c8754d7c61ed2147f7579ee3690487">&#9670;&nbsp;</a></span>AST_MATCHER_FUNCTION() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullPointerConstant&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that resolve to a null pointer constant, such as GNU's __null, C++11's nullptr, or C's NULL macro. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> *v1 = <a class="code" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div>
<div class="line"><span class="keywordtype">void</span> *v2 = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="keywordtype">void</span> *v3 = __null; <span class="comment">// GNU extension</span></div>
<div class="line"><span class="keywordtype">char</span> *cp = (<span class="keywordtype">char</span> *)0;</div>
<div class="line"><span class="keywordtype">int</span> *ip = 0;</div>
<div class="line"><span class="keywordtype">int</span> i = 0;</div>
</div><!-- fragment --><p> expr(nullPointerConstant()) matches the initializer for v1, v2, v3, cp, and ip. Does not match the initializer for i. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07816">7816</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00933">cxxNullPtrLiteralExpr</a>, <a class="el" href="ASTMatchers_8h_source.html#l05512">equals()</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00890">expr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00941">gnuNullExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01019">hasParent</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00923">integerLiteral</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01050">pointerType</a>.</p>

</div>
</div>
<a id="aab8d230186d4232b33a6bd1d9062d372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8d230186d4232b33a6bd1d9062d372">&#9670;&nbsp;</a></span>AST_MATCHER_FUNCTION() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isInTemplateInstantiation&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statements inside of a template instantiation. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> j;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> A(T t) { T i; j += 42;}</div>
<div class="line">A(0);</div>
<div class="line">A(0<a class="code" href="classU.html">U</a>);</div>
</div><!-- fragment --><p> declStmt(isInTemplateInstantiation()) matches 'int i;' and 'unsigned i'. unless(stmt(isInTemplateInstantiation())) will NOT match j += 42; as it's shared between the template definition and instantiation. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06426">6426</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">anyOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00745">cxxRecordDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00734">decl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">functionDecl</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01024">hasAncestor</a>, <a class="el" href="Specifiers_8h_source.html#l00197">clang::isTemplateInstantiation()</a>, and <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00810">stmt</a>.</p>

</div>
</div>
<a id="af208b1b6e204747b1aef07708022aec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af208b1b6e204747b1aef07708022aec5">&#9670;&nbsp;</a></span>AST_MATCHER_FUNCTION_P_OVERLOAD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_FUNCTION_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>NestedNameSpecifierLocs</code> for which the given inner NestedNameSpecifier-matcher matches. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07355">7355</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ab3481dc12121ff50b48803a6a867887b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3481dc12121ff50b48803a6a867887b">&#9670;&nbsp;</a></span>AST_MATCHER_FUNCTION_P_OVERLOAD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_FUNCTION_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>TypeLocs</code> for which the given inner QualType-matcher matches. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06452">6452</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9f5b8784e1ef435e2c12993d80053c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5b8784e1ef435e2c12993d80053c97">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[1/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasFalseExpression&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the false branch expression of a conditional operator (binary or ternary). </p>
<p>Example matches b </p><div class="fragment"><div class="line">condition ? a : <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
<div class="line">condition ?: <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05837">5837</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ad6019ff261c2b642ff8dc931abd80b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6019ff261c2b642ff8dc931abd80b67">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[2/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasTrueExpression&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the true branch expression of a conditional operator. </p>
<p>Example 1 (conditional ternary operator): matches a </p><div class="fragment"><div class="line">condition ? a : <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --><p>Example 2 (conditional binary operator): matches opaqueValueExpr(condition) </p><div class="fragment"><div class="line">condition ?: <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05822">5822</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2b2e70bf9f26381c3b9b55582d894db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2e70bf9f26381c3b9b55582d894db7">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[3/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasBase&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the base expression of an array subscript expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i[5];</div>
<div class="line"><span class="keywordtype">void</span> f() { i[1] = 42; }</div>
</div><!-- fragment --><p> arraySubscriptExpression(hasBase(implicitCastExpr( hasSourceExpression(declRefExpr())))) matches <code>i</code>[1] with the <code><a class="el" href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6" title="Matches expressions that refer to declarations.">declRefExpr()</a></code> matching <code>i</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05380">5380</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6bf010352b49cd17b4e902f7bef7ba82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf010352b49cd17b4e902f7bef7ba82">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[4/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasIndex&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the index expression of an array subscript expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i[5];</div>
<div class="line"><span class="keywordtype">void</span> f() { i[1] = 42; }</div>
</div><!-- fragment --><p> arraySubscriptExpression(hasIndex(integerLiteral())) matches <code>i</code>[1] with the <code><a class="el" href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac" title="Matches integer literals of all sizes / encodings, e.g.">integerLiteral()</a></code> matching <code>1</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05363">5363</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af54676e4f255159b2113847a3cd6fb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54676e4f255159b2113847a3cd6fb10">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[5/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1BaseUsingDecl.html">BaseUsingDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyUsingShadowDecl&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any using shadow declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(); }</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">X::b</a>;</div>
</div><!-- fragment --><p> usingDecl(hasAnyUsingShadowDecl(hasName("b")))) matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">X::b</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06334">6334</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aec8cfd5ba82d4ac370c5ff377b728f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8cfd5ba82d4ac370c5ff377b728f46">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[6/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forDecomposition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a> the binding belongs to. </p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> arr[3];</div>
<div class="line">    <span class="keyword">auto</span> &amp;[f, <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>, t] = arr;</div>
<div class="line"> </div>
<div class="line">    f = 42;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">bindingDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;f&quot;</span>),</div>
<div class="line">              forDecomposition(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">decompositionDecl</a>())</div>
</div><!-- fragment --><p> matches 'f' in 'auto &amp;[f, s, t]'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07840">7840</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a09c658c5f5005a9159e4a74960fa3e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c658c5f5005a9159e4a74960fa3e0f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[7/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callee&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the call expression's callee expression matches. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() { this-&gt;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); Y y; y.x(); } };</div>
<div class="line"><span class="keywordtype">void</span> f() { f(); }</div>
</div><!-- fragment --><p> callExpr(callee(expr())) matches this-&gt;<a class="el" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x()</a>, <a class="el" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x()</a>, y.x(), f() with callee(...) matching this-&gt;x, x, y.x, f respectively</p>
<p>Note: Callee cannot take the more general internal::Matcher&lt;Expr&gt; because this introduces ambiguous overloads with calls to Callee taking a internal::Matcher&lt;Decl&gt;, as the matcher hierarchy is purely implemented in terms of implicit casts. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03825">3825</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9a6283f33749110044dc071dd7daafe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6283f33749110044dc071dd7daafe4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[8/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasCaseConstant&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the given case statement does not use the GNU case range extension, matches the constant given in the statement. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (1) { <span class="keywordflow">case</span> 1: <span class="keywordflow">case</span> 1+1: <span class="keywordflow">case</span> 3 ... 4: ; }</div>
</div><!-- fragment --><p> caseStmt(hasCaseConstant(integerLiteral())) matches "case 1:" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07750">7750</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="acaa1d3e00476bc176f02041341776ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa1d3e00476bc176f02041341776ab1">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[9/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CastExpr.html">CastExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasCastKind&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#aa8bdb68daa57cbb2096f354001e2df8c">CastKind</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches casts that has a given cast kind. </p>
<p>Example: matches the implicit cast around <code>0</code> (matcher = castExpr(hasCastKind(CK_NullToPointer))) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *p = 0;</div>
</div><!-- fragment --><p>If the matcher is use from clang-query, CastKind parameter should be passed as a quoted string. e.g., hasCastKind("CK_NullToPointer"). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05736">5736</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a7b30a702681d01ead785188e04457f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b30a702681d01ead785188e04457f92">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[10/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSpecializedTemplate&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the specialized template of a specialization declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {}; #1</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&gt; {}; #2</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasSpecializedTemplate(classTemplateDecl())) matches '#2' with <a class="el" href="namespaceclang_1_1ast__matchers.html#afcdb6ae259330bdf0876aba6e07c8710" title="Matches C++ class template declarations.">classTemplateDecl()</a> matching the class template declaration of 'A' at #1. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00750">750</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a51e8f220890d4edd52d83be0784f917e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e8f220890d4edd52d83be0784f917e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[11/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">statementCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a compound statement contains a specific number of child statements. </p>
<p>Example: Given </p><div class="fragment"><div class="line">{ <span class="keywordflow">for</span> (;;) {} }</div>
</div><!-- fragment --><p> compoundStmt(statementCountIs(0))) matches '{}' but does not match the outer compound statement. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05480">5480</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a4887132c90f8fc757098cc7ae52d1f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4887132c90f8fc757098cc7ae52d1f80">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[12/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forEachConstructorInitializer&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches each constructor initializer in a constructor definition. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { A() : i(42), j(42) {} <span class="keywordtype">int</span> i; <span class="keywordtype">int</span> j; };</div>
</div><!-- fragment --><p> cxxConstructorDecl(forEachConstructorInitializer( forField(<a class="el" href="namespaceclang_1_1ast__matchers.html#ac5ccadfbea5e9e43c2153175afca6cac" title="Matches declarations.">decl()</a>.bind("x")) )) will trigger two matches, binding for 'i' and 'j' respectively. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07537">7537</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a1706a42c87f0ca22a7ab5875eb6d074b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1706a42c87f0ca22a7ab5875eb6d074b">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[13/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyConstructorInitializer&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl( hasAnyConstructorInitializer(anything()) ))) record matches Foo, hasAnyConstructorInitializer matches foo_(1) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04497">4497</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9bdaa82b53209463877c44d74dab03d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdaa82b53209463877c44d74dab03d4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[14/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forField&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the field declaration of a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer( forField(hasName("foo_")))))) matches Foo with forField matching foo_ </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04519">4519</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="abc97227bc2ea23c497ac5c88111fcab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc97227bc2ea23c497ac5c88111fcab7">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[15/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">withInitializer&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initializer expression of a constructor initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  Foo() : foo_(1) { }</div>
<div class="line">  <span class="keywordtype">int</span> foo_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> cxxRecordDecl(has(cxxConstructorDecl(hasAnyConstructorInitializer( withInitializer(integerLiteral(equals(1))))))) matches Foo with withInitializer matching (1) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04539">4539</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ad4754fedaf69686660d1d67816e610cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4754fedaf69686660d1d67816e610cd">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[16/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasMemberName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template-dependent, but known, member names. </p>
<p>In template declarations, dependent members are not resolved and so can not be matched to particular named declarations.</p>
<p>This matcher allows to match on the known name of members.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">    <span class="keywordtype">void</span> mem();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() {</div>
<div class="line">    S&lt;T&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
<div class="line">    <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>.mem();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code>cxxDependentScopeMemberExpr</code>(hasMemberName("mem")) matches <code>s.mem()</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03097">3097</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a1671534b91901a477c76a181b97e4111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1671534b91901a477c76a181b97e4111">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[17/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memberHasSameNameAsBoundNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingID&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template-dependent, but known, member names against an already-bound node. </p>
<p>In template declarations, dependent members are not resolved and so can not be matched to particular named declarations.</p>
<p>This matcher allows to match on the name of already-bound <a class="el" href="classclang_1_1VarDecl.html" title="Represents a variable declaration or definition.">VarDecl</a>, <a class="el" href="classclang_1_1FieldDecl.html" title="Represents a member of a struct/union/class.">FieldDecl</a> and <a class="el" href="classclang_1_1CXXMethodDecl.html" title="Represents a static or instance method of a struct/union/class.">CXXMethodDecl</a> nodes.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">    <span class="keywordtype">void</span> mem();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() {</div>
<div class="line">    S&lt;T&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
<div class="line">    <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>.mem();</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">\c</a> <a class="code" href="namespaceclang_1_1ast__matchers.html#a3285794ef7314a9b8ca5c18ed2744c13">cxxDependentScopeMemberExpr</a>(</div>
<div class="line">  hasObjectExpression(<a class="code" href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>(hasType(<a class="code" href="namespaceclang_1_1ast__matchers.html#a2fa868bfe1462fc934f1a64bad7d856d">templateSpecializationType</a>(</div>
<div class="line">      <a class="code" href="namespaceclang_1_1ast__matchers.html#aa76835a0f3b2093794608ce6c16da9bc">hasDeclaration</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#afcdb6ae259330bdf0876aba6e07c8710">classTemplateDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a>(</div>
<div class="line">          <a class="code" href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd">cxxMethodDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;mem&quot;</span>)).bind(<span class="stringliteral">&quot;templMem&quot;</span>)</div>
<div class="line">          )))))</div>
<div class="line">      )))),</div>
<div class="line">  memberHasSameNameAsBoundNode(<span class="stringliteral">&quot;templMem&quot;</span>)</div>
<div class="line">  )</div>
</div><!-- fragment --><p> first matches and binds the <code>mem</code> member of the <code>S</code> template, then compares its name to the usage in <code>s.mem()</code> in the <code>x</code> function template </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03135">3135</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a13417ea6d85e2bff1cadbf9f0969ae1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13417ea6d85e2bff1cadbf9f0969ae1d">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[18/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLoopVariable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initialization statement of a for loop. </p>
<p>Example: forStmt(hasLoopVariable(anything())) matches 'int x' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> : a) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02130">2130</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ad6716c3f117a63a7d60827379b4cc2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6716c3f117a63a7d60827379b4cc2a4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[19/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasRangeInit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the range initialization statement of a for loop. </p>
<p>Example: forStmt(hasRangeInit(anything())) matches 'a' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> : a) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02144">2144</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a99fc9646b82282913629cad30181a3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fc9646b82282913629cad30181a3a0">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[20/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">on&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the implicit object argument of a member call expression, after stripping off any parentheses or implicit casts. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line">Y g();</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> : <span class="keyword">public</span> Y {};</div>
<div class="line"><span class="keywordtype">void</span> z(Y y, <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { y.m(); (g()).m(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.m(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code> and <code>(g()).m()</code>. cxxMemberCallExpr(on(hasType(cxxRecordDecl(hasName("X"))))) matches <code>x.m()</code>. cxxMemberCallExpr(on(callExpr())) matches <code>(g()).m()</code>.</p>
<p>FIXME: Overload to allow directly matching types? </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03609">3609</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a4d9312d37843a929bb3d5e3fc89f6582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9312d37843a929bb3d5e3fc89f6582">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[21/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">onImplicitObjectArgument&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the implicit object argument of a member call expression. </p>
<p>Unlike <code>on</code>, matches the argument directly without stripping away anything.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line">Y g();</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> : <span class="keyword">public</span> Y { <span class="keywordtype">void</span> g(); };</div>
<div class="line"><span class="keywordtype">void</span> z(Y y, <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { y.m(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.m(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.g(); (g()).m(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(onImplicitObjectArgument(hasType( cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code>, <code>x.m()</code> and (g()).m(), but not <code>x.g()</code>. cxxMemberCallExpr(on(callExpr())) does not match <code>(g()).m()</code>, because the parens are not ignored.</p>
<p>FIXME: Overload to allow directly matching types? </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04076">4076</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="abaee42ec34375c06335058c4af2da024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee42ec34375c06335058c4af2da024">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[22/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forEachOverridden&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches each method overridden by the given method. </p>
<p>This matcher may produce multiple matches.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">virtual</span> <span class="keywordtype">void</span> f(); };</div>
<div class="line"><span class="keyword">class </span>B : <span class="keyword">public</span> A { <span class="keywordtype">void</span> f(); };</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">public</span> B { <span class="keywordtype">void</span> f(); };</div>
</div><!-- fragment --><p> cxxMethodDecl(ofClass(hasName("C")), forEachOverridden(<a class="el" href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd" title="Matches method declarations.">cxxMethodDecl()</a>.bind("b"))).bind("d") matches once, with "b" binding "A::f" and "d" binding "C::f" (Note that B::f is not overridden by C::f).</p>
<p>The check can produce multiple matches in case of multiple inheritance, e.g. </p><div class="fragment"><div class="line"><span class="keyword">class </span>A1 { <span class="keyword">virtual</span> <span class="keywordtype">void</span> f(); };</div>
<div class="line"><span class="keyword">class </span>A2 { <span class="keyword">virtual</span> <span class="keywordtype">void</span> f(); };</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">public</span> A1, <span class="keyword">public</span> A2 { <span class="keywordtype">void</span> f(); };</div>
</div><!-- fragment --><p> cxxMethodDecl(ofClass(hasName("C")), forEachOverridden(<a class="el" href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd" title="Matches method declarations.">cxxMethodDecl()</a>.bind("b"))).bind("d") matches twice, once with "b" binding "A1::f" and "d" binding "C::f", and once with "b" binding "A2::f" and "d" binding "C::f". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05936">5936</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a219e5adb14a8a36db06b0705c002014c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219e5adb14a8a36db06b0705c002014c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[23/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ofClass&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the class declaration that the given method declaration belongs to. </p>
<p>FIXME: Generalize this for other kinds of declarations. FIXME: What other kind of declarations would we need to generalize this to?</p>
<p>Example matches A() in the last line (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl( ofClass(hasName("A")))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  A();</div>
<div class="line">};</div>
<div class="line">A a = A();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05902">5902</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a95748550e6a5c26396235386d01ea052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95748550e6a5c26396235386d01ea052">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[24/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyPlacementArg&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any placement new expression arguments. </p>
<p>Given: </p><div class="fragment"><div class="line">MyClass *p1 = <span class="keyword">new</span> (Storage) MyClass();</div>
</div><!-- fragment --><p> cxxNewExpr(hasAnyPlacementArg(anything())) matches the expression 'new (Storage, 16) MyClass()'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08078">8078</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9a6658d09eeb51548739f6cecef2f3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6658d09eeb51548739f6cecef2f3c9">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[25/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasArraySize&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches array new expressions with a given array size. </p>
<p>Given: </p><div class="fragment"><div class="line">MyClass *p1 = <span class="keyword">new</span> MyClass[10];</div>
</div><!-- fragment --><p> cxxNewExpr(hasArraySize(integerLiteral(equals(10)))) matches the expression 'new MyClass[10]'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08093">8093</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af8d5ca0ebfe096ded3ced92d183b60a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d5ca0ebfe096ded3ced92d183b60a2">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[26/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyBase&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseSpecMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that have a direct or indirect base matching <code>BaseSpecMatcher</code>. </p>
<p>Example: matcher hasAnyBase(hasType(cxxRecordDecl(hasName("SpecialBase")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">class </span>Bar : Foo {};</div>
<div class="line"><span class="keyword">class </span>Baz : Bar {};</div>
<div class="line"><span class="keyword">class </span>SpecialBase;</div>
<div class="line"><span class="keyword">class </span>Proxy : SpecialBase {};  <span class="comment">// matches Proxy</span></div>
<div class="line"><span class="keyword">class </span>IndirectlyDerived : Proxy {};  <span class="comment">//matches IndirectlyDerived</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03227">3227</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00077">clang::ast_matchers::internal::matchesAnyBase()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a18a38d1fd2744bb4fa7264ce75e905ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a38d1fd2744bb4fa7264ce75e905ce">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[27/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDirectBase&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseSpecMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that have a direct base matching <code>BaseSpecMatcher</code>. </p>
<p>Example: matcher hasDirectBase(hasType(cxxRecordDecl(hasName("SpecialBase")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">class </span>Bar : Foo {};</div>
<div class="line"><span class="keyword">class </span>Baz : Bar {};</div>
<div class="line"><span class="keyword">class </span>SpecialBase;</div>
<div class="line"><span class="keyword">class </span>Proxy : SpecialBase {};  <span class="comment">// matches Proxy</span></div>
<div class="line"><span class="keyword">class </span>IndirectlyDerived : Proxy {};  <span class="comment">// doesn&#39;t match</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03244">3244</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae58c11d6864fd939f7c9e2bad80dde51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58c11d6864fd939f7c9e2bad80dde51">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[28/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasMethod&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the first method of a class or struct that satisfies <code>InnerMatcher</code>. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">void</span> func(); };</div>
<div class="line"><span class="keyword">class </span>B { <span class="keywordtype">void</span> <a class="code" href="namespaceclang_1_1transformer.html#a301efb90a8aff2321a691a7c8292e9df">member</a>(); };</div>
</div><!-- fragment --><p><code>cxxRecordDecl</code>(hasMethod(hasName("func"))) matches the declaration of <code>A</code> but not <code>B</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03346">3346</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ac36d1ab4dd342580f69ab63fe3b4120f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36d1ab4dd342580f69ab63fe3b4120f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[29/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DecayedType.html">DecayedType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDecayedType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the decayed type, whoes decayed type matches <code>InnerMatcher</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07308">7308</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aac2995332340b5792b85e50de5b1db15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2995332340b5792b85e50de5b1db15">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[30/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SemaCUDA_8cpp.html#a6d28c44d89e5f716fbc724a19a6c9b6b">hasAttr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1attr.html#ac160b7b7240633e6932ebb177d0f03ef">attr::Kind</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AttrKind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration that has a given attribute. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((device)) <span class="keywordtype">void</span> f() { ... }</div>
</div><!-- fragment --><p> decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of f. If the matcher is used from clang-query, <a class="el" href="namespaceclang_1_1attr.html#ac160b7b7240633e6932ebb177d0f03ef">attr::Kind</a> parameter should be passed as a quoted string. e.g., hasAttr("attr::CUDADevice"). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07767">7767</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Attr_8h_source.html#l00084">clang::Attr::getKind()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a616533eb9d1bd2fba65947fc59f237cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616533eb9d1bd2fba65947fc59f237cd">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[31/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDeclContext&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations whose declaration context, interpreted as a <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a>, matches <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line">  <span class="keyword">namespace </span>M {</div>
<div class="line">    <span class="keyword">class </span>D {};</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>cxxRcordDecl</code>(hasDeclContext(namedDecl(hasName("M")))) matches the declaration of <code>class</code> <code>D</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07327">7327</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2ae2d3c41e0c472fa618cfa95c73f17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae2d3c41e0c472fa618cfa95c73f17e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[32/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">to&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1DeclRefExpr.html" title="A reference to a declared variable, function, enum, etc.">DeclRefExpr</a> that refers to a declaration that matches the specified matcher. </p>
<p>Example matches x in if(x) (matcher = declRefExpr(to(varDecl(hasName("x"))))) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04123">4123</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aad3e9465ba62aea874dab861b34a2484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e9465ba62aea874dab861b34a2484">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[33/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">declCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration statements that contain a specific number of declarations. </p>
<p>Example: Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keywordtype">int</span> d = 2, e;</div>
</div><!-- fragment --><p> declCountIs(2) matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04434">4434</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="opencl-c_8h.html#a17df544dc4decc5c5b990f5ab5191fc4">distance()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a3490831f470cc4fa91a8e69e2b49cb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3490831f470cc4fa91a8e69e2b49cb92">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[34/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSingleDecl&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the <a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a> of a <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a> which has a single declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> declStmt(hasSingleDecl(anything())) matches 'int c;' but not 'int a, b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04192">4192</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aa6e11922930086f116be1c4472256e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e11922930086f116be1c4472256e94">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[35/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyBinding&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any binding of a <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a>. </p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> arr[3];</div>
<div class="line">    <span class="keyword">auto</span> &amp;[f, <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>, t] = arr;</div>
<div class="line"> </div>
<div class="line">    f = 42;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">decompositionDecl</a>(hasAnyBinding(<a class="code" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">bindingDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;f&quot;</span>).bind(<span class="stringliteral">&quot;fBinding&quot;</span>))))</div>
</div><!-- fragment --><p> matches the decomposition decl with 'f' bound to "fBinding". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07889">7889</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a0f1b90fe605ed44735e799e76d0b4786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1b90fe605ed44735e799e76d0b4786">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[36/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">designatorCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches designated initializer expressions that contain a specific number of designators. </p>
<p>Example: Given </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };</div>
<div class="line">point ptarray2[10] = { [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 };</div>
</div><!-- fragment --><p> designatorCountIs(2) matches '{ [2].y = 1.0, [0].x = 1.0 }', but not '{ [2].y = 1.0, [2].x = 0.0, [0].x = 1.0 }'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02698">2698</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ac0f915dc513a7302266dbc3fc9ade730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f915dc513a7302266dbc3fc9ade730">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[37/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasQualifier&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ElaboratedTypes whose qualifier, a <a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a>, matches <code>InnerMatcher</code> if the qualifier exists. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line">  <span class="keyword">namespace </span>M {</div>
<div class="line">    <span class="keyword">class </span>D {};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">N::M::D d;</div>
</div><!-- fragment --><p><code>elaboratedType</code>(hasQualifier(hasPrefix(specifiesNamespace(hasName("N")))) matches the type of the variable declaration of <code>d</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07203">7203</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a79bf5b9b8e54f44c8c159e78f532490f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bf5b9b8e54f44c8c159e78f532490f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[38/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">namesType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ElaboratedTypes whose named type matches <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line">  <span class="keyword">namespace </span>M {</div>
<div class="line">    <span class="keyword">class </span>D {};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">N::M::D d;</div>
</div><!-- fragment --><p><code>elaboratedType</code>(namesType(recordType( hasDeclaration(namedDecl(hasName("D")))))) matches the type of the variable declaration of <code>d</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07226">7226</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a37d722ea161c9e778a372802649e5c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d722ea161c9e778a372802649e5c2f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[39/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasNamedTypeLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches elaborated <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a named <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>&lt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>D {};</div>
<div class="line"><span class="keyword">class </span>D d;</div>
</div><!-- fragment --><p> elaboratedTypeLoc(hasNamedTypeLoc(templateSpecializationTypeLoc())); matches the <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> of the variable declaration of <code>c</code>, but not <code>d</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06634">6634</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae483f80b9fb6ac6dd16b9ca2150beaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae483f80b9fb6ac6dd16b9ca2150beaa4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[40/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasDestinationType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches casts whose destination type matches a given matcher. </p>
<p>(Note: Clang's AST refers to other conversions as "casts" too, and calls actual casts "explicit" casts.) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05744">5744</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7d3da709a45f0cd933497b1f7588f82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3da709a45f0cd933497b1f7588f82f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[41/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringElidableConstructorCall&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher that are possibly wrapped in an elidable constructor and other corresponding bookkeeping nodes. </p>
<p>In C++17, elidable copy constructors are no longer being generated in the AST as it is not permitted by the standard. They are, however, part of the AST in C++14 and earlier. So, a matcher must abstract over these differences to work in all language modes. This matcher skips elidable constructor-call AST nodes, <code><a class="el" href="classclang_1_1ExprWithCleanups.html" title="Represents an expression – generally a full-expression – that introduces cleanups to be run at the en...">ExprWithCleanups</a></code> nodes wrapping elidable constructor-calls and various implicit nodes inside the constructor calls, all of which will not appear in the C++17 AST.</p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>H {};</div>
<div class="line">H G();</div>
<div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  H D = G();</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>varDecl(hasInitializer(ignoringElidableConstructorCall(callExpr())))</code> matches <code>H D = G()</code> in C++11 through C++17 (and beyond). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08156">8156</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a1d68be4dc7543bd7e54dfe60c7e77b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d68be4dc7543bd7e54dfe60c7e77b30">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[42/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringImpCasts&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after any implicit casts are stripped off. </p>
<p>Parentheses and explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> arr[5];</div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = a;</div>
<div class="line"><span class="keywordtype">int</span> *d = arr;</div>
<div class="line"><span class="keywordtype">long</span> e = (long) 0l;</div>
</div><!-- fragment --><p> The matchers </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImpCasts(<a class="code" href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a>())))</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImpCasts(<a class="code" href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>())))</div>
</div><!-- fragment --><p> would match the declarations for a, b, c, and d, but not e. While </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code" href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a>()))</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code" href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">declRefExpr</a>()))</div>
</div><!-- fragment --><p> only match the declarations for a. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00921">921</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a92fc5ba0e3c7670df1211d78a0e8cd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fc5ba0e3c7670df1211d78a0e8cd3b">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[43/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringImplicit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after any implicit AST nodes are stripped off. </p>
<p>Parentheses and explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> a = <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>();</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
</div><!-- fragment --><p> The matchers </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(ignoringImplicit(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a>())))</div>
</div><!-- fragment --><p> would match the declarations for a, b, and c. While </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33">cxxConstructExpr</a>()))</div>
</div><!-- fragment --><p> only match the declarations for b and c. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00891">891</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a975436793549e3bf233afa633b959539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975436793549e3bf233afa633b959539">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[44/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParenCasts&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after parentheses and casts are stripped off. </p>
<p>Implicit and non-C Style casts are also discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = (0);</div>
<div class="line"><span class="keywordtype">void</span>* <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(0);</div>
<div class="line"><span class="keywordtype">char</span> d = char(0);</div>
</div><!-- fragment --><p> The matcher varDecl(hasInitializer(ignoringParenCasts(integerLiteral()))) would match the declarations for a, b, c, and d. while varDecl(hasInitializer(integerLiteral())) only match the declaration for a. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00943">943</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5c810b620cfe58f641cb695035984063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c810b620cfe58f641cb695035984063">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[45/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParenImpCasts&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that match InnerMatcher after implicit casts and parentheses are stripped off. </p>
<p>Explicit casts are not discarded. Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> arr[5];</div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="keywordtype">char</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = (0);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = a;</div>
<div class="line"><span class="keywordtype">int</span> *d = (arr);</div>
<div class="line"><span class="keywordtype">long</span> e = ((long) 0l);</div>
</div><!-- fragment --><p> The matchers varDecl(hasInitializer(ignoringParenImpCasts(integerLiteral()))) varDecl(hasInitializer(ignoringParenImpCasts(declRefExpr()))) would match the declarations for a, b, c, and d, but not e. while varDecl(hasInitializer(integerLiteral())) varDecl(hasInitializer(declRefExpr())) would only match the declaration for a. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00968">968</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a3e2e74bf00f236ab96f16fc7d3495f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2e74bf00f236ab96f16fc7d3495f78">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[46/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasBitWidth&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Width&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that are bit-fields of the specified bit width. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a : 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> : 4;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> : 2;</div>
<div class="line">};</div>
</div><!-- fragment --><p> fieldDecl(hasBitWidth(2)) matches 'int a;' and 'int c;' but not 'int b;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00708">708</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a041bd134ecb46dcb809880b2588a1c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041bd134ecb46dcb809880b2588a1c19">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[47/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInClassInitializer&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-static data members that have an in-class initializer. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keywordtype">int</span> a = 2;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 3;</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> fieldDecl(hasInClassInitializer(integerLiteral(equals(2)))) matches 'int a;' but not 'int b;'. fieldDecl(hasInClassInitializer(anything())) matches 'int a;' and 'int b;' but not 'int c;'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00727">727</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a290e141c4140d565458b4eebab9fe706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290e141c4140d565458b4eebab9fe706">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[48/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasIncrement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the increment statement of a for loop. </p>
<p>Example: forStmt(hasIncrement(unaryOperator(hasOperatorName("++")))) matches '++x' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> &lt; N; ++<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02091">2091</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ac25f93cc605e37bd0bb85673eb580a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f93cc605e37bd0bb85673eb580a1e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[49/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasLoopInit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the initialization statement of a for loop. </p>
<p>Example: forStmt(hasLoopInit(declStmt())) matches 'int x = 0' in </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 0; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> &lt; N; ++<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02106">2106</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a88bd01b778096c483b22f6d19a730a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bd01b778096c483b22f6d19a730a46">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[50/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyBody&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a function declaration that has a given body present in the AST. </p>
<p>Note that this matcher matches all the declarations of a function whose body is present in the AST.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
<div class="line"><span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keywordtype">void</span> g();</div>
</div><!-- fragment --><p> functionDecl(hasAnyBody(compoundStmt())) matches both 'void f();' and 'void f() {}' with <a class="el" href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749" title="Matches compound statements.">compoundStmt()</a> matching '{}' but does not match 'void g();' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05441">5441</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a449e8a24f8169202139270647cc24506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449e8a24f8169202139270647cc24506">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[51/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasExplicitSpecifier&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the expression in an explicit specifier if present in the given declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> b&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(<span class="keywordtype">int</span>); <span class="comment">// #1</span></div>
<div class="line">  <span class="keyword">explicit</span> S(<span class="keywordtype">double</span>); <span class="comment">// #2</span></div>
<div class="line">  <span class="keyword">operator</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>(); <span class="comment">// #3</span></div>
<div class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> <a class="code" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>(); <span class="comment">// #4</span></div>
<div class="line">  <span class="keyword">explicit</span>(<span class="keyword">false</span>) S(<span class="keywordtype">bool</span>) <span class="comment">// # 7</span></div>
<div class="line">  <span class="keyword">explicit</span>(<span class="keyword">true</span>) S(<span class="keywordtype">char</span>) <span class="comment">// # 8</span></div>
<div class="line">  <span class="keyword">explicit</span>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) S(S) <span class="comment">// # 9</span></div>
<div class="line">};</div>
<div class="line">S(<span class="keywordtype">int</span>) -&gt; S&lt;true&gt; <span class="comment">// #5</span></div>
<div class="line"><span class="keyword">explicit</span> S(<span class="keywordtype">double</span>) -&gt; S&lt;false&gt; <span class="comment">// #6</span></div>
</div><!-- fragment --><p> cxxConstructorDecl(hasExplicitSpecifier(constantExpr())) will match #7, #8 and #9, but not #1 or #2. cxxConversionDecl(hasExplicitSpecifier(constantExpr())) will not match #3 or #4. cxxDeductionGuideDecl(hasExplicitSpecifier(constantExpr())) will not match #5 or #6. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07665">7665</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="abe24b80b0c7f389698881797248ccba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe24b80b0c7f389698881797248ccba0">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[52/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReturnTypeLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReturnMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a function declared with the specified return <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 5; }</div>
<div class="line"><span class="keywordtype">void</span> g() {}</div>
</div><!-- fragment --><p> functionDecl(hasReturnTypeLoc(loc(asString("int")))) matches the declaration of <code>f</code>, but not <code>g</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06493">6493</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8788b28117869cda162e847833df3e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8788b28117869cda162e847833df3e1c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[53/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">returns&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the return type of a function declaration. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> 1; } };</div>
</div><!-- fragment --><p> cxxMethodDecl(returns(asString("int"))) matches int f() { return 1; } </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05038">5038</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a938c34e60bf2f27d1e66f9091b17f58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938c34e60bf2f27d1e66f9091b17f58b">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[54/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasConditionVariableStatement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the condition variable statement in an if statement. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (A* a = GetAPointer()) {}</div>
</div><!-- fragment --><p> hasConditionVariableStatement(...) matches 'A* a = GetAPointer()'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05346">5346</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5b626d54664c5e174cfb8e4733c97e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b626d54664c5e174cfb8e4733c97e89">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[55/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasElse&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the else-statement of an if statement. </p>
<p>Examples matches the if statement (matcher = ifStmt(hasElse(cxxBoolLiteral(equals(true))))) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">false</span>) <span class="keyword">false</span>; <span class="keywordflow">else</span> <span class="keyword">true</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05296">5296</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a24292ba3bd8669c92e59fcaaebcf672c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24292ba3bd8669c92e59fcaaebcf672c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[56/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasThen&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the then-statement of an if statement. </p>
<p>Examples matches the if statement (matcher = ifStmt(hasThen(cxxBoolLiteral(equals(true))))) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">false</span>) <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keyword">false</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05284">5284</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5fa618c0bf6f0873d081052cb92a35d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa618c0bf6f0873d081052cb92a35d2">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[57/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasImplicitDestinationType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches implicit casts whose destination type matches a given matcher. </p>
<p>FIXME: Unit test this matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05754">5754</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a246e4f4313edb67d25bdd6fb935746b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246e4f4313edb67d25bdd6fb935746b4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[58/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSyntacticForm&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the syntactic form of init list expressions (if expression have it). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01683">1683</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a36b0de5095cbd59d3e99338aadeedd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b0de5095cbd59d3e99338aadeedd6f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[59/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">capturesVar&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classclang_1_1LambdaCapture.html" title="Describes the capture of a variable or of this, or of a C++1y init-capture.">LambdaCapture</a></code> that refers to the specified <code><a class="el" href="classclang_1_1VarDecl.html" title="Represents a variable declaration or definition.">VarDecl</a></code>. </p>
<p>The <code><a class="el" href="classclang_1_1VarDecl.html" title="Represents a variable declaration or definition.">VarDecl</a></code> can be a separate variable that is captured by value or reference, or a synthesized variable if the capture has an initializer.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">auto</span> f = [<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>](){};</div>
<div class="line">  <span class="keyword">auto</span> g = [<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 1](){};</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the matcher lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName("x")))), capturesVar(hasName("x")) matches <code>x</code> and <code>x = 1</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04693">4693</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8847b49fa5e19735067eb7a690da5d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8847b49fa5e19735067eb7a690da5d5e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[60/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forEachLambdaCapture&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches each lambda capture in a lambda expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="ClangSrcLocDump_8cpp.html#a217dbf8b442f20279ea00b898af96f52">main</a>() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, y;</div>
<div class="line">  <span class="keywordtype">float</span> z;</div>
<div class="line">  <span class="keyword">auto</span> f = [=]() { <span class="keywordflow">return</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> + y + z; };</div>
<div class="line">}</div>
</div><!-- fragment --><p> lambdaExpr(forEachLambdaCapture( lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))) will trigger two matches, binding for 'x' and 'y' respectively. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04238">4238</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a1eb3eae1c288af703b6bac40de050e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb3eae1c288af703b6bac40de050e41">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[61/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyCapture&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any capture in a lambda expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keywordtype">int</span> t = 5;</div>
<div class="line">  <span class="keyword">auto</span> f = [=](){ <span class="keywordflow">return</span> t; };</div>
<div class="line">}</div>
</div><!-- fragment --><p> lambdaExpr(hasAnyCapture(lambdaCapture())) and lambdaExpr(hasAnyCapture(lambdaCapture(refersToVarDecl(hasName("t"))))) both match <code>[=](){ return t; }</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04666">4666</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae9537471ed664862c0392e7af2a9122d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9537471ed664862c0392e7af2a9122d">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[62/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">member&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a member expression where the member is matched by a given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>{ <span class="keywordtype">int</span> first, second; } first, second;</div>
<div class="line"><span class="keywordtype">int</span> i(second.first);</div>
<div class="line"><span class="keywordtype">int</span> j(first.second);</div>
</div><!-- fragment --><p> memberExpr(member(hasName("first"))) matches second.first but not first.second (because the member name there is "second"). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06290">6290</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af541323ee4a7cfcaa6032acb78ac3a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af541323ee4a7cfcaa6032acb78ac3a86">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[63/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnderlyingDecl&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <code><a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a></code> whose underlying declaration matches the given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>N { <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f(T t); }</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> g() { <span class="keyword">using</span> N::f; f(T()); }</div>
</div><!-- fragment --><p> <code>unresolvedLookupExpr</code>(hasAnyDeclaration( namedDecl(hasUnderlyingDecl(hasName("::N::f"))))) matches the use of <code>f</code> in <code>g()</code> . </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03583">3583</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7a93eeb115d0957d26d204424fbfb0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a93eeb115d0957d26d204424fbfb0c1">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[64/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">specifiesNamespace&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nested name specifiers that specify a namespace matching the given namespace matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>ns { <span class="keyword">struct </span>A {}; }</div>
<div class="line">ns::A a;</div>
</div><!-- fragment --><p> nestedNameSpecifier(specifiesNamespace(hasName("ns"))) matches "ns::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07445">7445</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a94cf25202b4b45344cc6fcc0cb6da8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cf25202b4b45344cc6fcc0cb6da8f4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[65/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">specifiesType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nested name specifiers that specify a type matching the given <code><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a></code> matcher without qualifiers. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keyword">struct </span>B { <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {}; }; };</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">A::B::C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> nestedNameSpecifier(specifiesType( hasDeclaration(cxxRecordDecl(hasName("A"))) )) matches "A::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07375">7375</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a4947552d76a386eff09436d02433c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4947552d76a386eff09436d02433c8f5">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[66/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">specifiesTypeLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nested name specifier locs that specify a type matching the given <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keyword">struct </span>B { <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {}; }; };</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">A::B::C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> nestedNameSpecifierLoc(specifiesTypeLoc(loc(type( hasDeclaration(cxxRecordDecl(hasName("A"))))))) matches "A::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07393">7393</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ac1ca863c3bc2d2bc5af99d90933d6e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ca863c3bc2d2bc5af99d90933d6e9c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[67/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnySelectorMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matches&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00045">45</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa81978c4da301b92d8b05c2f29c73d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81978c4da301b92d8b05c2f29c73d86">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[68/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReceiver&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the Objective-C message is sent to an instance, and the inner matcher matches on that instance. </p>
<p>For example the method call in </p><div class="fragment"><div class="line">NSString *<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">[<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> containsString:<span class="stringliteral">@&quot;h&quot;</span>];</div>
</div><!-- fragment --><p> is matched by objcMessageExpr(hasReceiver(declRefExpr(to(varDecl(hasName("x")))))) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03710">3710</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2eadcbb53864d57ff194cfb633fc783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eadcbb53864d57ff194cfb633fc783e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[69/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReceiverType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the receiver of an ObjectiveC Message expression. </p>
<p>Example matcher = objCMessageExpr(hasReceiverType(asString("UIWebView *"))); matches the [webView ...] message invocation. </p><div class="fragment"><div class="line">NSString *webViewJavaScript = ...</div>
<div class="line">UIWebView *webView = ...</div>
<div class="line">[webView stringByEvaluatingJavaScriptFromString:webViewJavascript];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03628">3628</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae7c4492e391c4ebab66249547cbda68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c4492e391c4ebab66249547cbda68c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[70/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSelector&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when BaseName == <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a> </p>
<p>matcher = objCMessageExpr(hasSelector("loadHTMLString:baseURL:")); matches the outer message expr in the code below, but NOT the message invocation for self.bodyView. </p><div class="fragment"><div class="line">[<span class="keyword">self</span>.bodyView loadHTMLString:html baseURL:<a class="code" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03726">3726</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="IdentifierTable_8cpp_source.html#l00528">clang::Selector::getAsString()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a73b6b13e9f4c74054e742f1222a70a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b6b13e9f4c74054e742f1222a70a8c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[71/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">numSelectorArgs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when the selector has the specified number of arguments. </p>
<p>matcher = objCMessageExpr(numSelectorArgs(0)); matches self.bodyView in the code below</p>
<p>matcher = objCMessageExpr(numSelectorArgs(2)); matches the invocation of "loadHTMLString:baseURL:" but not that of self.bodyView </p><div class="fragment"><div class="line">[<span class="keyword">self</span>.bodyView loadHTMLString:html baseURL:<a class="code" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03805">3805</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a620158236235a959021528136fdea9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620158236235a959021528136fdea9a4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[72/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyClause&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1OMPClause.html">OMPClause</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any clause in an OpenMP directive. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
</div><!-- fragment --><p><code>ompExecutableDirective(hasAnyClause(anything()))</code> matches <code>omp parallel default(none)</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08248">8248</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aab6eac16c91f23300c033128c7d237e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6eac16c91f23300c033128c7d237e2">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[73/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasStructuredBlock&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the structured-block of the OpenMP executable directive. </p>
<p>Prerequisite: the executable directive must not be standalone directive. If it is, it will never match.</p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line">;</div>
<div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">{}</span></div>
</div><!-- fragment --><p><code>ompExecutableDirective(hasStructuredBlock(nullStmt()))</code> will match <code>;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08230">8230</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aaa5713ebcfebb04bcfd89e6098999e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5713ebcfebb04bcfd89e6098999e65">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[74/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAllowedToContainClauseKind&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a4e0b3c12565106860a261ba7d4330112">OpenMPClauseKind</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the OpenMP directive is allowed to contain the specified OpenMP clause kind. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel for</span></div>
<div class="line"><span class="preprocessor">#pragma omp          for</span></div>
</div><!-- fragment --><p><code>ompExecutableDirective(isAllowedToContainClause(OMPC_default))</code><code>matches </code><code>omp parallel</code><code>and</code><code>omp parallel for</code>`.</p>
<p>If the matcher is use from clang-query, <code>OpenMPClauseKind</code> parameter should be passed as a quoted string. e.g., <code>isAllowedToContainClauseKind("OMPC_default").</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08339">8339</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a19ee00dadd390e9911cdc64d2f0f0aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ee00dadd390e9911cdc64d2f0f0aa0">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[75/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1OverloadExpr.html">OverloadExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyDeclaration&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a node refers to a declaration through a specific using shadow declaration. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>a { <span class="keywordtype">int</span> f(); }</div>
<div class="line"><span class="keyword">using</span> a::f;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = f();</div>
</div><!-- fragment --><p> declRefExpr(throughUsingDecl(anything())) matches <code>f</code> </p>
<div class="fragment"><div class="line">      <span class="keyword">namespace </span>a { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>{}; }</div>
<div class="line">      <span class="keyword">using</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">a::X</a>;</div>
<div class="line">      <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">    \code</div>
<div class="line">    <a class="code" href="namespaceclang_1_1ast__matchers.html#a605961d8a647c2ec766b2417552393a2">typeLoc</a>(loc(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8c09ef1f494b514efb2056e08b0f55d8">usingType</a>(throughUsingDecl(<a class="code" href="namespaceclang_1_1ast__matchers.html#a652afe55bf376c9c0789d550409d90fe">anything</a>()))))</div>
<div class="line">      <a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> \<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a></div>
<div class="line">   </div>
<div class="line">    Usable as: Matcher&lt;DeclRefExpr&gt;, Matcher&lt;UsingType&gt;</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a35486e436ae0dbb176252fc6b3cf62fd">AST_POLYMORPHIC_MATCHER_P</a>(throughUsingDecl,</div>
<div class="line">                          <a class="code" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(DeclRefExpr,</div>
<div class="line">                                                          UsingType),</div>
<div class="line">                          internal::Matcher&lt;UsingShadowDecl&gt;, Inner) {</div>
<div class="line">  <span class="keyword">const</span> NamedDecl *FoundDecl = <a class="code" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>.getFoundDecl();</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">const</span> UsingShadowDecl *UsingDecl = dyn_cast&lt;UsingShadowDecl&gt;(FoundDecl))</div>
<div class="line">    <span class="keywordflow">return</span> Inner.matches(*UsingDecl, Finder, Builder);</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">    Matches <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">an \c</a> OverloadExpr <span class="keywordflow">if</span> <a class="code" href="opencl-c_8h.html#aba012e9e58cf457e566250f019adf2f2">any</a> of the declarations in the <a class="code" href="lib_2Analysis_2plugins_2CheckerDependencyHandling_2CMakeLists_8txt.html#a683a3174a12f54668fcda805c841439b">set</a> of</div>
<div class="line">    overloads <a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> the given matcher.</div>
<div class="line">   </div>
<div class="line">    Given</div>
<div class="line">    \code</div>
<div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> foo(T);</div>
<div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> bar(T);</div>
<div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> baz(T t) {</div>
<div class="line">        foo(t);</div>
<div class="line">        bar(t);</div>
<div class="line">      }</div>
</div><!-- fragment --><p> unresolvedLookupExpr(hasAnyDeclaration( functionTemplateDecl(hasName("foo")))) matches <code>foo</code> in <code>foo(t)</code>; but not <code>bar</code> in <code>bar(t)</code>; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04176">4176</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a20b1f3a0f652c9f6a1b9664e62f8806a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1f3a0f652c9f6a1b9664e62f8806a">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[76/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isAtPosition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a> nodes that are at the N'th position in the parameter list. </p>
<p>The parameter list could be that of either a block, function, or objc-method.</p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) {</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>parmVarDecl(isAtPosition(0))</code> matches <code>int a</code>.</p>
<p><code>parmVarDecl(isAtPosition(1))</code> matches <code>int b</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04935">4935</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a13b21a24755b4c4f087b0280223a5d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b21a24755b4c4f087b0280223a5d90">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[77/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasPointeeLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointeeMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches pointer <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a pointee <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>PointeeMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>* <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> pointerTypeLoc(hasPointeeLoc(loc(asString("int")))) matches <code>int*</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06519">6519</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae337c8496000b5158bd5d078f049681c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae337c8496000b5158bd5d078f049681c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[78/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnqualifiedLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1QualifiedTypeLoc.html" title="Wrapper of type source information for a type with non-trivial direct qualifiers.">QualifiedTypeLoc</a></code>s that have an unqualified <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>* <span class="keyword">const</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> y;</div>
</div><!-- fragment --><p> qualifiedTypeLoc(hasUnqualifiedLoc(pointerTypeLoc())) matches the <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> of the variable declaration of <code>x</code>, but not <code>y</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06479">6479</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8d441fb8797a726cc8f58469ea017523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d441fb8797a726cc8f58469ea017523">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[79/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asString&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Name&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the type location of a node matches the inner matcher. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> declaratorDecl(hasTypeLoc(loc(asString("int")))) matches int x</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>(3);</div>
<div class="line">    \code</div>
<div class="line">    <a class="code" href="namespaceclang_1_1ast__matchers.html#a704e8b0c7519edb6b05d1663a4266b6d">cxxTemporaryObjectExpr</a>(hasTypeLoc(loc(asString(<span class="stringliteral">&quot;int&quot;</span>))))</div>
<div class="line">      <a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> <span class="keywordtype">int</span>(3)</div>
<div class="line">   </div>
<div class="line">    \code</div>
<div class="line">    struct Foo { Foo(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>); };</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = Foo(1, 2);</div>
<div class="line">    \code</div>
<div class="line">    <a class="code" href="namespaceclang_1_1ast__matchers.html#a701d2c84173a8709dcb4a221ad478e1e">cxxFunctionalCastExpr</a>(hasTypeLoc(loc(asString(<span class="stringliteral">&quot;struct Foo&quot;</span>))))</div>
<div class="line">      <a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> Foo(1, 2)</div>
<div class="line">   </div>
<div class="line">    Usable as: Matcher&lt;BlockDecl&gt;, Matcher&lt;CXXBaseSpecifier&gt;,</div>
<div class="line">      Matcher&lt;CXXCtorInitializer&gt;, Matcher&lt;CXXFunctionalCastExpr&gt;,</div>
<div class="line">      Matcher&lt;CXXNewExpr&gt;, Matcher&lt;CXXTemporaryObjectExpr&gt;,</div>
<div class="line">      Matcher&lt;CXXUnresolvedConstructExpr&gt;,</div>
<div class="line">      Matcher&lt;ClassTemplateSpecializationDecl&gt;, Matcher&lt;CompoundLiteralExpr&gt;,</div>
<div class="line">      Matcher&lt;DeclaratorDecl&gt;, Matcher&lt;ExplicitCastExpr&gt;,</div>
<div class="line">      Matcher&lt;ObjCPropertyDecl&gt;, Matcher&lt;TemplateArgumentLoc&gt;,</div>
<div class="line">      Matcher&lt;TypedefNameDecl&gt;</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a35486e436ae0dbb176252fc6b3cf62fd">AST_POLYMORPHIC_MATCHER_P</a>(</div>
<div class="line">    hasTypeLoc,</div>
<div class="line">    <a class="code" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(</div>
<div class="line">        BlockDecl, CXXBaseSpecifier, CXXCtorInitializer, CXXFunctionalCastExpr,</div>
<div class="line">        CXXNewExpr, CXXTemporaryObjectExpr, CXXUnresolvedConstructExpr,</div>
<div class="line">        ClassTemplateSpecializationDecl, CompoundLiteralExpr, DeclaratorDecl,</div>
<div class="line">        ExplicitCastExpr, ObjCPropertyDecl, TemplateArgumentLoc,</div>
<div class="line">        TypedefNameDecl),</div>
<div class="line">    internal::Matcher&lt;TypeLoc&gt;, Inner) {</div>
<div class="line">  TypeSourceInfo *source = internal::GetTypeSourceInfo(<a class="code" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>);</div>
<div class="line">  <span class="keywordflow">if</span> (source == <span class="keyword">nullptr</span>) {</div>
<div class="line">    <span class="comment">// This happens for example for implicit destructors.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> Inner.matches(source-&gt;getTypeLoc(), Finder, Builder);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">    Matches <span class="keywordflow">if</span> the matched <a class="code" href="classstd_1_1conditional_1_1type.html">type</a> is represented by the given <span class="keywordtype">string</span>.</div>
<div class="line">   </div>
<div class="line">    Given</div>
<div class="line">    \code</div>
<div class="line">      <span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); };</div>
<div class="line">      <span class="keywordtype">void</span> z() { Y* y; y-&gt;x(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(on(hasType(asString("class Y *")))) matches y-&gt;<a class="el" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x()</a> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03970">3970</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aa0898cce8002e6e0db4a3e13b5e9d7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0898cce8002e6e0db4a3e13b5e9d7ff">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[80/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasCanonicalType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches QualTypes whose canonical type matches InnerMatcher. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> &amp;int_ref;</div>
<div class="line"><span class="keywordtype">int</span> a;</div>
<div class="line">int_ref <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = a;</div>
</div><!-- fragment --><p><code>varDecl</code>(hasType(qualType(referenceType()))))) will not match the declaration of b but <code>varDecl</code>(hasType(qualType(hasCanonicalType(referenceType())))))) does. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04045">4045</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a34619df672712c3c1b89e9556ea6fb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34619df672712c3c1b89e9556ea6fb5e">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[81/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pointsTo&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type is a pointer type and the pointee type matches the specified matcher. </p>
<p>Example matches y-&gt;<a class="el" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x()</a> (matcher = cxxMemberCallExpr(on(hasType(pointsTo cxxRecordDecl(hasName("Y"))))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y *y; y-&gt;x(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03984">3984</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a326c00e2c764f18193b0e2ba5050199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326c00e2c764f18193b0e2ba5050199a">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[82/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">references&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type is a reference type and the referenced type matches the specified matcher. </p>
<p>Example matches X &amp;x and const X &amp;y (matcher = varDecl(hasType(references(cxxRecordDecl(hasName("X")))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  <span class="keywordtype">void</span> a(<a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">    <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> &amp;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> &amp;y = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04027">4027</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a224b76b39157090fd8b19e496e6c7938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224b76b39157090fd8b19e496e6c7938">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[83/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReferentLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReferentMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches reference <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have a referent <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> matching <code>ReferentMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 3;</div>
<div class="line"><span class="keywordtype">int</span>&amp; xx = <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> referenceTypeLoc(hasReferentLoc(loc(asString("int")))) matches <code>int&amp;</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06547">6547</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ac2ff88ab9d0d424289cd086b65dda0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ff88ab9d0d424289cd086b65dda0e4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[84/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasReturnValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the return value expression of a return statement. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> a + <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
</div><!-- fragment --><p> hasReturnValue(binaryOperator()) matches 'return a + b' with <a class="el" href="namespaceclang_1_1ast__matchers.html#a92d236ec1064f604664b1e9123249e01" title="Matches binary operator expressions.">binaryOperator()</a> matching 'a + b' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07785">7785</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5393b4cd5dfd74fe486e15f1c0e0cdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5393b4cd5dfd74fe486e15f1c0e0cdc3">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[85/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forCallable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration of the function, method, or block the statement belongs to. </p>
<p>Given: </p><div class="fragment"><div class="line">F&amp; operator=(<span class="keyword">const</span> F&amp; o) {</div>
<div class="line">  std::copy_if(o.begin(), o.end(), begin(), [](<a class="code" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>) { <span class="keywordflow">return</span> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a> &gt; 0; });</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> returnStmt(forCallable(functionDecl(hasName("operator=")))) matches 'return *this' but does not match 'return v &gt; 0'</p>
<p>Given: </p><div class="fragment"><div class="line">-(void) foo {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 1;</div>
<div class="line">  dispatch_sync(queue, ^{ <span class="keywordtype">int</span> y = 2; });</div>
<div class="line">}</div>
</div><!-- fragment --><p> declStmt(forCallable(objcMethodDecl())) matches 'int x = 1' but does not match 'int y = 2'. whereas declStmt(forCallable(blockDecl())) matches 'int y = 2' but does not match 'int x = 1'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07964">7964</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae84a79607cf2c340fa7b7ab1c9ddc28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84a79607cf2c340fa7b7ab1c9ddc28a">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[86/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forFunction&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration of the function the statement belongs to. </p>
<p>Deprecated. Use forCallable() to correctly handle the situation when the declaration is not a function (but a block or an Objective-C method). forFunction() not only fails to take non-functions into account but also may match the wrong declaration in their presence.</p>
<p>Given: </p><div class="fragment"><div class="line">F&amp; operator=(<span class="keyword">const</span> F&amp; o) {</div>
<div class="line">  std::copy_if(o.begin(), o.end(), begin(), [](<a class="code" href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>) { <span class="keywordflow">return</span> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a> &gt; 0; });</div>
<div class="line">  <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> returnStmt(forFunction(hasName("operator="))) matches 'return *this' but does not match 'return v &gt; 0' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07913">7913</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a48a998865c12796efc3e50a1799f60e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a998865c12796efc3e50a1799f60e2">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[87/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mentionsBoundType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BindingID&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OSObjectCStyleCast_8cpp_source.html#l00039">39</a> of file <a class="el" href="OSObjectCStyleCast_8cpp_source.html">OSObjectCStyleCast.cpp</a>.</p>

</div>
</div>
<a id="a4a92ba420d89f91d64dce561258473bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a92ba420d89f91d64dce561258473bd">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[88/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forEachSwitchCase&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches each case or default statement belonging to the given switch statement. </p>
<p>This matcher may produce multiple matches.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (1) { <span class="keywordflow">case</span> 1: <span class="keywordflow">case</span> 2: <span class="keywordflow">default</span>: <span class="keywordflow">switch</span> (2) { <span class="keywordflow">case</span> 3: <span class="keywordflow">case</span> 4: ; } }</div>
</div><!-- fragment --><p> switchStmt(forEachSwitchCase(<a class="el" href="namespaceclang_1_1ast__matchers.html#a5725bf80823feea320c27f79c712e8f6" title="Matches case statements inside switch statements.">caseStmt()</a>.bind("c"))).bind("s") matches four times, with "c" binding each of "case 1:", "case 2:", "case 3:" and "case 4:", and "s" respectively binding "switch (1)", "switch (1)", "switch (2)" and "switch (2)". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07506">7506</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7a50116e967de8dce02523cc01150f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50116e967de8dce02523cc01150f4d">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[89/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">equalsIntegralValue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> of integral type with a given value. </p>
<p>Note that 'Value' is a string as the template argument's value is an arbitrary precision integer. 'Value' must be euqal to the canonical representation of that integral value in base 10.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;42&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(equalsIntegralValue("42"))) matches the implicit instantiation of C in C&lt;42&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01216">1216</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="TemplateBase_8h_source.html#l00082">clang::TemplateArgument::Integral</a>, <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="ThreadSafetyCommon_8h_source.html#l00089">clang::threadSafety::sx::toString()</a>.</p>

</div>
</div>
<a id="a0f8b99a0a4e189acdcdaf259c2290f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8b99a0a4e189acdcdaf259c2290f3d">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[90/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">isExpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a sugar <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> next; };</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>(B::*next_ptr)&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;&amp;B::next&gt; a;</div>
</div><!-- fragment --><p> templateSpecializationType(hasAnyTemplateArgument( isExpr(hasDescendant(declRefExpr(to(fieldDecl(hasName("next")))))))) matches the specialization <code>A&lt;&amp;B::next&gt;</code> with <code>fieldDecl(...)</code> matching <code>B::next</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01164">1164</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a0d66a056fa6763e89a41550a4468db2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d66a056fa6763e89a41550a4468db2f">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[91/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToDeclaration&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a canonical <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> next; };</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>(B::*next_ptr)&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;&amp;B::next&gt; a;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToDeclaration(fieldDecl(hasName("next"))))) matches the specialization <code>A&lt;&amp;B::next&gt;</code> with <code>fieldDecl(...)</code> matching <code>B::next</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01145">1145</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a911620ba71c61c54fcf02cd42d828e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911620ba71c61c54fcf02cd42d828e56">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[92/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToIntegralType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to an integral type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;42&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl( hasAnyTemplateArgument(refersToIntegralType(asString("int")))) matches the implicit instantiation of C in C&lt;42&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01195">1195</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a78151d2a32277bb385119910e537d58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78151d2a32277bb385119910e537d58a">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[93/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToTemplate&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain template. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>S&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>Y {};</div>
<div class="line">X&lt;Y&gt; xi;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToTemplate(templateName()))) matches the specialization <code>X&lt;Y&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01125">1125</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af189946951ce7f935861b3943634e6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af189946951ce7f935861b3943634e6d4">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[94/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">refersToType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> that refers to a certain type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>A {};</div>
<div class="line">A&lt;X&gt; a;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToType(class(hasName("X"))))) matches the specialization <code>A&lt;X&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01107">1107</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7180d456edbc9ab91e28edc4912b5675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7180d456edbc9ab91e28edc4912b5675">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[95/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasAnyTemplateArgumentLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s that have at least one <code><a class="el" href="classclang_1_1TemplateArgumentLoc.html" title="Location wrapper for a TemplateArgument.">TemplateArgumentLoc</a></code> matching the given <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {};</div>
<div class="line">A&lt;int&gt; a;</div>
</div><!-- fragment --><p> varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasAnyTemplateArgumentLoc( hasTypeLoc(loc(asString("int"))))))) matches <code>A&lt;int&gt; a</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06576">6576</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6ce9ed079b63bde07a29f118be67d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9ed079b63bde07a29f118be67d998">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[96/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasUnqualifiedDesugaredType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the matched type matches the unqualified desugared type of the matched node. </p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">using</span> B = A;</div>
</div><!-- fragment --><p> The matcher type(hasUnqualifiedDesugaredType(recordType())) matches both B and A. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04008">4008</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="afda923705023b2e6030c83ffe359a5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda923705023b2e6030c83ffe359a5b1">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[97/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasArgumentOfType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary expressions that have a specific type of argument. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>; <span class="keywordtype">float</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="keyword">sizeof</span>(a) + <span class="keyword">sizeof</span>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) + <span class="keyword">alignof</span>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>);</div>
</div><!-- fragment --><p> unaryExprOrTypeTraitExpr(hasArgumentOfType(asString("int")) matches <code>sizeof(a)</code> and <code><a class="el" href="stdalign_8h.html#abb241e4f00c28465643e1010172aef04">alignof(c)</a></code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02937">2937</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a364b968cdd1a5dd039ef4002d426e62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364b968cdd1a5dd039ef4002d426e62c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[98/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ofKind&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a5d73f06594a5ccb763a726bed94a541f">UnaryExprOrTypeTrait</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kind&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary expressions of a certain kind. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="keyword">sizeof</span>(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) + <span class="keyword">alignof</span>(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>)</div>
</div><!-- fragment --><p> unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf)) matches <code>sizeof(x)</code> </p>
<p>If the matcher is use from clang-query, UnaryExprOrTypeTrait parameter should be passed as a quoted string. e.g., ofKind("UETT_SizeOf"). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02955">2955</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="acafed008cf985cdd00f757db410c921c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafed008cf985cdd00f757db410c921c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[99/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1UsingShadowDecl.html">UsingShadowDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasTargetDecl&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a using shadow declaration where the target declaration is matched by the given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> a; <span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>(); }</div>
<div class="line"><span class="keyword">using</span> X::a;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">X::b</a>;</div>
</div><!-- fragment --><p> usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))) matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">X::b</a> </div>
</div><!-- fragment --><p> but not</p><div class="fragment"><div class="line"><span class="keyword">using</span> X::a </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06353">6353</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af17df7f136021603cccaee853f067429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17df7f136021603cccaee853f067429">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[100/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInitializer&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a variable declaration that has an initializer expression that matches the given matcher. </p>
<p>Example matches x (matcher = varDecl(hasInitializer(callExpr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> y() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04208">4208</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8c97f65fbd9a52a76ebc63979c76f44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c97f65fbd9a52a76ebc63979c76f44c">&#9670;&nbsp;</a></span>AST_MATCHER_P() <span class="overload">[101/101]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasSizeExpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1VariableArrayType.html" title="Represents a C array with a specified size that is not an integer-constant-expression.">VariableArrayType</a></code> nodes that have a specific size expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) {</div>
<div class="line">  <span class="keywordtype">int</span> a[<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>];</div>
<div class="line">}</div>
</div><!-- fragment --><p> variableArrayType(hasSizeExpr(ignoringImpCasts(declRefExpr(to( varDecl(hasName("b"))))))) matches "int a[b]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06820">6820</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6db73fc80716eac3847be470e9d5a8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db73fc80716eac3847be470e9d5a8b3">&#9670;&nbsp;</a></span>AST_MATCHER_P2() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasPlacementArg&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches placement new expression arguments. </p>
<p>Given: </p><div class="fragment"><div class="line">MyClass *p1 = <span class="keyword">new</span> (Storage, 16) MyClass();</div>
</div><!-- fragment --><p> cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))) matches the expression 'new (Storage, 16) MyClass()'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l08064">8064</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a436242d922937081d26821317552407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436242d922937081d26821317552407e">&#9670;&nbsp;</a></span>AST_MATCHER_P2() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">containsDeclaration&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th declaration of a declaration statement. </p>
<p>Note that this does not work for global declarations because the AST breaks up multiple-declaration <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a>'s into multiple single-declaration <a class="el" href="classclang_1_1DeclStmt.html" title="DeclStmt - Adaptor class for mixing declarations with statements and expressions.">DeclStmt</a>'s. Example: Given non-global declarations </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 0;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keywordtype">int</span> d = 2, e;</div>
</div><!-- fragment --><p> declStmt(containsDeclaration( 0, varDecl(hasInitializer(anything())))) matches only 'int d = 2, e;', and declStmt(containsDeclaration(1, varDecl())) </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">matches</a> <span class="stringliteral">&#39;int a, b = 0&#39;</span> as well as <span class="stringliteral">&#39;int d = 2, e;&#39;</span></div>
<div class="line">but <span class="stringliteral">&#39;int c;&#39;</span> is <a class="code" href="iso646_8h.html#a31739c27bdcfdac9faae7bf7a5df49e4">not</a> matched.</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04457">4457</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a61c5a8881ab6f78c544c0a5e158cb54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c5a8881ab6f78c544c0a5e158cb54d">&#9670;&nbsp;</a></span>AST_MATCHER_P2() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasBinding&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the Nth binding of a <a class="el" href="classclang_1_1DecompositionDecl.html" title="A decomposition declaration.">DecompositionDecl</a>. </p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> arr[3];</div>
<div class="line">    <span class="keyword">auto</span> &amp;[f, <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>, t] = arr;</div>
<div class="line"> </div>
<div class="line">    f = 42;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">decompositionDecl</a>(hasBinding(0,</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">bindingDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;f&quot;</span>).bind(<span class="stringliteral">&quot;fBinding&quot;</span>))))</div>
</div><!-- fragment --><p> matches the decomposition decl with 'f' bound to "fBinding". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07865">7865</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a0a44f1320d0ad1ade3dc82fc4730f17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a44f1320d0ad1ade3dc82fc4730f17f">&#9670;&nbsp;</a></span>AST_MATCHER_P2() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasInit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ast_matchers::internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th item of an initializer list expression. </p>
<p>Example matches y. (matcher = initListExpr(hasInit(0, expr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>{y}.</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04417">4417</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a20927991ed40f5b7fc29095fa96e9c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20927991ed40f5b7fc29095fa96e9c36">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callee&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the call expression's callee's declaration matches the given matcher. </p>
<p>Example matches y.x() (matcher = callExpr(callee( cxxMethodDecl(hasName("x"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y y; y.x(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03841">3841</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8932ce498cc406f28f22149d1936c4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932ce498cc406f28f22149d1936c4b1">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thisPointerType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04107">4107</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a86ef01849f0ca8c3b8b5222a4b8e0522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ef01849f0ca8c3b8b5222a4b8e0522">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thisPointerType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the type of the expression's implicit object argument either matches the InnerMatcher, or is a pointer to a type that matches the InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y { <span class="keyword">public</span>: <span class="keywordtype">void</span> m(); };</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> : <span class="keyword">public</span> Y { <span class="keywordtype">void</span> g(); };</div>
<div class="line"><span class="keywordtype">void</span> z() { Y y; y.m(); Y *p; p-&gt;m(); <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.m(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.g(); }</div>
</div><!-- fragment --><p> cxxMemberCallExpr(thisPointerType(hasDeclaration( cxxRecordDecl(hasName("Y"))))) matches <code>y.m()</code>, <code>p-&gt;m()</code> and <code>x.m()</code>. cxxMemberCallExpr(thisPointerType(hasDeclaration( cxxRecordDecl(hasName("X"))))) matches <code>x.g()</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04099">4099</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="abfbd285c2c8e933e8daf5e70ba7442ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbd285c2c8e933e8daf5e70ba7442ac">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Decl.html">Decl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">equalsNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Decl.html">Decl</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads for the <code>equalsNode</code> matcher. </p>
<p>FIXME: Implement for other node types. Matches if a node equals another node.</p>
<p><code><a class="el" href="classclang_1_1Decl.html" title="Decl - This represents one declaration (or definition), e.g.">Decl</a></code> has pointer identity in the AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07477">7477</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a07fc7328f73d9bb7d7d88855195afb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fc7328f73d9bb7d7d88855195afb34">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Expr.html">Expr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParens&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload <code>ignoringParens</code> for <code><a class="el" href="classclang_1_1Expr.html" title="This represents one expression.">Expr</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* str = (<span class="stringliteral">&quot;my-string&quot;</span>);</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a28b1bdd70cca95686345d5a96d97071a">implicitCastExpr</a>(hasSourceExpression(ignoringParens(<a class="code" href="namespaceclang_1_1ast__matchers.html#a2c9fffe33e90bbb4b8f099caf377d7b1">stringLiteral</a>())))</div>
</div><!-- fragment --><p> would match the implicit cast resulting from the assignment. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01000">1000</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aca3d9f788a6b28e7dc769bea201f3931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3d9f788a6b28e7dc769bea201f3931">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasPrefix&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the prefix of a <code><a class="el" href="classclang_1_1NestedNameSpecifier.html" title="Represents a C++ nested name specifier, such as &quot;\::std::vector&lt;int&gt;::&quot;.">NestedNameSpecifier</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keyword">struct </span>B { <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {}; }; };</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">A::B::C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> nestedNameSpecifier(hasPrefix(specifiesType(asString("struct A")))) and matches "A::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07408">7408</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6ea7972419fdbae1850a62aa39c99137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea7972419fdbae1850a62aa39c99137">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hasPrefix&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches on the prefix of a <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html" title="A C++ nested-name-specifier augmented with source location information.">NestedNameSpecifierLoc</a></code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keyword">struct </span>B { <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {}; }; };</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">A::B::C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> nestedNameSpecifierLoc(hasPrefix(loc(specifiesType(asString("struct A"))))) matches "A::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07426">7426</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af4045123f0a783a289d12aaa2f5dc8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4045123f0a783a289d12aaa2f5dc8e7">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ignoringParens&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types that match InnerMatcher after any parens are stripped. </p>
<p>Given </p><div class="fragment"><div class="line">void (*fp)(void);</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasType(<a class="code" href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765">pointerType</a>(pointee(ignoringParens(<a class="code" href="namespaceclang_1_1ast__matchers.html#aeb793c9ea9a7c9a4584f8d9a84963981">functionType</a>())))))</div>
</div><!-- fragment --><p> would match the declaration for fp. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00984">984</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aac6356d65a88dcac0fda65fd48fa0338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6356d65a88dcac0fda65fd48fa0338">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pointsTo&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the pointee type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03992">3992</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aee02e539525731a4811d4d33437b5ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee02e539525731a4811d4d33437b5ff7">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1QualType.html">QualType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">references&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the referenced type's declaration. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04053">4053</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a3a4d5c3bb12d4dde840c16fe5fd11c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4d5c3bb12d4dde840c16fe5fd11c1f">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">equalsNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Stmt.html">Stmt</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a node equals another node. </p>
<p><code><a class="el" href="classclang_1_1Stmt.html" title="Stmt - This represents one statement.">Stmt</a></code> has pointer identity in the AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07483">7483</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a298d1936e4599ecc1d5d0de5717d5125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298d1936e4599ecc1d5d0de5717d5125">&#9670;&nbsp;</a></span>AST_MATCHER_P_OVERLOAD() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">equalsNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Other&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a node equals another node. </p>
<p><code><a class="el" href="classclang_1_1Type.html" title="The base class of the type hierarchy.">Type</a></code> has pointer identity in the AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07489">7489</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aa8cb7556571e959aa00a7d5c8cdd9394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cb7556571e959aa00a7d5c8cdd9394">&#9670;&nbsp;</a></span>AST_MATCHER_REGEX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matchesName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes whose fully qualified names contain a substring matched by the given RegExp. </p>
<p>Supports specifying enclosing namespaces or classes by prefixing the name with '&lt;enclosing&gt;::'. Does not match typedefs of an underlying type with the given name.</p>
<p>Example matches X (regexp == "::X") </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p>Example matches X (regexp is one of "::X", "^foo::.*X", among others) </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>foo { <span class="keyword">namespace </span>bar { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>; } }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03026">3026</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="a1a26f57707ca1cc9c7c2f915bdef1dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26f57707ca1cc9c7c2f915bdef1dec">&#9670;&nbsp;</a></span>AST_MATCHER_REGEX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matchesSelector&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ObjC selectors whose name contains a substring matched by the given RegExp. </p>
<p>matcher = objCMessageExpr(matchesSelector("loadHTMLString\:baseURL?")); matches the outer message expr in the code below, but NOT the message invocation for self.bodyView. </p><div class="fragment"><div class="line">[<span class="keyword">self</span>.bodyView loadHTMLString:html baseURL:<a class="code" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03753">3753</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">string()</a>.</p>

</div>
</div>
<a id="aa682f6d7ba1fc7a0a4473ef0a9a60cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa682f6d7ba1fc7a0a4473ef0a9a60cf2">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">hasDynamicExceptionSpec&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functions that have a dynamic exception specification. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
<div class="line"><span class="keywordtype">void</span> g() noexcept;</div>
<div class="line"><span class="keywordtype">void</span> h() noexcept(<a class="code" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>);</div>
<div class="line"><span class="keywordtype">void</span> i() noexcept(<a class="code" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>);</div>
<div class="line"><span class="keywordtype">void</span> j() throw();</div>
<div class="line"><span class="keywordtype">void</span> k() throw(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> l() throw(...);</div>
</div><!-- fragment --><p> functionDecl(hasDynamicExceptionSpec()) and functionProtoType(hasDynamicExceptionSpec()) match the declarations of j, k, and l, but not f, g, h, or i. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05135">5135</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ac1fdc35c5063926e195a8e9f0814b058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fdc35c5063926e195a8e9f0814b058">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isArrow&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member expressions that are called with '-&gt;' as opposed to '. </p>
<p>'.</p>
<p>Member calls on the implicit this pointer match as called with '-&gt;'.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() { this-&gt;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); Y y; y.x(); a; this-&gt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">Y::b</a>; }</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f() { this-&gt;f&lt;T&gt;(); f&lt;T&gt;(); }</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Z {</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() { this-&gt;m; }</div>
<div class="line">};</div>
</div><!-- fragment --><p> memberExpr(isArrow()) matches this-&gt;x, x, y.x, a, this-&gt;b cxxDependentScopeMemberExpr(isArrow()) matches this-&gt;m unresolvedMemberExpr(isArrow()) matches this-&gt;f&lt;T&gt;, f&lt;T&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06141">6141</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad2906b75257d9178e6513f1cb5834b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2906b75257d9178e6513f1cb5834b79">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isAssignmentOperator&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all kinds of assignment operators. </p>
<p>Example 1: matches a += b (matcher = binaryOperator(isAssignmentOperator())) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (a == <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  a += <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
</div><!-- fragment --><p>Example 2: matches s1 = s2 (matcher = cxxOperatorCallExpr(isAssignmentOperator())) </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S { S&amp; operator=(<span class="keyword">const</span> S&amp;); };</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() { S s1, s2; s1 = s2; }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05592">5592</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a921dd0c92df1afb657e587157c605ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921dd0c92df1afb657e587157c605ab0">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isComparisonOperator&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches comparison operators. </p>
<p>Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (a == <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
<div class="line">  a += <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
</div><!-- fragment --><p>Example 2: matches s1 &lt; s2 (matcher = cxxOperatorCallExpr(isComparisonOperator())) </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S { <span class="keywordtype">bool</span> <a class="code" href="namespaceclang.html#a51e572049a11fe5cf42e8da840bf69af">operator&lt;</a>(<span class="keyword">const</span> S&amp; other); };</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(S s1, S s2) { <span class="keywordtype">bool</span> b1 = s1 &lt; s2; }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05613">5613</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a34c636295b8e279c5b5878462d002f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c636295b8e279c5b5878462d002f0b">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isConsteval&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches consteval function declarations and if consteval/if ! consteval statements. </p>
<p>Given: </p><div class="fragment"><div class="line">consteval <span class="keywordtype">int</span> a();</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>() { <span class="keywordflow">if</span> consteval {} }</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>() { <span class="keywordflow">if</span> ! consteval {} }</div>
<div class="line"><span class="keywordtype">void</span> d() { <span class="keywordflow">if</span> ! consteval {} <span class="keywordflow">else</span> {} }</div>
</div><!-- fragment --><p> functionDecl(isConsteval()) matches the declaration of "int a()". ifStmt(isConsteval()) matches the if statement in "void b()", "void c()", "void d()". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05187">5187</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad47b3fd0af4c1fd58128fd23c52af8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47b3fd0af4c1fd58128fd23c52af8dd">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isConstexpr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constexpr variable and function declarations, and if constexpr. </p>
<p>Given: </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> foo = 42;</div>
<div class="line">constexpr <span class="keywordtype">int</span> bar();</div>
<div class="line"><span class="keywordtype">void</span> baz() { <span class="keywordflow">if</span> constexpr(1 &gt; 0) {} }</div>
</div><!-- fragment --><p> varDecl(isConstexpr()) matches the declaration of foo. functionDecl(isConstexpr()) matches the declaration of bar. ifStmt(isConstexpr()) matches the if statement in baz. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05207">5207</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae8f8830105eda64428bbebf2e06104cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f8830105eda64428bbebf2e06104cd">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isDefinition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1TagDecl.html">TagDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a declaration has a body attached. </p>
<p>Example matches A, va, fa </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">class </span>B;  <span class="comment">// Doesn&#39;t match, as it has no body.</span></div>
<div class="line"><span class="keywordtype">int</span> va;</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> vb;  <span class="comment">// Doesn&#39;t match, as it doesn&#39;t define the variable.</span></div>
<div class="line"><span class="keywordtype">void</span> fa() {}</div>
<div class="line"><span class="keywordtype">void</span> fb();  <span class="comment">// Doesn&#39;t match, as it has no body.</span></div>
<div class="line"><span class="keyword">@interface </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a></div>
<div class="line">- (void)ma; <span class="comment">// Doesn&#39;t match, interface is declaration.</span></div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"><span class="keyword">@implementation </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a></div>
<div class="line">- (void)ma {}</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --><p>Usable as: Matcher&lt;TagDecl&gt;, Matcher&lt;VarDecl&gt;, Matcher&lt;FunctionDecl&gt;, Matcher&lt;ObjCMethodDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05864">5864</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a968ac67c58589231ded255cfa8b7d70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968ac67c58589231ded255cfa8b7d70e">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExpansionInMainFile&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within the main-file. </p>
<p>Example matches X but not Y (matcher = cxxRecordDecl(isExpansionInMainFile()) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Y.h&gt;</span></div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
</div><!-- fragment --><p> Y.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00245">245</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5ac38e17b4f443550d465158fa148ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac38e17b4f443550d465158fa148ec4">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExpansionInSystemHeader&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within system-header-files. </p>
<p>Example matches Y but not X (matcher = cxxRecordDecl(isExpansionInSystemHeader()) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;SystemHeader.h&gt;</span></div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
</div><!-- fragment --><p> SystemHeader.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00266">266</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a3ace1f0e85191bbb9826bea67ed9825c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ace1f0e85191bbb9826bea67ed9825c">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExplicit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor, conversion function, and deduction guide declarations that have an explicit specifier if this explicit specifier is resolved to true. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> b&gt;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  S(<span class="keywordtype">int</span>); <span class="comment">// #1</span></div>
<div class="line">  <span class="keyword">explicit</span> S(<span class="keywordtype">double</span>); <span class="comment">// #2</span></div>
<div class="line">  <span class="keyword">operator</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>(); <span class="comment">// #3</span></div>
<div class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> <a class="code" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>(); <span class="comment">// #4</span></div>
<div class="line">  <span class="keyword">explicit</span>(<span class="keyword">false</span>) S(<span class="keywordtype">bool</span>) <span class="comment">// # 7</span></div>
<div class="line">  <span class="keyword">explicit</span>(<span class="keyword">true</span>) S(<span class="keywordtype">char</span>) <span class="comment">// # 8</span></div>
<div class="line">  <span class="keyword">explicit</span>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) S(S) <span class="comment">// # 9</span></div>
<div class="line">};</div>
<div class="line">S(<span class="keywordtype">int</span>) -&gt; S&lt;true&gt; <span class="comment">// #5</span></div>
<div class="line"><span class="keyword">explicit</span> S(<span class="keywordtype">double</span>) -&gt; S&lt;false&gt; <span class="comment">// #6</span></div>
</div><!-- fragment --><p> cxxConstructorDecl(isExplicit()) will match #2 and #8, but not #1, #7 or #9. cxxConversionDecl(isExplicit()) will match #4, but not #3. cxxDeductionGuideDecl(isExplicit()) will match #6, but not #5. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07638">7638</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a712ca64c1b2c32d0a675fea55d05231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ca64c1b2c32d0a675fea55d05231f">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isExplicitTemplateSpecialization&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches explicit template specializations of function, class, or static member variable template instantiations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> A(T t) { }</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> A(<span class="keywordtype">int</span> N) { }</div>
</div><!-- fragment --><p> functionDecl(isExplicitTemplateSpecialization()) matches the specialization A&lt;int&gt;().</p>
<p>Usable as: Matcher&lt;FunctionDecl&gt;, Matcher&lt;VarDecl&gt;, Matcher&lt;CXXRecordDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06444">6444</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00183">clang::TSK_ExplicitSpecialization</a>.</p>

</div>
</div>
<a id="ac23d371182732d8e3f7bf723c389bcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d371182732d8e3f7bf723c389bcf0">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SemaDecl_8cpp.html#aec982ed92ad089218775cb39b43df9fc">isExternC</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches extern "C" function or variable declarations. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> { <span class="keywordtype">void</span> g() {} }</div>
<div class="line"><span class="keywordtype">void</span> h() {}</div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 1;</div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> y = 2;</div>
<div class="line"><span class="keywordtype">int</span> z = 3;</div>
</div><!-- fragment --><p> functionDecl(isExternC()) matches the declaration of f and g, but not the declaration of h. varDecl(isExternC()) matches the declaration of x and y, but not the declaration of z. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05058">5058</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a9751536735d265204f305b51cefd1ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9751536735d265204f305b51cefd1ab6">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isFinal&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the given method or class declaration is final. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A final {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>B {</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> f();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : B {</div>
<div class="line">  <span class="keywordtype">void</span> f() final;</div>
<div class="line">};</div>
</div><!-- fragment --><p> matches A and C::f, but not B, C, or B::f </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06015">6015</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a6be371ebd5c73a20026d875d3f3afffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be371ebd5c73a20026d875d3f3afffe">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isImplicit&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a>, <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches an entity that has been implicitly added by the compiler (e.g. </p>
<p>implicit default/copy constructors). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00759">759</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a0c2d8baceba2a26515ef9ed5d850f12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d8baceba2a26515ef9ed5d850f12e">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isInline&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functions, variables and namespace declarations that are marked with the inline keyword. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> f();</div>
<div class="line"><span class="keywordtype">void</span> g();</div>
<div class="line"><span class="keyword">namespace </span>n {</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">namespace </span>m {}</div>
<div class="line">}</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">int</span> Foo = 5;</div>
</div><!-- fragment --><p> functionDecl(isInline()) will match ::f(). namespaceDecl(isInline()) will match n::m. varDecl(isInline()) will match Foo; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l07691">7691</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8994aabec60a6969bd1db250086972e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8994aabec60a6969bd1db250086972e6">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isNoThrow&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functions that have a non-throwing exception specification. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
<div class="line"><span class="keywordtype">void</span> g() noexcept;</div>
<div class="line"><span class="keywordtype">void</span> h() throw();</div>
<div class="line"><span class="keywordtype">void</span> i() throw(<span class="keywordtype">int</span>);</div>
<div class="line"><span class="keywordtype">void</span> j() noexcept(<a class="code" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>);</div>
</div><!-- fragment --><p> functionDecl(isNoThrow()) and functionProtoType(isNoThrow()) match the declarations of g, and h, but not f, i or j. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05155">5155</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Type_8h_source.html#l04135">clang::FunctionProtoType::getExceptionSpecType()</a>, <a class="el" href="Type_8h_source.html#l04227">clang::FunctionProtoType::isNothrow()</a>, <a class="el" href="ExceptionSpecificationType_8h_source.html#l00049">clang::isUnresolvedExceptionSpec()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ad2128e92dde14b184065a2c1aae5e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2128e92dde14b184065a2c1aae5e23b">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isPrivate&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches private C++ declarations and C++ base specifers that specify private inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>; <span class="comment">// fieldDecl(isPrivate()) matches &#39;c&#39;</span></div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">struct </span>Derived1 : <span class="keyword">private</span> <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
<div class="line"><span class="keyword">class </span>Derived2 : <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00674">674</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00111">clang::AS_private</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aa70d182f0dc6e578582e680c791f0425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70d182f0dc6e578582e680c791f0425">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isProtected&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches protected C++ declarations and C++ base specifers that specify protected inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a;</div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <span class="comment">// fieldDecl(isProtected()) matches &#39;b&#39;</span></div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived : <span class="keyword">protected</span> <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00651">651</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00110">clang::AS_protected</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="ae26030464371cdda3687f2a9e71a6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26030464371cdda3687f2a9e71a6518">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isPublic&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches public C++ declarations and C++ base specifers that specify public inheritance. </p>
<p>Examples: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:    <span class="keywordtype">int</span> a; <span class="comment">// fieldDecl(isPublic()) matches &#39;a&#39;</span></div>
<div class="line"><span class="keyword">protected</span>: <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">private</span>:   <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived1 : <span class="keyword">public</span> <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
<div class="line"><span class="keyword">struct </span>Derived2 : <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches &#39;Base&#39;</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00629">629</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="Specifiers_8h_source.html#l00109">clang::AS_public</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a9ff96786938aea59fcf81f4f787dddbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff96786938aea59fcf81f4f787dddbd">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isStaticStorageClass&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches variable/function declarations that have "static" storage class specifier ("static" keyword) written in the source. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> i = 0;</div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> j;</div>
<div class="line"><span class="keywordtype">int</span> k;</div>
</div><!-- fragment --><p> functionDecl(isStaticStorageClass()) matches the function declaration f. varDecl(isStaticStorageClass()) matches the variable declaration i. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05077">5077</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, and <a class="el" href="Specifiers_8h_source.html#l00237">clang::SC_Static</a>.</p>

</div>
</div>
<a id="ab7ea8656591d99d51f9101406b84bc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ea8656591d99d51f9101406b84bc6e">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a0b8388fd083767ec7fc87ac872cb7be3">isTemplateInstantiation</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template instantiations of function, class, or static member variable template instantiations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; <span class="keyword">class </span>A {}; X&lt;A&gt; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; <span class="keyword">class </span>A {}; <span class="keyword">template</span> <span class="keyword">class </span>X&lt;A&gt;;</div>
</div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; <span class="keyword">class </span>A {}; <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>X&lt;A&gt;;</div>
</div><!-- fragment --><p> cxxRecordDecl(hasName("::X"), <a class="el" href="namespaceclang.html#a0b8388fd083767ec7fc87ac872cb7be3" title="Determine whether this template specialization kind refers to an instantiation of an entity (as oppos...">isTemplateInstantiation()</a>) matches the template instantiation of X.</p>
<p>But given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; <span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>&lt;A&gt; {}; X&lt;A&gt; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> cxxRecordDecl(hasName("::X"), <a class="el" href="namespaceclang.html#a0b8388fd083767ec7fc87ac872cb7be3" title="Determine whether this template specialization kind refers to an instantiation of an entity (as oppos...">isTemplateInstantiation()</a>) does not match, as X is an explicit template specialization.</p>
<p>Usable as: Matcher&lt;FunctionDecl&gt;, Matcher&lt;VarDecl&gt;, Matcher&lt;CXXRecordDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06385">6385</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>, <a class="el" href="Specifiers_8h_source.html#l00187">clang::TSK_ExplicitInstantiationDeclaration</a>, <a class="el" href="Specifiers_8h_source.html#l00191">clang::TSK_ExplicitInstantiationDefinition</a>, and <a class="el" href="Specifiers_8h_source.html#l00179">clang::TSK_ImplicitInstantiation</a>.</p>

</div>
</div>
<a id="ab0448005fc240cb31fe89537aa08fdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0448005fc240cb31fe89537aa08fdac">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER </td>
          <td>(</td>
          <td class="paramtype">isVirtual&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations of virtual methods and C++ base specifers that specify virtual inheritance. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); <span class="comment">// matches x</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>DirectlyDerived : <span class="keyword">virtual</span> <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches Base</span></div>
<div class="line"><span class="keyword">class </span>IndirectlyDerived : DirectlyDerived, <a class="code" href="classBase.html">Base</a> {}; <span class="comment">// matches Base</span></div>
</div><!-- fragment --><p>Usable as: Matcher&lt;CXXMethodDecl&gt;, Matcher&lt;CXXBaseSpecifier&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05972">5972</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a46a4ccd4bcea5a4e03c1a502b4febba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a4ccd4bcea5a4e03c1a502b4febba3">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">argumentCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a call expression or a constructor call expression has a specific number of arguments (including absent default arguments). </p>
<p>Example matches f(0, 0) (matcher = callExpr(argumentCountIs(2))) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, <span class="keywordtype">int</span> y);</div>
<div class="line">f(0, 0);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04373">4373</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a311e24bcf30db85f9701f1edd3f74b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311e24bcf30db85f9701f1edd3f74b70">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">equalsBoundNode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Type.html">Type</a>, <a class="el" href="classclang_1_1QualType.html">QualType</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if a node equals a previously bound node. </p>
<p>Matches a node if it equals the node previously bound to <code>ID</code>.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> a; <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; };</div>
</div><!-- fragment --><p> cxxRecordDecl( has(fieldDecl(hasName("a"), hasType(<a class="el" href="namespaceclang_1_1ast__matchers.html#a600679c157b5bd05c4bfb940fb2511dd" title="Matches Types in the clang AST.">type()</a>.bind("t")))), has(fieldDecl(hasName("b"), hasType(type(equalsBoundNode("t")))))) matches the class <code>X</code>, as <code>a</code> and <code>b</code> have the same type.</p>
<p>Note that when multiple matches are involved via <code>forEach*</code> matchers, <code>equalsBoundNodes</code> acts as a filter. For example: compoundStmt( forEachDescendant(<a class="el" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82" title="Matches variable declarations.">varDecl()</a>.bind("d")), forEachDescendant(declRefExpr(to(decl(equalsBoundNode("d")))))) will trigger a match for each combination of variable declaration and reference to that variable declaration within a compound statement. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05322">5322</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTTypeTraits_8h_source.html#l00253">clang::DynTypedNode::create()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a33beb8112c5d3457aa00768aaafc89f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33beb8112c5d3457aa00768aaafc89f2">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnyArgument&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any argument of a call expression or a constructor call expression, or an ObjC-message-send expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>) { <span class="keywordtype">int</span> y; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(1, y, 42); }</div>
</div><!-- fragment --><p> callExpr(hasAnyArgument(declRefExpr())) matches x(1, y, 42) with hasAnyArgument(...) matching y</p>
<p>For ObjectiveC, given </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void) f:(<span class="keywordtype">int</span>) y; <span class="keyword">@end</span></div>
<div class="line"><span class="keywordtype">void</span> foo(I *i) { [i f:12]; }</div>
</div><!-- fragment --><p> objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))) matches [i f:12] </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04622">4622</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8247f72147eb15518da3fefa6d89de38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8247f72147eb15518da3fefa6d89de38">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnyParameter&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any parameter of a function or an ObjC method declaration or a block. </p>
<p>Does not match the 'this' parameter of a method.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z) {} };</div>
</div><!-- fragment --><p> cxxMethodDecl(hasAnyParameter(hasName("y"))) matches f(int x, int y, int z) {} with hasAnyParameter(...) matching int y</p>
<p>For ObjectiveC, given </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void) f:(<span class="keywordtype">int</span>) y; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> the matcher objcMethodDecl(hasAnyParameter(hasName("y"))) matches the declaration of method f with hasParameter matching y.</p>
<p>For blocks, given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = ^(<span class="keywordtype">int</span> y) { <a class="code" href="opencl-c-base_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a>(<span class="stringliteral">&quot;%d&quot;</span>, y) };</div>
</div><!-- fragment --><p>the matcher blockDecl(hasAnyParameter(hasName("y"))) matches the declaration of the block b with hasParameter matching y. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04979">4979</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a4ff742094cc27e60ffda9e493ccf0773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff742094cc27e60ffda9e493ccf0773">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnySubstatement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches compound statements where at least one substatement matches a given matcher. </p>
<p>Also matches StmtExprs that have <a class="el" href="classclang_1_1CompoundStmt.html" title="CompoundStmt - This represents a group of statements like { stmt stmt }.">CompoundStmt</a> as children.</p>
<p>Given </p><div class="fragment"><div class="line">{ {}; 1+2; }</div>
</div><!-- fragment --><p> hasAnySubstatement(compoundStmt()) matches '{ {}; 1+2; }' with <a class="el" href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749" title="Matches compound statements.">compoundStmt()</a> matching '{}' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05460">5460</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2a6b5c72b69ebf86c242f591b3a607cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6b5c72b69ebf86c242f591b3a607cf">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasAnyTemplateArgument&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches classTemplateSpecializations, templateSpecializationType and functionDecl that have at least one <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matching the given InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a81cb22c87f277e41a39a91e48766e549">double</a>&gt; {};</div>
<div class="line">A&lt;int&gt; a;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; f() {};</div>
<div class="line"><span class="keywordtype">void</span> func() { f&lt;int&gt;(); };</div>
</div><!-- fragment --><p>classTemplateSpecializationDecl(hasAnyTemplateArgument( refersToType(asString("int")))) matches the specialization <code>A&lt;int&gt;</code> </p>
<p>functionDecl(hasAnyTemplateArgument(refersToType(asString("int")))) matches the specialization <code>f&lt;int&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00786">786</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a108c5647ad1e01c2f4a2bfdb4b917965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108c5647ad1e01c2f4a2bfdb4b917965">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasBody&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DoStmt.html">DoStmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a 'for', 'while', 'do while' statement or a function definition that has a given body. </p>
<p>Note that in case of functions this matcher only matches the definition itself and not the other declarations of the same function.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (;;) {}</div>
</div><!-- fragment --><p> hasBody(compoundStmt()) matches 'for (;;) {}' with <a class="el" href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749" title="Matches compound statements.">compoundStmt()</a> matching '{}'</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
<div class="line"><span class="keywordtype">void</span> f() {}</div>
</div><!-- fragment --><p> hasBody(functionDecl()) matches 'void f() {}' with <a class="el" href="namespaceclang_1_1ast__matchers.html#a496a3f466a3f754041e8a1cfd3aaf749" title="Matches compound statements.">compoundStmt()</a> matching '{}' but does not match 'void f();' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05412">5412</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ae29d543b314240f67d977c1e1211c8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29d543b314240f67d977c1e1211c8bb">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasCondition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>, <a class="el" href="classclang_1_1AbstractConditionalOperator.html">AbstractConditionalOperator</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the condition expression of an if statement, for loop, switch statement or conditional operator. </p>
<p>Example matches true (matcher = hasCondition(cxxBoolLiteral(equals(true)))) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">true</span>) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05267">5267</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a3e5713c227c2899711e0994de49ce918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5713c227c2899711e0994de49ce918">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasEitherOperand&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if either the left hand side or the right hand side of a binary operator matches. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05654">5654</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ac51232687c8252d0341b5a094b0feb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51232687c8252d0341b5a094b0feb33">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasInitStatement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1IfStmt.html">IfStmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches selection statements with initializer. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() {</div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keywordtype">int</span> i = foobar(); i &gt; 0) {}</div>
<div class="line">  <span class="keywordflow">switch</span> (<span class="keywordtype">int</span> i = foobar(); i) {}</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a = get_range(); <span class="keyword">auto</span>&amp; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> : a) {}</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> bar() {</div>
<div class="line">  <span class="keywordflow">if</span> (foobar() &gt; 0) {}</div>
<div class="line">  <span class="keywordflow">switch</span> (foobar()) {}</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> : get_range()) {}</div>
<div class="line">}</div>
</div><!-- fragment --><p> ifStmt(hasInitStatement(anything())) matches the if statement in foo but not in bar. switchStmt(hasInitStatement(anything())) matches the switch statement in foo but not in bar. cxxForRangeStmt(hasInitStatement(anything())) matches the range for statement in foo but not in bar. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05252">5252</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a58e231cf3ad9b2d725fe41521ae01416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e231cf3ad9b2d725fe41521ae01416">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasLHS&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the left hand side of binary operator expressions. </p>
<p>Example matches a (matcher = binaryOperator(hasLHS())) </p><div class="fragment"><div class="line">a || <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05626">5626</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="adc0d19d5ba477202f97ac5a225d246a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0d19d5ba477202f97ac5a225d246a3">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasObjectExpression&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a member expression where the object expression is matched by a given matcher. </p>
<p>Implicit object expressions are included; that is, it matches use of implicit <code>this</code>.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  <span class="keywordtype">int</span> m;</div>
<div class="line">  <span class="keywordtype">int</span> f(<a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.m; <span class="keywordflow">return</span> m; }</div>
<div class="line">};</div>
</div><!-- fragment --><p> memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName("X"))))) matches <code>x.m</code>, but not <code>m</code>; however, memberExpr(hasObjectExpression(hasType(pointsTo( matches <code>m</code> (aka. <code>this-&gt;m</code>), but not <code>x.m</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06311">6311</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7347eb115ff1dd512cb2f720ca35f812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7347eb115ff1dd512cb2f720ca35f812">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasOperatorName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Name&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the operator Name of operator expressions (binary or unary). </p>
<p>Example matches a || b (matcher = binaryOperator(hasOperatorName("||"))) </p><div class="fragment"><div class="line">!(a || <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05553">5553</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aa103fa34c8174316318f579a15234a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa103fa34c8174316318f579a15234a33">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasRHS&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the right hand side of binary operator expressions. </p>
<p>Example matches b (matcher = binaryOperator(hasRHS())) </p><div class="fragment"><div class="line">a || <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05642">5642</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2e42518161472ddb640ba49d061a6507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e42518161472ddb640ba49d061a6507">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasSize&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes that have the specified size. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[42];</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[2 * 21];</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[41], d[43];</div>
<div class="line"><span class="keywordtype">char</span> *<a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="stringliteral">&quot;abcd&quot;</span>;</div>
<div class="line"><span class="keywordtype">wchar_t</span> *ws = L<span class="stringliteral">&quot;abcd&quot;</span>;</div>
<div class="line"><span class="keywordtype">char</span> *w = <span class="stringliteral">&quot;a&quot;</span>;</div>
</div><!-- fragment --><p> constantArrayType(hasSize(42)) matches "int a[42]" and "int b[2 * 21]" stringLiteral(hasSize(4)) matches "abcd", L"abcd" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06761">6761</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a5f3cd96cdc8e727cc6d2b1a997d00ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3cd96cdc8e727cc6d2b1a997d00ee4">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasSourceExpression&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CastExpr.html">CastExpr</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the cast's source expression or opaque value's source expression matches the given matcher. </p>
<p>Example 1: matches "a string" (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))) </p><div class="fragment"><div class="line"><span class="keyword">class </span>URL { URL(<span class="keywordtype">string</span>); };</div>
<div class="line">URL url = <span class="stringliteral">&quot;a string&quot;</span>;</div>
</div><!-- fragment --><p>Example 2: matches 'b' (matcher = opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> ?: 1;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05716">5716</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a3b418923f78e631d2435afa5e2e19652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b418923f78e631d2435afa5e2e19652">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">hasUnaryOperand&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the operand of a unary operator matches. </p>
<p>Example matches true (matcher = hasUnaryOperand( cxxBoolLiteral(equals(true)))) </p><div class="fragment"><div class="line">!<span class="keyword">true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05692">5692</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a7aeb83f2ec21f29e79ce86e902ed8540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeb83f2ec21f29e79ce86e902ed8540">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">isDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ classes that are directly or indirectly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>, or Objective-C classes that directly or indirectly subclass a class matching <code><a class="el" href="classBase.html">Base</a></code>. </p>
<p>Note that a class is not considered to be derived from itself.</p>
<p>Example matches Y, Z, C (<a class="el" href="classBase.html">Base</a> == hasName("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">class </span>Y : <span class="keyword">public</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};  <span class="comment">// directly derived</span></div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> Y {};  <span class="comment">// indirectly derived</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> A;</div>
<div class="line"><span class="keyword">typedef</span> A B;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">public</span> B {};  <span class="comment">// derived from a typedef of X</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("X")): </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">typedef</span> Foo <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">class </span>Bar : <span class="keyword">public</span> Foo {};  <span class="comment">// derived from a type that X is a typedef of</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("NSObject")) </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>NSObject <span class="keyword">@end</span></div>
<div class="line"><span class="keyword">@interface </span>Bar : NSObject @end</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;CXXRecordDecl&gt;, Matcher&lt;ObjCInterfaceDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03181">3181</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a35486e436ae0dbb176252fc6b3cf62fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35486e436ae0dbb176252fc6b3cf62fd">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">isExpandedFromMacro&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MacroName&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statements that are (transitively) expanded from the named macro. </p>
<p>Does not match if only part of the statement is expanded from that macro or if different parts of the statement are expanded from different appearances of the macro. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00314">314</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a5c864eda133965e8b52b66d3f05a1e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c864eda133965e8b52b66d3f05a1e28">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">parameterCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>FunctionDecls</code> and <code>FunctionProtoTypes</code> that have a specific parameter count. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i) {}</div>
<div class="line"><span class="keywordtype">void</span> g(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) {}</div>
<div class="line"><span class="keywordtype">void</span> h(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);</div>
<div class="line"><span class="keywordtype">void</span> j(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="keywordtype">void</span> k(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z, ...);</div>
</div><!-- fragment --><p> functionDecl(parameterCountIs(2)) matches <code>g</code> and <code>h</code> functionProtoType(parameterCountIs(2)) matches <code>g</code> and <code>h</code> functionProtoType(parameterCountIs(3)) matches <code>k</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05007">5007</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a8d5bfa4d4498d0db062ebae29807b397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5bfa4d4498d0db062ebae29807b397">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P </td>
          <td>(</td>
          <td class="paramtype">templateArgumentCountIs&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the number of template arguments equals <code>N</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(templateArgumentCountIs(1)) matches C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01088">1088</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2af575f4746ac9a3a887ba95055a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af575f4746ac9a3a887ba95055a0b98">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">forEachArgumentWithParam&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all arguments and their respective <a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="keywordtype">int</span> y;</div>
<div class="line">f(y);</div>
</div><!-- fragment --><p> callExpr( forEachArgumentWithParam( declRefExpr(to(varDecl(hasName("y")))), parmVarDecl(hasType(isInteger())) )) matches f(y); with declRefExpr(...) matching int y and parmVarDecl(...) matching int i </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04784">4784</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="af7884898943337e06f5ab539e5b508b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7884898943337e06f5ab539e5b508b0">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">forEachArgumentWithParamType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParamMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all arguments and their respective types for a <code><a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a></code> or <code><a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a></code>. </p>
<p>It is very similar to <code>forEachArgumentWithParam</code> but it works on calls through function pointers as well.</p>
<p>The difference is, that function pointers do not provide access to a <code><a class="el" href="classclang_1_1ParmVarDecl.html" title="Represents a parameter to a function.">ParmVarDecl</a></code>, but only the <code><a class="el" href="classclang_1_1QualType.html" title="A (possibly-)qualified type.">QualType</a></code> for each argument.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="keywordtype">int</span> y;</div>
<div class="line">f(y);</div>
<div class="line">void (*f_ptr)(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) = f;</div>
<div class="line">f_ptr(y);</div>
</div><!-- fragment --><p> callExpr( forEachArgumentWithParamType( declRefExpr(to(varDecl(hasName("y")))), qualType(isInteger()).bind("type) )) matches f(y) and f_ptr(y) with declRefExpr(...) matching int y and qualType(...) matching int </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04845">4845</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ad47efa625b357d8576ddd7845b4d8a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47efa625b357d8576ddd7845b4d8a2e">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasArgument&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>( <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th argument of a call expression or a constructor call expression. </p>
<p>Example matches y in x(y) (matcher = callExpr(hasArgument(0, declRefExpr()))) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(<span class="keywordtype">int</span>) { <span class="keywordtype">int</span> y; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(y); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04397">4397</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9f4a96b1f5a45478d7712a6ff08c5a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4a96b1f5a45478d7712a6ff08c5a12">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasOperands&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matcher1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matcher2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if both matchers match with opposite sides of the binary operator. </p>
<p>Example matcher = binaryOperator(hasOperands(integerLiteral(equals(1), integerLiteral(equals(2))) </p><div class="fragment"><div class="line">1 + 2 <span class="comment">// Match</span></div>
<div class="line">2 + 1 <span class="comment">// Match</span></div>
<div class="line">1 + 1 <span class="comment">// No match</span></div>
<div class="line">2 + 2 <span class="comment">// No match</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05674">5674</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00992">allOf</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">anyOf</a>, <a class="el" href="ThreadSafetyCommon_8h_source.html#l00067">clang::threadSafety::sx::matches()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a79ebb293017dba39bb149d8faea59176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ebb293017dba39bb149d8faea59176">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasParameter&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the n'th parameter of a function or an ObjC method declaration or a block. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) {} };</div>
</div><!-- fragment --><p> cxxMethodDecl(hasParameter(0, hasType(varDecl()))) matches f(int x) {} with hasParameter(...) matching int x</p>
<p>For ObjectiveC, given </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>I - (void) f:(<span class="keywordtype">int</span>) y; <span class="keyword">@end</span></div>
</div><!-- fragment --><p> the matcher objcMethodDecl(hasParameter(0, hasName("y"))) matches the declaration of method f with hasParameter matching y. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l04756">4756</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ac2ae808f2b4db9e59ead6b1695186d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ae808f2b4db9e59ead6b1695186d91">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasTemplateArgument&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a>, <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches classTemplateSpecializations, templateSpecializationType and functionDecl where the n'th <a class="el" href="classclang_1_1TemplateArgument.html" title="Represents a template argument.">TemplateArgument</a> matches the given InnerMatcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class </span>A {};</div>
<div class="line">A&lt;bool, int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">A&lt;int, bool&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> f() {}</div>
<div class="line"><span class="keywordtype">void</span> func() { f&lt;int&gt;(); };</div>
</div><!-- fragment --><p> classTemplateSpecializationDecl(hasTemplateArgument( 1, refersToType(asString("int")))) matches the specialization <code>A&lt;bool, int&gt;</code> </p>
<p>functionDecl(hasTemplateArgument(0, refersToType(asString("int")))) matches the specialization <code>f&lt;int&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l01066">1066</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="aa2cfe4f5d9f29cc35a12a3abb6443bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cfe4f5d9f29cc35a12a3abb6443bce">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P2() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P2 </td>
          <td>(</td>
          <td class="paramtype">hasTemplateArgumentLoc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a>, <a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s where the n'th <code><a class="el" href="classclang_1_1TemplateArgumentLoc.html" title="Location wrapper for a TemplateArgument.">TemplateArgumentLoc</a></code> matches the given <code>InnerMatcher</code>. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">class </span>A {};</div>
<div class="line">A&lt;double, int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">A&lt;int, double&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0, hasTypeLoc(loc(asString("double"))))))) matches <code>A&lt;double, int&gt; b</code>, but not <code>A&lt;int, double&gt; c</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l06600">6600</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a8896d437173e705cd26d3a57a6949840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8896d437173e705cd26d3a57a6949840">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____clang__hip__libdevice__declares_8h.html#a81cb22c87f277e41a39a91e48766e549">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05536">5536</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="aaa3fb0f523a50436b680799583adf5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3fb0f523a50436b680799583adf5b2">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05518">5518</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a93b7ca6be7f065051e54b82cde76f81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b7ca6be7f065051e54b82cde76f81d">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="UninitializedValues_8cpp.html#a896c037a32087c5c20d97e64a1786880">Value</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05527">5527</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a32edc701e40baa415fe15868791c4b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32edc701e40baa415fe15868791c4b9a">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">hasType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the expression's or declaration's type matches a type matcher. </p>
<p>Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X"))))) and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X"))))) and <a class="el" href="classU.html">U</a> (matcher = typedefDecl(hasType(asString("int"))) and friend class X (matcher = friendDecl(hasType("X")) and public virtual X (matcher = cxxBaseSpecifier(hasType( asString("class X"))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keywordtype">void</span> y(<a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> &amp;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> z; }</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="classU.html">U</a>;</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>; };</div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03862">3862</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ace3a094ff7ddc1b0328cb262bffc465b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3a094ff7ddc1b0328cb262bffc465b">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">hasType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Expr.html">Expr</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a>, <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InnerMatcher&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded to match the declaration of the expression's or value declaration's type. </p>
<p>In case of a value declaration (for example a variable declaration), this resolves one layer of indirection. For example, in the value declaration "X x;", cxxRecordDecl(hasName("X")) matches the declaration of X, while varDecl(hasType(cxxRecordDecl(hasName("X")))) matches the declaration of x.</p>
<p>Example matches x (matcher = expr(hasType(cxxRecordDecl(hasName("X"))))) and z (matcher = varDecl(hasType(cxxRecordDecl(hasName("X"))))) and friend class X (matcher = friendDecl(hasType("X")) and public virtual X (matcher = cxxBaseSpecifier(hasType( cxxRecordDecl(hasName("X")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keywordtype">void</span> y(<a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> &amp;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) { <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> z; }</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>; };</div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> <span class="keyword">virtual</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
</div><!-- fragment --><p>Example matches class Derived (matcher = cxxRecordDecl(hasAnyBase(hasType(cxxRecordDecl(hasName("Base")))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classBase.html">Base</a> {};</div>
<div class="line"><span class="keyword">class </span>Derived : <a class="code" href="classBase.html">Base</a> {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Expr&gt;, Matcher&lt;FriendDecl&gt;, Matcher&lt;ValueDecl&gt;, Matcher&lt;CXXBaseSpecifier&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03903">3903</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a931d53d9c92b933394ca4e31fd3610db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d53d9c92b933394ca4e31fd3610db">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03196">3196</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l02991">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a5e3046ab1a3310f7867a4c1e47c9bfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3046ab1a3310f7867a4c1e47c9bfff">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDirectlyDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ or Objective-C classes that are directly derived from a class matching <code><a class="el" href="classBase.html">Base</a></code>. </p>
<p>Note that a class is not considered to be derived from itself.</p>
<p>Example matches Y, C (<a class="el" href="classBase.html">Base</a> == hasName("X")) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">class </span>Y : <span class="keyword">public</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};  <span class="comment">// directly derived</span></div>
<div class="line"><span class="keyword">class </span>Z : <span class="keyword">public</span> Y {};  <span class="comment">// indirectly derived</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> A;</div>
<div class="line"><span class="keyword">typedef</span> A B;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">public</span> B {};  <span class="comment">// derived from a typedef of X</span></div>
</div><!-- fragment --><p>In the following example, Bar matches isDerivedFrom(hasName("X")): </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo;</div>
<div class="line"><span class="keyword">typedef</span> Foo <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">class </span>Bar : <span class="keyword">public</span> Foo {};  <span class="comment">// derived from a type that X is a typedef of</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03306">3306</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a898b5ddf30c2409c36bdb3cc0abb789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898b5ddf30c2409c36bdb3cc0abb789f">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isDirectlyDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isDirectlyDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03321">3321</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l02991">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="a2fbefa428d3a7d1641d6ac07a021cdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbefa428d3a7d1641d6ac07a021cdcf">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isSameOrDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase.html">Base</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <code>isDerivedFrom()</code>, but also matches classes that directly match <code><a class="el" href="classBase.html">Base</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03254">3254</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">anyOf</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="afb9b17e996eb7d40a1b04ce7701a07db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9b17e996eb7d40a1b04ce7701a07db">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_P_OVERLOAD() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P_OVERLOAD </td>
          <td>(</td>
          <td class="paramtype">isSameOrDerivedFrom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseName&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded method as shortcut for <code>isSameOrDerivedFrom(hasName(...))</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03269">3269</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchers_8h_source.html#l02991">hasName()</a>, and <a class="el" href="ASTMatchFinder_8cpp_source.html#l00068">Node</a>.</p>

</div>
</div>
<a id="acb873849aa797b4e9b6691b4d9fed736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb873849aa797b4e9b6691b4d9fed736">&#9670;&nbsp;</a></span>AST_POLYMORPHIC_MATCHER_REGEX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_REGEX </td>
          <td>(</td>
          <td class="paramtype">isExpansionInFileMatching&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegExp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that were expanded within files whose name is partially matching a given regex. </p>
<p>Example matches Y but not X (matcher = cxxRecordDecl(isExpansionInFileMatching("AST.*")) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ASTMatcher.h&quot;</span></div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
</div><!-- fragment --><p> ASTMatcher.h: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Matcher&lt;Decl&gt;, Matcher&lt;Stmt&gt;, Matcher&lt;TypeLoc&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00291">291</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a2e736c2b875e6ea57aa811e01da8ef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e736c2b875e6ea57aa811e01da8ef6d">&#9670;&nbsp;</a></span>AST_TYPE_TRAVERSE_MATCHER() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPE_TRAVERSE_MATCHER </td>
          <td>(</td>
          <td class="paramtype">hasDeducedType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">getDeducedType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AutoType.html">AutoType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1AutoType.html" title="Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained by a type-constraint.">AutoType</a></code> nodes where the deduced type is a specific type. </p>
<p>Note: There is no <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> for the deduced type and thus no <code>getDeducedLoc()</code> matcher.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">auto</span> a = 1;</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 2.0;</div>
</div><!-- fragment --><p> autoType(hasDeducedType(isInteger())) matches "auto a"</p>
<p>Usable as: Matcher&lt;AutoType&gt; </p>

</div>
</div>
<a id="a10974b3b97a20357316c2557f54d55fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10974b3b97a20357316c2557f54d55fc">&#9670;&nbsp;</a></span>AST_TYPE_TRAVERSE_MATCHER() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPE_TRAVERSE_MATCHER </td>
          <td>(</td>
          <td class="paramtype">hasReplacementType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">getReplacementType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template type parameter substitutions that have a replacement type that matches the provided matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">double</span> F(T t);</div>
<div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordtype">double</span> j = F(i);</div>
</div><!-- fragment --><p><code>substTemplateTypeParmType</code>(hasReplacementType(type())) matches int </p>

</div>
</div>
<a id="a0dfb240ad1b8144d7d9a59c834a8e5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfb240ad1b8144d7d9a59c834a8e5cb">&#9670;&nbsp;</a></span>AST_TYPE_TRAVERSE_MATCHER() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPE_TRAVERSE_MATCHER </td>
          <td>(</td>
          <td class="paramtype">hasUnderlyingType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="RegionStore_8cpp.html#aa40d60a0a659ed599a32ba7f410edd06">getUnderlyingType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a>, <a class="el" href="classclang_1_1UsingType.html">UsingType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1DecltypeType.html" title="Represents the type decltype(expr) (C++11).">DecltypeType</a></code> or <code><a class="el" href="classclang_1_1UsingType.html">UsingType</a></code> nodes to find the underlying type. </p>
<p>Given </p><div class="fragment"><div class="line">decltype(1) a = 1;</div>
<div class="line">decltype(2.0) <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 2.0;</div>
</div><!-- fragment --><p> decltypeType(hasUnderlyingType(isInteger())) matches the type of "a"</p>
<p>Usable as: Matcher&lt;DecltypeType&gt;, Matcher&lt;UsingType&gt; </p>

</div>
</div>
<a id="a641d86a073599a892f18f64743cf5af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641d86a073599a892f18f64743cf5af1">&#9670;&nbsp;</a></span>AST_TYPE_TRAVERSE_MATCHER() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPE_TRAVERSE_MATCHER </td>
          <td>(</td>
          <td class="paramtype">innerType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">getInnerType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ParenType.html">ParenType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1ParenType.html" title="Sugar for parentheses used when specifying types.">ParenType</a></code> nodes where the inner type is a specific type. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> (*ptr_to_array)[4];</div>
<div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> (*ptr_to_func)(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>);</div>
</div><!-- fragment --><p><code>varDecl</code>(hasType(pointsTo(parenType(innerType(functionType()))))) matches <code>ptr_to_func</code> but not <code>ptr_to_array</code>.</p>
<p>Usable as: Matcher&lt;ParenType&gt; </p>

</div>
</div>
<a id="a558dcdb7f37b0f64f9ebdfa2855b2445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558dcdb7f37b0f64f9ebdfa2855b2445">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DECL() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DECL </td>
          <td>(</td>
          <td class="paramtype">hasElementType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">getElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches arrays and C99 complex types that have a specific element type. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A {};</div>
<div class="line">A a[7];</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[7];</div>
</div><!-- fragment --><p> arrayType(hasElementType(builtinType())) matches "int b[7]"</p>
<p>Usable as: Matcher&lt;ArrayType&gt;, Matcher&lt;ComplexType&gt; </p>

</div>
</div>
<a id="ad64bdc785ad1466d7bc3752335e5e1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64bdc785ad1466d7bc3752335e5e1b5">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DECL() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DECL </td>
          <td>(</td>
          <td class="paramtype">hasValueType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ArrayBoundCheckerV2_8cpp.html#a0f5cc163e1c5feb0c0b0af79d4b4869a">getValue</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches atomic types with a specific value type. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="stdatomic_8h.html#afff57ffb45845b688f5b8749a5ee4f64">_Atomic</a>(<span class="keywordtype">int</span>) i;</div>
<div class="line"><a class="code" href="stdatomic_8h.html#afff57ffb45845b688f5b8749a5ee4f64">_Atomic</a>(<span class="keywordtype">float</span>) f;</div>
</div><!-- fragment --><p> atomicType(hasValueType(isInteger())) matches "_Atomic(int) i"</p>
<p>Usable as: Matcher&lt;AtomicType&gt; </p>

</div>
</div>
<a id="abf51c463d9416f6dff27349995032db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51c463d9416f6dff27349995032db1">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DECL() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DECL </td>
          <td>(</td>
          <td class="paramtype">pointee&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">getPointee&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrows <a class="el" href="classclang_1_1PointerType.html" title="PointerType - C99 6.7.5.1 - Pointer Declarators.">PointerType</a> (and similar) matchers to those where the <code>pointee</code> matches a given matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> *<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">float</span> <span class="keyword">const</span> *f;</div>
</div><!-- fragment --><p> pointerType(pointee(isConstQualified(), isInteger())) matches "int const *b"</p>
<p>Usable as: Matcher&lt;BlockPointerType&gt;, Matcher&lt;MemberPointerType&gt;, Matcher&lt;PointerType&gt;, Matcher&lt;ReferenceType&gt; </p>

</div>
</div>
<a id="a9e40f7a7120043b6e36077adcf44c9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e40f7a7120043b6e36077adcf44c9cd">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">hasElementType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1ArrayType.html">ArrayType</a>, <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a953d25fd07bb81ad8bf5a87a0068f13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953d25fd07bb81ad8bf5a87a0068f13b">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">hasValueType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1AtomicType.html">AtomicType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3509e3798b4581a7a8cb59106aa6b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3509e3798b4581a7a8cb59106aa6b73">&#9670;&nbsp;</a></span>AST_TYPELOC_TRAVERSE_MATCHER_DEF() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clang::ast_matchers::AST_TYPELOC_TRAVERSE_MATCHER_DEF </td>
          <td>(</td>
          <td class="paramtype">pointee&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a>, <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a>, <a class="el" href="classclang_1_1PointerType.html">PointerType</a>, <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa144e36e553f364291ec8746c14cd05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa144e36e553f364291ec8746c14cd05c">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::PolymorphicMatcher&lt;internal::ValueEqualsMatcher, void(internal::AllNodeBaseTypes), ValueT&gt; clang::ast_matchers::equals </td>
          <td>(</td>
          <td class="paramtype">const ValueT &amp;&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches literals that are equal to the given value of type ValueT. </p>
<p>Given </p><div class="fragment"><div class="line">f(<span class="charliteral">&#39;\0&#39;</span>, <span class="keyword">false</span>, 3.14, 42);</div>
</div><!-- fragment --><p> characterLiteral(equals(0)) matches '\0' cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)) match false floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)) match 3.14 integerLiteral(equals(42)) matches 42</p>
<p>Note that you cannot directly match a negative numeric literal because the minus sign is not part of the literal: It is a unary operator whose operand is the positive numeric literal. Instead, you must use a <a class="el" href="namespaceclang_1_1ast__matchers.html#a71ac1ea4304cca5a3d773782c45e3a9d" title="Matches unary operator expressions.">unaryOperator()</a> matcher to match the minus sign:</p>
<p>unaryOperator(hasOperatorName("-"), hasUnaryOperand(integerLiteral(equals(13))))</p>
<p>Usable as: Matcher&lt;CharacterLiteral&gt;, Matcher&lt;CXXBoolLiteralExpr&gt;, Matcher&lt;FloatingLiteral&gt;, Matcher&lt;IntegerLiteral&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l05512">5512</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>.</p>

</div>
</div>
<a id="a2adc91bda011c0b3ffcc4c315131cfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adc91bda011c0b3ffcc4c315131cfb4">&#9670;&nbsp;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt;T&gt; clang::ast_matchers::findAll </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if the node or any descendant matches. </p>
<p>Generates results for each match.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span>B {}; <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {}; };</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;::A&quot;</span>),</div>
<div class="line">              <a class="code" href="namespaceclang_1_1ast__matchers.html#a2adc91bda011c0b3ffcc4c315131cfb4">findAll</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(isDefinition()).bind(<span class="stringliteral">&quot;m&quot;</span>)))</div>
</div><!-- fragment --><p> will generate results for <code>A</code>, <code>B</code> and <code>C</code>.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03480">3480</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a300e0f48793e28002e73a44d46dc3392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300e0f48793e28002e73a44d46dc3392">&#9670;&nbsp;</a></span>getComparisonDecl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceclang_1_1ast__matchers.html#a22b3e62e1b83cda2c7a5d9fc0f14f5cf">DeclarationMatcher</a> clang::ast_matchers::getComparisonDecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00039">39</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="a11ddfef6d6925f8360634963103be7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ddfef6d6925f8360634963103be7e2">&#9670;&nbsp;</a></span>getComparisonTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::StringRef clang::ast_matchers::getComparisonTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00071">71</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="aca7d2d8f325494b15676b71942e33834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7d2d8f325494b15676b71942e33834">&#9670;&nbsp;</a></span>getMacroName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> clang::ast_matchers::getMacroName </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00089">89</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="a1b10fa75961d05f6dfe195cc5a83a4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b10fa75961d05f6dfe195cc5a83a4b8">&#9670;&nbsp;</a></span>getMacroName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> clang::ast_matchers::getMacroName </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>Operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00093">93</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GtestMatchers_8cpp_source.html#l00059">getMacroTypeName()</a>.</p>

</div>
</div>
<a id="a5a953cbdfc1d8d2d93032fa0b0c7124c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a953cbdfc1d8d2d93032fa0b0c7124c">&#9670;&nbsp;</a></span>getMacroTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::StringRef clang::ast_matchers::getMacroTypeName </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00059">59</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00093">getMacroName()</a>.</p>

</div>
</div>
<a id="ae386bd504bd7c7e82630d30f5b29f73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae386bd504bd7c7e82630d30f5b29f73c">&#9670;&nbsp;</a></span>getSpecSetterName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static llvm::StringRef clang::ast_matchers::getSpecSetterName </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00101">101</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="a03719ad642f4411e33d92b1081361f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03719ad642f4411e33d92b1081361f07">&#9670;&nbsp;</a></span>gtestAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's ASSERT comparison macros including ASSERT_EQ, ASSERT_NE, ASSERT_GE, ASSERT_GT, ASSERT_LE and ASSERT_LT. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00191">191</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="aad460b6b2d5e64993560b4ce2d830181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad460b6b2d5e64993560b4ce2d830181">&#9670;&nbsp;</a></span>gtestAssertThat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestAssertThat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's ASSERT_THAT macro. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00201">201</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="aee9a3786e1bd4444c0543aad1e41ddb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9a3786e1bd4444c0543aad1e41ddb2">&#9670;&nbsp;</a></span>gtestCallInternal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::gtestCallInternal </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00147">147</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00820">cxxMemberCallExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00887">cxxOperatorCallExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">functionDecl</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00089">getMacroName()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00101">getSpecSetterName()</a>, <a class="el" href="ASTMatchers_8h_source.html#l02991">hasName()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03054">hasOverloadedOperatorName()</a>, <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920da6adf97f83acf6453d4a6a4b1070f3754">None</a>, and <a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920da695c6ae413c00446733d926ccadefd8b">Some</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00181">gtestCallInternal()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00222">gtestExpectCall()</a>, and <a class="el" href="GtestMatchers_8cpp_source.html#l00211">gtestOnCall()</a>.</p>

</div>
</div>
<a id="a6d09072840ada9128cb4cf992168c623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d09072840ada9128cb4cf992168c623">&#9670;&nbsp;</a></span>gtestCallInternal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::gtestCallInternal </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>MockMethodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00181">181</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00820">cxxMemberCallExpr</a>, <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">functionDecl</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>, and <a class="el" href="ASTMatchers_8h_source.html#l02991">hasName()</a>.</p>

</div>
</div>
<a id="a03f6fa697150613afbee7342dd3b2963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f6fa697150613afbee7342dd3b2963">&#9670;&nbsp;</a></span>gtestComparisonInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::gtestComparisonInternal </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00123">123</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="a33afaf3f80e491354dc39625e4a6785b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33afaf3f80e491354dc39625e4a6785b">&#9670;&nbsp;</a></span>gtestExpect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestExpect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a1c8d79365d495125b8c32aa08e15ae9d">GtestCmp</a>&#160;</td>
          <td class="paramname"><em>Cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's EXPECT comparison macros including EXPECT_EQ, EXPECT_NE, EXPECT_GE, EXPECT_GT, EXPECT_LE and EXPECT_LT. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00196">196</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="a6164c2c64e8ff507e212408e9a68e1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6164c2c64e8ff507e212408e9a68e1bc">&#9670;&nbsp;</a></span>gtestExpectCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestExpectCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's EXPECT_CALL macro. </p>
<p><code>MockCall</code> matches the whole mock member method call. This API is more flexible but requires more knowledge of the AST structure of EXPECT_CALL macros. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00228">228</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="acc094e9ea85b60b5c76234c641737076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc094e9ea85b60b5c76234c641737076">&#9670;&nbsp;</a></span>gtestExpectCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestExpectCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>MockMethodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's EXPECT_CALL macro. </p>
<p><code>MockObject</code> matches the mock object and <code>MockMethodName</code> is the name of the method invoked on the mock object. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00222">222</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="a97b24c7e7612943db3615925608bb3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b24c7e7612943db3615925608bb3b4">&#9670;&nbsp;</a></span>gtestExpectThat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestExpectThat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matcher for gtest's EXPECT_THAT macro. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00206">206</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="aba86627675f3e19c46523c535e450e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86627675f3e19c46523c535e450e88">&#9670;&nbsp;</a></span>gtestOnCall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestOnCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the second <code>gtestExpectCall</code> overload but for <code>ON_CALL</code>. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00217">217</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="ac4762f4e0573506f32ba15ead667acd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4762f4e0573506f32ba15ead667acd8">&#9670;&nbsp;</a></span>gtestOnCall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::gtestOnCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>MockObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>MockMethodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#a10b507ef98509576ab7fa90acdc3920d">MockArgs</a>&#160;</td>
          <td class="paramname"><em>Args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the first <code>gtestExpectCall</code> overload but for <code>ON_CALL</code>. </p>

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00211">211</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

<p class="reference">References <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="aa032516f93fe85701798c899d7e3ea6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa032516f93fe85701798c899d7e3ea6b">&#9670;&nbsp;</a></span>gtestThatInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::gtestThatInternal </td>
          <td>(</td>
          <td class="paramtype">MacroType&#160;</td>
          <td class="paramname"><em>Macro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceclang_1_1ast__matchers.html#aac1d4a43f06a6eaa2702a396b8a7b88d">StatementMatcher</a>&#160;</td>
          <td class="paramname"><em>Matcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GtestMatchers_8cpp_source.html#l00131">131</a> of file <a class="el" href="GtestMatchers_8cpp_source.html">GtestMatchers.cpp</a>.</p>

</div>
</div>
<a id="aa76835a0f3b2093794608ce6c16da9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76835a0f3b2093794608ce6c16da9bc">&#9670;&nbsp;</a></span>hasDeclaration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::PolymorphicMatcher&lt; internal::HasDeclarationMatcher, void(internal::HasDeclarationSupportedTypes), internal::Matcher&lt;<a class="el" href="classclang_1_1Decl.html">Decl</a>&gt; &gt; clang::ast_matchers::hasDeclaration </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a node if the declaration associated with that node matches the given matcher. </p>
<p>The associated declaration is:</p><ul>
<li>for type nodes, the declaration of the underlying type</li>
<li>for <a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a>, the declaration of the callee</li>
<li>for <a class="el" href="classclang_1_1MemberExpr.html" title="MemberExpr - [C99 6.5.2.3] Structure and Union Members.">MemberExpr</a>, the declaration of the referenced member</li>
<li>for <a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a>, the declaration of the constructor</li>
<li>for <a class="el" href="classclang_1_1CXXNewExpr.html" title="Represents a new-expression for memory allocation and constructor calls, e.g: &quot;new CXXNewExpr(foo)&quot;.">CXXNewExpr</a>, the declaration of the operator new</li>
<li>for ObjCIvarExpr, the declaration of the ivar</li>
</ul>
<p>For type nodes, hasDeclaration will generally match the declaration of the sugared type. Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> Y;</div>
<div class="line">Y y;</div>
</div><!-- fragment --><p> in varDecl(hasType(hasDeclaration(decl()))) the decl will match the typedefDecl. A common use case is to match the underlying, desugared type. This can be achieved by using the hasUnqualifiedDesugaredType matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasType(hasUnqualifiedDesugaredType(</div>
<div class="line">    <a class="code" href="namespaceclang_1_1ast__matchers.html#abf2f0de9c9e156981b881b8d5d89aec6">recordType</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#aa76835a0f3b2093794608ce6c16da9bc">hasDeclaration</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ac5ccadfbea5e9e43c2153175afca6cac">decl</a>())))))</div>
</div><!-- fragment --><p> In this matcher, the decl will match the <a class="el" href="classclang_1_1CXXRecordDecl.html" title="Represents a C++ struct/union/class.">CXXRecordDecl</a> of class X.</p>
<p>Usable as: Matcher&lt;AddrLabelExpr&gt;, Matcher&lt;CallExpr&gt;, Matcher&lt;CXXConstructExpr&gt;, Matcher&lt;CXXNewExpr&gt;, Matcher&lt;DeclRefExpr&gt;, Matcher&lt;EnumType&gt;, Matcher&lt;InjectedClassNameType&gt;, Matcher&lt;LabelStmt&gt;, Matcher&lt;MemberExpr&gt;, Matcher&lt;QualType&gt;, Matcher&lt;RecordType&gt;, Matcher&lt;TagType&gt;, Matcher&lt;TemplateSpecializationType&gt;, Matcher&lt;TemplateTypeParmType&gt;, Matcher&lt;TypedefType&gt;, Matcher&lt;UnresolvedUsingType&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03565">3565</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00124">clang::ento::getAddrTo()</a>, <a class="el" href="OSObjectCStyleCast_8cpp_source.html#l00076">hasTypePointingTo()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>, and <a class="el" href="BugReporterVisitors_8cpp_source.html#l00590">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="a8d768f291504a2ab44e97d4732e25810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d768f291504a2ab44e97d4732e25810">&#9670;&nbsp;</a></span>hasName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt;<a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a>&gt; clang::ast_matchers::hasName </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have the specified name. </p>
<p>Supports specifying enclosing namespaces or classes by prefixing the name with '&lt;enclosing&gt;::'. Does not match typedefs of an underlying type with the given name.</p>
<p>Example matches X (Name == "X") </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p>Example matches X (Name is one of "::a::b::X", "a::b::X", "b::X", "X") </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>a { <span class="keyword">namespace </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>; } }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02991">2991</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l03196">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00131">getRunLoopRunM()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>, and <a class="el" href="RetainSummaryManager_8cpp_source.html#l00148">isExactClass()</a>.</p>

</div>
</div>
<a id="a79daca24a6baeebb272b2b822bc5f3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79daca24a6baeebb272b2b822bc5f3d3">&#9670;&nbsp;</a></span>hasOverloadedOperatorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::PolymorphicMatcher&lt; internal::HasOverloadedOperatorNameMatcher, <a class="el" href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a>(<a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a>), std::vector&lt;<a class="el" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>&gt; &gt; clang::ast_matchers::hasOverloadedOperatorName </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches overloaded operator names. </p>
<p>Matches overloaded operator names specified in strings without the "operator" prefix: e.g. "&lt;&lt;".</p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">int</span> <a class="code" href="CharUnits_8h.html#a30c408b1824dd612b35a6b4e20ed423f">operator*</a>(); };</div>
<div class="line"><span class="keyword">const</span> A &amp;<a class="code" href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">operator&lt;&lt;</a>(<span class="keyword">const</span> A &amp;a, <span class="keyword">const</span> A &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line">A a;</div>
<div class="line">a &lt;&lt; a;   <span class="comment">// &lt;-- This matches</span></div>
</div><!-- fragment --><p><code>cxxOperatorCallExpr</code>(hasOverloadedOperatorName("&lt;&lt;"))) matches the specified line and <code>cxxRecordDecl</code>(hasMethod(hasOverloadedOperatorName("*"))) matches the declaration of <code>A</code>.</p>
<p>Usable as: Matcher&lt;CXXOperatorCallExpr&gt;, Matcher&lt;FunctionDecl&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l03054">3054</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="a90d2caaa3c207f5b5f91216fe06f1158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d2caaa3c207f5b5f91216fe06f1158">&#9670;&nbsp;</a></span>mapAnyOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto clang::ast_matchers::mapAnyOf </td>
          <td>(</td>
          <td class="paramtype">internal::VariadicDynCastAllOfMatcher&lt; T, <a class="el" href="classU.html">U</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any of the <code>NodeMatchers</code> with InnerMatchers nested within. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<span class="keyword">true</span>);</div>
<div class="line"><span class="keywordflow">for</span> (; <span class="keyword">true</span>; );</div>
</div><!-- fragment --><p> with the matcher </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a90d2caaa3c207f5b5f91216fe06f1158">mapAnyOf</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a>, <a class="code" href="namespaceclang_1_1ast__matchers.html#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a>).with(</div>
<div class="line">  hasCondition(cxxBoolLiteralExpr(<a class="code" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>(<span class="keyword">true</span>)))</div>
<div class="line">  ).bind(<span class="stringliteral">&quot;trueCond&quot;</span>)</div>
</div><!-- fragment --><p> matches the <code>if</code> and the <code>for</code>. It is equivalent to: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> trueCond = hasCondition(cxxBoolLiteralExpr(<a class="code" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>(<span class="keyword">true</span>)));</div>
<div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a>(</div>
<div class="line">  <a class="code" href="namespaceclang_1_1ast__matchers.html#af5cd72a6718872ac996d48de9a80bf81">ifStmt</a>(trueCond).bind(<span class="stringliteral">&quot;trueCond&quot;</span>),</div>
<div class="line">  <a class="code" href="namespaceclang_1_1ast__matchers.html#a8e6f109ac0734990e8ae974d36e76c7e">forStmt</a>(trueCond).bind(<span class="stringliteral">&quot;trueCond&quot;</span>)</div>
<div class="line">  );</div>
</div><!-- fragment --><p>The with() chain-call accepts zero or more matchers which are combined as-if with <a class="el" href="namespaceclang_1_1ast__matchers.html#ab7f7f0b785ca07327256931286ebc99f" title="Matches if all given matchers match.">allOf()</a> in each of the node matchers. Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02813">2813</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a6e076c5e724f5522f9c51ffdc6dddf89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e076c5e724f5522f9c51ffdc6dddf89">&#9670;&nbsp;</a></span>match() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of matching <code>Matcher</code> on the translation unit of <code>Context</code> and collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00318">318</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a6eef98a03801d29f261611aef6b48f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eef98a03801d29f261611aef6b48f0f">&#9670;&nbsp;</a></span>match() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00301">301</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a58409ce605d979d1d1e0a600ec417a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58409ce605d979d1d1e0a600ec417a0a">&#9670;&nbsp;</a></span>match() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatcherT , typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1 &gt; clang::ast_matchers::match </td>
          <td>(</td>
          <td class="paramtype">MatcherT&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeT &amp;&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of matching <code>Matcher</code> on <code>Node</code>. </p>
<p>Collects the <code><a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html" title="Maps string IDs to AST nodes matched by parts of a matcher.">BoundNodes</a></code> of all callback invocations when matching <code>Matcher</code> on <code>Node</code> and returns the collected results.</p>
<p>Multiple results occur when using matchers like <code>forEachDescendant</code>, which generate a result for each sub-match.</p>
<p>If you want to find all matches on the sub-tree rooted at <code>Node</code> (rather than only the matches on <code>Node</code> itself), surround the <code>Matcher</code> with a <code><a class="el" href="namespaceclang_1_1ast__matchers.html#a2adc91bda011c0b3ffcc4c315131cfb4" title="Matches if the node or any descendant matches.">findAll()</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceclang_1_1ast__matchers.html#a87727e2eb520afc1b6df1b71b12f1712" title="Returns the first result of type NodeT bound to BoundTo.">selectFirst</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a57">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00312">312</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaExprCXX_8cpp_source.html#l03515">clang::Sema::ActOnCXXDelete()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l01129">AttributesMatch()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l00601">ClassImplementsAllMethodsAndProperties()</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00209">clang::tooling::IncludeCategoryManager::getIncludePriority()</a>, <a class="el" href="HeaderIncludes_8cpp_source.html#l00222">clang::tooling::IncludeCategoryManager::getSortIncludePriority()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="RetainSummaryManager_8cpp_source.html#l00148">isExactClass()</a>, <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>, <a class="el" href="RetainSummaryManager_8cpp_source.html#l00140">isSubclass()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l01100">MatchTwoAttributeLists()</a>, <a class="el" href="ASTContext_8cpp_source.html#l09363">clang::ASTContext::ObjCQualifiedClassTypesAreCompatible()</a>, <a class="el" href="ASTContext_8cpp_source.html#l09381">clang::ASTContext::ObjCQualifiedIdTypesAreCompatible()</a>, and <a class="el" href="SemaDeclObjC_8cpp_source.html#l02616">clang::Sema::WarnExactTypedMethods()</a>.</p>

</div>
</div>
<a id="a0a3d62b16e618eb1aff8f3334fa773bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d62b16e618eb1aff8f3334fa773bd">&#9670;&nbsp;</a></span>matchDynamic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1&gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00344">344</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="af58768c3354b28da90a699c86524c62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58768c3354b28da90a699c86524c62c">&#9670;&nbsp;</a></span>matchDynamic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1&gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classclang_1_1DynTypedNode.html">DynTypedNode</a> &amp;&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00327">327</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a263fa8fdf923632b5d87560254b12432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263fa8fdf923632b5d87560254b12432">&#9670;&nbsp;</a></span>matchDynamic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a>, 1&gt; clang::ast_matchers::matchDynamic </td>
          <td>(</td>
          <td class="paramtype">internal::DynTypedMatcher&#160;</td>
          <td class="paramname"><em>Matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeT &amp;&#160;</td>
          <td class="paramname"><em>Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classclang_1_1ASTContext.html">ASTContext</a> &amp;&#160;</td>
          <td class="paramname"><em>Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00337">337</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a87727e2eb520afc1b6df1b71b12f1712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87727e2eb520afc1b6df1b71b12f1712">&#9670;&nbsp;</a></span>selectFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const NodeT* clang::ast_matchers::selectFirst </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>BoundTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classclang_1_1ast__matchers_1_1BoundNodes.html">BoundNodes</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first result of type <code>NodeT</code> bound to <code>BoundTo</code>. </p>
<p>Returns <code>NULL</code> if there is no match, or if the matching node cannot be casted to <code>NodeT</code>.</p>
<p>This is useful in combanation with <code><a class="el" href="namespaceclang_1_1ast__matchers.html#a58409ce605d979d1d1e0a600ec417a0a" title="Returns the results of matching Matcher on Node.">match()</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceclang_1_1CodeGen.html#a1c294b2b5bfa35483ddb984a1ad6db17ac02172f092142d31f6b3d06ff4eca48c">Decl</a> *D = selectFirst&lt;Decl&gt;(<span class="stringliteral">&quot;id&quot;</span>, <a class="code" href="namespaceclang_1_1ast__matchers.html#a58409ce605d979d1d1e0a600ec417a0a">match</a>(Matcher.bind(<span class="stringliteral">&quot;id&quot;</span>),</div>
<div class="line">                                              <a class="code" href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a>, Context));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchFinder_8h_source.html#l00277">277</a> of file <a class="el" href="ASTMatchFinder_8h_source.html">ASTMatchFinder.h</a>.</p>

</div>
</div>
<a id="a1c21055a9e5d4af474b90f49b8fc79d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c21055a9e5d4af474b90f49b8fc79d4">&#9670;&nbsp;</a></span>sizeOfExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt;<a class="el" href="classclang_1_1Stmt.html">Stmt</a>&gt; clang::ast_matchers::sizeOfExpr </td>
          <td>(</td>
          <td class="paramtype">const internal::Matcher&lt; <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as unaryExprOrTypeTraitExpr, but only matching sizeof. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l02970">2970</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a548ce086dbc50a9894e16405bbe8d405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548ce086dbc50a9894e16405bbe8d405">&#9670;&nbsp;</a></span>traverse() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename ToArg, typename FromArg &gt; class ArgumentAdapterT, typename T , typename ToTypes &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::ArgumentAdaptingMatcherFuncAdaptor&lt;ArgumentAdapterT, T, ToTypes&gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::ArgumentAdaptingMatcherFuncAdaptor&lt; ArgumentAdapterT, T, ToTypes &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00845">845</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a9ae07894db27f5bb11e0a76abf77f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae07894db27f5bb11e0a76abf77f0eb">&#9670;&nbsp;</a></span>traverse() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::BindableMatcher&lt;T&gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::BindableMatcher&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00825">825</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="a52ba5b3eadb9679a24ed60cb13a30dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ba5b3eadb9679a24ed60cb13a30dac">&#9670;&nbsp;</a></span>traverse() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt;typename internal::GetClade&lt;T...&gt;::<a class="el" href="classclang_1_1Type.html">Type</a>&gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::MapAnyOfHelper&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00866">866</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<a id="ab70d18a272b82cd99f0dba56e9ab0c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70d18a272b82cd99f0dba56e9ab0c21">&#9670;&nbsp;</a></span>traverse() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::Matcher&lt;T&gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::Matcher&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes all nested matchers to be matched with the specified traversal kind. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> i = 3.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ab70d18a272b82cd99f0dba56e9ab0c21">traverse</a>(<a class="code" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d">TK_IgnoreUnlessSpelledInSource</a>,</div>
<div class="line">  <a class="code" href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">varDecl</a>(hasInitializer(<a class="code" href="namespaceclang_1_1ast__matchers.html#a4a4e38c6224c16252040dc697a6af832">floatLiteral</a>().bind(<span class="stringliteral">&quot;init&quot;</span>)))</div>
<div class="line">)</div>
</div><!-- fragment --><p> matches the variable declaration with "init" bound to the "3.0". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00815">815</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tree_8cpp_source.html#l00307">clang::syntax::Node::assertInvariantsRecursive()</a>, <a class="el" href="ThreadSafety_8cpp_source.html#l01138">clang::threadSafety::BeforeSet::checkBeforeAfter()</a>, and <a class="el" href="Tree_8cpp_source.html#l00258">clang::syntax::Node::dumpTokens()</a>.</p>

</div>
</div>
<a id="a6a97c0d3af71effcec1e3aaf14f4f36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a97c0d3af71effcec1e3aaf14f4f36c">&#9670;&nbsp;</a></span>traverse() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename T, typename... P &gt; class MatcherT, typename... P, typename ReturnTypesF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt; internal::PolymorphicMatcher&lt;MatcherT, ReturnTypesF, P...&gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::PolymorphicMatcher&lt; MatcherT, ReturnTypesF, P... &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00856">856</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

<p class="reference">References <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00563">P</a>.</p>

</div>
</div>
<a id="a047209d5bc6685d7cabbd31d53122834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047209d5bc6685d7cabbd31d53122834">&#9670;&nbsp;</a></span>traverse() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::TraversalWrapper&lt;internal::VariadicOperatorMatcher&lt;T...&gt; &gt; clang::ast_matchers::traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058">TraversalKind</a>&#160;</td>
          <td class="paramname"><em>TK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::VariadicOperatorMatcher&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>InnerMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ASTMatchers_8h_source.html#l00835">835</a> of file <a class="el" href="ASTMatchers_8h_source.html">ASTMatchers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7acfa3a6a57ccd2484a71e0f1bbe9c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acfa3a6a57ccd2484a71e0f1bbe9c09">&#9670;&nbsp;</a></span>accessSpecDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1AccessSpecDecl.html">AccessSpecDecl</a> &gt; clang::ast_matchers::accessSpecDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ access specifier declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a7acfa3a6a57ccd2484a71e0f1bbe9c09" title="Matches C++ access specifier declarations.">accessSpecDecl()</a> matches 'public:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00758">758</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a32844cb1d9bb3605e13b8bed8092cc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32844cb1d9bb3605e13b8bed8092cc14">&#9670;&nbsp;</a></span>addrLabelExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AddrLabelExpr.html">AddrLabelExpr</a> &gt; clang::ast_matchers::addrLabelExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches address of label statements (GNU extension). </p>
<p>Given </p><div class="fragment"><div class="line">FOO: bar();</div>
<div class="line"><span class="keywordtype">void</span> *ptr = &amp;&amp;FOO;</div>
<div class="line"><span class="keywordflow">goto</span> *bar;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a32844cb1d9bb3605e13b8bed8092cc14" title="Matches address of label statements (GNU extension).">addrLabelExpr()</a> matches '&amp;&amp;FOO' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00906">906</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7f7f0b785ca07327256931286ebc99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f7f0b785ca07327256931286ebc99f">&#9670;&nbsp;</a></span>allOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt; clang::ast_matchers::allOf = {internal::DynTypedMatcher::VO_AllOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if all given matchers match. </p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00992">992</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, <a class="el" href="ASTMatchers_8h_source.html#l05674">AST_POLYMORPHIC_MATCHER_P2()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="ae56a1974283c9a2cb2410008e32fe3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a1974283c9a2cb2410008e32fe3f1">&#9670;&nbsp;</a></span>anyOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt; clang::ast_matchers::anyOf = {internal::DynTypedMatcher::VO_AnyOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if any of the given matchers matches. </p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00989">989</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, <a class="el" href="ASTMatchers_8h_source.html#l06406">AST_MATCHER_FUNCTION()</a>, <a class="el" href="ASTMatchers_8h_source.html#l05674">AST_POLYMORPHIC_MATCHER_P2()</a>, <a class="el" href="ASTMatchers_8h_source.html#l03254">AST_POLYMORPHIC_MATCHER_P_OVERLOAD()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00097">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00147">getOtherMessageSentM()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00131">getRunLoopRunM()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a770b1eeabaf13b5ab1547634f8fef742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770b1eeabaf13b5ab1547634f8fef742">&#9670;&nbsp;</a></span>arraySubscriptExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ArraySubscriptExpr.html">ArraySubscriptExpr</a> &gt; clang::ast_matchers::arraySubscriptExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches array subscript expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = a[1];</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a770b1eeabaf13b5ab1547634f8fef742" title="Matches array subscript expressions.">arraySubscriptExpr()</a> matches "a[1]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00883">883</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6733c0e2dab3236688140fb7e73db035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6733c0e2dab3236688140fb7e73db035">&#9670;&nbsp;</a></span>arrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ArrayType.html">ArrayType</a> &gt; clang::ast_matchers::arrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches all kinds of arrays. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[] = { 2, 3 };</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[4];</div>
<div class="line"><span class="keywordtype">void</span> f() { <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[a[0]]; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a6733c0e2dab3236688140fb7e73db035" title="Matches all kinds of arrays.">arrayType()</a> matches "int a[]", "int b[4]" and "int c[a[0]]"; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01034">1034</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>, <a class="el" href="CodeGenFunction_8cpp_source.html#l02269">clang::CodeGen::CodeGenFunction::emitArrayLength()</a>, <a class="el" href="CGExpr_8cpp_source.html#l03781">clang::CodeGen::CodeGenFunction::EmitArraySubscriptExpr()</a>, <a class="el" href="CGExpr_8cpp_source.html#l03732">emitArraySubscriptGEP()</a>, <a class="el" href="CGClass_8cpp_source.html#l01942">clang::CodeGen::CodeGenFunction::EmitCXXAggrConstructorCall()</a>, <a class="el" href="CGExprCXX_8cpp_source.html#l00585">clang::CodeGen::CodeGenFunction::EmitCXXConstructExpr()</a>, <a class="el" href="CGDecl_8cpp_source.html#l02233">clang::CodeGen::CodeGenFunction::emitDestroy()</a>, <a class="el" href="CGDecl_8cpp_source.html#l02328">emitPartialArrayDestroy()</a>, <a class="el" href="TemplateBase_8cpp_source.html#l00137">getArrayDepth()</a>, <a class="el" href="Type_8h_source.html#l07213">clang::Type::getBaseElementTypeUnsafe()</a>, <a class="el" href="ASTContext_8cpp_source.html#l01732">clang::ASTContext::getDeclAlign()</a>, <a class="el" href="CFG_8cpp_source.html#l05110">clang::CFGImplicitDtor::getDestructorDecl()</a>, and <a class="el" href="SemaInit_8cpp_source.html#l00137">IsStringInit()</a>.</p>

</div>
</div>
<a id="a4329ae4c7c6f153f7529aab870ffec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4329ae4c7c6f153f7529aab870ffec8b">&#9670;&nbsp;</a></span>asmStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AsmStmt.html">AsmStmt</a> &gt; clang::ast_matchers::asmStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches asm statements. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 100;</div>
<div class="line"> __asm(<span class="stringliteral">&quot;mov al, 2&quot;</span>);</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a4329ae4c7c6f153f7529aab870ffec8b" title="Matches asm statements.">asmStmt()</a> matches '__asm("mov al, 2")' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00916">916</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2fc5672f38513ca660c5c383e958cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc5672f38513ca660c5c383e958cec0">&#9670;&nbsp;</a></span>atomicExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1AtomicExpr.html">AtomicExpr</a> &gt; clang::ast_matchers::atomicExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches atomic builtins. </p>
<p>Example matches __atomic_load_n(ptr, 1) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo() { <span class="keywordtype">int</span> *ptr; __atomic_load_n(ptr, 1); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00944">944</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a88f187323c83df32908d285ed132bd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f187323c83df32908d285ed132bd18">&#9670;&nbsp;</a></span>atomicType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1AtomicType.html">AtomicType</a> &gt; clang::ast_matchers::atomicType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches atomic types. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="stdatomic_8h.html#afff57ffb45845b688f5b8749a5ee4f64">_Atomic</a>(<span class="keywordtype">int</span>) i;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a88f187323c83df32908d285ed132bd18" title="Matches atomic types.">atomicType()</a> matches "_Atomic(int) i" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01042">1042</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>.</p>

</div>
</div>
<a id="a44173f6c846c27df62f0f56fc741534c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44173f6c846c27df62f0f56fc741534c">&#9670;&nbsp;</a></span>attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt; clang::ast_matchers::attr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches attributes. </p>
<p>Attributes may be attached with a variety of different syntaxes (including keywords, C++11 attributes, GNU <code>__attribute</code><code>and MSVC</code>__declspec<code>, and</code>#pragma``s). They may also be implicit.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>[[nodiscard]] Foo{};</div>
<div class="line"><span class="keywordtype">void</span> bar(<span class="keywordtype">int</span> * <a class="code" href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a>((nonnull)) );</div>
<div class="line">__declspec(noinline) <span class="keywordtype">void</span> baz();</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma omp declare simd</span></div>
<div class="line"><span class="preprocessor">int min();</span></div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a44173f6c846c27df62f0f56fc741534c" title="Matches attributes.">attr()</a> matches "nodiscard", "nonnull", "noinline", and the whole "#pragma" line. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01030">1030</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ParsedAttr_8h_source.html#l01037">clang::ParsedAttributes::addNew()</a>, <a class="el" href="ParsedAttr_8h_source.html#l01102">clang::ParsedAttributes::addNewPropertyAttr()</a>, <a class="el" href="ParsedAttr_8h_source.html#l01090">clang::ParsedAttributes::addNewTypeAttr()</a>, <a class="el" href="ParsedAttr_8h_source.html#l01077">clang::ParsedAttributes::addNewTypeTagForDatatype()</a>, <a class="el" href="Transforms_8cpp_source.html#l00460">clang::arcmt::trans::MigrationContext::addPropertyAttribute()</a>, <a class="el" href="ObjCMT_8cpp_source.html#l00386">append_attr()</a>, <a class="el" href="SemaDeclObjC_8cpp_source.html#l04411">clang::Sema::CheckObjCMethodDirectOverrides()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l00443">clang::Sema::DiagnoseSentinelCalls()</a>, <a class="el" href="SemaType_8cpp_source.html#l00593">distributeFunctionTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l00669">distributeFunctionTypeAttrFromDeclarator()</a>, <a class="el" href="SemaType_8cpp_source.html#l00643">distributeFunctionTypeAttrFromDeclSpec()</a>, <a class="el" href="SemaType_8cpp_source.html#l00624">distributeFunctionTypeAttrToInnermost()</a>, <a class="el" href="SemaType_8cpp_source.html#l07453">distributeNullabilityTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l00476">distributeObjCPointerTypeAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l00532">distributeObjCPointerTypeAttrFromDeclarator()</a>, <a class="el" href="SemaType_8cpp_source.html#l00694">distributeTypeAttrsFromDeclarator()</a>, <a class="el" href="TypeLoc_8cpp_source.html#l00454">clang::TypeLoc::findExplicitQualifierLoc()</a>, <a class="el" href="USRGeneration_8cpp_source.html#l00050">GetExternalSourceContainer()</a>, <a class="el" href="DeclBase_8cpp_source.html#l00480">clang::Decl::getExternalSourceSymbolAttr()</a>, <a class="el" href="DeclObjC_8cpp_source.html#l01018">clang::ObjCMethodDecl::getMethodFamily()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l03846">getObjCBridgeAttr()</a>, <a class="el" href="SemaObjCProperty_8cpp_source.html#l00158">getOwnershipRule()</a>, <a class="el" href="Decl_8cpp_source.html#l00208">getVisibilityFromAttr()</a>, <a class="el" href="SemaType_8cpp_source.html#l00391">handleObjCPointerTypeAttr()</a>, <a class="el" href="ParsePragma_8cpp_source.html#l01389">isAbstractAttrMatcherRule()</a>, <a class="el" href="SemaType_8cpp_source.html#l08221">isAddressSpaceKind()</a>, <a class="el" href="IndexingContext_8cpp_source.html#l00021">isGeneratedDecl()</a>, <a class="el" href="SemaType_8cpp_source.html#l00358">moveAttrFromListToList()</a>, <a class="el" href="SemaType_8cpp_source.html#l08234">processTypeAttrs()</a>, and <a class="el" href="TransBlockObjCVariable_8cpp_source.html#l00126">clang::arcmt::trans::BlockObjCVariableTraverser::traverseBody()</a>.</p>

</div>
</div>
<a id="a4b4d2e026596dc3bea52f83878ebc1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4d2e026596dc3bea52f83878ebc1a7">&#9670;&nbsp;</a></span>autoreleasePoolStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAutoreleasePoolStmt.html">ObjCAutoreleasePoolStmt</a> &gt; clang::ast_matchers::autoreleasePoolStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches an Objective-C autorelease pool statement. </p>
<p>Given </p><div class="fragment"><div class="line">@autoreleasepool {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> autoreleasePoolStmt(stmt()) matches the declaration of "x" inside the autorelease pool. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00725">725</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00174">checkTempObjectsInNoPool()</a>, and <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00155">checkTempObjectsInSamePool()</a>.</p>

</div>
</div>
<a id="a6616dde4596353abb9635c1f322fca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6616dde4596353abb9635c1f322fca1e">&#9670;&nbsp;</a></span>autoType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1AutoType.html">AutoType</a> &gt; clang::ast_matchers::autoType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types nodes representing C++11 auto types. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> n = 4;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>[] = { 2, 3 }</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i : <a class="code" href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a>) { }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a6616dde4596353abb9635c1f322fca1e" title="Matches types nodes representing C++11 auto types.">autoType()</a> matches "auto n" and "auto i" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01043">1043</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa466a1e59dbf5a8785b2561a308ae4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa466a1e59dbf5a8785b2561a308ae4fb">&#9670;&nbsp;</a></span>binaryConditionalOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryConditionalOperator.html">BinaryConditionalOperator</a> &gt; clang::ast_matchers::binaryConditionalOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches binary conditional operator expressions (GNU extension). </p>
<p>Example matches a ?: b </p><div class="fragment"><div class="line">(a ?: <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>) + 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00956">956</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a76efced611335bad85d3da6fe6ae790e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76efced611335bad85d3da6fe6ae790e">&#9670;&nbsp;</a></span>binaryOperation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt; clang::ast_matchers::binaryOperation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes which can be used with binary operators. </p>
<p>The code </p><div class="fragment"><div class="line">var1 != var2;</div>
</div><!-- fragment --><p> might be represented in the clang AST as a binaryOperator, a cxxOperatorCallExpr or a cxxRewrittenBinaryOperator, depending on</p>
<ul>
<li>whether the types of var1 and var2 are fundamental (binaryOperator) or at least one is a class type (cxxOperatorCallExpr)</li>
<li>whether the code appears in a template declaration, if at least one of the vars is a dependent-type (binaryOperator)</li>
<li>whether the code relies on a rewritten binary operator, such as a spaceship operator or an inverted equality operator (cxxRewrittenBinaryOperator)</li>
</ul>
<p>This matcher elides details in places where the matchers for the nodes are compatible.</p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e">binaryOperation</a>(</div>
<div class="line">  hasOperatorName(<span class="stringliteral">&quot;!=&quot;</span>),</div>
<div class="line">  hasLHS(<a class="code" href="namespaceclang_1_1ast__matchers.html#adfc0ccd398780d345e2c541cc716cc66">expr</a>().bind(<span class="stringliteral">&quot;lhs&quot;</span>)),</div>
<div class="line">  hasRHS(<a class="code" href="namespaceclang_1_1ast__matchers.html#adfc0ccd398780d345e2c541cc716cc66">expr</a>().bind(<span class="stringliteral">&quot;rhs&quot;</span>))</div>
<div class="line">)</div>
</div><!-- fragment --><p> matches each use of "!=" in: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S{</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceclang.html#aafe7017f6d734340af27ef4e92b19b77">operator!=</a>(<span class="keyword">const</span> S&amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> foo()</div>
<div class="line">{</div>
<div class="line">   1 != 2;</div>
<div class="line">   S() != S();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> templ()</div>
<div class="line">{</div>
<div class="line">   1 != 2;</div>
<div class="line">   T() != S();</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>HasOpEq</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="namespaceclang.html#a4a57f21b55a81cefae4379e09a3be0c3">operator==</a>(<span class="keyword">const</span> HasOpEq &amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> inverse()</div>
<div class="line">{</div>
<div class="line">    HasOpEq s1;</div>
<div class="line">    HasOpEq s2;</div>
<div class="line">    <span class="keywordflow">if</span> (s1 != s2)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>HasSpaceship</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator&lt;=&gt;(<span class="keyword">const</span> HasOpEq &amp;) <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> use_spaceship()</div>
<div class="line">{</div>
<div class="line">    HasSpaceship s1;</div>
<div class="line">    HasSpaceship s2;</div>
<div class="line">    <span class="keywordflow">if</span> (s1 != s2)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00950">950</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a92d236ec1064f604664b1e9123249e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d236ec1064f604664b1e9123249e01">&#9670;&nbsp;</a></span>binaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BinaryOperator.html">BinaryOperator</a> &gt; clang::ast_matchers::binaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches binary operator expressions. </p>
<p>Example matches a || b </p><div class="fragment"><div class="line">!(a || <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>)</div>
</div><!-- fragment --><p> See also the <a class="el" href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00947">947</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00097">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00590">potentiallyWritesIntoIvar()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a3661a4b3ebe2e4a9b67ab5be7d1c17e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">&#9670;&nbsp;</a></span>bindingDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BindingDecl.html">BindingDecl</a> &gt; clang::ast_matchers::bindingDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches binding declarations Example matches <code>foo</code> and <code>bar</code> (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6" title="Matches binding declarations Example matches foo and bar (matcher = bindingDecl()">bindingDecl()</a> </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [foo, bar] = std::make_pair{42, 42};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00736">736</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aeba4cdc11e5f93571b6b2107d4a9030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba4cdc11e5f93571b6b2107d4a9030e">&#9670;&nbsp;</a></span>blockDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1BlockDecl.html">BlockDecl</a> &gt; clang::ast_matchers::blockDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches block declarations. </p>
<p>Example matches the declaration of the nameless block printing an input integer.</p>
<div class="fragment"><div class="line">myFunc(^(<span class="keywordtype">int</span> p) {</div>
<div class="line">  <a class="code" href="opencl-c-base_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a>(<span class="stringliteral">&quot;%d&quot;</span>, p);</div>
<div class="line">})</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00836">836</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGBlocks_8cpp_source.html#l01447">clang::CodeGen::CodeGenFunction::GenerateBlockFunction()</a>.</p>

</div>
</div>
<a id="a9731ff0864f46a3fb06e34554ae54cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9731ff0864f46a3fb06e34554ae54cb8">&#9670;&nbsp;</a></span>blockExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BlockExpr.html">BlockExpr</a> &gt; clang::ast_matchers::blockExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reference to a block. </p>
<p>Example: matches "^{}": </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { ^{}(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00893">893</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGBlocks_8cpp_source.html#l00785">clang::CodeGen::CodeGenFunction::EmitBlockLiteral()</a>.</p>

</div>
</div>
<a id="a83cb286e46a83694307c53a4c1375852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cb286e46a83694307c53a4c1375852">&#9670;&nbsp;</a></span>blockPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1BlockPointerType.html">BlockPointerType</a> &gt; clang::ast_matchers::blockPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches block pointer types, i.e. </p>
<p>types syntactically represented as "void (^)(int)".</p>
<p>The <code>pointee</code> is always required to be a <code><a class="el" href="classclang_1_1FunctionType.html" title="FunctionType - C99 6.7.5.3 - Function Declarators.">FunctionType</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01048">1048</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3570a0e97bc3258e6b063729994e791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3570a0e97bc3258e6b063729994e791f">&#9670;&nbsp;</a></span>breakStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1BreakStmt.html">BreakStmt</a> &gt; clang::ast_matchers::breakStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches break statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a3570a0e97bc3258e6b063729994e791f" title="Matches break statements.">breakStmt()</a> matches 'break' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00900">900</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a16ab8ee766c693dcbe7b511984675e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ab8ee766c693dcbe7b511984675e75">&#9670;&nbsp;</a></span>builtinType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1BuiltinType.html">BuiltinType</a> &gt; clang::ast_matchers::builtinType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches builtin Types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A {};</div>
<div class="line">A a;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keywordtype">bool</span> d;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a16ab8ee766c693dcbe7b511984675e75" title="Matches builtin Types.">builtinType()</a> matches "int b", "float c" and "bool d" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01033">1033</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a460801cda670b9a3ccc3d42f51f3bd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460801cda670b9a3ccc3d42f51f3bd5c">&#9670;&nbsp;</a></span>callExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a> &gt; clang::ast_matchers::callExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches call expressions. </p>
<p>Example matches x.y() and y() </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.y();</div>
<div class="line">y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00817">817</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00131">getRunLoopRunM()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a5725bf80823feea320c27f79c712e8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5725bf80823feea320c27f79c712e8f6">&#9670;&nbsp;</a></span>caseStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CaseStmt.html">CaseStmt</a> &gt; clang::ast_matchers::caseStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches case statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a5725bf80823feea320c27f79c712e8f6" title="Matches case statements inside switch statements.">caseStmt()</a> matches 'case 42:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00909">909</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aee0910ccb567ed2465a935d7bd6831ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0910ccb567ed2465a935d7bd6831ed">&#9670;&nbsp;</a></span>castExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CastExpr.html">CastExpr</a> &gt; clang::ast_matchers::castExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any cast nodes of Clang's AST. </p>
<p>Example: <a class="el" href="namespaceclang_1_1ast__matchers.html#aee0910ccb567ed2465a935d7bd6831ed" title="Matches any cast nodes of Clang&#39;s AST.">castExpr()</a> matches each of the following: </p><div class="fragment"><div class="line">(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) 3;</div>
<div class="line"><span class="keyword">const_cast&lt;</span>Expr *<span class="keyword">&gt;</span>(SubExpr);</div>
<div class="line"><span class="keywordtype">char</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 0;</div>
</div><!-- fragment --><p> but does not match </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = (0);</div>
<div class="line"><span class="keywordtype">int</span> k = 0;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00975">975</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaExprObjC_8cpp_source.html#l04187">clang::Sema::CheckObjCBridgeRelatedCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04394">clang::Sema::CheckObjCConversion()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04137">clang::Sema::CheckTollFreeBridgeCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04208">clang::Sema::CheckTollFreeBridgeStaticCast()</a>, <a class="el" href="SemaExprObjC_8cpp_source.html#l04514">clang::Sema::diagnoseARCUnbridgedCast()</a>, and <a class="el" href="CGDecl_8cpp_source.html#l00718">tryEmitARCCopyWeakInit()</a>.</p>

</div>
</div>
<a id="ae2752fd9ce2d1e53440035178d4a0feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2752fd9ce2d1e53440035178d4a0feb">&#9670;&nbsp;</a></span>characterLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CharacterLiteral.html">CharacterLiteral</a> &gt; clang::ast_matchers::characterLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches character literals (also matches wchar_t). </p>
<p>Not matching Hex-encoded chars (e.g. 0x1234, which is a <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a>), though.</p>
<p>Example matches 'a', L'a' </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> ch = <span class="charliteral">&#39;a&#39;</span>;</div>
<div class="line"><span class="keywordtype">wchar_t</span> chw = L<span class="charliteral">&#39;a&#39;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00921">921</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab3d6075693f8e67b1a952da3fe26acaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d6075693f8e67b1a952da3fe26acaf">&#9670;&nbsp;</a></span>chooseExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ChooseExpr.html">ChooseExpr</a> &gt; clang::ast_matchers::chooseExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches GNU __builtin_choose_expr. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00934">934</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="afcdb6ae259330bdf0876aba6e07c8710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdb6ae259330bdf0876aba6e07c8710">&#9670;&nbsp;</a></span>classTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateDecl.html">ClassTemplateDecl</a> &gt; clang::ast_matchers::classTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template declarations. </p>
<p>Example matches <code>Z</code> </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00747">747</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a614a4778ab8392430ee9a0a28b7e9693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614a4778ab8392430ee9a0a28b7e9693">&#9670;&nbsp;</a></span>classTemplatePartialSpecializationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplatePartialSpecializationDecl.html">ClassTemplatePartialSpecializationDecl</a> &gt; clang::ast_matchers::classTemplatePartialSpecializationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template partial specializations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2, <span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">class </span>A {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">class </span>A&lt;T, T*, I&gt; {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line"><span class="keyword">class </span>A&lt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>, <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>, 1&gt; {};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a614a4778ab8392430ee9a0a28b7e9693" title="Matches C++ class template partial specializations.">classTemplatePartialSpecializationDecl()</a> matches the specialization <code>A&lt;T,T*,I&gt;</code> but not <code>A&lt;int,int,1&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00753">753</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab81538ee441769591ce912334397e6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81538ee441769591ce912334397e6b7">&#9670;&nbsp;</a></span>classTemplateSpecializationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ClassTemplateSpecializationDecl.html">ClassTemplateSpecializationDecl</a> &gt; clang::ast_matchers::classTemplateSpecializationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class template specializations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>A {};</div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>A&lt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a81cb22c87f277e41a39a91e48766e549">double</a>&gt; {};</div>
<div class="line">A&lt;int&gt; a;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab81538ee441769591ce912334397e6b7" title="Matches C++ class template specializations.">classTemplateSpecializationDecl()</a> matches the specializations <code>A&lt;int&gt;</code> and <code>A&lt;double&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00750">750</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a316dfc14ff4a5e127c5942d1bd97340c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316dfc14ff4a5e127c5942d1bd97340c">&#9670;&nbsp;</a></span>coawaitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoawaitExpr.html">CoawaitExpr</a> &gt; clang::ast_matchers::coawaitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches co_await expressions. </p>
<p>Given </p><div class="fragment"><div class="line">co_await 1;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a316dfc14ff4a5e127c5942d1bd97340c" title="Matches co_await expressions.">coawaitExpr()</a> matches 'co_await 1' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00936">936</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae84886494cbc41d78353574764bf4566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84886494cbc41d78353574764bf4566">&#9670;&nbsp;</a></span>complexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ComplexType.html">ComplexType</a> &gt; clang::ast_matchers::complexType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C99 complex types. </p>
<p>Given </p><div class="fragment"><div class="line">_Complex <span class="keywordtype">float</span> f;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ae84886494cbc41d78353574764bf4566" title="Matches C99 complex types.">complexType()</a> matches "_Complex float f" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01035">1035</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00063">clang::CodeGen::swiftcall::SwiftAggLowering::addTypedData()</a>.</p>

</div>
</div>
<a id="adcac5ffe32ca0150ad183cbdc3d0f6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcac5ffe32ca0150ad183cbdc3d0f6c1">&#9670;&nbsp;</a></span>compoundLiteralExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundLiteralExpr.html">CompoundLiteralExpr</a> &gt; clang::ast_matchers::compoundLiteralExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches compound (i.e. </p>
<p>non-scalar) literals</p>
<p>Example match: {1}, (1, 2) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> array[4] = {1};</div>
<div class="line">vector <span class="keywordtype">int</span> myvec = (vector <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>)(1, 2);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00931">931</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a496a3f466a3f754041e8a1cfd3aaf749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496a3f466a3f754041e8a1cfd3aaf749">&#9670;&nbsp;</a></span>compoundStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CompoundStmt.html">CompoundStmt</a> &gt; clang::ast_matchers::compoundStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches compound statements. </p>
<p>Example matches '{}' and '{{}}' in 'for (;;) {{}}' </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (;;) {{}}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00911">911</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae471648f1de66bdde248ef4b1edae5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae471648f1de66bdde248ef4b1edae5e5">&#9670;&nbsp;</a></span>conditionalOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConditionalOperator.html">ConditionalOperator</a> &gt; clang::ast_matchers::conditionalOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches conditional operator expressions. </p>
<p>Example matches a ? b : c </p><div class="fragment"><div class="line">(a ? <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> : <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) + 42</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00954">954</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="aac021576281120c3d3621e0bf2bcf591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac021576281120c3d3621e0bf2bcf591">&#9670;&nbsp;</a></span>constantArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ConstantArrayType.html">ConstantArrayType</a> &gt; clang::ast_matchers::constantArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C arrays with a specified constant size. </p>
<p>Given </p><div class="fragment"><div class="line">void() {</div>
<div class="line">  <span class="keywordtype">int</span> a[2];</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[] = { 2, 3 };</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[0]];</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aac021576281120c3d3621e0bf2bcf591" title="Matches C arrays with a specified constant size.">constantArrayType()</a> matches "int a[2]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01036">1036</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1636090af19685070c1f5183bce08909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1636090af19685070c1f5183bce08909">&#9670;&nbsp;</a></span>constantExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ConstantExpr.html">ConstantExpr</a> &gt; clang::ast_matchers::constantExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a constant expression wrapper. </p>
<p>Example matches the constant in the case statement: (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#a1636090af19685070c1f5183bce08909" title="Matches a constant expression wrapper.">constantExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (a) {</div>
<div class="line"><span class="keywordflow">case</span> 37: <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00867">867</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af901ad829d7e589a44f983a327351ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af901ad829d7e589a44f983a327351ebf">&#9670;&nbsp;</a></span>continueStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ContinueStmt.html">ContinueStmt</a> &gt; clang::ast_matchers::continueStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches continue statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { <span class="keywordflow">continue</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#af901ad829d7e589a44f983a327351ebf" title="Matches continue statements.">continueStmt()</a> matches 'continue' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00901">901</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a44762e1acc1d5a4f9921704755f87a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44762e1acc1d5a4f9921704755f87a9c">&#9670;&nbsp;</a></span>coreturnStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoreturnStmt.html">CoreturnStmt</a> &gt; clang::ast_matchers::coreturnStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches co_return statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) { co_return; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a44762e1acc1d5a4f9921704755f87a9c" title="Matches co_return statements.">coreturnStmt()</a> matches 'co_return' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00902">902</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a19508bdafd0681dc1c08480af65bf65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19508bdafd0681dc1c08480af65bf65e">&#9670;&nbsp;</a></span>coyieldExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CoyieldExpr.html">CoyieldExpr</a> &gt; clang::ast_matchers::coyieldExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches co_yield expressions. </p>
<p>Given </p><div class="fragment"><div class="line">co_yield 1;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a19508bdafd0681dc1c08480af65bf65e" title="Matches co_yield expressions.">coyieldExpr()</a> matches 'co_yield 1' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00940">940</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0262eb3971f2f7649d0354cbddaaec73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0262eb3971f2f7649d0354cbddaaec73">&#9670;&nbsp;</a></span>cStyleCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CStyleCastExpr.html">CStyleCastExpr</a> &gt; clang::ast_matchers::cStyleCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C-style cast expression. </p>
<p>Example: Matches (int) 2.2f in </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = (<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>) 2.2f;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00970">970</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae99eeac842695b2fd84e506a06f0d2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99eeac842695b2fd84e506a06f0d2de">&#9670;&nbsp;</a></span>cudaKernelCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CUDAKernelCallExpr.html">CUDAKernelCallExpr</a> &gt; clang::ast_matchers::cudaKernelCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches CUDA kernel call expression. </p>
<p>Example matches, </p><div class="fragment"><div class="line">kernel&lt;&lt;&lt;i,j&gt;&gt;&gt;();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01032">1032</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5309a87cb7c21babc136012e839f910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5309a87cb7c21babc136012e839f910a">&#9670;&nbsp;</a></span>cxxBaseSpecifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXBaseSpecifier.html">CXXBaseSpecifier</a> &gt; clang::ast_matchers::cxxBaseSpecifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches class bases. </p>
<p>Examples matches <code>public</code> virtual B. </p><div class="fragment"><div class="line"><span class="keyword">class </span>B {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">public</span> <span class="keyword">virtual</span> B {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00759">759</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab78d0ccf6cfdd2460d9c4d5f7847605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78d0ccf6cfdd2460d9c4d5f7847605d">&#9670;&nbsp;</a></span>cxxBindTemporaryExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBindTemporaryExpr.html">CXXBindTemporaryExpr</a> &gt; clang::ast_matchers::cxxBindTemporaryExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes where temporaries are created. </p>
<p>Example matches FunctionTakesString(GetStringByValue()) (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#ab78d0ccf6cfdd2460d9c4d5f7847605d" title="Matches nodes where temporaries are created.">cxxBindTemporaryExpr()</a>) </p><div class="fragment"><div class="line">FunctionTakesString(GetStringByValue());</div>
<div class="line">FunctionTakesStringByPointer(GetStringPointer());</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00875">875</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a409ccd26dc35075d52eef632d86bbf33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409ccd26dc35075d52eef632d86bbf33">&#9670;&nbsp;</a></span>cxxBoolLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXBoolLiteralExpr.html">CXXBoolLiteralExpr</a> &gt; clang::ast_matchers::cxxBoolLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches bool literals. </p>
<p>Example matches true </p><div class="fragment"><div class="line"><span class="keyword">true</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00918">918</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aed73db7e4f5258557e39edc7fc5168d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed73db7e4f5258557e39edc7fc5168d0">&#9670;&nbsp;</a></span>cxxCatchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXCatchStmt.html">CXXCatchStmt</a> &gt; clang::ast_matchers::cxxCatchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches catch statements. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {} <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aed73db7e4f5258557e39edc7fc5168d0" title="Matches catch statements.">cxxCatchStmt()</a> matches 'catch(int i)' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00912">912</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a704390715c62f500730acc8eb8133ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704390715c62f500730acc8eb8133ee0">&#9670;&nbsp;</a></span>cxxConstCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstCastExpr.html">CXXConstCastExpr</a> &gt; clang::ast_matchers::cxxConstCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a const_cast expression. </p>
<p>Example: Matches const_cast&lt;int*&gt;(&amp;r) in </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> n = 42;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> &amp;r(n);</div>
<div class="line"><span class="keywordtype">int</span>* p = <span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(&amp;r);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00968">968</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab0da198b76c77bfd4737a339d5a78e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da198b76c77bfd4737a339d5a78e33">&#9670;&nbsp;</a></span>cxxConstructExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt; clang::ast_matchers::cxxConstructExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor call expressions (including implicit ones). </p>
<p>Example matches string(ptr, n) and ptr within arguments of f (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33" title="Matches constructor call expressions (including implicit ones).">cxxConstructExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line"><span class="keywordtype">char</span> *ptr;</div>
<div class="line"><span class="keywordtype">int</span> n;</div>
<div class="line">f(<span class="keywordtype">string</span>(ptr, n), ptr);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00870">870</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a832104640e9b865d3d10cb779f59dbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832104640e9b865d3d10cb779f59dbee">&#9670;&nbsp;</a></span>cxxConstructorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConstructorDecl.html">CXXConstructorDecl</a> &gt; clang::ast_matchers::cxxConstructorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ constructor declarations. </p>
<p>Example matches Foo::Foo() and Foo::Foo(int) </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  Foo();</div>
<div class="line">  Foo(<span class="keywordtype">int</span>);</div>
<div class="line">  <span class="keywordtype">int</span> DoSomething();</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00792">792</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a67d2f76b0d40efafcb16d997b1928f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d2f76b0d40efafcb16d997b1928f5b">&#9670;&nbsp;</a></span>cxxConversionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXConversionDecl.html">CXXConversionDecl</a> &gt; clang::ast_matchers::cxxConversionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches conversion operator declarations. </p>
<p>Example matches the operator. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keyword">operator</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>() <span class="keyword">const</span>; };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00801">801</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2d0414dac04ff22f5ebd022efd442d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0414dac04ff22f5ebd022efd442d4e">&#9670;&nbsp;</a></span>cxxCtorInitializer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1CXXCtorInitializer.html">CXXCtorInitializer</a> &gt; clang::ast_matchers::cxxCtorInitializer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches constructor initializers. </p>
<p>Examples matches <code>i(42)</code>. </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>() : i(42) {}</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00760">760</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a400a7d8c9a439cb1c43dfa8ed4f6d5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400a7d8c9a439cb1c43dfa8ed4f6d5d7">&#9670;&nbsp;</a></span>cxxDeductionGuideDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDeductionGuideDecl.html">CXXDeductionGuideDecl</a> &gt; clang::ast_matchers::cxxDeductionGuideDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches user-defined and implicitly generated deduction guide. </p>
<p>Example matches the deduction guide. </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>(<span class="keywordtype">int</span>) };</div>
<div class="line"><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>(<span class="keywordtype">int</span>) -&gt; X&lt;int&gt;;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01082">1082</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5505ee16ebcb2b7ee272e91d709849ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5505ee16ebcb2b7ee272e91d709849ee">&#9670;&nbsp;</a></span>cxxDefaultArgExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDefaultArgExpr.html">CXXDefaultArgExpr</a> &gt; clang::ast_matchers::cxxDefaultArgExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the value of a default argument at the call site. </p>
<p>Example matches the <a class="el" href="classclang_1_1CXXDefaultArgExpr.html" title="A default argument (C++ [dcl.fct.default]).">CXXDefaultArgExpr</a> placeholder inserted for the default value of the second parameter in the call expression f(42) (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#a5505ee16ebcb2b7ee272e91d709849ee" title="Matches the value of a default argument at the call site.">cxxDefaultArgExpr()</a>) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, <span class="keywordtype">int</span> y = 0);</div>
<div class="line">f(42);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00885">885</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a21c9455ba631c516e4e7818a0f7f8eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c9455ba631c516e4e7818a0f7f8eff">&#9670;&nbsp;</a></span>cxxDeleteExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDeleteExpr.html">CXXDeleteExpr</a> &gt; clang::ast_matchers::cxxDeleteExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches delete expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">delete</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a21c9455ba631c516e4e7818a0f7f8eff" title="Matches delete expressions.">cxxDeleteExpr()</a> matches 'delete X'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00879">879</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3285794ef7314a9b8ca5c18ed2744c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3285794ef7314a9b8ca5c18ed2744c13">&#9670;&nbsp;</a></span>cxxDependentScopeMemberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDependentScopeMemberExpr.html">CXXDependentScopeMemberExpr</a> &gt; clang::ast_matchers::cxxDependentScopeMemberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member expressions where the actual member referenced could not be resolved because the base expression or the member name was dependent. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f() { T t; t.g(); }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a3285794ef7314a9b8ca5c18ed2744c13" title="Matches member expressions where the actual member referenced could not be resolved because the base ...">cxxDependentScopeMemberExpr()</a> matches t.g </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00816">816</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac797cd3d7e0d85d5bd07773f1c9e2f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac797cd3d7e0d85d5bd07773f1c9e2f7e">&#9670;&nbsp;</a></span>cxxDestructorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXDestructorDecl.html">CXXDestructorDecl</a> &gt; clang::ast_matchers::cxxDestructorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches explicit C++ destructor declarations. </p>
<p>Example matches Foo::~Foo() </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~Foo();</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00794">794</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a446ee71422a19b825dd23d6dde2c0551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ee71422a19b825dd23d6dde2c0551">&#9670;&nbsp;</a></span>cxxDynamicCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXDynamicCastExpr.html">CXXDynamicCastExpr</a> &gt; clang::ast_matchers::cxxDynamicCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a dynamic_cast expression. </p>
<p>Example: <a class="el" href="namespaceclang_1_1ast__matchers.html#a446ee71422a19b825dd23d6dde2c0551" title="Matches a dynamic_cast expression.">cxxDynamicCastExpr()</a> matches dynamic_cast&lt;D*&gt;(&amp;b); in </p><div class="fragment"><div class="line"><span class="keyword">struct </span>B { <span class="keyword">virtual</span> ~B() {} }; <span class="keyword">struct </span>D : B {};</div>
<div class="line">B <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">D* p = <span class="keyword">dynamic_cast&lt;</span>D*<span class="keyword">&gt;</span>(&amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00966">966</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8270a8d8f21ce50af2f56e4bcdd31eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8270a8d8f21ce50af2f56e4bcdd31eba">&#9670;&nbsp;</a></span>cxxForRangeStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXForRangeStmt.html">CXXForRangeStmt</a> &gt; clang::ast_matchers::cxxForRangeStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches range-based for statements. </p>
<p><a class="el" href="namespaceclang_1_1ast__matchers.html#a8270a8d8f21ce50af2f56e4bcdd31eba" title="Matches range-based for statements.">cxxForRangeStmt()</a> matches 'for (auto a : i)' </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i[] =  {1, 2, 3}; <span class="keywordflow">for</span> (<span class="keyword">auto</span> a : i);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 5; ++j);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00897">897</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a701d2c84173a8709dcb4a221ad478e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701d2c84173a8709dcb4a221ad478e1e">&#9670;&nbsp;</a></span>cxxFunctionalCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXFunctionalCastExpr.html">CXXFunctionalCastExpr</a> &gt; clang::ast_matchers::cxxFunctionalCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functional cast expressions. </p>
<p>Example: Matches Foo(bar); </p><div class="fragment"><div class="line">Foo f = bar;</div>
<div class="line">Foo g = (Foo) bar;</div>
<div class="line">Foo h = Foo(bar);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00977">977</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a831e164251478f3b38b3685d4d330cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831e164251478f3b38b3685d4d330cff">&#9670;&nbsp;</a></span>cxxMemberCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXMemberCallExpr.html">CXXMemberCallExpr</a> &gt; clang::ast_matchers::cxxMemberCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member call expressions. </p>
<p>Example matches x.y() </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.y();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00820">820</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="aebe825b22b86295d319b09c996fe78fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe825b22b86295d319b09c996fe78fd">&#9670;&nbsp;</a></span>cxxMethodDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXMethodDecl.html">CXXMethodDecl</a> &gt; clang::ast_matchers::cxxMethodDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches method declarations. </p>
<p>Example matches y </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">void</span> y(); };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00799">799</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8c90fa40e809e57f174ef162b26bb7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c90fa40e809e57f174ef162b26bb7d9">&#9670;&nbsp;</a></span>cxxNewExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNewExpr.html">CXXNewExpr</a> &gt; clang::ast_matchers::cxxNewExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches new expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">new</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a8c90fa40e809e57f174ef162b26bb7d9" title="Matches new expressions.">cxxNewExpr()</a> matches 'new X'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00878">878</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a896f97c027b999f18752148a0921a19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896f97c027b999f18752148a0921a19c">&#9670;&nbsp;</a></span>cxxNoexceptExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNoexceptExpr.html">CXXNoexceptExpr</a> &gt; clang::ast_matchers::cxxNoexceptExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches noexcept expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> a() noexcept;</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>() noexcept(<a class="code" href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>() noexcept(<a class="code" href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>);</div>
<div class="line"><span class="keywordtype">bool</span> d() noexcept(noexcept(a()));</div>
<div class="line"><span class="keywordtype">bool</span> e = noexcept(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>()) || noexcept(<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>());</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a896f97c027b999f18752148a0921a19c" title="Matches noexcept expressions.">cxxNoexceptExpr()</a> matches <code>noexcept(a())</code>, <code>noexcept(b())</code> and <code>noexcept(c())</code>. doesn't match the noexcept specifier in the declarations a, b, c or d. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00881">881</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad74cde61d132689b56daab21db683425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74cde61d132689b56daab21db683425">&#9670;&nbsp;</a></span>cxxNullPtrLiteralExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXNullPtrLiteralExpr.html">CXXNullPtrLiteralExpr</a> &gt; clang::ast_matchers::cxxNullPtrLiteralExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nullptr literal. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00933">933</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>.</p>

</div>
</div>
<a id="ab422b5e5502151463a9d2d6ad04350e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab422b5e5502151463a9d2d6ad04350e4">&#9670;&nbsp;</a></span>cxxOperatorCallExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXOperatorCallExpr.html">CXXOperatorCallExpr</a> &gt; clang::ast_matchers::cxxOperatorCallExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches overloaded operator calls. </p>
<p>Note that if an operator isn't overloaded, it won't match. Instead, use binaryOperator matcher. Currently it does not match operators such as new delete. FIXME: figure out why these do not match?</p>
<p>Example matches both operator&lt;&lt;((o &lt;&lt; b), c) and operator&lt;&lt;(o, b) (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#ab422b5e5502151463a9d2d6ad04350e4" title="Matches overloaded operator calls.">cxxOperatorCallExpr()</a>) </p><div class="fragment"><div class="line">ostream &amp;<a class="code" href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">operator&lt;&lt; </a>(ostream &amp;out, <span class="keywordtype">int</span> i) { };</div>
<div class="line">ostream &amp;o; <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 1, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 1;</div>
<div class="line">o &lt;&lt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> &lt;&lt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> See also the <a class="el" href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching of binary uses of this AST node. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00887">887</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>.</p>

</div>
</div>
<a id="ac1ef73826e6b83dd0e8fc4a4b7284c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef73826e6b83dd0e8fc4a4b7284c74">&#9670;&nbsp;</a></span>cxxRecordDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1CXXRecordDecl.html">CXXRecordDecl</a> &gt; clang::ast_matchers::cxxRecordDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ class declarations. </p>
<p>Example matches <code>X</code>, <code>Z</code> </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00745">745</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l06406">AST_MATCHER_FUNCTION()</a>, <a class="el" href="ASTSrcLocProcessor_8cpp_source.html#l00019">clang::tooling::ASTSrcLocProcessor::ASTSrcLocProcessor()</a>, <a class="el" href="RetainSummaryManager_8cpp_source.html#l00148">isExactClass()</a>, <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>, and <a class="el" href="RetainSummaryManager_8cpp_source.html#l00140">isSubclass()</a>.</p>

</div>
</div>
<a id="a04dc23e7233bd6aa6c8cd1240dfc71de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc23e7233bd6aa6c8cd1240dfc71de">&#9670;&nbsp;</a></span>cxxReinterpretCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXReinterpretCastExpr.html">CXXReinterpretCastExpr</a> &gt; clang::ast_matchers::cxxReinterpretCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reinterpret_cast expression. </p>
<p>Either the source expression or the destination type can be matched using <a class="el" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962" title="Matches AST nodes that have child AST nodes that match the provided matcher.">has()</a>, but hasDestinationType() is more specific and can be more readable.</p>
<p>Example matches reinterpret_cast&lt;char*&gt;(&amp;p) in </p><div class="fragment"><div class="line"><span class="keywordtype">void</span>* p = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(&amp;p);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00962">962</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3b9e9197127c18de63db7a43256f1aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e9197127c18de63db7a43256f1aff">&#9670;&nbsp;</a></span>cxxRewrittenBinaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXRewrittenBinaryOperator.html">CXXRewrittenBinaryOperator</a> &gt; clang::ast_matchers::cxxRewrittenBinaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches rewritten binary operators. </p>
<p>Example matches use of "&lt;": </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;compare&gt;</span></div>
<div class="line"><span class="keyword">struct </span>HasSpaceshipMem {</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">  constexpr <span class="keyword">auto</span> operator&lt;=&gt;(<span class="keyword">const</span> HasSpaceshipMem&amp;) <span class="keyword">const</span> = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="PathDiagnostic_8cpp.html#a0a3098eaa1bf35a10ed829cd2ab49411">compare</a>() {</div>
<div class="line">  HasSpaceshipMem hs1, hs2;</div>
<div class="line">  <span class="keywordflow">if</span> (hs1 &lt; hs2)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> See also the <a class="el" href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e" title="Matches nodes which can be used with binary operators.">binaryOperation()</a> matcher for more-general matching of this AST node. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00889">889</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa83203112fbb0fc35646465509fce105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83203112fbb0fc35646465509fce105">&#9670;&nbsp;</a></span>cxxStaticCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStaticCastExpr.html">CXXStaticCastExpr</a> &gt; clang::ast_matchers::cxxStaticCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ static_cast expression. </p>
<dl class="section see"><dt>See also</dt><dd>hasDestinationType </dd>
<dd>
reinterpretCast</dd></dl>
<p>Example: <a class="el" href="namespaceclang_1_1ast__matchers.html#aa83203112fbb0fc35646465509fce105" title="Matches a C++ static_cast expression.">cxxStaticCastExpr()</a> matches static_cast&lt;long&gt;(8) in </p><div class="fragment"><div class="line"><span class="keywordtype">long</span> eight(<span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span><span class="keyword">&gt;</span>(8));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00964">964</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae4cf0cd73005c114b30400dc613baa59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cf0cd73005c114b30400dc613baa59">&#9670;&nbsp;</a></span>cxxStdInitializerListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXStdInitializerListExpr.html">CXXStdInitializerListExpr</a> &gt; clang::ast_matchers::cxxStdInitializerListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ initializer list expressions. </p>
<p>Given </p><div class="fragment"><div class="line">std::vector&lt;int&gt; a({ 1, 2, 3 });</div>
<div class="line">std::vector&lt;int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = { 4, 5 };</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[] = { 6, 7 };</div>
<div class="line">std::pair&lt;int, int&gt; d = { 8, 9 };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ae4cf0cd73005c114b30400dc613baa59" title="Matches C++ initializer list expressions.">cxxStdInitializerListExpr()</a> matches "{ 1, 2, 3 }" and "{ 4, 5 }" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00851">851</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a704e8b0c7519edb6b05d1663a4266b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704e8b0c7519edb6b05d1663a4266b6d">&#9670;&nbsp;</a></span>cxxTemporaryObjectExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTemporaryObjectExpr.html">CXXTemporaryObjectExpr</a> &gt; clang::ast_matchers::cxxTemporaryObjectExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches functional cast expressions having N != 1 arguments. </p>
<p>Example: Matches Foo(bar, bar) </p><div class="fragment"><div class="line">Foo h = Foo(bar, bar);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00979">979</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af636f476cad8054e282b42e8ea613987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af636f476cad8054e282b42e8ea613987">&#9670;&nbsp;</a></span>cxxThisExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThisExpr.html">CXXThisExpr</a> &gt; clang::ast_matchers::cxxThisExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches implicit and explicit this expressions. </p>
<p>Example matches the implicit this expression in "return i". (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#af636f476cad8054e282b42e8ea613987" title="Matches implicit and explicit this expressions.">cxxThisExpr()</a>) </p><div class="fragment"><div class="line"><span class="keyword">struct </span>foo {</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  <span class="keywordtype">int</span> f() { <span class="keywordflow">return</span> i; }</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00873">873</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abc856098ca748d9cff1734ff8fe3bd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc856098ca748d9cff1734ff8fe3bd56">&#9670;&nbsp;</a></span>cxxThrowExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXThrowExpr.html">CXXThrowExpr</a> &gt; clang::ast_matchers::cxxThrowExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches throw expressions. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> { <span class="keywordflow">throw</span> 5; } <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#abc856098ca748d9cff1734ff8fe3bd56" title="Matches throw expressions.">cxxThrowExpr()</a> matches 'throw 5' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00914">914</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af0002878ac1dc163307befba0daa2b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0002878ac1dc163307befba0daa2b17">&#9670;&nbsp;</a></span>cxxTryStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXTryStmt.html">CXXTryStmt</a> &gt; clang::ast_matchers::cxxTryStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches try statements. </p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {} <span class="keywordflow">catch</span>(<span class="keywordtype">int</span> i) {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#af0002878ac1dc163307befba0daa2b17" title="Matches try statements.">cxxTryStmt()</a> matches 'try {}' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00913">913</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="accfe2da9177520906d97d82833577922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfe2da9177520906d97d82833577922">&#9670;&nbsp;</a></span>cxxUnresolvedConstructExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1CXXUnresolvedConstructExpr.html">CXXUnresolvedConstructExpr</a> &gt; clang::ast_matchers::cxxUnresolvedConstructExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved constructor call expressions. </p>
<p>Example matches T(t) in return statement of f (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#accfe2da9177520906d97d82833577922" title="Matches unresolved constructor call expressions.">cxxUnresolvedConstructExpr()</a>) </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keyword">const</span> T&amp; t) { <span class="keywordflow">return</span> T(t); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00872">872</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="adbb22e211875d1365ddfdf3a721f63e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb22e211875d1365ddfdf3a721f63e6">&#9670;&nbsp;</a></span>decayedType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DecayedType.html">DecayedType</a> &gt; clang::ast_matchers::decayedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches decayed type Example matches i[] in declaration of f. </p>
<p>(matcher = valueDecl(hasType(decayedType(hasDecayedType(pointerType()))))) Example matches i[1]. (matcher = expr(hasType(decayedType(hasDecayedType(pointerType()))))) </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i[]) {</div>
<div class="line">  i[1] = 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01066">1066</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac5ccadfbea5e9e43c2153175afca6cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ccadfbea5e9e43c2153175afca6cac">&#9670;&nbsp;</a></span>decl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a> &gt; clang::ast_matchers::decl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarations. </p>
<p>Examples matches <code>X</code>, <code>C</code>, and the friend declaration inside <code>C</code>; </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>();</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {</div>
<div class="line">  <span class="keyword">friend</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00734">734</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaStmt_8cpp_source.html#l00083">clang::Sema::ActOnForEachDeclStmt()</a>, <a class="el" href="ASTMatchers_8h_source.html#l06406">AST_MATCHER_FUNCTION()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00155">checkTempObjectsInSamePool()</a>, <a class="el" href="Type_8cpp_source.html#l03521">getInterestingTagDecl()</a>, <a class="el" href="Store_8cpp_source.html#l00439">clang::ento::StoreManager::getLValueIvar()</a>, <a class="el" href="CGExprConstant_8cpp_source.html#l02190">clang::CodeGen::CodeGenModule::getMemberPointerConstant()</a>, <a class="el" href="Decl_8cpp_source.html#l01882">getTemplateOrInnerLocStart()</a>, <a class="el" href="DeclObjC_8cpp_source.html#l00321">clang::ObjCInterfaceDecl::getTypeParamList()</a>, <a class="el" href="ExprCXX_8cpp_source.html#l01439">hasOnlyNonStaticMemberFunctions()</a>, <a class="el" href="SemaDecl_8cpp_source.html#l06540">clang::Sema::inferObjCARCLifetime()</a>, <a class="el" href="CGDecl_8cpp_source.html#l00711">isAccessedBy()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l00816">clang::ento::ExprEngine::ProcessInitializer()</a>, <a class="el" href="AbstractBasicReader_8h_source.html#l00191">clang::serialization::DataStreamBasicReader&lt; ASTRecordReader &gt;::readLValuePathSerializationHelper()</a>, and <a class="el" href="ASTReaderDecl_8cpp_source.html#l01581">clang::ASTDeclReader::VisitBlockDecl()</a>.</p>

</div>
</div>
<a id="a91cafc159defa3d1fdcbb28ec72ae418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cafc159defa3d1fdcbb28ec72ae418">&#9670;&nbsp;</a></span>declaratorDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DeclaratorDecl.html">DeclaratorDecl</a> &gt; clang::ast_matchers::declaratorDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declarator declarations (field, variable, function and non-type template parameter declarations). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> y; };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a91cafc159defa3d1fdcbb28ec72ae418" title="Matches declarator declarations (field, variable, function and non-type template parameter declaratio...">declaratorDecl()</a> matches <code>int</code> y. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00755">755</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0781cbe6d50bd620cb6f8f0627378be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0781cbe6d50bd620cb6f8f0627378be6">&#9670;&nbsp;</a></span>declRefExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclRefExpr.html">DeclRefExpr</a> &gt; clang::ast_matchers::declRefExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that refer to declarations. </p>
<p>Example matches x in if (x) </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) {}</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a55">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00891">891</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00097">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00124">clang::ento::getAddrTo()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="adc3d4ad0df1926038d75178efe06dcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d4ad0df1926038d75178efe06dcd8">&#9670;&nbsp;</a></span>declStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DeclStmt.html">DeclStmt</a> &gt; clang::ast_matchers::declStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches declaration statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#adc3d4ad0df1926038d75178efe06dcd8" title="Matches declaration statements.">declStmt()</a> matches 'int a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00811">811</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="a60595a1ea21c91357ce6a094ae9d24a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60595a1ea21c91357ce6a094ae9d24a7">&#9670;&nbsp;</a></span>decltypeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DecltypeType.html">DecltypeType</a> &gt; clang::ast_matchers::decltypeType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types nodes representing C++11 decltype(&lt;expr&gt;) types. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">short</span> i = 1;</div>
<div class="line"><span class="keywordtype">int</span> j = 42;</div>
<div class="line">decltype(i + j) result = i + j;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a60595a1ea21c91357ce6a094ae9d24a7" title="Matches types nodes representing C++11 decltype(&lt;expr&gt;) types.">decltypeType()</a> matches "decltype(i + j)" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01044">1044</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab8c34f70634543e4f54c46ee7df6614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c34f70634543e4f54c46ee7df6614f">&#9670;&nbsp;</a></span>decompositionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1DecompositionDecl.html">DecompositionDecl</a> &gt; clang::ast_matchers::decompositionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches decomposition-declarations. </p>
<p>Examples matches the declaration node with <code>foo</code> and <code>bar</code>, but not <code>number</code>. (matcher = declStmt(has(decompositionDecl())))</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> number = 42;</div>
<div class="line"><span class="keyword">auto</span> [foo, bar] = std::make_pair{42, 42};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00735">735</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a30f4487f1a9017a589b1eca7c8f277f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f4487f1a9017a589b1eca7c8f277f9">&#9670;&nbsp;</a></span>deducedTemplateSpecializationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DeducedTemplateSpecializationType.html">DeducedTemplateSpecializationType</a> &gt; clang::ast_matchers::deducedTemplateSpecializationType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++17 deduced template specialization types, e.g. </p>
<p>deduced class template types.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { <span class="keyword">public</span>: <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a>(T); };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>(123);</div>
</div><!-- fragment --><p> <code><a class="el" href="namespaceclang_1_1ast__matchers.html#a30f4487f1a9017a589b1eca7c8f277f9" title="Matches C++17 deduced template specialization types, e.g.">deducedTemplateSpecializationType()</a></code> matches the type in the declaration of the variable <code>c</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01038">1038</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7cc259a084492c93e3053e78ea9d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cc259a084492c93e3053e78ea9d088">&#9670;&nbsp;</a></span>defaultStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DefaultStmt.html">DefaultStmt</a> &gt; clang::ast_matchers::defaultStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches default statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab7cc259a084492c93e3053e78ea9d088" title="Matches default statements inside switch statements.">defaultStmt()</a> matches 'default:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00910">910</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a34bfb525257906764abbd2c71bd8e8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bfb525257906764abbd2c71bd8e8e0">&#9670;&nbsp;</a></span>dependentCoawaitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DependentCoawaitExpr.html">DependentCoawaitExpr</a> &gt; clang::ast_matchers::dependentCoawaitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches co_await expressions where the type of the promise is dependent. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00938">938</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2e34f28aac1f47aac489477a599a0efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e34f28aac1f47aac489477a599a0efd">&#9670;&nbsp;</a></span>dependentSizedArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1DependentSizedArrayType.html">DependentSizedArrayType</a> &gt; clang::ast_matchers::dependentSizedArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ arrays whose size is a value-dependent expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> Size&gt;</div>
<div class="line"><span class="keyword">class </span>array {</div>
<div class="line">  T data[<a class="code" href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">Size</a>];</div>
<div class="line">};</div>
</div><!-- fragment --><p> dependentSizedArrayType matches "T data[Size]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01039">1039</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac5af767c2d681ddb0122fec2e3ab43a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af767c2d681ddb0122fec2e3ab43a5">&#9670;&nbsp;</a></span>designatedInitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DesignatedInitExpr.html">DesignatedInitExpr</a> &gt; clang::ast_matchers::designatedInitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C99 designated initializer expressions [C99 6.7.8]. </p>
<p>Example: Matches { [2].y = 1.0, [0].x = 1.0 } </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [0].x = 1.0 };</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00983">983</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad35f9309e910ba3399781cc30baa2439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35f9309e910ba3399781cc30baa2439">&#9670;&nbsp;</a></span>doStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1DoStmt.html">DoStmt</a> &gt; clang::ast_matchers::doStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches do statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">do</span> {} <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ad35f9309e910ba3399781cc30baa2439" title="Matches do statements.">doStmt()</a> matches 'do {} while(true)' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00899">899</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab0c3c535f34a336b4e966342d44a631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3c535f34a336b4e966342d44a631d">&#9670;&nbsp;</a></span>eachOf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;::<a class="el" href="opencl-c_8h.html#a5c0209014bb5a50470c436fa6e00c669">max</a>()&gt; clang::ast_matchers::eachOf = {internal::DynTypedMatcher::VO_EachOf}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if any of the given matchers matches. </p>
<p>Unlike <code>anyOf</code>, <code>eachOf</code> will generate a match result for each matching submatcher.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keywordtype">int</span> a; <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; };</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab0c3c535f34a336b4e966342d44a631d">eachOf</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;a&quot;</span>)).bind(<span class="stringliteral">&quot;v&quot;</span>)),</div>
<div class="line">                     <a class="code" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;b&quot;</span>)).bind(<span class="stringliteral">&quot;v&quot;</span>))))</div>
</div><!-- fragment --><p> will generate two results binding "v", the first of which binds the field declaration of <code>a</code>, the second the field declaration of <code>b</code>.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00986">986</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a138456104e5e77cc8dd42e8a2f6fc8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138456104e5e77cc8dd42e8a2f6fc8bf">&#9670;&nbsp;</a></span>elaboratedType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ElaboratedType.html">ElaboratedType</a> &gt; clang::ast_matchers::elaboratedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types specified with an elaborated type keyword or with a qualified name. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>N {</div>
<div class="line">  <span class="keyword">namespace </span>M {</div>
<div class="line">    <span class="keyword">class </span>D {};</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">N::M::D d;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#a138456104e5e77cc8dd42e8a2f6fc8bf" title="Matches types specified with an elaborated type keyword or with a qualified name.">elaboratedType()</a></code> matches the type of the variable declarations of both <code>c</code> and <code>d</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01061">1061</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a065704e9c5222dd93296aaeb3383cdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065704e9c5222dd93296aaeb3383cdf7">&#9670;&nbsp;</a></span>elaboratedTypeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1ElaboratedTypeLoc.html">ElaboratedTypeLoc</a> &gt; clang::ast_matchers::elaboratedTypeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C or C++ elaborated <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> {};</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> ss;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a065704e9c5222dd93296aaeb3383cdf7" title="Matches C or C++ elaborated TypeLocs.">elaboratedTypeLoc()</a> matches the <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code> of the variable declaration of <code>ss</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00786">786</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8dcb1ffb5fb859e719d305b311baaeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcb1ffb5fb859e719d305b311baaeba">&#9670;&nbsp;</a></span>enumConstantDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumConstantDecl.html">EnumConstantDecl</a> &gt; clang::ast_matchers::enumConstantDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches enum constants. </p>
<p>Example matches A, B, C </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  A, B, <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00797">797</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a31e48dc9e0067b916df8f57d3d3bb72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e48dc9e0067b916df8f57d3d3bb72a">&#9670;&nbsp;</a></span>enumDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1EnumDecl.html">EnumDecl</a> &gt; clang::ast_matchers::enumDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches enum declarations. </p>
<p>Example matches X </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  A, B, <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00795">795</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1182014746912db21f315121c2ed6098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1182014746912db21f315121c2ed6098">&#9670;&nbsp;</a></span>enumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1EnumType.html">EnumType</a> &gt; clang::ast_matchers::enumType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches enum types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { Green };</div>
<div class="line"><span class="keyword">enum class</span> S { Red };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">S <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
</div><!-- fragment --><p> <code><a class="el" href="namespaceclang_1_1ast__matchers.html#a1182014746912db21f315121c2ed6098" title="Matches enum types.">enumType()</a></code> matches the type of the variable declarations of both <code>c</code> and <code>s</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01056">1056</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa64f0fe0351af4d0e37f7838e6385d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64f0fe0351af4d0e37f7838e6385d3c">&#9670;&nbsp;</a></span>explicitCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExplicitCastExpr.html">ExplicitCastExpr</a> &gt; clang::ast_matchers::explicitCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches explicit cast expressions. </p>
<p>Matches any cast expression written in user code, whether it be a C-style cast, a functional-style cast, or a keyword cast.</p>
<p>Does not match implicit conversions.</p>
<p>Note: the name "explicitCast" is chosen to match Clang's terminology, as Clang uses the term "cast" to apply to implicit conversions as well as to actual cast expressions.</p>
<dl class="section see"><dt>See also</dt><dd>hasDestinationType.</dd></dl>
<p>Example: matches all five of the casts in </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>((<span class="keywordtype">int</span>)(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(42)))))</div>
</div><!-- fragment --><p> but does not match the implicit conversion in </p><div class="fragment"><div class="line"><span class="keywordtype">long</span> ell = 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00972">972</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="adfc0ccd398780d345e2c541cc716cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc0ccd398780d345e2c541cc716cc66">&#9670;&nbsp;</a></span>expr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1Expr.html">Expr</a> &gt; clang::ast_matchers::expr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions. </p>
<p>Example matches <a class="el" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x()</a> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); }</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00890">890</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaDecl_8cpp_source.html#l18745">clang::Sema::ActOnFileScopeAsmDecl()</a>, <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>, <a class="el" href="SValBuilder_8h_source.html#l00201">clang::ento::SValBuilder::conjureSymbol()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00163">clang::ento::SValBuilder::conjureSymbolVal()</a>, <a class="el" href="CGExpr_8cpp_source.html#l04618">clang::CodeGen::CodeGenFunction::EmitConditionalOperatorLValue()</a>, <a class="el" href="CGObjC_8cpp_source.html#l03470">clang::CodeGen::CodeGenFunction::EmitObjCThrowOperand()</a>, <a class="el" href="CGExprScalar_8cpp_source.html#l03459">emitPointerArithmetic()</a>, <a class="el" href="Expr_8cpp_source.html#l02904">clang::Expr::findBoundMemberType()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00208">clang::CodeGen::CGCXXABI::GetArrayCookieSize()</a>, <a class="el" href="CheckSecuritySyntaxOnly_8cpp_source.html#l00229">getIncrementedVar()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00221">clang::ento::SValBuilder::getMetadataSymbolVal()</a>, <a class="el" href="SValBuilder_8h_source.html#l00390">clang::ento::SValBuilder::makeLoc()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00248">clang::CodeGen::CGCXXABI::ReadArrayCookie()</a>, <a class="el" href="CGCXXABI_8cpp_source.html#l00229">clang::CodeGen::CGCXXABI::requiresArrayCookie()</a>, <a class="el" href="Expr_8h_source.html#l04902">clang::InitListExpr::setInit()</a>, <a class="el" href="CodeGenFunction_8h_source.html#l01266">clang::CodeGen::CodeGenFunction::OpaqueValueMappingData::shouldBindAsLValue()</a>, <a class="el" href="CodeGenFunction_8h_source.html#l01330">clang::CodeGen::CodeGenFunction::OpaqueValueMapping::shouldBindAsLValue()</a>, and <a class="el" href="Expr_8cpp_source.html#l02301">clang::InitListExpr::updateInit()</a>.</p>

</div>
</div>
<a id="a071d31bd81eb28a0b2db583b181cfc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071d31bd81eb28a0b2db583b181cfc01">&#9670;&nbsp;</a></span>exprWithCleanups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ExprWithCleanups.html">ExprWithCleanups</a> &gt; clang::ast_matchers::exprWithCleanups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches expressions that introduce cleanups to be run at the end of the sub-expression's evaluation. </p>
<p>Example matches std::string() </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a> str = <a class="code" href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">std::string</a>();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00848">848</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab26f3ff62d6be975196efa86f3b15d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26f3ff62d6be975196efa86f3b15d82">&#9670;&nbsp;</a></span>fieldDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FieldDecl.html">FieldDecl</a> &gt; clang::ast_matchers::fieldDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches field declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> m; };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82" title="Matches field declarations.">fieldDecl()</a> matches 'm'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00803">803</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0045003e9bc57bbe8c8f5e32a64c9533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0045003e9bc57bbe8c8f5e32a64c9533">&#9670;&nbsp;</a></span>fixedPointLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FixedPointLiteral.html">FixedPointLiteral</a> &gt; clang::ast_matchers::fixedPointLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches fixed point literals. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00927">927</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4a4e38c6224c16252040dc697a6af832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e38c6224c16252040dc697a6af832">&#9670;&nbsp;</a></span>floatLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1FloatingLiteral.html">FloatingLiteral</a> &gt; clang::ast_matchers::floatLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches float literals of all sizes / encodings, e.g. </p>
<p>1.0, 1.0f, 1.0L and 1e10.</p>
<p>Does not match implicit conversions such as </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 10;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00924">924</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a56e1d83c63172816c6678224f6d73fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e1d83c63172816c6678224f6d73fb8">&#9670;&nbsp;</a></span>forEach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachMatcher &gt; clang::ast_matchers::forEach</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    {}</div>
</div><!-- fragment -->
<p>Matches AST nodes that have child AST nodes that match the provided matcher. </p>
<p>Example matches X, Y, Y::X, Z::Y, Z::Y::X (matcher = cxxRecordDecl(forEach(cxxRecordDecl(hasName("X"))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; };  <span class="comment">// Matches Y, because Y::X is a class of name X</span></div>
<div class="line">                          <span class="comment">// inside Y.</span></div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; }; };  <span class="comment">// Does not match Z.</span></div>
</div><!-- fragment --><p>ChildT must be an AST base type.</p>
<p>As opposed to 'has', 'forEach' will cause a match for each result that matches instead of only on the first one.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01011">1011</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5114cdbe34bca53c82f6304894904740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114cdbe34bca53c82f6304894904740">&#9670;&nbsp;</a></span>forEachDescendant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::ForEachDescendantMatcher &gt; clang::ast_matchers::forEachDescendant = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have descendant AST nodes that match the provided matcher. </p>
<p>Example matches X, A, A::X, B, B::C, B::C::X (matcher = cxxRecordDecl(forEachDescendant(cxxRecordDecl(hasName("X"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; };  <span class="comment">// Matches A, because A::X is a class of name</span></div>
<div class="line">                          <span class="comment">// X inside A.</span></div>
<div class="line"><span class="keyword">class </span>B { <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; }; };</div>
</div><!-- fragment --><p>DescendantT must be an AST base type.</p>
<p>As opposed to 'hasDescendant', 'forEachDescendant' will cause a match for each result that matches instead of only on the first one.</p>
<p>Note: Recursively combined ForEachDescendant can cause many matches: cxxRecordDecl(forEachDescendant(cxxRecordDecl( forEachDescendant(cxxRecordDecl()) ))) will match 10 times (plus injected class name matches) on: </p><div class="fragment"><div class="line"><span class="keyword">class </span>A { <span class="keyword">class </span>B { <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { <span class="keyword">class </span>D { <span class="keyword">class </span>E {}; }; }; }; };</div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01014">1014</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8e6f109ac0734990e8ae974d36e76c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f109ac0734990e8ae974d36e76c7e">&#9670;&nbsp;</a></span>forStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ForStmt.html">ForStmt</a> &gt; clang::ast_matchers::forStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches for statements. </p>
<p>Example matches 'for (;;) {}' </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (;;) {}</div>
<div class="line"><span class="keywordtype">int</span> i[] =  {1, 2, 3}; <span class="keywordflow">for</span> (<span class="keyword">auto</span> a : i);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00895">895</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>.</p>

</div>
</div>
<a id="aded924f4ec88be994f9c255803e6075c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded924f4ec88be994f9c255803e6075c">&#9670;&nbsp;</a></span>friendDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FriendDecl.html">FriendDecl</a> &gt; clang::ast_matchers::friendDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches friend declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keyword">friend</span> <span class="keywordtype">void</span> foo(); };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aded924f4ec88be994f9c255803e6075c" title="Matches friend declarations.">friendDecl()</a> matches 'friend void foo()'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00809">809</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab95624c30888b0c7688e3a6171ed49cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95624c30888b0c7688e3a6171ed49cc">&#9670;&nbsp;</a></span>functionDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionDecl.html">FunctionDecl</a> &gt; clang::ast_matchers::functionDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches function declarations. </p>
<p>Example matches f </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00806">806</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l06406">AST_MATCHER_FUNCTION()</a>, <a class="el" href="ObjCAutoreleaseWriteChecker_8cpp_source.html#l00105">callsNames()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00174">checkTempObjectsInNoPool()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00131">getRunLoopRunM()</a>, <a class="el" href="GtestMatchers_8cpp_source.html#l00147">gtestCallInternal()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a129a0097a2bce4041eef9fbb315a35a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129a0097a2bce4041eef9fbb315a35a7">&#9670;&nbsp;</a></span>functionProtoType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1FunctionProtoType.html">FunctionProtoType</a> &gt; clang::ast_matchers::functionProtoType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1FunctionProtoType.html" title="Represents a prototype with parameter type info, e.g.">FunctionProtoType</a></code> nodes. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> (*f)(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>);</div>
<div class="line"><span class="keywordtype">void</span> g();</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a129a0097a2bce4041eef9fbb315a35a7" title="Matches FunctionProtoType nodes.">functionProtoType()</a> matches "int (*f)(int)" and the type of "g" in C++ mode. In C mode, "g" is not matched because it does not contain a prototype. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01046">1046</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a973fc1ea542ea4bb3543d905e2ee1e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973fc1ea542ea4bb3543d905e2ee1e11">&#9670;&nbsp;</a></span>functionTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1FunctionTemplateDecl.html">FunctionTemplateDecl</a> &gt; clang::ast_matchers::functionTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C++ function template declarations. </p>
<p>Example matches f </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f(T t) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00808">808</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aeb793c9ea9a7c9a4584f8d9a84963981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb793c9ea9a7c9a4584f8d9a84963981">&#9670;&nbsp;</a></span>functionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1FunctionType.html">FunctionType</a> &gt; clang::ast_matchers::functionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1FunctionType.html" title="FunctionType - C99 6.7.5.3 - Function Declarators.">FunctionType</a></code> nodes. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> (*f)(<a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>);</div>
<div class="line"><span class="keywordtype">void</span> g();</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aeb793c9ea9a7c9a4584f8d9a84963981" title="Matches FunctionType nodes.">functionType()</a> matches "int (*f)(int)" and the type of "g". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01045">1045</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGExpr_8cpp_source.html#l05033">clang::CodeGen::CodeGenFunction::EmitCallee()</a>.</p>

</div>
</div>
<a id="a3f42e20a3d2500bbee1741d7f8bc04f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f42e20a3d2500bbee1741d7f8bc04f3">&#9670;&nbsp;</a></span>genericSelectionExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GenericSelectionExpr.html">GenericSelectionExpr</a> &gt; clang::ast_matchers::genericSelectionExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C11 _Generic expression. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00943">943</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a80570a2d56d8d2d1788318a946a68a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80570a2d56d8d2d1788318a946a68a05">&#9670;&nbsp;</a></span>gnuNullExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GNUNullExpr.html">GNUNullExpr</a> &gt; clang::ast_matchers::gnuNullExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches GNU __null expression. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00941">941</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>.</p>

</div>
</div>
<a id="a8f07c79fb3acf3af34be21d41010648a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f07c79fb3acf3af34be21d41010648a">&#9670;&nbsp;</a></span>gotoStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1GotoStmt.html">GotoStmt</a> &gt; clang::ast_matchers::gotoStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches goto statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a8f07c79fb3acf3af34be21d41010648a" title="Matches goto statements.">gotoStmt()</a> matches 'goto FOO' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00904">904</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>.</p>

</div>
</div>
<a id="a9a14e1788aad32c318543405b5ec5962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a14e1788aad32c318543405b5ec5962">&#9670;&nbsp;</a></span>has</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt; clang::ast_matchers::has = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have child AST nodes that match the provided matcher. </p>
<p>Example matches X, Y (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName("X"))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};  <span class="comment">// Matches X, because X::X is a class of name X inside X.</span></div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; };</div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; }; };  <span class="comment">// Does not match Z.</span></div>
</div><!-- fragment --><p>ChildT must be an AST base type.</p>
<p>Usable as: Any Matcher Note that has is direct matcher, so it also matches things like implicit casts and paren casts. If you are matching with expr then you should probably consider using ignoringParenImpCasts like: has(ignoringParenImpCasts(expr())). </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01008">1008</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, and <a class="el" href="RewriteObjCFoundationAPI_8cpp_source.html#l00682">getLiteralInfo()</a>.</p>

</div>
</div>
<a id="af3c2ce2d42eb22f44382ea0f139a45b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c2ce2d42eb22f44382ea0f139a45b4">&#9670;&nbsp;</a></span>hasAncestor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasAncestorMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt; &gt; clang::ast_matchers::hasAncestor = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have an ancestor that matches the provided matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { <span class="keywordflow">if</span> (<span class="keyword">true</span>) { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 42; } }</div>
<div class="line"><span class="keywordtype">void</span> g() { <span class="keywordflow">for</span> (;;) { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 43; } }</div>
</div><!-- fragment --><p> <code>expr</code>(integerLiteral(hasAncestor(ifStmt()))) matches <code>42</code>, but not 43.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01024">1024</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l06406">AST_MATCHER_FUNCTION()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00174">checkTempObjectsInNoPool()</a>, and <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00155">checkTempObjectsInSamePool()</a>.</p>

</div>
</div>
<a id="a75176e564329aea08a65d667d019d9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75176e564329aea08a65d667d019d9f8">&#9670;&nbsp;</a></span>hasAnyName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#afaf7bb46aec8e879467a959bcb38fefe">internal::hasAnyNameFunc</a> &gt; clang::ast_matchers::hasAnyName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <a class="el" href="classclang_1_1NamedDecl.html" title="This represents a decl that may have a name.">NamedDecl</a> nodes that have any of the specified names. </p>
<p>This matcher is only provided as a performance optimization of hasName. </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#a75176e564329aea08a65d667d019d9f8">hasAnyName</a>(a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>, <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>)</div>
</div><!-- fragment --><p> is equivalent to, but faster than </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ae56a1974283c9a2cb2410008e32fe3f1">anyOf</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(a), <a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>), <a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>))</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00997">997</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTSrcLocProcessor_8cpp_source.html#l00019">clang::tooling::ASTSrcLocProcessor::ASTSrcLocProcessor()</a>, <a class="el" href="ObjCAutoreleaseWriteChecker_8cpp_source.html#l00105">callsNames()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, and <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>.</p>

</div>
</div>
<a id="ae7072ab53ba2443d644a2a478f1d5280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7072ab53ba2443d644a2a478f1d5280">&#9670;&nbsp;</a></span>hasAnyOperatorName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::HasOpNameMatcher, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#aa6c82af4b9087769a26b4e80ff53d5e0">internal::hasAnyOperatorNameFunc</a> &gt; clang::ast_matchers::hasAnyOperatorName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches operator expressions (binary or unary) that have any of the specified names. </p>
<p>hasAnyOperatorName("+", "-") Is equivalent to anyOf(hasOperatorName("+"), hasOperatorName("-")) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01001">1001</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4baa5862611b82aa132a5ab534b63e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa5862611b82aa132a5ab534b63e9b">&#9670;&nbsp;</a></span>hasAnyOverloadedOperatorName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::HasOverloadOpNameMatcher, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#a1e5b2642d58cd1ce19c81f4c4335fc80">internal::hasAnyOverloadedOperatorNameFunc</a> &gt; clang::ast_matchers::hasAnyOverloadedOperatorName = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches overloaded operator names. </p>
<p>Matches overloaded operator names specified in strings without the "operator" prefix: e.g. "&lt;&lt;".</p>
<p>hasAnyOverloadedOperatorName("+", "-") Is equivalent to anyOf(hasOverloadedOperatorName("+"), hasOverloadedOperatorName("-")) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01004">1004</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6568b14e2ddad80f141bc0f81958f12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6568b14e2ddad80f141bc0f81958f12b">&#9670;&nbsp;</a></span>hasAnySelector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicFunction&lt; internal::Matcher&lt; <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt;, StringRef, <a class="el" href="namespaceclang_1_1ast__matchers_1_1internal.html#ab36710df5527233f1d4ea5ac9e78a7b9">internal::hasAnySelectorFunc</a> &gt; clang::ast_matchers::hasAnySelector = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches when at least one of the supplied string equals to the <a class="el" href="classclang_1_1Selector.html#a4fc5593940af968fa1187c3cb6a8ef8b" title="Derive the full selector name (e.g.">Selector.getAsString()</a> </p>
<p>matcher = objCMessageExpr(hasSelector("methodA:", "methodB:")); matches both of the expressions below: </p><div class="fragment"><div class="line">[myObj methodA:argA];</div>
<div class="line">[myObj methodB:argB];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01007">1007</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2b133847db656cf51934b25cde311b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b133847db656cf51934b25cde311b8e">&#9670;&nbsp;</a></span>hasDescendant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasDescendantMatcher &gt; clang::ast_matchers::hasDescendant = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have descendant AST nodes that match the provided matcher. </p>
<p>Example matches X, Y, Z (matcher = cxxRecordDecl(hasDescendant(cxxRecordDecl(hasName("X"))))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};  <span class="comment">// Matches X, because X::X is a class of name X inside X.</span></div>
<div class="line"><span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; };</div>
<div class="line"><span class="keyword">class </span>Z { <span class="keyword">class </span>Y { <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {}; }; };</div>
</div><!-- fragment --><p>DescendantT must be an AST base type.</p>
<p>Usable as: Any Matcher </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a54">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01010">1010</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00174">checkTempObjectsInNoPool()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00155">checkTempObjectsInSamePool()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, and <a class="el" href="BugReporterVisitors_8cpp_source.html#l00590">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="af5ae5090f4e722ad6ee2a8ae45d59223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ae5090f4e722ad6ee2a8ae45d59223">&#9670;&nbsp;</a></span>hasParent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasParentMatcher, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt;, internal::TypeList&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a>, <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1Attr.html">Attr</a> &gt; &gt; clang::ast_matchers::hasParent = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches AST nodes that have a parent that matches the provided matcher. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() { <span class="keywordflow">for</span> (;;) { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 42; <span class="keywordflow">if</span> (<span class="keyword">true</span>) { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 43; } } }</div>
</div><!-- fragment --><p> <code>compoundStmt</code>(hasParent(ifStmt())) matches "{ int x = 43; }".</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01019">1019</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>.</p>

</div>
</div>
<a id="af5cd72a6718872ac996d48de9a80bf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cd72a6718872ac996d48de9a80bf81">&#9670;&nbsp;</a></span>ifStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IfStmt.html">IfStmt</a> &gt; clang::ast_matchers::ifStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches if statements. </p>
<p>Example matches 'if (x) {}' </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00894">894</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="af7b21c26d322030721227bd877344452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b21c26d322030721227bd877344452">&#9670;&nbsp;</a></span>imaginaryLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImaginaryLiteral.html">ImaginaryLiteral</a> &gt; clang::ast_matchers::imaginaryLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches imaginary literals, which are based on integer and floating point literals e.g. </p>
<p>: 1i, 1.0i </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00925">925</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a28b1bdd70cca95686345d5a96d97071a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b1bdd70cca95686345d5a96d97071a">&#9670;&nbsp;</a></span>implicitCastExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitCastExpr.html">ImplicitCastExpr</a> &gt; clang::ast_matchers::implicitCastExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the implicit cast nodes of Clang's AST. </p>
<p>This matches many different places, including function call return value eliding, as well as any type conversions. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00974">974</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad3014baa2a35a9fa076ae72bcedd48ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3014baa2a35a9fa076ae72bcedd48ad">&#9670;&nbsp;</a></span>implicitValueInitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ImplicitValueInitExpr.html">ImplicitValueInitExpr</a> &gt; clang::ast_matchers::implicitValueInitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches implicit initializers of init list expressions. </p>
<p>Given </p><div class="fragment"><div class="line">point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ad3014baa2a35a9fa076ae72bcedd48ad" title="Matches implicit initializers of init list expressions.">implicitValueInitExpr()</a> matches "[0].y" (implicitly) </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00853">853</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae0ce6e0c98327394eeecc992d9d1715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ce6e0c98327394eeecc992d9d1715e">&#9670;&nbsp;</a></span>incompleteArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1IncompleteArrayType.html">IncompleteArrayType</a> &gt; clang::ast_matchers::incompleteArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C arrays with unspecified size. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[] = { 2, 3 };</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[42];</div>
<div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[]) { <span class="keywordtype">int</span> d[a[0]]; };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ae0ce6e0c98327394eeecc992d9d1715e" title="Matches C arrays with unspecified size.">incompleteArrayType()</a> matches "int a[]" and "int c[]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01040">1040</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aeb255b80ce8ca025df9e3d52ddbcfe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb255b80ce8ca025df9e3d52ddbcfe9e">&#9670;&nbsp;</a></span>indirectFieldDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1IndirectFieldDecl.html">IndirectFieldDecl</a> &gt; clang::ast_matchers::indirectFieldDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches indirect field declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keyword">struct </span>{ <span class="keywordtype">int</span> a; }; };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aeb255b80ce8ca025df9e3d52ddbcfe9e" title="Matches indirect field declarations.">indirectFieldDecl()</a> matches 'a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00805">805</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8514475a0724042d82b5323d5a7710f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8514475a0724042d82b5323d5a7710f6">&#9670;&nbsp;</a></span>initListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1InitListExpr.html">InitListExpr</a> &gt; clang::ast_matchers::initListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches init list expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a[] = { 1, 2 };</div>
<div class="line"><span class="keyword">struct </span>B { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>, y; };</div>
<div class="line">B <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = { 5, 6 };</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a8514475a0724042d82b5323d5a7710f6" title="Matches init list expressions.">initListExpr()</a> matches "{ 1, 2 }" and "{ 5, 6 }" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00849">849</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>.</p>

</div>
</div>
<a id="a7ed6218432518ee468d2fae74289a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed6218432518ee468d2fae74289a1b2">&#9670;&nbsp;</a></span>injectedClassNameType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1InjectedClassNameType.html">InjectedClassNameType</a> &gt; clang::ast_matchers::injectedClassNameType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches injected class name types. </p>
<p>Example matches S s, but not S&lt;T&gt; s. (matcher = parmVarDecl(hasType(injectedClassNameType()))) </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keywordtype">void</span> f(S <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>);</div>
<div class="line">  <span class="keywordtype">void</span> g(S&lt;T&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>);</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01065">1065</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad2109e16a4a151dc8f6416a66a750eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2109e16a4a151dc8f6416a66a750eac">&#9670;&nbsp;</a></span>integerLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1IntegerLiteral.html">IntegerLiteral</a> &gt; clang::ast_matchers::integerLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches integer literals of all sizes / encodings, e.g. </p>
<p>1, 1L, 0x1 and 1<a class="el" href="classU.html">U</a>.</p>
<p>Does not match character-encoded integers such as L'a'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00923">923</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="abb82889579b3228e5741598746e94b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb82889579b3228e5741598746e94b31">&#9670;&nbsp;</a></span>invocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::MapAnyOfMatcher&lt; <a class="el" href="classclang_1_1CallExpr.html">CallExpr</a>, <a class="el" href="classclang_1_1CXXConstructExpr.html">CXXConstructExpr</a> &gt; clang::ast_matchers::invocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches function calls and constructor calls. </p>
<p>Because <a class="el" href="classclang_1_1CallExpr.html" title="CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).">CallExpr</a> and <a class="el" href="classclang_1_1CXXConstructExpr.html" title="Represents a call to a C++ constructor.">CXXConstructExpr</a> do not share a common base class with API accessing arguments etc, AST Matchers for code which should match both are typically duplicated. This matcher removes the need for duplication.</p>
<p>Given code </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ConstructorTakesInt</div>
<div class="line">{</div>
<div class="line">  ConstructorTakesInt(<span class="keywordtype">int</span> i) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> callTakesInt(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> doCall()</div>
<div class="line">{</div>
<div class="line">  callTakesInt(42);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> doConstruct()</div>
<div class="line">{</div>
<div class="line">  ConstructorTakesInt cti(42);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The matcher </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#abb82889579b3228e5741598746e94b31">invocation</a>(hasArgument(0, <a class="code" href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">integerLiteral</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">equals</a>(42))))</div>
</div><!-- fragment --><p> matches the expression in both doCall and doConstruct </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00951">951</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6f0e34720bac0bffb62007c39c84ba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e34720bac0bffb62007c39c84ba58">&#9670;&nbsp;</a></span>labelDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LabelDecl.html">LabelDecl</a> &gt; clang::ast_matchers::labelDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of label. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a6f0e34720bac0bffb62007c39c84ba58" title="Matches a declaration of label.">labelDecl()</a> matches 'FOO:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00740">740</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="add73462f8d3fac6fc366163c4665447b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add73462f8d3fac6fc366163c4665447b">&#9670;&nbsp;</a></span>labelStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LabelStmt.html">LabelStmt</a> &gt; clang::ast_matchers::labelStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches label statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">goto</span> FOO;</div>
<div class="line">FOO: bar();</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#add73462f8d3fac6fc366163c4665447b" title="Matches label statements.">labelStmt()</a> matches 'FOO:' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00905">905</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab01242d6cc88506d489ed38978597292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01242d6cc88506d489ed38978597292">&#9670;&nbsp;</a></span>lambdaCapture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1LambdaCapture.html">LambdaCapture</a> &gt; clang::ast_matchers::lambdaCapture</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches lambda captures. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="ClangSrcLocDump_8cpp.html#a217dbf8b442f20279ea00b898af96f52">main</a>() {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">  <span class="keyword">auto</span> f = [<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>](){};</div>
<div class="line">  <span class="keyword">auto</span> g = [<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 1](){};</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the matcher <code>lambdaExpr(hasAnyCapture(lambdaCapture()))</code>, <code><a class="el" href="namespaceclang_1_1ast__matchers.html#ab01242d6cc88506d489ed38978597292" title="Matches lambda captures.">lambdaCapture()</a></code> matches <code>x</code> and <code>x=1</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00771">771</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a479809a0ad129df8390412a37ba54462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479809a0ad129df8390412a37ba54462">&#9670;&nbsp;</a></span>lambdaExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1LambdaExpr.html">LambdaExpr</a> &gt; clang::ast_matchers::lambdaExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches lambda expressions. </p>
<p>Example matches [&amp;](){return 5;} </p><div class="fragment"><div class="line">[&amp;](){<span class="keywordflow">return</span> 5;}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00818">818</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a7cf8474301563772fb4c854671e4f33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf8474301563772fb4c854671e4f33f">&#9670;&nbsp;</a></span>linkageSpecDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1LinkageSpecDecl.html">LinkageSpecDecl</a> &gt; clang::ast_matchers::linkageSpecDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a linkage specification. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a7cf8474301563772fb4c854671e4f33f" title="Matches a declaration of a linkage specification.">linkageSpecDecl()</a> matches "extern "C" {}" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00738">738</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="afd4571b67b57d8cb1499ddd796819306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4571b67b57d8cb1499ddd796819306">&#9670;&nbsp;</a></span>lValueReferenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1LValueReferenceType.html">LValueReferenceType</a> &gt; clang::ast_matchers::lValueReferenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches lvalue reference types. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;&amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 1;</div>
<div class="line"><span class="keyword">auto</span> &amp;d = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;e = <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;f = 2;</div>
<div class="line"><span class="keywordtype">int</span> g = 5;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#afd4571b67b57d8cb1499ddd796819306" title="Matches lvalue reference types.">lValueReferenceType()</a></code> matches the types of <code>b</code>, <code>d</code>, and <code>e</code>. <code>e</code> is matched since the type is deduced as int&amp; by reference collapsing rules. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01053">1053</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa051954c84b4df94040c842186dc7af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa051954c84b4df94040c842186dc7af7">&#9670;&nbsp;</a></span>materializeTemporaryExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MaterializeTemporaryExpr.html">MaterializeTemporaryExpr</a> &gt; clang::ast_matchers::materializeTemporaryExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nodes where temporaries are materialized. </p>
<p>Example: Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>T {<span class="keywordtype">void</span> func();};</div>
<div class="line">T f();</div>
<div class="line"><span class="keywordtype">void</span> g(T);</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#aa051954c84b4df94040c842186dc7af7" title="Matches nodes where temporaries are materialized.">materializeTemporaryExpr()</a> matches 'f()' in these statements </p><div class="fragment"><div class="line">T u(f());</div>
<div class="line">g(f());</div>
<div class="line">f().func();</div>
</div><!-- fragment --><p> but does not match </p><div class="fragment"><div class="line">f();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00877">877</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac11400493de87945dbc3c568ac8e4b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11400493de87945dbc3c568ac8e4b08">&#9670;&nbsp;</a></span>memberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1MemberExpr.html">MemberExpr</a> &gt; clang::ast_matchers::memberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span>Y {</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>() { this-&gt;<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(); Y y; y.x(); a; this-&gt;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>; <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">Y::b</a>; }</div>
<div class="line">  <span class="keywordtype">int</span> a; <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ac11400493de87945dbc3c568ac8e4b08" title="Matches member expressions.">memberExpr()</a> matches this-&gt;x, x, y.x, a, this-&gt;b </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00812">812</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="add0cfc47879f5df22623bd4ca7680c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0cfc47879f5df22623bd4ca7680c7e">&#9670;&nbsp;</a></span>memberPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1MemberPointerType.html">MemberPointerType</a> &gt; clang::ast_matchers::memberPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches member pointer types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keywordtype">int</span> i; }</div>
<div class="line">A::* ptr = A::i;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#add0cfc47879f5df22623bd4ca7680c7e" title="Matches member pointer types.">memberPointerType()</a> matches "A::* ptr" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01049">1049</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a58f643ef24ff21b9fcedf8bca5c56a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f643ef24ff21b9fcedf8bca5c56a66">&#9670;&nbsp;</a></span>namedDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamedDecl.html">NamedDecl</a> &gt; clang::ast_matchers::namedDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of anything that could have a name. </p>
<p>Example matches <code>X</code>, <code>S</code>, the anonymous union type, <code>i</code>, and <code><a class="el" href="classU.html">U</a></code>; </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keyword">union </span>{</div>
<div class="line">    <span class="keywordtype">int</span> i;</div>
<div class="line">  } <a class="code" href="classU.html">U</a>;</div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00739">739</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTSrcLocProcessor_8cpp_source.html#l00019">clang::tooling::ASTSrcLocProcessor::ASTSrcLocProcessor()</a>.</p>

</div>
</div>
<a id="ab75d519da08b712a2dbc687eb84bfafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75d519da08b712a2dbc687eb84bfafd">&#9670;&nbsp;</a></span>namespaceAliasDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceAliasDecl.html">NamespaceAliasDecl</a> &gt; clang::ast_matchers::namespaceAliasDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a namespace alias. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>test {}</div>
<div class="line"><span class="keyword">namespace </span>alias = ::test;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab75d519da08b712a2dbc687eb84bfafd" title="Matches a declaration of a namespace alias.">namespaceAliasDecl()</a> matches "namespace alias" but not "namespace test" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00743">743</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ad499907435f5547a1f44215dd65c00a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad499907435f5547a1f44215dd65c00a2">&#9670;&nbsp;</a></span>namespaceDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NamespaceDecl.html">NamespaceDecl</a> &gt; clang::ast_matchers::namespaceDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a declaration of a namespace. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{}</div>
<div class="line"><span class="keyword">namespace </span>test {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ad499907435f5547a1f44215dd65c00a2" title="Matches a declaration of a namespace.">namespaceDecl()</a> matches "namespace {}" and "namespace test {}" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00741">741</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a33d403e158636a01ed2f43b87029f7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d403e158636a01ed2f43b87029f7cc">&#9670;&nbsp;</a></span>nestedNameSpecifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifier.html">NestedNameSpecifier</a> &gt; clang::ast_matchers::nestedNameSpecifier</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches nested name specifiers. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>ns {</div>
<div class="line">  <span class="keyword">struct </span>A { <span class="keyword">static</span> <span class="keywordtype">void</span> f(); };</div>
<div class="line">  <span class="keywordtype">void</span> A::f() {}</div>
<div class="line">  <span class="keywordtype">void</span> g() { A::f(); }</div>
<div class="line">}</div>
<div class="line">ns::A a;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a33d403e158636a01ed2f43b87029f7cc" title="Matches nested name specifiers.">nestedNameSpecifier()</a> matches "ns::" and both "A::" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01027">1027</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a58010de6c771b8d3deea3f55c1a208f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58010de6c771b8d3deea3f55c1a208f7">&#9670;&nbsp;</a></span>nestedNameSpecifierLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1NestedNameSpecifierLoc.html">NestedNameSpecifierLoc</a> &gt; clang::ast_matchers::nestedNameSpecifierLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>nestedNameSpecifier</code> but matches <code><a class="el" href="classclang_1_1NestedNameSpecifierLoc.html" title="A C++ nested-name-specifier augmented with source location information.">NestedNameSpecifierLoc</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01029">1029</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4c54a7bb3aa3ae9d1fdca749e1da10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c54a7bb3aa3ae9d1fdca749e1da10c6">&#9670;&nbsp;</a></span>nonTypeTemplateParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1NonTypeTemplateParmDecl.html">NonTypeTemplateParmDecl</a> &gt; clang::ast_matchers::nonTypeTemplateParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches non-type template parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a4c54a7bb3aa3ae9d1fdca749e1da10c6" title="Matches non-type template parameter declarations.">nonTypeTemplateParmDecl()</a> matches 'N', but not 'T'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00765">765</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4e85f3028bc3d2d590878c3587d43f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e85f3028bc3d2d590878c3587d43f5c">&#9670;&nbsp;</a></span>nullStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1NullStmt.html">NullStmt</a> &gt; clang::ast_matchers::nullStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches null statements. </p>
<div class="fragment"><div class="line">foo();;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a4e85f3028bc3d2d590878c3587d43f5c" title="Matches null statements.">nullStmt()</a> matches the second ';' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00915">915</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a928d07f25f82fdf52ca6b480e0aca4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928d07f25f82fdf52ca6b480e0aca4d5">&#9670;&nbsp;</a></span>objcCatchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtCatchStmt.html">ObjCAtCatchStmt</a> &gt; clang::ast_matchers::objcCatchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @catch statements. </p>
<p>Example matches @catch </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@catch</span> (...) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00844">844</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a64d992911b288aaba2ba96ecc5e1e33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d992911b288aaba2ba96ecc5e1e33c">&#9670;&nbsp;</a></span>objcCategoryDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryDecl.html">ObjCCategoryDecl</a> &gt; clang::ast_matchers::objcCategoryDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C category declarations. </p>
<p>Example matches Foo (Additions) </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo (Additions)</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00830">830</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a9a8d9b5d54b3ed41d0b2d03e776af90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d9b5d54b3ed41d0b2d03e776af90e">&#9670;&nbsp;</a></span>objcCategoryImplDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCCategoryImplDecl.html">ObjCCategoryImplDecl</a> &gt; clang::ast_matchers::objcCategoryImplDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C category definitions. </p>
<p>Example matches Foo (Additions) </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo (Additions)</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00832">832</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2d463a0af3ae121edc9b41d14c0706a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d463a0af3ae121edc9b41d14c0706a7">&#9670;&nbsp;</a></span>objcFinallyStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtFinallyStmt.html">ObjCAtFinallyStmt</a> &gt; clang::ast_matchers::objcFinallyStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @finally statements. </p>
<p>Example matches @finally </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@finally</span> {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00846">846</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="acd07286ab423090b73a60717e8ccf5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd07286ab423090b73a60717e8ccf5a7">&#9670;&nbsp;</a></span>objcImplementationDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCImplementationDecl.html">ObjCImplementationDecl</a> &gt; clang::ast_matchers::objcImplementationDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C implementation declarations. </p>
<p>Example matches Foo </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00826">826</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab10a69694c50b6e017fbe02072e7115e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10a69694c50b6e017fbe02072e7115e">&#9670;&nbsp;</a></span>objcInterfaceDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCInterfaceDecl.html">ObjCInterfaceDecl</a> &gt; clang::ast_matchers::objcInterfaceDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C interface declarations. </p>
<p>Example matches Foo </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00824">824</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a10b9991e6e90b4ca132af940b11b4339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b9991e6e90b4ca132af940b11b4339">&#9670;&nbsp;</a></span>objcIvarDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCIvarDecl.html">ObjCIvarDecl</a> &gt; clang::ast_matchers::objcIvarDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C instance variable declarations. </p>
<p>Example matches _enabled </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>Foo {</div>
<div class="line">  BOOL _enabled;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00837">837</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1691aa67fc4125c0978aa73995001aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1691aa67fc4125c0978aa73995001aa8">&#9670;&nbsp;</a></span>objcIvarRefExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCIvarRefExpr.html">ObjCIvarRefExpr</a> &gt; clang::ast_matchers::objcIvarRefExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a reference to an ObjCIvar. </p>
<p>Example: matches "a" in "init" method: </p><div class="fragment"><div class="line"><span class="keyword">@implementation </span>A {</div>
<div class="line">  NSString *a;</div>
<div class="line">}</div>
<div class="line">- (void) init {</div>
<div class="line">  a = <span class="stringliteral">@&quot;hello&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00892">892</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BugReporterVisitors_8cpp_source.html#l00590">potentiallyWritesIntoIvar()</a>.</p>

</div>
</div>
<a id="a76e430a6b71305865cc46c57a9465c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e430a6b71305865cc46c57a9465c84">&#9670;&nbsp;</a></span>objcMessageExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCMessageExpr.html">ObjCMessageExpr</a> &gt; clang::ast_matchers::objcMessageExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches ObjectiveC Message invocation expressions. </p>
<p>The innermost message send invokes the "alloc" class method on the NSString class, while the outermost message send invokes the "initWithString" instance method on the object returned from NSString's "alloc". This matcher should match both message sends. </p><div class="fragment"><div class="line">[[NSString alloc] initWithString:<span class="stringliteral">@&quot;Hello&quot;</span>]</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00822">822</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00147">getOtherMessageSentM()</a>, and <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00131">getRunLoopRunM()</a>.</p>

</div>
</div>
<a id="a3a90eb6eeec44cfb79ef98129ad90ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a90eb6eeec44cfb79ef98129ad90ec1">&#9670;&nbsp;</a></span>objcMethodDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCMethodDecl.html">ObjCMethodDecl</a> &gt; clang::ast_matchers::objcMethodDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C method declarations. </p>
<p>Example matches both declaration and definition of -[Foo method] </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line">- (void)method;</div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">@implementation </span>Foo</div>
<div class="line">- (void)method {}</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00834">834</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a161e81bed81f9401f7ea8e89de381a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161e81bed81f9401f7ea8e89de381a50">&#9670;&nbsp;</a></span>objcObjectPointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ObjCObjectPointerType.html">ObjCObjectPointerType</a> &gt; clang::ast_matchers::objcObjectPointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches an Objective-C object pointer type, which is different from a pointer type, despite being syntactically similar. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line">Foo *f;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765" title="Matches pointer types, but does not match Objective-C object pointer types.">pointerType()</a> matches "Foo *f", but does not match "int *a". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01051">1051</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2bfb6ad7b935550af24feaa79d757eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfb6ad7b935550af24feaa79d757eca">&#9670;&nbsp;</a></span>objcPropertyDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCPropertyDecl.html">ObjCPropertyDecl</a> &gt; clang::ast_matchers::objcPropertyDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C property declarations. </p>
<p>Example matches enabled </p><div class="fragment"><div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@property</span> BOOL enabled;</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00839">839</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a27b140b9aeec980b173418f5b4490c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b140b9aeec980b173418f5b4490c8e">&#9670;&nbsp;</a></span>objcProtocolDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ObjCProtocolDecl.html">ObjCProtocolDecl</a> &gt; clang::ast_matchers::objcProtocolDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C protocol declarations. </p>
<p>Example matches FooDelegate </p><div class="fragment"><div class="line"><span class="keyword">@protocol </span>FooDelegate</div>
<div class="line"><span class="keyword">@end</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00828">828</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abb294df9fab76f0f4677ccc500d94f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb294df9fab76f0f4677ccc500d94f26">&#9670;&nbsp;</a></span>objcThrowStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtThrowStmt.html">ObjCAtThrowStmt</a> &gt; clang::ast_matchers::objcThrowStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @throw statements. </p>
<p>Example matches @throw </p><div class="fragment"><div class="line"><span class="keyword">@throw</span> obj;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00841">841</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa54c79304345729b9a3b5f1abf9dc5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c79304345729b9a3b5f1abf9dc5a8">&#9670;&nbsp;</a></span>objcTryStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ObjCAtTryStmt.html">ObjCAtTryStmt</a> &gt; clang::ast_matchers::objcTryStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches Objective-C @try statements. </p>
<p>Example matches @try </p><div class="fragment"><div class="line"><span class="keywordflow">@try</span> {}</div>
<div class="line"><span class="keywordflow">@catch</span> (...) {}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00842">842</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a7936cb99a469a161f6ad457bda882628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7936cb99a469a161f6ad457bda882628">&#9670;&nbsp;</a></span>ompDefaultClause</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1OMPClause.html">OMPClause</a>, <a class="el" href="classclang_1_1OMPDefaultClause.html">OMPDefaultClause</a> &gt; clang::ast_matchers::ompDefaultClause</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches OpenMP <code>default</code> clause. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(shared)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(firstprivate)</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#a7936cb99a469a161f6ad457bda882628" title="Matches OpenMP default clause.">ompDefaultClause()</a></code> matches <code>default(none)</code>, <code>default(shared)</code>, and <code>default(firstprivate)</code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01080">1080</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a38a4fde56ab996048a27733bdbe3f80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a4fde56ab996048a27733bdbe3f80f">&#9670;&nbsp;</a></span>ompExecutableDirective</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OMPExecutableDirective.html">OMPExecutableDirective</a> &gt; clang::ast_matchers::ompExecutableDirective</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any <code>#pragma omp</code> executable directive. </p>
<p>Given</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line"><span class="preprocessor">#pragma omp parallel default(none)</span></div>
<div class="line"><span class="preprocessor">#pragma omp taskyield</span></div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#a38a4fde56ab996048a27733bdbe3f80f" title="Matches any #pragma omp executable directive.">ompExecutableDirective()</a></code> matches <code>omp parallel</code>, <code>omp parallel default(none)</code> and <code>omp taskyield</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01078">1078</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ae7160bb2f02400b2152dc7e0b10d763a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7160bb2f02400b2152dc7e0b10d763a">&#9670;&nbsp;</a></span>opaqueValueExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1OpaqueValueExpr.html">OpaqueValueExpr</a> &gt; clang::ast_matchers::opaqueValueExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches opaque value expressions. </p>
<p>They are used as helpers to reference another expressions and can be met in BinaryConditionalOperators, for example.</p>
<p>Example matches 'a' </p><div class="fragment"><div class="line">(a ?: <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>) + 42;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00958">958</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2a07934509f8d264c16974bbe0c15ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a07934509f8d264c16974bbe0c15ac7">&#9670;&nbsp;</a></span>optionally</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; clang::ast_matchers::optionally</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    internal::DynTypedMatcher::VO_Optionally}</div>
</div><!-- fragment -->
<p>Matches any node regardless of the submatcher. </p>
<p>However, <code>optionally</code> will retain any bindings generated by the submatcher. Useful when additional information which may or may not present about a main matching node is desired.</p>
<p>For example, in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo {</div>
<div class="line">  <span class="keywordtype">int</span> bar;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The matcher: </p><div class="fragment"><div class="line"><a class="code" href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">cxxRecordDecl</a>(</div>
<div class="line">  <a class="code" href="namespaceclang_1_1ast__matchers.html#a2a07934509f8d264c16974bbe0c15ac7">optionally</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">has</a>(</div>
<div class="line">    <a class="code" href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">fieldDecl</a>(<a class="code" href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">hasName</a>(<span class="stringliteral">&quot;bar&quot;</span>)).bind(<span class="stringliteral">&quot;var&quot;</span>)</div>
<div class="line">))).bind(<span class="stringliteral">&quot;record&quot;</span>)</div>
</div><!-- fragment --><p> will produce a result binding for both "record" and "var". The matcher will produce a "record" binding for even if there is no data member named "bar" in that class.</p>
<p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00993">993</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ASTSrcLocProcessor_8cpp_source.html#l00019">clang::tooling::ASTSrcLocProcessor::ASTSrcLocProcessor()</a>.</p>

</div>
</div>
<a id="a97ef12437e36922d96bea2cb8f762b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ef12437e36922d96bea2cb8f762b9a">&#9670;&nbsp;</a></span>parenExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenExpr.html">ParenExpr</a> &gt; clang::ast_matchers::parenExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches parentheses used in expressions. </p>
<p>Example matches (foo() + 1) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> foo() { <span class="keywordflow">return</span> 1; }</div>
<div class="line"><span class="keywordtype">int</span> a = (foo() + 1);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00868">868</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a6137ba1734e9c2499cefdac0ad7474de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6137ba1734e9c2499cefdac0ad7474de">&#9670;&nbsp;</a></span>parenListExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a> &gt; clang::ast_matchers::parenListExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches paren list expressions. </p>
<p>ParenListExprs don't have a predefined type and are used for late parsing. In the final AST, they can be met in template declarations.</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  <span class="keywordtype">void</span> f() {</div>
<div class="line">    <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>(*<span class="keyword">this</span>);</div>
<div class="line">    <span class="keywordtype">int</span> a = 0, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = 1; <span class="keywordtype">int</span> i = (a, <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a6137ba1734e9c2499cefdac0ad7474de" title="Matches paren list expressions.">parenListExpr()</a> matches "*this" but NOT matches (a, b) because (a, b) has a predefined type and is a <a class="el" href="classclang_1_1ParenExpr.html" title="ParenExpr - This represents a parethesized expression, e.g.">ParenExpr</a>, not a <a class="el" href="classclang_1_1ParenListExpr.html">ParenListExpr</a>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00854">854</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a68ff863eb011e066031ce6b86a11da65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ff863eb011e066031ce6b86a11da65">&#9670;&nbsp;</a></span>parenType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ParenType.html">ParenType</a> &gt; clang::ast_matchers::parenType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1ParenType.html" title="Sugar for parentheses used when specifying types.">ParenType</a></code> nodes. </p>
<p>Given </p><div class="fragment"><div class="line"><a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a> (*ptr_to_array)[4];</div>
<div class="line"><span class="keywordtype">int</span> *array_of_ptrs[4];</div>
</div><!-- fragment --><p><code>varDecl</code>(hasType(pointsTo(parenType()))) matches <code>ptr_to_array</code> but not <code>array_of_ptrs</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01047">1047</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3b7539a5a5ad3112f453ffb3ab9a67c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7539a5a5ad3112f453ffb3ab9a67c5">&#9670;&nbsp;</a></span>parmVarDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ParmVarDecl.html">ParmVarDecl</a> &gt; clang::ast_matchers::parmVarDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches parameter variable declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f(<span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>);</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a3b7539a5a5ad3112f453ffb3ab9a67c5" title="Matches parameter variable declarations.">parmVarDecl()</a> matches <code>int</code> x. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00756">756</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>.</p>

</div>
</div>
<a id="a34b0467fd444a7daa8a8aa79ec045765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b0467fd444a7daa8a8aa79ec045765">&#9670;&nbsp;</a></span>pointerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1PointerType.html">PointerType</a> &gt; clang::ast_matchers::pointerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches pointer types, but does not match Objective-C object pointer types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = *a;</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 5;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">@interface </span>Foo</div>
<div class="line"><span class="keyword">@end</span></div>
<div class="line">Foo *f;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765" title="Matches pointer types, but does not match Objective-C object pointer types.">pointerType()</a> matches "int *a", but does not match "Foo *f". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01050">1050</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaStmt_8cpp_source.html#l04276">clang::Sema::ActOnObjCAtSynchronizedOperand()</a>, <a class="el" href="ASTMatchers_8h_source.html#l07816">AST_MATCHER_FUNCTION()</a>, <a class="el" href="SemaChecking_8cpp_source.html#l05768">clang::Sema::BuildAtomicExpr()</a>, <a class="el" href="SemaStmt_8cpp_source.html#l02199">clang::Sema::CheckObjCForCollectionOperand()</a>, <a class="el" href="CGExprScalar_8cpp_source.html#l03459">emitPointerArithmetic()</a>, and <a class="el" href="OSObjectCStyleCast_8cpp_source.html#l00076">hasTypePointingTo()</a>.</p>

</div>
</div>
<a id="a82053583c94237b11f14c38d58262e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82053583c94237b11f14c38d58262e69">&#9670;&nbsp;</a></span>pointerTypeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1PointerTypeLoc.html">PointerTypeLoc</a> &gt; clang::ast_matchers::pointerTypeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches pointer <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>* <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a82053583c94237b11f14c38d58262e69" title="Matches pointer TypeLocs.">pointerTypeLoc()</a> matches <code>int*</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00779">779</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a33b52666b405fc2bf1a28120d488488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b52666b405fc2bf1a28120d488488c">&#9670;&nbsp;</a></span>predefinedExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1PredefinedExpr.html">PredefinedExpr</a> &gt; clang::ast_matchers::predefinedExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches predefined identifier expressions [C99 6.4.2.2]. </p>
<p>Example: Matches <b>func</b> </p><div class="fragment"><div class="line"><a class="code" href="opencl-c-base_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a>(<span class="stringliteral">&quot;%s&quot;</span>, __func__);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00981">981</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a93e5eef17f07cfff020966a57173654c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e5eef17f07cfff020966a57173654c">&#9670;&nbsp;</a></span>qualifiedTypeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1QualifiedTypeLoc.html">QualifiedTypeLoc</a> &gt; clang::ast_matchers::qualifiedTypeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code><a class="el" href="classclang_1_1QualifiedTypeLoc.html" title="Wrapper of type source information for a type with non-trivial direct qualifiers.">QualifiedTypeLoc</a></code>s in the clang AST. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 0;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a93e5eef17f07cfff020966a57173654c" title="Matches QualifiedTypeLocs in the clang AST.">qualifiedTypeLoc()</a> matches <code>const int</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00777">777</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aefc28b8bf75f10413691d11b9c371116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc28b8bf75f10413691d11b9c371116">&#9670;&nbsp;</a></span>qualType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1QualType.html">QualType</a> &gt; clang::ast_matchers::qualType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>QualTypes</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00772">772</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>.</p>

</div>
</div>
<a id="ace97e34c0eac8c61ce7fe928633657c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97e34c0eac8c61ce7fe928633657c9">&#9670;&nbsp;</a></span>recordDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1RecordDecl.html">RecordDecl</a> &gt; clang::ast_matchers::recordDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches class, struct, and union declarations. </p>
<p>Example matches <code>X</code>, <code>Z</code>, <code><a class="el" href="classU.html">U</a></code>, and <code>S</code> </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
<div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00744">744</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AbstractBasicReader_8h_source.html#l00191">clang::serialization::DataStreamBasicReader&lt; ASTRecordReader &gt;::readLValuePathSerializationHelper()</a>, and <a class="el" href="AbstractBasicWriter_8h_source.html#l00175">clang::serialization::DataStreamBasicWriter&lt; ASTRecordWriter &gt;::writeLValuePathSerializationHelper()</a>.</p>

</div>
</div>
<a id="abf2f0de9c9e156981b881b8d5d89aec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2f0de9c9e156981b881b8d5d89aec6">&#9670;&nbsp;</a></span>recordType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1RecordType.html">RecordType</a> &gt; clang::ast_matchers::recordType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches record types (e.g. </p>
<p>structs, classes).</p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line">S <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#abf2f0de9c9e156981b881b8d5d89aec6" title="Matches record types (e.g.">recordType()</a></code> matches the type of the variable declarations of both <code>c</code> and <code>s</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01059">1059</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SwiftCallingConv_8cpp_source.html#l00815">classifyType()</a>, <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>, and <a class="el" href="CGBlocks_8cpp_source.html#l00438">isSafeForCXXConstantCapture()</a>.</p>

</div>
</div>
<a id="ac599b04c233b9d56cb646d22d9440f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac599b04c233b9d56cb646d22d9440f68">&#9670;&nbsp;</a></span>referenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1ReferenceType.html">ReferenceType</a> &gt; clang::ast_matchers::referenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches both lvalue and rvalue reference types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;&amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 1;</div>
<div class="line"><span class="keyword">auto</span> &amp;d = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;e = <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;f = 2;</div>
<div class="line"><span class="keywordtype">int</span> g = 5;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#ac599b04c233b9d56cb646d22d9440f68" title="Matches both lvalue and rvalue reference types.">referenceType()</a></code> matches the types of <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, and <code>f</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01052">1052</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>.</p>

</div>
</div>
<a id="a739478b8ffe02ebfd1a48be839ae440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739478b8ffe02ebfd1a48be839ae440d">&#9670;&nbsp;</a></span>referenceTypeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1ReferenceTypeLoc.html">ReferenceTypeLoc</a> &gt; clang::ast_matchers::referenceTypeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches reference <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = 3;</div>
<div class="line"><span class="keywordtype">int</span>&amp; l = <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line"><span class="keywordtype">int</span>&amp;&amp; r = 3;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a739478b8ffe02ebfd1a48be839ae440d" title="Matches reference TypeLocs.">referenceTypeLoc()</a> matches <code>int&amp;</code> and <code>int&amp;&amp;</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00781">781</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a42e8f0ff0127b0536c53a76dbf5f28a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e8f0ff0127b0536c53a76dbf5f28a7">&#9670;&nbsp;</a></span>returnStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1ReturnStmt.html">ReturnStmt</a> &gt; clang::ast_matchers::returnStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches return statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> 1;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a42e8f0ff0127b0536c53a76dbf5f28a7" title="Matches return statements.">returnStmt()</a> matches 'return 1' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00903">903</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>.</p>

</div>
</div>
<a id="af7b6bc736027364037dec0b5f9d574a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b6bc736027364037dec0b5f9d574a3">&#9670;&nbsp;</a></span>rValueReferenceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1RValueReferenceType.html">RValueReferenceType</a> &gt; clang::ast_matchers::rValueReferenceType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches rvalue reference types. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a> = *a;</div>
<div class="line"><span class="keywordtype">int</span> &amp;&amp;<a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a> = 1;</div>
<div class="line"><span class="keyword">auto</span> &amp;d = <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;e = <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
<div class="line"><span class="keyword">auto</span> &amp;&amp;f = 2;</div>
<div class="line"><span class="keywordtype">int</span> g = 5;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#af7b6bc736027364037dec0b5f9d574a3" title="Matches rvalue reference types.">rValueReferenceType()</a></code> matches the types of <code>c</code> and <code>f</code>. <code>e</code> is not matched as it is deduced to int&amp; by reference collapsing rules. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01054">1054</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a99ab1f66ff6c5a790900ae8f625e9a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ab1f66ff6c5a790900ae8f625e9a09">&#9670;&nbsp;</a></span>staticAssertDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1StaticAssertDecl.html">StaticAssertDecl</a> &gt; clang::ast_matchers::staticAssertDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches a C++ static_assert declaration. </p>
<p>Example: staticAssertExpr() matches static_assert(sizeof(S) == sizeof(int)) in </p><div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>;</div>
<div class="line">};</div>
<div class="line">static_assert(<span class="keyword">sizeof</span>(S) == <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00960">960</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ade2304887c9dd0e9fad2e0ff35320739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2304887c9dd0e9fad2e0ff35320739">&#9670;&nbsp;</a></span>stmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a> &gt; clang::ast_matchers::stmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statements. </p>
<p>Given </p><div class="fragment"><div class="line">{ ++a; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ade2304887c9dd0e9fad2e0ff35320739" title="Matches statements.">stmt()</a> matches both the compound statement '{ ++a; }' and '++a'. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a53">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00810">810</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="CFG_8h_source.html#l01258">clang::CFG::BuildOptions::alwaysAdd()</a>, <a class="el" href="ASTMatchers_8h_source.html#l06426">AST_MATCHER_FUNCTION()</a>, <a class="el" href="SValBuilder_8h_source.html#l00193">clang::ento::SValBuilder::conjureSymbol()</a>, <a class="el" href="SValBuilder_8cpp_source.html#l00182">clang::ento::SValBuilder::conjureSymbolVal()</a>, <a class="el" href="AnalysisDeclContext_8cpp_source.html#l00190">clang::AnalysisDeclContext::getBlockForRegisteredExpression()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>, <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>, <a class="el" href="BugReporterVisitors_8cpp_source.html#l00590">potentiallyWritesIntoIvar()</a>, and <a class="el" href="AnalysisDeclContext_8cpp_source.html#l00180">clang::AnalysisDeclContext::registerForcedBlockExpression()</a>.</p>

</div>
</div>
<a id="a07128394c216b2d373a8ee39956e7689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07128394c216b2d373a8ee39956e7689">&#9670;&nbsp;</a></span>stmtExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StmtExpr.html">StmtExpr</a> &gt; clang::ast_matchers::stmtExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches statement expression (GNU extension). </p>
<p>Example match: ({ int X = 4; X; }) </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> = ({ <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> = 4; <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>; });</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00945">945</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2c9fffe33e90bbb4b8f099caf377d7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9fffe33e90bbb4b8f099caf377d7b1">&#9670;&nbsp;</a></span>stringLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1StringLiteral.html">StringLiteral</a> &gt; clang::ast_matchers::stringLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches string literals (also matches wide string literals). </p>
<p>Example matches "abcd", L"abcd" </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> *<a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a> = <span class="stringliteral">&quot;abcd&quot;</span>;</div>
<div class="line"><span class="keywordtype">wchar_t</span> *ws = L<span class="stringliteral">&quot;abcd&quot;</span>;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00919">919</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af06b6e50f8eb6094020ec5bf89a746a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06b6e50f8eb6094020ec5bf89a746a4">&#9670;&nbsp;</a></span>substNonTypeTemplateParmExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SubstNonTypeTemplateParmExpr.html">SubstNonTypeTemplateParmExpr</a> &gt; clang::ast_matchers::substNonTypeTemplateParmExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches substitutions of non-type template parameters. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keyword">struct </span>A { <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n = N; };</div>
<div class="line"><span class="keyword">struct </span>B : <span class="keyword">public</span> A&lt;42&gt; {};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#af06b6e50f8eb6094020ec5bf89a746a4" title="Matches substitutions of non-type template parameters.">substNonTypeTemplateParmExpr()</a> matches "N" in the right-hand side of "static const int n = N;" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00856">856</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab8fe2d09e8930e40adf164af9377fc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fe2d09e8930e40adf164af9377fc44">&#9670;&nbsp;</a></span>substTemplateTypeParmType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1SubstTemplateTypeParmType.html">SubstTemplateTypeParmType</a> &gt; clang::ast_matchers::substTemplateTypeParmType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types that represent the result of substituting a type for a template type parameter. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> F(T t) {</div>
<div class="line">  <span class="keywordtype">int</span> i = 1 + t;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#ab8fe2d09e8930e40adf164af9377fc44" title="Matches types that represent the result of substituting a type for a template type parameter.">substTemplateTypeParmType()</a></code> matches the type of 't' but not '1' </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01063">1063</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab7abc89804682f83816d2323cdc718cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7abc89804682f83816d2323cdc718cf">&#9670;&nbsp;</a></span>switchCase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchCase.html">SwitchCase</a> &gt; clang::ast_matchers::switchCase</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches case and default statements inside switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab7abc89804682f83816d2323cdc718cf" title="Matches case and default statements inside switch statements.">switchCase()</a> matches 'case 42:' and 'default:'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00908">908</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="abf04346715336de0dfc10dac8ed114d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf04346715336de0dfc10dac8ed114d9">&#9670;&nbsp;</a></span>switchStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1SwitchStmt.html">SwitchStmt</a> &gt; clang::ast_matchers::switchStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches switch statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>(a) { <span class="keywordflow">case</span> 42: <span class="keywordflow">break</span>; <span class="keywordflow">default</span>: <span class="keywordflow">break</span>; }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#abf04346715336de0dfc10dac8ed114d9" title="Matches switch statements.">switchStmt()</a> matches 'switch(a)'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00907">907</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00130">clang::ento::hasSuspiciousStmt()</a>, and <a class="el" href="UninitializedObjectChecker_8cpp_source.html#l00525">hasUnguardedAccess()</a>.</p>

</div>
</div>
<a id="a036eda5d1a6e83d02a2479799aa1e0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036eda5d1a6e83d02a2479799aa1e0ad">&#9670;&nbsp;</a></span>tagDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TagDecl.html">TagDecl</a> &gt; clang::ast_matchers::tagDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches tag declarations. </p>
<p>Example matches X, Z, <a class="el" href="classU.html">U</a>, S, E </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Z {};</div>
<div class="line"><span class="keyword">struct </span>S {};</div>
<div class="line"><span class="keyword">union </span><a class="code" href="classU.html">U</a> {};</div>
<div class="line"><span class="keyword">enum</span> E {</div>
<div class="line">  A, B, <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a></div>
<div class="line">};</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00798">798</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aa3ff15545b1962675f3b54e94e136b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ff15545b1962675f3b54e94e136b72">&#9670;&nbsp;</a></span>tagType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TagType.html">TagType</a> &gt; clang::ast_matchers::tagType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches tag types (record and enum types). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">enum</span> E {};</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line"> </div>
<div class="line">E e;</div>
<div class="line"><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#aa3ff15545b1962675f3b54e94e136b72" title="Matches tag types (record and enum types).">tagType()</a></code> matches the type of the variable declarations of both <code>e</code> and <code>c</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01060">1060</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a56c848824461ac59d9a1c7e7aeea9ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c848824461ac59d9a1c7e7aeea9ec3">&#9670;&nbsp;</a></span>templateArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgument.html">TemplateArgument</a> &gt; clang::ast_matchers::templateArgument</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template arguments. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a56c848824461ac59d9a1c7e7aeea9ec3" title="Matches template arguments.">templateArgument()</a> matches 'int' in C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00761">761</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ac2354be35a4ff17fd80deade9753ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2354be35a4ff17fd80deade9753ea97">&#9670;&nbsp;</a></span>templateArgumentLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateArgumentLoc.html">TemplateArgumentLoc</a> &gt; clang::ast_matchers::templateArgumentLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template arguments (with location info). </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;int&gt; <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ac2354be35a4ff17fd80deade9753ea97" title="Matches template arguments (with location info).">templateArgumentLoc()</a> matches 'int' in C&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00762">762</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2244dfcab0601fe79666d8a4a9dde4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2244dfcab0601fe79666d8a4a9dde4b9">&#9670;&nbsp;</a></span>templateName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TemplateName.html">TemplateName</a> &gt; clang::ast_matchers::templateName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template name. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { };</div>
<div class="line">X&lt;int&gt; xi;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a2244dfcab0601fe79666d8a4a9dde4b9" title="Matches template name.">templateName()</a> matches 'X' in X&lt;int&gt;. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00763">763</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2fa868bfe1462fc934f1a64bad7d856d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa868bfe1462fc934f1a64bad7d856d">&#9670;&nbsp;</a></span>templateSpecializationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TemplateSpecializationType.html">TemplateSpecializationType</a> &gt; clang::ast_matchers::templateSpecializationType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template specialization types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> { };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span>C&lt;int&gt;;  <span class="comment">// A</span></div>
<div class="line">C&lt;char&gt; <a class="code" href="namespaceclang_1_1dataflow.html#aa858fe7ef413718673ced2de8af3b28a">var</a>;            <span class="comment">// B</span></div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#a2fa868bfe1462fc934f1a64bad7d856d" title="Matches template specialization types.">templateSpecializationType()</a></code> matches the type of the explicit instantiation in <code>A</code> and the type of the variable declaration in <code>B</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01057">1057</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a50c3729d0b5b87dee87ab24e7e8d3671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c3729d0b5b87dee87ab24e7e8d3671">&#9670;&nbsp;</a></span>templateSpecializationTypeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a>, <a class="el" href="classclang_1_1TemplateSpecializationTypeLoc.html">TemplateSpecializationTypeLoc</a> &gt; clang::ast_matchers::templateSpecializationTypeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template specialization <code><a class="el" href="classclang_1_1TypeLoc.html" title="Base wrapper for a particular &quot;section&quot; of type source info.">TypeLoc</a></code>s. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
<div class="line">C&lt;char&gt; <a class="code" href="namespaceclang_1_1dataflow.html#aa858fe7ef413718673ced2de8af3b28a">var</a>;</div>
</div><!-- fragment --><p> varDecl(hasTypeLoc(templateSpecializationTypeLoc(typeLoc()))) matches <code>C&lt;char&gt; var</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00784">784</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab193711230649b28f6fd61cde737bed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab193711230649b28f6fd61cde737bed5">&#9670;&nbsp;</a></span>templateTemplateParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTemplateParmDecl.html">TemplateTemplateParmDecl</a> &gt; clang::ast_matchers::templateTemplateParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template template parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class </span>Z, <span class="keywordtype">int</span> N&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a95a6a300dc0c5bbfdcdc2af001c316f6" title="Matches template type parameter declarations.">templateTypeParmDecl()</a> matches 'Z', but not 'N'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00769">769</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a95a6a300dc0c5bbfdcdc2af001c316f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a6a300dc0c5bbfdcdc2af001c316f6">&#9670;&nbsp;</a></span>templateTypeParmDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TemplateTypeParmDecl.html">TemplateTypeParmDecl</a> &gt; clang::ast_matchers::templateTypeParmDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template type parameter declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> N&gt; <span class="keyword">struct </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> {};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a95a6a300dc0c5bbfdcdc2af001c316f6" title="Matches template type parameter declarations.">templateTypeParmDecl()</a> matches 'T', but not 'N'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00767">767</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aaad61df8e618f0aad595f8cbdbc3f644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad61df8e618f0aad595f8cbdbc3f644">&#9670;&nbsp;</a></span>templateTypeParmType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TemplateTypeParmType.html">TemplateTypeParmType</a> &gt; clang::ast_matchers::templateTypeParmType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches template type parameter types. </p>
<p>Example matches T, but not int. (matcher = <a class="el" href="namespaceclang_1_1ast__matchers.html#aaad61df8e618f0aad595f8cbdbc3f644" title="Matches template type parameter types.">templateTypeParmType()</a>) </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> f(<span class="keywordtype">int</span> i);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01064">1064</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aaa73ed83faa263bfb5cface81d30ef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa73ed83faa263bfb5cface81d30ef91">&#9670;&nbsp;</a></span>translationUnitDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TranslationUnitDecl.html">TranslationUnitDecl</a> &gt; clang::ast_matchers::translationUnitDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches the top declaration context. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">namespace </span>NS {</div>
<div class="line"><span class="keywordtype">int</span> Y;</div>
<div class="line">}  <span class="comment">// namespace NS</span></div>
</div><!-- fragment --><p> decl(hasDeclContext(translationUnitDecl())) matches "int X", but not "int Y". </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00727">727</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a600679c157b5bd05c4bfb940fb2511dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600679c157b5bd05c4bfb940fb2511dd">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1Type.html">Type</a> &gt; clang::ast_matchers::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>Types</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00773">773</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SemaInit_8cpp_source.html#l03751">clang::InitializationSequence::AddPassByIndirectCopyRestoreStep()</a>, <a class="el" href="ASTContext_8cpp_source.html#l05311">clang::ASTContext::applyObjCProtocolQualifiers()</a>, <a class="el" href="SemaExpr_8cpp_source.html#l07662">breakDownVectorType()</a>, <a class="el" href="Transforms_8cpp_source.html#l00038">clang::arcmt::trans::canApplyWeak()</a>, <a class="el" href="Expr_8cpp_source.html#l04634">clang::PseudoObjectExpr::Create()</a>, <a class="el" href="CGDecl_8cpp_source.html#l02017">clang::CodeGen::CodeGenFunction::emitAutoVarTypeCleanup()</a>, <a class="el" href="Expr_8cpp_source.html#l02904">clang::Expr::findBoundMemberType()</a>, <a class="el" href="Type_8h_source.html#l07213">clang::Type::getBaseElementTypeUnsafe()</a>, <a class="el" href="SwiftCallingConv_8cpp_source.html#l00567">clang::CodeGen::swiftcall::SwiftAggLowering::getCoerceAndExpandTypes()</a>, <a class="el" href="CGExprConstant_8cpp_source.html#l01606">getNonMemoryType()</a>, <a class="el" href="Type_8h_source.html#l07220">clang::Type::getPointeeOrArrayElementType()</a>, <a class="el" href="ASTContext_8h_source.html#l02158">clang::ASTContext::getUnqualifiedObjCPointerType()</a>, <a class="el" href="ASTContext_8cpp_source.html#l03554">clang::ASTContext::getVariableArrayDecayedType()</a>, <a class="el" href="SourceCodeBuilders_8cpp_source.html#l00065">clang::tooling::isKnownPointerLikeType()</a>, <a class="el" href="SValBuilder_8h_source.html#l00366">clang::ento::SValBuilder::makeNullWithType()</a>, <a class="el" href="DiagnosticOptions_8h_source.html#l00060">clang::operator&amp;()</a>, <a class="el" href="DiagnosticOptions_8cpp_source.html#l00019">clang::operator&lt;&lt;()</a>, <a class="el" href="DiagnosticOptions_8h_source.html#l00053">clang::operator|()</a>, <a class="el" href="DiagnosticOptions_8h_source.html#l00048">clang::operator~()</a>, and <a class="el" href="APINotes_2Types_8h_source.html#l00325">clang::api_notes::VariableInfo::setType()</a>.</p>

</div>
</div>
<a id="a13f1d727044894974cd023ecdd58c879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f1d727044894974cd023ecdd58c879">&#9670;&nbsp;</a></span>typeAliasDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasDecl.html">TypeAliasDecl</a> &gt; clang::ast_matchers::typeAliasDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type alias declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">using</span> Y = <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a13f1d727044894974cd023ecdd58c879" title="Matches type alias declarations.">typeAliasDecl()</a> matches "using Y = int", but not "typedef int X" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00731">731</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a89576459aa43e2e320832d2221f6d405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89576459aa43e2e320832d2221f6d405">&#9670;&nbsp;</a></span>typeAliasTemplateDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypeAliasTemplateDecl.html">TypeAliasTemplateDecl</a> &gt; clang::ast_matchers::typeAliasTemplateDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches type alias template declarations. </p>
<p><a class="el" href="namespaceclang_1_1ast__matchers.html#a89576459aa43e2e320832d2221f6d405" title="Matches type alias template declarations.">typeAliasTemplateDecl()</a> matches </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> Y = X&lt;T&gt;;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00733">733</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a3c8a234965f6e7ef273e30c9b19fd778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8a234965f6e7ef273e30c9b19fd778">&#9670;&nbsp;</a></span>typedefDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefDecl.html">TypedefDecl</a> &gt; clang::ast_matchers::typedefDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches typedef declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">using</span> Y = <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a3c8a234965f6e7ef273e30c9b19fd778" title="Matches typedef declarations.">typedefDecl()</a> matches "typedef int X", but not "using Y = int" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00728">728</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a0e36abe1065caf311d087b0a24ce3b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e36abe1065caf311d087b0a24ce3b00">&#9670;&nbsp;</a></span>typedefNameDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1TypedefNameDecl.html">TypedefNameDecl</a> &gt; clang::ast_matchers::typedefNameDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches typedef name declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
<div class="line"><span class="keyword">using</span> Y = <a class="code" href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a0e36abe1065caf311d087b0a24ce3b00" title="Matches typedef name declarations.">typedefNameDecl()</a> matches "typedef int X" and "using Y = int" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00730">730</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a9f43dc5af55843306a50ec410c088d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43dc5af55843306a50ec410c088d6a">&#9670;&nbsp;</a></span>typedefType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1TypedefType.html">TypedefType</a> &gt; clang::ast_matchers::typedefType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches typedef types. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a9f43dc5af55843306a50ec410c088d6a" title="Matches typedef types.">typedefType()</a> matches "typedef int X" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01055">1055</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Type_8cpp_source.html#l04318">clang::Type::isObjCIndependentClassType()</a>, and <a class="el" href="Type_8cpp_source.html#l04305">clang::Type::isObjCNSObjectType()</a>.</p>

</div>
</div>
<a id="a605961d8a647c2ec766b2417552393a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605961d8a647c2ec766b2417552393a2">&#9670;&nbsp;</a></span>typeLoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicAllOfMatcher&lt; <a class="el" href="classclang_1_1TypeLoc.html">TypeLoc</a> &gt; clang::ast_matchers::typeLoc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches <code>TypeLocs</code> in the clang AST. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00774">774</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a4e6f1fbd69a5f3bd0b1f7c81f30ba547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f1fbd69a5f3bd0b1f7c81f30ba547">&#9670;&nbsp;</a></span>unaryExprOrTypeTraitExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryExprOrTypeTraitExpr.html">UnaryExprOrTypeTraitExpr</a> &gt; clang::ast_matchers::unaryExprOrTypeTraitExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL) </p>
<p>Given </p><div class="fragment"><div class="line">Foo <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> = bar;</div>
<div class="line"><span class="keywordtype">int</span> y = <span class="keyword">sizeof</span>(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>) + <span class="keyword">alignof</span>(<a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>);</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a4e6f1fbd69a5f3bd0b1f7c81f30ba547" title="Matches sizeof (C99), alignof (C++11) and vec_step (OpenCL)">unaryExprOrTypeTraitExpr()</a> matches <code>sizeof(x)</code> and <code><a class="el" href="stdalign_8h.html#abb241e4f00c28465643e1010172aef04">alignof(x)</a></code> </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00789">789</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a71ac1ea4304cca5a3d773782c45e3a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ac1ea4304cca5a3d773782c45e3a9d">&#9670;&nbsp;</a></span>unaryOperator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnaryOperator.html">UnaryOperator</a> &gt; clang::ast_matchers::unaryOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unary operator expressions. </p>
<p>Example matches !a </p><div class="fragment"><div class="line">!a || <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00952">952</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00097">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00124">clang::ento::getAddrTo()</a>.</p>

</div>
</div>
<a id="ab992eb4eee25162bb3cf9eb24bdd387f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992eb4eee25162bb3cf9eb24bdd387f">&#9670;&nbsp;</a></span>unaryTransformType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1UnaryTransformType.html">UnaryTransformType</a> &gt; clang::ast_matchers::unaryTransformType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types nodes representing unary type transformations. </p>
<p>Given: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> __underlying_type(T) <a class="code" href="namespaceclang_1_1ast__matchers.html#a600679c157b5bd05c4bfb940fb2511dd">type</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab992eb4eee25162bb3cf9eb24bdd387f" title="Matches types nodes representing unary type transformations.">unaryTransformType()</a> matches "__underlying_type(T)" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01058">1058</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a183ba07d4205e38e5d960a99062722dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183ba07d4205e38e5d960a99062722dc">&#9670;&nbsp;</a></span>unless</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; clang::ast_matchers::unless</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    internal::DynTypedMatcher::VO_UnaryNot}</div>
</div><!-- fragment -->
<p>Matches if the provided matcher does not match. </p>
<p>Example matches Y (matcher = cxxRecordDecl(unless(hasName("X")))) </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {};</div>
<div class="line"><span class="keyword">class </span>Y {};</div>
</div><!-- fragment --><p>Usable as: Any Matcher </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01025">1025</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>, <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00174">checkTempObjectsInNoPool()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, and <a class="el" href="RunLoopAutoreleaseLeakChecker_8cpp_source.html#l00147">getOtherMessageSentM()</a>.</p>

</div>
</div>
<a id="a3721288207aea6b68f442b2d752e78d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3721288207aea6b68f442b2d752e78d0">&#9670;&nbsp;</a></span>unresolvedLookupExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedLookupExpr.html">UnresolvedLookupExpr</a> &gt; clang::ast_matchers::unresolvedLookupExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches reference to a name that can be looked up during parsing but could not be resolved to a specific declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T foo() { T a; <span class="keywordflow">return</span> a; }</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keywordtype">void</span> bar() {</div>
<div class="line">  foo&lt;T&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a3721288207aea6b68f442b2d752e78d0" title="Matches reference to a name that can be looked up during parsing but could not be resolved to a speci...">unresolvedLookupExpr()</a> matches</p><div class="fragment"><div class="line">foo&lt;T&gt;() </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00862">862</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab9f2cfd327a640154b61dc04b4dbe173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2cfd327a640154b61dc04b4dbe173">&#9670;&nbsp;</a></span>unresolvedMemberExpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UnresolvedMemberExpr.html">UnresolvedMemberExpr</a> &gt; clang::ast_matchers::unresolvedMemberExpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved member expressions. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> f();</div>
<div class="line">  <span class="keywordtype">void</span> g();</div>
<div class="line">};</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> h() { <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.f&lt;T&gt;(); <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>.g(); }</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#ab9f2cfd327a640154b61dc04b4dbe173" title="Matches unresolved member expressions.">unresolvedMemberExpr()</a> matches x.f&lt;T&gt; </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00814">814</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a5ebfdb4a7578a482a07cefc8e5907c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebfdb4a7578a482a07cefc8e5907c85">&#9670;&nbsp;</a></span>unresolvedUsingTypenameDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingTypenameDecl.html">UnresolvedUsingTypenameDecl</a> &gt; clang::ast_matchers::unresolvedUsingTypenameDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved using value declarations that involve the typename. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="classBase.html">Base</a> { <span class="keyword">typedef</span> T Foo; };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>S : <span class="keyword">private</span> <a class="code" href="classBase.html">Base</a>&lt;T&gt; {</div>
<div class="line">  <span class="keyword">using</span> <span class="keyword">typename</span> <a class="code" href="classBase.html">Base&lt;T&gt;::Foo</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a5ebfdb4a7578a482a07cefc8e5907c85" title="Matches unresolved using value declarations that involve the typename.">unresolvedUsingTypenameDecl()</a> matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classBase.html">Base&lt;T&gt;::Foo</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00866">866</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af2fcb7fd463685d9e37e8f31637ed45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fcb7fd463685d9e37e8f31637ed45f">&#9670;&nbsp;</a></span>unresolvedUsingValueDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UnresolvedUsingValueDecl.html">UnresolvedUsingValueDecl</a> &gt; clang::ast_matchers::unresolvedUsingValueDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches unresolved using value declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> : <span class="keyword">private</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> {</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#af2fcb7fd463685d9e37e8f31637ed45f" title="Matches unresolved using value declarations.">unresolvedUsingValueDecl()</a> matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00864">864</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="ab2f2a941709daf18c1eb096bdde38868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f2a941709daf18c1eb096bdde38868">&#9670;&nbsp;</a></span>userDefinedLiteral</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1UserDefinedLiteral.html">UserDefinedLiteral</a> &gt; clang::ast_matchers::userDefinedLiteral</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches user defined literal operator call. </p>
<p>Example match: "foo"_suffix </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00929">929</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a2a9d64e967b6707c36254647d2bc4155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9d64e967b6707c36254647d2bc4155">&#9670;&nbsp;</a></span>usingDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDecl.html">UsingDecl</a> &gt; clang::ast_matchers::usingDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches using declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; }</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a2a9d64e967b6707c36254647d2bc4155" title="Matches using declarations.">usingDecl()</a> matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00857">857</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="af0b5096b155587486eb932cc3a86c481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b5096b155587486eb932cc3a86c481">&#9670;&nbsp;</a></span>usingDirectiveDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingDirectiveDecl.html">UsingDirectiveDecl</a> &gt; clang::ast_matchers::usingDirectiveDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches using namespace declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keywordtype">int</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a>; }</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#af0b5096b155587486eb932cc3a86c481" title="Matches using namespace declarations.">usingDirectiveDecl()</a> matches</p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00860">860</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a1470af2f7c9754818e2946266066461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470af2f7c9754818e2946266066461e">&#9670;&nbsp;</a></span>usingEnumDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1UsingEnumDecl.html">UsingEnumDecl</a> &gt; clang::ast_matchers::usingEnumDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches using-enum declarations. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { <span class="keyword">enum</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a> {...}; }</div>
<div class="line"><span class="keyword">using</span> <span class="keyword">enum</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a>;</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a1470af2f7c9754818e2946266066461e" title="Matches using-enum declarations.">usingEnumDecl()</a> matches</p><div class="fragment"><div class="line"><span class="keyword">using</span> <span class="keyword">enum</span> <a class="code" href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">X::x</a> </div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00858">858</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a8c09ef1f494b514efb2056e08b0f55d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c09ef1f494b514efb2056e08b0f55d8">&#9670;&nbsp;</a></span>usingType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1UsingType.html">UsingType</a> &gt; clang::ast_matchers::usingType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches types specified through a using declaration. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>a { <span class="keyword">struct </span>S {}; }</div>
<div class="line"><span class="keyword">using</span> a::S;</div>
<div class="line">S <a class="code" href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a>;</div>
</div><!-- fragment --><p><code><a class="el" href="namespaceclang_1_1ast__matchers.html#a8c09ef1f494b514efb2056e08b0f55d8" title="Matches types specified through a using declaration.">usingType()</a></code> matches the type of the variable declaration of <code>s</code>. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01062">1062</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="aaa27f54246f26b3989e97274e01a4c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa27f54246f26b3989e97274e01a4c30">&#9670;&nbsp;</a></span>valueDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1ValueDecl.html">ValueDecl</a> &gt; clang::ast_matchers::valueDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches any value declaration. </p>
<p>Example matches A, B, C and F </p><div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">X</a> { A, B, <a class="code" href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">C</a> };</div>
<div class="line"><span class="keywordtype">void</span> F();</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00790">790</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AbstractBasicWriter_8h_source.html#l00175">clang::serialization::DataStreamBasicWriter&lt; ASTRecordWriter &gt;::writeLValuePathSerializationHelper()</a>.</p>

</div>
</div>
<a id="a056e81429237736b6458df18bb538c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e81429237736b6458df18bb538c82">&#9670;&nbsp;</a></span>varDecl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Decl.html">Decl</a>, <a class="el" href="classclang_1_1VarDecl.html">VarDecl</a> &gt; clang::ast_matchers::varDecl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches variable declarations. </p>
<p>Note: this does not match declarations of member variables, which are "field" declarations in Clang parlance.</p>
<p>Example matches a </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> a;</div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2llvm_2llvm_2repo_2clang_2lib_2StaticAnalyzer_2Core_2RegionStore_8cpp-example.html#a56">/home/runner/work/llvm/llvm/repo/clang/lib/StaticAnalyzer/Core/RegionStore.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00802">802</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrolling_8cpp_source.html#l00115">clang::ento::assignedToRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00108">clang::ento::callByRef()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00097">clang::ento::changeIntBoundNode()</a>, <a class="el" href="LoopUnrolling_8cpp_source.html#l00142">clang::ento::forLoopMatcher()</a>, <a class="el" href="ExprEngine_8cpp_source.html#l00950">clang::ento::ExprEngine::ProcessAutomaticObjDtor()</a>, and <a class="el" href="LoopUnrolling_8cpp_source.html#l00082">clang::ento::simpleCondition()</a>.</p>

</div>
</div>
<a id="a4d12a4d6b3a44f08f4bb0e37a3b1f9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d12a4d6b3a44f08f4bb0e37a3b1f9c5">&#9670;&nbsp;</a></span>variableArrayType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceclang_1_1ast__matchers.html#a8ae01b358e8e1f82b6e2fcd501dc62c3">AstTypeMatcher</a>&lt; <a class="el" href="classclang_1_1VariableArrayType.html">VariableArrayType</a> &gt; clang::ast_matchers::variableArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches C arrays with a specified size that is not an integer-constant-expression. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> f() {</div>
<div class="line">  <span class="keywordtype">int</span> a[] = { 2, 3 }</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a>[42];</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code" href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a>[a[0]];</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a4d12a4d6b3a44f08f4bb0e37a3b1f9c5" title="Matches C arrays with a specified size that is not an integer-constant-expression.">variableArrayType()</a> matches "int c[a[0]]" </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l01041">1041</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
<a id="a63fb772f53dc8076440090557a4bb388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fb772f53dc8076440090557a4bb388">&#9670;&nbsp;</a></span>whileStmt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const internal::VariadicDynCastAllOfMatcher&lt; <a class="el" href="classclang_1_1Stmt.html">Stmt</a>, <a class="el" href="classclang_1_1WhileStmt.html">WhileStmt</a> &gt; clang::ast_matchers::whileStmt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matches while statements. </p>
<p>Given </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {}</div>
</div><!-- fragment --><p> <a class="el" href="namespaceclang_1_1ast__matchers.html#a63fb772f53dc8076440090557a4bb388" title="Matches while statements.">whileStmt()</a> matches 'while (true) {}'. </p>

<p class="definition">Definition at line <a class="el" href="ASTMatchersInternal_8cpp_source.html#l00898">898</a> of file <a class="el" href="ASTMatchersInternal_8cpp_source.html">ASTMatchersInternal.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceclang_html_aafe7017f6d734340af27ef4e92b19b77"><div class="ttname"><a href="namespaceclang.html#aafe7017f6d734340af27ef4e92b19b77">clang::operator!=</a></div><div class="ttdeci">bool operator!=(CanQual&lt; T &gt; x, CanQual&lt; U &gt; y)</div><div class="ttdef"><b>Definition:</b> <a href="CanonicalType_8h_source.html#l00207">CanonicalType.h:207</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab8c34f70634543e4f54c46ee7df6614f"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ab8c34f70634543e4f54c46ee7df6614f">clang::ast_matchers::decompositionDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, DecompositionDecl &gt; decompositionDecl</div><div class="ttdoc">Matches decomposition-declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00735">ASTMatchersInternal.cpp:735</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a90d2caaa3c207f5b5f91216fe06f1158"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a90d2caaa3c207f5b5f91216fe06f1158">clang::ast_matchers::mapAnyOf</a></div><div class="ttdeci">auto mapAnyOf(internal::VariadicDynCastAllOfMatcher&lt; T, U &gt; const &amp;...)</div><div class="ttdoc">Matches any of the NodeMatchers with InnerMatchers nested within.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l02813">ASTMatchers.h:2813</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_abb82889579b3228e5741598746e94b31"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#abb82889579b3228e5741598746e94b31">clang::ast_matchers::invocation</a></div><div class="ttdeci">const internal::MapAnyOfMatcher&lt; CallExpr, CXXConstructExpr &gt; invocation</div><div class="ttdoc">Matches function calls and constructor calls.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00951">ASTMatchersInternal.cpp:951</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a75176e564329aea08a65d667d019d9f8"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a75176e564329aea08a65d667d019d9f8">clang::ast_matchers::hasAnyName</a></div><div class="ttdeci">const internal::VariadicFunction&lt; internal::Matcher&lt; NamedDecl &gt;, StringRef, internal::hasAnyNameFunc &gt; hasAnyName</div><div class="ttdoc">Matches NamedDecl nodes that have any of the specified names.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00997">ASTMatchersInternal.cpp:997</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a35486e436ae0dbb176252fc6b3cf62fd"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a35486e436ae0dbb176252fc6b3cf62fd">clang::ast_matchers::AST_POLYMORPHIC_MATCHER_P</a></div><div class="ttdeci">AST_POLYMORPHIC_MATCHER_P(isExpandedFromMacro, AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc), std::string, MacroName)</div><div class="ttdoc">Matches statements that are (transitively) expanded from the named macro.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l00314">ASTMatchers.h:314</a></div></div>
<div class="ttc" id="aclassstd_1_1conditional_1_1type_html"><div class="ttname"><a href="classstd_1_1conditional_1_1type.html">type</a></div></div>
<div class="ttc" id="alib_2Tooling_2CMakeLists_8txt_html_af86de1f06488914e30d948a42f397df5"><div class="ttname"><a href="lib_2Tooling_2CMakeLists_8txt.html#af86de1f06488914e30d948a42f397df5">string</a></div><div class="ttdeci">string(SUBSTRING ${CMAKE_CURRENT_BINARY_DIR} 0 ${PATH_LIB_START} PATH_HEAD) string(SUBSTRING $</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Tooling_2CMakeLists_8txt_source.html#l00022">CMakeLists.txt:22</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2c9fffe33e90bbb4b8f099caf377d7b1"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a2c9fffe33e90bbb4b8f099caf377d7b1">clang::ast_matchers::stringLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, StringLiteral &gt; stringLiteral</div><div class="ttdoc">Matches string literals (also matches wide string literals).</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00919">ASTMatchersInternal.cpp:919</a></div></div>
<div class="ttc" id="astdatomic_8h_html_afff57ffb45845b688f5b8749a5ee4f64"><div class="ttname"><a href="stdatomic_8h.html#afff57ffb45845b688f5b8749a5ee4f64">_Atomic</a></div><div class="ttdeci">typedef _Atomic(_Bool) atomic_bool</div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ae56a1974283c9a2cb2410008e32fe3f1"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ae56a1974283c9a2cb2410008e32fe3f1">clang::ast_matchers::anyOf</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; unsigned &gt;::max()&gt; anyOf</div><div class="ttdoc">Matches if any of the given matchers matches.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00989">ASTMatchersInternal.cpp:989</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a701d2c84173a8709dcb4a221ad478e1e"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a701d2c84173a8709dcb4a221ad478e1e">clang::ast_matchers::cxxFunctionalCastExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXFunctionalCastExpr &gt; cxxFunctionalCastExpr</div><div class="ttdoc">Matches functional cast expressions.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00977">ASTMatchersInternal.cpp:977</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2adc91bda011c0b3ffcc4c315131cfb4"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a2adc91bda011c0b3ffcc4c315131cfb4">clang::ast_matchers::findAll</a></div><div class="ttdeci">internal::Matcher&lt; T &gt; findAll(const internal::Matcher&lt; T &gt; &amp;Matcher)</div><div class="ttdoc">Matches if the node or any descendant matches.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l03480">ASTMatchers.h:3480</a></div></div>
<div class="ttc" id="astddef_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> <a href="stddef_8h_source.html#l00089">stddef.h:89</a></div></div>
<div class="ttc" id="anamespaceAttributeLangSupport_html_a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e"><div class="ttname"><a href="namespaceAttributeLangSupport.html#a2f895ae8ae6d7966390f197b109d1f4dac1c6ab9ca121c29c650b3ab6a4212b4e">AttributeLangSupport::C</a></div><div class="ttdeci">@ C</div><div class="ttdef"><b>Definition:</b> <a href="SemaDeclAttr_8cpp_source.html#l00054">SemaDeclAttr.cpp:54</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a600679c157b5bd05c4bfb940fb2511dd"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a600679c157b5bd05c4bfb940fb2511dd">clang::ast_matchers::type</a></div><div class="ttdeci">const internal::VariadicAllOfMatcher&lt; Type &gt; type</div><div class="ttdoc">Matches Types in the clang AST.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00773">ASTMatchersInternal.cpp:773</a></div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aa7b8984e16daeff79f73e22b4e040334"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aa7b8984e16daeff79f73e22b4e040334">int</a></div><div class="ttdeci">__device__ int</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00063">__clang_hip_libdevice_declares.h:63</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aa144e36e553f364291ec8746c14cd05c"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#aa144e36e553f364291ec8746c14cd05c">clang::ast_matchers::equals</a></div><div class="ttdeci">internal::PolymorphicMatcher&lt; internal::ValueEqualsMatcher, void(internal::AllNodeBaseTypes), ValueT &gt; equals(const ValueT &amp;Value)</div><div class="ttdoc">Matches literals that are equal to the given value of type ValueT.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l05512">ASTMatchers.h:5512</a></div></div>
<div class="ttc" id="anamespaceclang_1_1tooling_html_a4ffee664435dba78b2225a5457619b53"><div class="ttname"><a href="namespaceclang_1_1tooling.html#a4ffee664435dba78b2225a5457619b53">clang::tooling::X</a></div><div class="ttdeci">static ToolExecutorPluginRegistry::Add&lt; AllTUsToolExecutorPlugin &gt; X(&quot;all-TUs&quot;, &quot;Runs FrontendActions on all TUs in the compilation database. &quot; &quot;Tool results are stored in memory.&quot;)</div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a373e9fc646873cd20f2c9fdb7125a207"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a373e9fc646873cd20f2c9fdb7125a207">b</a></div><div class="ttdeci">__device__ __2f16 b</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00314">__clang_hip_libdevice_declares.h:314</a></div></div>
<div class="ttc" id="aClangSrcLocDump_8cpp_html_a217dbf8b442f20279ea00b898af96f52"><div class="ttname"><a href="ClangSrcLocDump_8cpp.html#a217dbf8b442f20279ea00b898af96f52">main</a></div><div class="ttdeci">int main(int argc, const char **argv)</div><div class="ttdef"><b>Definition:</b> <a href="ClangSrcLocDump_8cpp_source.html#l00068">ClangSrcLocDump.cpp:68</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab70d18a272b82cd99f0dba56e9ab0c21"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ab70d18a272b82cd99f0dba56e9ab0c21">clang::ast_matchers::traverse</a></div><div class="ttdeci">internal::Matcher&lt; T &gt; traverse(TraversalKind TK, const internal::Matcher&lt; T &gt; &amp;InnerMatcher)</div><div class="ttdoc">Causes all nested matchers to be matched with the specified traversal kind.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l00815">ASTMatchers.h:815</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a4a4e38c6224c16252040dc697a6af832"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a4a4e38c6224c16252040dc697a6af832">clang::ast_matchers::floatLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, FloatingLiteral &gt; floatLiteral</div><div class="ttdoc">Matches float literals of all sizes / encodings, e.g.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00924">ASTMatchersInternal.cpp:924</a></div></div>
<div class="ttc" id="aopencl-c_8h_html_aba012e9e58cf457e566250f019adf2f2"><div class="ttname"><a href="opencl-c_8h.html#aba012e9e58cf457e566250f019adf2f2">any</a></div><div class="ttdeci">int __ovld __cnfn any(char)</div><div class="ttdoc">Returns 1 if the most significant bit in any component of x is set; otherwise returns 0.</div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a605961d8a647c2ec766b2417552393a2"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a605961d8a647c2ec766b2417552393a2">clang::ast_matchers::typeLoc</a></div><div class="ttdeci">const internal::VariadicAllOfMatcher&lt; TypeLoc &gt; typeLoc</div><div class="ttdoc">Matches TypeLocs in the clang AST.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00774">ASTMatchersInternal.cpp:774</a></div></div>
<div class="ttc" id="anamespaceclang_1_1CodeGen_html_a1c294b2b5bfa35483ddb984a1ad6db17ac02172f092142d31f6b3d06ff4eca48c"><div class="ttname"><a href="namespaceclang_1_1CodeGen.html#a1c294b2b5bfa35483ddb984a1ad6db17ac02172f092142d31f6b3d06ff4eca48c">clang::CodeGen::AlignmentSource::Decl</a></div><div class="ttdeci">@ Decl</div><div class="ttdoc">The l-value was an access to a declared entity or something equivalently strong, like the address of ...</div></div>
<div class="ttc" id="aclassU_html"><div class="ttname"><a href="classU.html">U</a></div></div>
<div class="ttc" id="aASTContext_8h_html_ab1457e11becd51c5d0c750caab5446c2"><div class="ttname"><a href="ASTContext_8h.html#ab1457e11becd51c5d0c750caab5446c2">V</a></div><div class="ttdeci">#define V(N, I)</div><div class="ttdef"><b>Definition:</b> <a href="ASTContext_8h_source.html#l03167">ASTContext.h:3167</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_adfc0ccd398780d345e2c541cc716cc66"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#adfc0ccd398780d345e2c541cc716cc66">clang::ast_matchers::expr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, Expr &gt; expr</div><div class="ttdoc">Matches expressions.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00890">ASTMatchersInternal.cpp:890</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a3285794ef7314a9b8ca5c18ed2744c13"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a3285794ef7314a9b8ca5c18ed2744c13">clang::ast_matchers::cxxDependentScopeMemberExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXDependentScopeMemberExpr &gt; cxxDependentScopeMemberExpr</div><div class="ttdoc">Matches member expressions where the actual member referenced could not be resolved because the base ...</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00816">ASTMatchersInternal.cpp:816</a></div></div>
<div class="ttc" id="aiso646_8h_html_a31739c27bdcfdac9faae7bf7a5df49e4"><div class="ttname"><a href="iso646_8h.html#a31739c27bdcfdac9faae7bf7a5df49e4">not</a></div><div class="ttdeci">#define not</div><div class="ttdef"><b>Definition:</b> <a href="iso646_8h_source.html#l00019">iso646.h:19</a></div></div>
<div class="ttc" id="aASTMatchFinder_8cpp_html_a32ca2adfad3611927e87efc253e7b7b1"><div class="ttname"><a href="ASTMatchFinder_8cpp.html#a32ca2adfad3611927e87efc253e7b7b1">Node</a></div><div class="ttdeci">DynTypedNode Node</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchFinder_8cpp_source.html#l00068">ASTMatchFinder.cpp:68</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aeb793c9ea9a7c9a4584f8d9a84963981"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#aeb793c9ea9a7c9a4584f8d9a84963981">clang::ast_matchers::functionType</a></div><div class="ttdeci">const AstTypeMatcher&lt; FunctionType &gt; functionType</div><div class="ttdoc">Matches FunctionType nodes.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01045">ASTMatchersInternal.cpp:1045</a></div></div>
<div class="ttc" id="aPathDiagnostic_8cpp_html_a0a3098eaa1bf35a10ed829cd2ab49411"><div class="ttname"><a href="PathDiagnostic_8cpp.html#a0a3098eaa1bf35a10ed829cd2ab49411">compare</a></div><div class="ttdeci">static bool compare(const PathDiagnostic &amp;X, const PathDiagnostic &amp;Y)</div><div class="ttdef"><b>Definition:</b> <a href="PathDiagnostic_8cpp_source.html#l00351">PathDiagnostic.cpp:351</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a3661a4b3ebe2e4a9b67ab5be7d1c17e6"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a3661a4b3ebe2e4a9b67ab5be7d1c17e6">clang::ast_matchers::bindingDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, BindingDecl &gt; bindingDecl</div><div class="ttdoc">Matches binding declarations Example matches foo and bar (matcher = bindingDecl()</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00736">ASTMatchersInternal.cpp:736</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aebe825b22b86295d319b09c996fe78fd"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#aebe825b22b86295d319b09c996fe78fd">clang::ast_matchers::cxxMethodDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, CXXMethodDecl &gt; cxxMethodDecl</div><div class="ttdoc">Matches method declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00799">ASTMatchersInternal.cpp:799</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a76efced611335bad85d3da6fe6ae790e"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a76efced611335bad85d3da6fe6ae790e">clang::ast_matchers::binaryOperation</a></div><div class="ttdeci">const internal::MapAnyOfMatcher&lt; BinaryOperator, CXXOperatorCallExpr, CXXRewrittenBinaryOperator &gt; binaryOperation</div><div class="ttdoc">Matches nodes which can be used with binary operators.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00950">ASTMatchersInternal.cpp:950</a></div></div>
<div class="ttc" id="alib_2Analysis_2plugins_2CheckerDependencyHandling_2CMakeLists_8txt_html_a683a3174a12f54668fcda805c841439b"><div class="ttname"><a href="lib_2Analysis_2plugins_2CheckerDependencyHandling_2CMakeLists_8txt.html#a683a3174a12f54668fcda805c841439b">set</a></div><div class="ttdeci">set(LLVM_LINK_COMPONENTS Support) set(LLVM_EXPORTED_SYMBOL_FILE $</div><div class="ttdef"><b>Definition:</b> <a href="lib_2Analysis_2plugins_2CheckerDependencyHandling_2CMakeLists_8txt_source.html#l00001">CMakeLists.txt:1</a></div></div>
<div class="ttc" id="astdnoreturn_8h_html_a4a453f3a748e55cbdac6fcc79357cfef"><div class="ttname"><a href="stdnoreturn_8h.html#a4a453f3a748e55cbdac6fcc79357cfef">noreturn</a></div><div class="ttdeci">#define noreturn</div><div class="ttdef"><b>Definition:</b> <a href="stdnoreturn_8h_source.html#l00013">stdnoreturn.h:13</a></div></div>
<div class="ttc" id="astdbool_8h_html_abb452686968e48b67397da5f97445f5b"><div class="ttname"><a href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></div><div class="ttdeci">#define bool</div><div class="ttdef"><b>Definition:</b> <a href="stdbool_8h_source.html#l00020">stdbool.h:20</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_af5cd72a6718872ac996d48de9a80bf81"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#af5cd72a6718872ac996d48de9a80bf81">clang::ast_matchers::ifStmt</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, IfStmt &gt; ifStmt</div><div class="ttdoc">Matches if statements.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00894">ASTMatchersInternal.cpp:894</a></div></div>
<div class="ttc" id="anamespaceclang_1_1dataflow_html_aa858fe7ef413718673ced2de8af3b28a"><div class="ttname"><a href="namespaceclang_1_1dataflow.html#aa858fe7ef413718673ced2de8af3b28a">clang::dataflow::var</a></div><div class="ttdeci">static constexpr Variable var(Literal L)</div><div class="ttdoc">Returns the variable of L.</div><div class="ttdef"><b>Definition:</b> <a href="WatchedLiteralsSolver_8cpp_source.html#l00071">WatchedLiteralsSolver.cpp:71</a></div></div>
<div class="ttc" id="aclassBase_html"><div class="ttname"><a href="classBase.html">Base</a></div></div>
<div class="ttc" id="anamespaceclang_html_a60ee2b234598aa6e46b20012d281f701"><div class="ttname"><a href="namespaceclang.html#a60ee2b234598aa6e46b20012d281f701">clang::operator&lt;&lt;</a></div><div class="ttdeci">const StreamingDiagnostic &amp; operator&lt;&lt;(const StreamingDiagnostic &amp;DB, const ASTContext::SectionInfo &amp;Section)</div><div class="ttdoc">Insertion operator for diagnostics.</div><div class="ttdef"><b>Definition:</b> <a href="ASTContext_8cpp_source.html#l12297">ASTContext.cpp:12297</a></div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a81cb22c87f277e41a39a91e48766e549"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a81cb22c87f277e41a39a91e48766e549">double</a></div><div class="ttdeci">__device__ double</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00165">__clang_hip_libdevice_declares.h:165</a></div></div>
<div class="ttc" id="aCodeGen_2README_8txt_html_a2f5467b833926827f4292d3ba7fea003"><div class="ttname"><a href="CodeGen_2README_8txt.html#a2f5467b833926827f4292d3ba7fea003">x</a></div><div class="ttdeci">IRgen optimization opportunities The common pattern of short x</div><div class="ttdef"><b>Definition:</b> <a href="CodeGen_2README_8txt_source.html#l00007">README.txt:7</a></div></div>
<div class="ttc" id="aASTMatchersMacros_8h_html_a54f22df2b42d3616291b4a7c8ef97106"><div class="ttname"><a href="ASTMatchersMacros_8h.html#a54f22df2b42d3616291b4a7c8ef97106">AST_POLYMORPHIC_SUPPORTED_TYPES</a></div><div class="ttdeci">#define AST_POLYMORPHIC_SUPPORTED_TYPES(...)</div><div class="ttdoc">Construct a type-list to be passed to the AST_POLYMORPHIC_MATCHER* macros.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersMacros_8h_source.html#l00221">ASTMatchersMacros.h:221</a></div></div>
<div class="ttc" id="aiso646_8h_html_aa3d7d535cf450b91b9cb6d9cee2edbb9"><div class="ttname"><a href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a></div><div class="ttdeci">#define and</div><div class="ttdef"><b>Definition:</b> <a href="iso646_8h_source.html#l00014">iso646.h:14</a></div></div>
<div class="ttc" id="aCharUnits_8h_html_a30c408b1824dd612b35a6b4e20ed423f"><div class="ttname"><a href="CharUnits_8h.html#a30c408b1824dd612b35a6b4e20ed423f">operator*</a></div><div class="ttdeci">clang::CharUnits operator*(clang::CharUnits::QuantityType Scale, const clang::CharUnits &amp;CU)</div><div class="ttdef"><b>Definition:</b> <a href="CharUnits_8h_source.html#l00212">CharUnits.h:212</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab0c3c535f34a336b4e966342d44a631d"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ab0c3c535f34a336b4e966342d44a631d">clang::ast_matchers::eachOf</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 2, std::numeric_limits&lt; unsigned &gt;::max()&gt; eachOf</div><div class="ttdoc">Matches if any of the given matchers matches.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00986">ASTMatchersInternal.cpp:986</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ac5ccadfbea5e9e43c2153175afca6cac"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ac5ccadfbea5e9e43c2153175afca6cac">clang::ast_matchers::decl</a></div><div class="ttdeci">const internal::VariadicAllOfMatcher&lt; Decl &gt; decl</div><div class="ttdoc">Matches declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00734">ASTMatchersInternal.cpp:734</a></div></div>
<div class="ttc" id="anamespaceclang_1_1syntax_html_a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719"><div class="ttname"><a href="namespaceclang_1_1syntax.html#a0d10149d69e32e3c86140b4d325925e5a6f6cb72d544962fa333e2e34ce64f719">clang::syntax::NodeRole::Size</a></div><div class="ttdeci">@ Size</div></div>
<div class="ttc" id="astdbool_8h_html_a65e9886d74aaee76545e83dd09011727"><div class="ttname"><a href="stdbool_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></div><div class="ttdeci">#define false</div><div class="ttdef"><b>Definition:</b> <a href="stdbool_8h_source.html#l00022">stdbool.h:22</a></div></div>
<div class="ttc" id="anamespaceclang_html_a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d"><div class="ttname"><a href="namespaceclang.html#a6196a82dc53119822ac96e34a9726058afd4a878609d940f0f79ddb010c3ad92d">clang::TK_IgnoreUnlessSpelledInSource</a></div><div class="ttdeci">@ TK_IgnoreUnlessSpelledInSource</div><div class="ttdoc">Ignore AST nodes not written in the source.</div><div class="ttdef"><b>Definition:</b> <a href="ASTTypeTraits_8h_source.html#l00043">ASTTypeTraits.h:43</a></div></div>
<div class="ttc" id="anamespaceclang_1_1transformer_html_a301efb90a8aff2321a691a7c8292e9df"><div class="ttname"><a href="namespaceclang_1_1transformer.html#a301efb90a8aff2321a691a7c8292e9df">clang::transformer::member</a></div><div class="ttdeci">RangeSelector member(std::string ID)</div><div class="ttdoc">Given a MemberExpr, selects the member token.</div><div class="ttdef"><b>Definition:</b> <a href="RangeSelector_8cpp_source.html#l00188">RangeSelector.cpp:188</a></div></div>
<div class="ttc" id="anamespaceclang_1_1threadSafety_1_1sx_html_a1f94e70f0b582e39c677f6db080856fd"><div class="ttname"><a href="namespaceclang_1_1threadSafety_1_1sx.html#a1f94e70f0b582e39c677f6db080856fd">clang::threadSafety::sx::matches</a></div><div class="ttdeci">bool matches(const til::SExpr *E1, const til::SExpr *E2)</div><div class="ttdef"><b>Definition:</b> <a href="ThreadSafetyCommon_8h_source.html#l00067">ThreadSafetyCommon.h:67</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a0781cbe6d50bd620cb6f8f0627378be6"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a0781cbe6d50bd620cb6f8f0627378be6">clang::ast_matchers::declRefExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, DeclRefExpr &gt; declRefExpr</div><div class="ttdoc">Matches expressions that refer to declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00891">ASTMatchersInternal.cpp:891</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="Format_8h_source.html#l04296">Format.h:4296</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a652afe55bf376c9c0789d550409d90fe"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a652afe55bf376c9c0789d550409d90fe">clang::ast_matchers::anything</a></div><div class="ttdeci">internal::TrueMatcher anything()</div><div class="ttdoc">Matches any node.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l00169">ASTMatchers.h:169</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a34b0467fd444a7daa8a8aa79ec045765"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a34b0467fd444a7daa8a8aa79ec045765">clang::ast_matchers::pointerType</a></div><div class="ttdeci">const AstTypeMatcher&lt; PointerType &gt; pointerType</div><div class="ttdoc">Matches pointer types, but does not match Objective-C object pointer types.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01050">ASTMatchersInternal.cpp:1050</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_abf2f0de9c9e156981b881b8d5d89aec6"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#abf2f0de9c9e156981b881b8d5d89aec6">clang::ast_matchers::recordType</a></div><div class="ttdeci">const AstTypeMatcher&lt; RecordType &gt; recordType</div><div class="ttdoc">Matches record types (e.g.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01059">ASTMatchersInternal.cpp:1059</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2a07934509f8d264c16974bbe0c15ac7"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a2a07934509f8d264c16974bbe0c15ac7">clang::ast_matchers::optionally</a></div><div class="ttdeci">const internal::VariadicOperatorMatcherFunc&lt; 1, 1 &gt; optionally</div><div class="ttdoc">Matches any node regardless of the submatcher.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00993">ASTMatchersInternal.cpp:993</a></div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_a3da0931a820e46f95754b07f9b413d58"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#a3da0931a820e46f95754b07f9b413d58">__attribute__</a></div><div class="ttdeci">_Float16 __2f16 __attribute__((ext_vector_type(2)))</div><div class="ttdoc">Zeroes the upper 128 bits (bits 255:128) of all YMM registers.</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00311">__clang_hip_libdevice_declares.h:311</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a8e6f109ac0734990e8ae974d36e76c7e"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a8e6f109ac0734990e8ae974d36e76c7e">clang::ast_matchers::forStmt</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, ForStmt &gt; forStmt</div><div class="ttdoc">Matches for statements.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00895">ASTMatchersInternal.cpp:895</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a58409ce605d979d1d1e0a600ec417a0a"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a58409ce605d979d1d1e0a600ec417a0a">clang::ast_matchers::match</a></div><div class="ttdeci">SmallVector&lt; BoundNodes, 1 &gt; match(MatcherT Matcher, const NodeT &amp;Node, ASTContext &amp;Context)</div><div class="ttdoc">Returns the results of matching Matcher on Node.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchFinder_8h_source.html#l00312">ASTMatchFinder.h:312</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a8d768f291504a2ab44e97d4732e25810"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a8d768f291504a2ab44e97d4732e25810">clang::ast_matchers::hasName</a></div><div class="ttdeci">internal::Matcher&lt; NamedDecl &gt; hasName(StringRef Name)</div><div class="ttdoc">Matches NamedDecl nodes that have the specified name.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l02991">ASTMatchers.h:2991</a></div></div>
<div class="ttc" id="anamespaceclang_html_a51e572049a11fe5cf42e8da840bf69af"><div class="ttname"><a href="namespaceclang.html#a51e572049a11fe5cf42e8da840bf69af">clang::operator&lt;</a></div><div class="ttdeci">bool operator&lt;(DeclarationName LHS, DeclarationName RHS)</div><div class="ttdoc">Ordering on two declaration names.</div><div class="ttdef"><b>Definition:</b> <a href="DeclarationName_8h_source.html#l00538">DeclarationName.h:538</a></div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_aeec2d21816235dac201bf39185a3e86f"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#aeec2d21816235dac201bf39185a3e86f">s</a></div><div class="ttdeci">__device__ __2f16 float bool s</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00315">__clang_hip_libdevice_declares.h:315</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a704e8b0c7519edb6b05d1663a4266b6d"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a704e8b0c7519edb6b05d1663a4266b6d">clang::ast_matchers::cxxTemporaryObjectExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXTemporaryObjectExpr &gt; cxxTemporaryObjectExpr</div><div class="ttdoc">Matches functional cast expressions having N != 1 arguments.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00979">ASTMatchersInternal.cpp:979</a></div></div>
<div class="ttc" id="aopencl-c-base_8h_html_a1b66ea7b0c0b95a8154b5c0641848db6"><div class="ttname"><a href="opencl-c-base_8h.html#a1b66ea7b0c0b95a8154b5c0641848db6">printf</a></div><div class="ttdeci">int printf(__constant const char *st,...) __attribute__((format(printf</div></div>
<div class="ttc" id="a____clang__hip__libdevice__declares_8h_html_ad55181c98da0de5b29a5afc3060fc6d0"><div class="ttname"><a href="____clang__hip__libdevice__declares_8h.html#ad55181c98da0de5b29a5afc3060fc6d0">c</a></div><div class="ttdeci">__device__ __2f16 float c</div><div class="ttdef"><b>Definition:</b> <a href="____clang__hip__libdevice__declares_8h_source.html#l00315">__clang_hip_libdevice_declares.h:315</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ac1ef73826e6b83dd0e8fc4a4b7284c74"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ac1ef73826e6b83dd0e8fc4a4b7284c74">clang::ast_matchers::cxxRecordDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, CXXRecordDecl &gt; cxxRecordDecl</div><div class="ttdoc">Matches C++ class declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00745">ASTMatchersInternal.cpp:745</a></div></div>
<div class="ttc" id="aarm__acle_8h_html_a8603782009ff58be0587ea58013b3e52"><div class="ttname"><a href="arm__acle_8h.html#a8603782009ff58be0587ea58013b3e52">v</a></div><div class="ttdeci">do v</div><div class="ttdef"><b>Definition:</b> <a href="arm__acle_8h_source.html#l00076">arm_acle.h:76</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a8c09ef1f494b514efb2056e08b0f55d8"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a8c09ef1f494b514efb2056e08b0f55d8">clang::ast_matchers::usingType</a></div><div class="ttdeci">const AstTypeMatcher&lt; UsingType &gt; usingType</div><div class="ttdoc">Matches types specified through a using declaration.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01062">ASTMatchersInternal.cpp:1062</a></div></div>
<div class="ttc" id="astdbool_8h_html_a41f9c5fb8b08eb5dc3edce4dcb37fee7"><div class="ttname"><a href="stdbool_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></div><div class="ttdeci">#define true</div><div class="ttdef"><b>Definition:</b> <a href="stdbool_8h_source.html#l00021">stdbool.h:21</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ad2109e16a4a151dc8f6416a66a750eac"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ad2109e16a4a151dc8f6416a66a750eac">clang::ast_matchers::integerLiteral</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, IntegerLiteral &gt; integerLiteral</div><div class="ttdoc">Matches integer literals of all sizes / encodings, e.g.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00923">ASTMatchersInternal.cpp:923</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab0da198b76c77bfd4737a339d5a78e33"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ab0da198b76c77bfd4737a339d5a78e33">clang::ast_matchers::cxxConstructExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, CXXConstructExpr &gt; cxxConstructExpr</div><div class="ttdoc">Matches constructor call expressions (including implicit ones).</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00870">ASTMatchersInternal.cpp:870</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a056e81429237736b6458df18bb538c82"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a056e81429237736b6458df18bb538c82">clang::ast_matchers::varDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, VarDecl &gt; varDecl</div><div class="ttdoc">Matches variable declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00802">ASTMatchersInternal.cpp:802</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a9a14e1788aad32c318543405b5ec5962"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a9a14e1788aad32c318543405b5ec5962">clang::ast_matchers::has</a></div><div class="ttdeci">const internal::ArgumentAdaptingMatcherFunc&lt; internal::HasMatcher &gt; has</div><div class="ttdoc">Matches AST nodes that have child AST nodes that match the provided matcher.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01008">ASTMatchersInternal.cpp:1008</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_aa76835a0f3b2093794608ce6c16da9bc"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#aa76835a0f3b2093794608ce6c16da9bc">clang::ast_matchers::hasDeclaration</a></div><div class="ttdeci">internal::PolymorphicMatcher&lt; internal::HasDeclarationMatcher, void(internal::HasDeclarationSupportedTypes), internal::Matcher&lt; Decl &gt; &gt; hasDeclaration(const internal::Matcher&lt; Decl &gt; &amp;InnerMatcher)</div><div class="ttdoc">Matches a node if the declaration associated with that node matches the given matcher.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchers_8h_source.html#l03565">ASTMatchers.h:3565</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a28b1bdd70cca95686345d5a96d97071a"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a28b1bdd70cca95686345d5a96d97071a">clang::ast_matchers::implicitCastExpr</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Stmt, ImplicitCastExpr &gt; implicitCastExpr</div><div class="ttdoc">Matches the implicit cast nodes of Clang's AST.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00974">ASTMatchersInternal.cpp:974</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_ab26f3ff62d6be975196efa86f3b15d82"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#ab26f3ff62d6be975196efa86f3b15d82">clang::ast_matchers::fieldDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, FieldDecl &gt; fieldDecl</div><div class="ttdoc">Matches field declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00803">ASTMatchersInternal.cpp:803</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_afcdb6ae259330bdf0876aba6e07c8710"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#afcdb6ae259330bdf0876aba6e07c8710">clang::ast_matchers::classTemplateDecl</a></div><div class="ttdeci">const internal::VariadicDynCastAllOfMatcher&lt; Decl, ClassTemplateDecl &gt; classTemplateDecl</div><div class="ttdoc">Matches C++ class template declarations.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l00747">ASTMatchersInternal.cpp:747</a></div></div>
<div class="ttc" id="anamespaceclang_1_1ast__matchers_html_a2fa868bfe1462fc934f1a64bad7d856d"><div class="ttname"><a href="namespaceclang_1_1ast__matchers.html#a2fa868bfe1462fc934f1a64bad7d856d">clang::ast_matchers::templateSpecializationType</a></div><div class="ttdeci">const AstTypeMatcher&lt; TemplateSpecializationType &gt; templateSpecializationType</div><div class="ttdoc">Matches template specialization types.</div><div class="ttdef"><b>Definition:</b> <a href="ASTMatchersInternal_8cpp_source.html#l01057">ASTMatchersInternal.cpp:1057</a></div></div>
<div class="ttc" id="anamespaceclang_html_a4a57f21b55a81cefae4379e09a3be0c3"><div class="ttname"><a href="namespaceclang.html#a4a57f21b55a81cefae4379e09a3be0c3">clang::operator==</a></div><div class="ttdeci">bool operator==(const CallGraphNode::CallRecord &amp;LHS, const CallGraphNode::CallRecord &amp;RHS)</div><div class="ttdef"><b>Definition:</b> <a href="CallGraph_8h_source.html#l00223">CallGraph.h:223</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 4 2022 01:36:26 for clang by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
